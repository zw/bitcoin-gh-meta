[
   {
      "author_association" : "MEMBER",
      "body" : "Initial light Concept ACK based on first reading of the code, the documentation in `txrequest.h`, and thinking about the differences with respect to the current tx request logic. Debug build clean and local tests green at each commit. The new `txrequest` fuzzer is running so far without issues.",
      "created_at" : "2020-09-21T11:00:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#issuecomment-696044101",
      "id" : 696044101,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19988",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5NjA0NDEwMQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-21T11:00:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/696044101",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #20044 (Make all of net_processing (and some of net) use std::chrono types by sipa)\n* #19893 (test: Remove or explain syncwithvalidationinterfacequeue by MarcoFalke)\n* #19753 (p2p: don't add AlreadyHave transactions to recentRejects by troygiorshev)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2020-09-21T11:34:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#issuecomment-696058761",
      "id" : 696058761,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19988",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5NjA1ODc2MQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-02T19:56:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/696058761",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "committing to review soon(TM)",
      "created_at" : "2020-09-21T14:59:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#issuecomment-696171592",
      "id" : 696171592,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19988",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5NjE3MTU5Mg==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-21T14:59:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/696171592",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Reviewed the first commit, \"Add txrequest module\". Overall looks good. Various minor suggestions in https://github.com/jonatack/bitcoin/commits/pr-19988-review-suggestions to not add noise here; feel free to pick and choose.",
      "created_at" : "2020-09-21T18:11:54Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#issuecomment-696281970",
      "id" : 696281970,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19988",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5NjI4MTk3MA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-21T18:11:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/696281970",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Pushed an update, incorporating @jonatack's nits above, and addressing a number of @ariard's comments on #19184. I also moved the entire implementation to txrequest.cpp, hidden using a `TxRequestTracker::Impl` object. I hope this makes it easier to distinguish the comments in the .h (now entirely about the observable behavior without implementation details) vs the .cpp (which works quite differently). This also fixed an AppVeyer issue with MSVC failing to compile.",
      "created_at" : "2020-09-22T00:58:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#issuecomment-696458038",
      "id" : 696458038,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19988",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5NjQ1ODAzOA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-22T00:58:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/696458038",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r492832470"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492832470"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n * - Whether it's from a \"preferred\" peer or not (outbound and noban peers are preferred).\r\n```\r\n\r\nstyle-nit: Would be good to mention the exact permission flag, because legacy whitelisted is discouraged, has been deprecated, and might be removed some time in the future.\r\n\r\n(Same below)",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-22T15:30:39Z",
      "diff_hunk" : "@@ -0,0 +1,226 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r492832470",
      "id" : 492832470,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgzMjQ3MA==",
      "original_commit_id" : "2cac00639e5eb22eb6b076bcc001196d958a4f2e",
      "original_line" : 28,
      "original_position" : 28,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 493590059,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492832470",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493158786"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493158786"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`exptime` is slightly ambiguous with \"expected time\" to me, maybe replace with \"timeout\" or \"expiry_time\" or just \"expiry\" ?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-23T02:23:39Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493158786",
      "id" : 493158786,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE1ODc4Ng==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 30,
      "original_position" : 30,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 493984643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493158786",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493160848"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493160848"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "\"(see further for details)\" is true of all these points, I think.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-23T02:30:44Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493160848",
      "id" : 493160848,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE2MDg0OA==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 29,
      "original_position" : 29,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 493984643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493160848",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493161600"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493161600"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This was confusing -- I read it as \"the first of many markers\" rather than \"a marker indicating it was first\" and wondered what these \"markers\" were. Adding quotes around \"first\" consistently might be better?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-23T02:33:34Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493161600",
      "id" : 493161600,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE2MTYwMA==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 69,
      "original_position" : 69,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 493984643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493161600",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493162248"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493162248"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Incomplete sentence?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-23T02:35:50Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the first marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the first mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ *   The overall effect of these rules is that an attacker that races announcements to us can delay",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493162248",
      "id" : 493162248,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE2MjI0OA==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 81,
      "original_position" : 81,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 493984643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493162248",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493163586"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493163586"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Add a reference to https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf to document/explain the invblock terminology? \"What does this have to do with an INV message about a block?\"",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-23T02:41:13Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the first marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the first mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ *   The overall effect of these rules is that an attacker that races announcements to us can delay\n+ *\n+ * \"First\" marker rules: the first marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the impact an attacker who races the network for many transaction can have.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and being influenceable by\n+ * attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493163586",
      "id" : 493163586,
      "line" : 95,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE2MzU4Ng==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 95,
      "original_position" : 106,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 95,
      "pull_request_review_id" : 493984643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493163586",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493163901"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493163901"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "\"and **not** being influencable by attackers\"",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-23T02:42:25Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the first marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the first mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ *   The overall effect of these rules is that an attacker that races announcements to us can delay\n+ *\n+ * \"First\" marker rules: the first marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the impact an attacker who races the network for many transaction can have.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and being influenceable by",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493163901",
      "id" : 493163901,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE2MzkwMQ==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 92,
      "original_position" : 92,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 493984643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493163901",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493166644"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493166644"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "\"uint64_t\" as a parameter name?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-23T02:53:21Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the first marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the first mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ *   The overall effect of these rules is that an attacker that races announcements to us can delay\n+ *\n+ * \"First\" marker rules: the first marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the impact an attacker who races the network for many transaction can have.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and being influenceable by\n+ * attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // No copy constructors.\n+    TxRequestTracker(const TxRequestTracker&) = delete;\n+    TxRequestTracker& operator=(const TxRequestTracker&) = delete;\n+\n+    // Move constructors.\n+    TxRequestTracker(TxRequestTracker&&) = default;\n+    TxRequestTracker& operator=(TxRequestTracker&&) = default;\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their exptime value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, but they timed out, a\n+    //   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DeletedPeer(uint64_t uint64_t);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493166644",
      "id" : 493166644,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE2NjY0NA==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 156,
      "original_position" : 156,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 493984643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493166644",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493168472"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493168472"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Isn't this exactly the same performance as having a subclass and making the methods virtual, except with all the dispatching written out explicitly? ie, could instead write something like:\r\n\r\n```c++\r\nclass TxRequestTracker\r\n{\r\nprotected:\r\n    TxRequestTracker() { } // pure virtual class, must instantiate via subclass\r\npublic:\r\n    virtual ~TxRequestTracker();\r\n    virtual void DeletedPeer(uint64_t peer) = 0;\r\n    ...\r\n};\r\nstd::unique_ptr<TxRequestTracker> CreateTxRequestTracker(bool deterministic = false);\r\n\r\nstatic std::unique_ptr<TxRequestTracker> g_txrequest = CreateTxRequestTracker() GUARDED_BY(cs_main);\r\n```\r\n\r\nthen hide the subclass in txrequest.cpp? Of course, \"exactly the same\" means no objective reason to prefer changing to this.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-23T03:00:34Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the first marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the first mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ *   The overall effect of these rules is that an attacker that races announcements to us can delay\n+ *\n+ * \"First\" marker rules: the first marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the impact an attacker who races the network for many transaction can have.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and being influenceable by\n+ * attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493168472",
      "id" : 493168472,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE2ODQ3Mg==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 122,
      "original_position" : 121,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 493984643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493168472",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493169664"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493169664"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Are these needed for fuzz testing, or could they be deleted as well? (copy constructors are implicitly deleted because of the unique ptr, so I think currently this is just making the implicit defaults explicit)",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-23T03:05:34Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the first marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the first mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ *   The overall effect of these rules is that an attacker that races announcements to us can delay\n+ *\n+ * \"First\" marker rules: the first marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the impact an attacker who races the network for many transaction can have.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and being influenceable by\n+ * attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // No copy constructors.\n+    TxRequestTracker(const TxRequestTracker&) = delete;\n+    TxRequestTracker& operator=(const TxRequestTracker&) = delete;\n+\n+    // Move constructors.\n+    TxRequestTracker(TxRequestTracker&&) = default;\n+    TxRequestTracker& operator=(TxRequestTracker&&) = default;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493169664",
      "id" : 493169664,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE2OTY2NA==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 134,
      "original_position" : 134,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 493984643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493169664",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@sr-gi You may be interested in this.",
      "created_at" : "2020-09-23T03:06:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#issuecomment-697104797",
      "id" : 697104797,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19988",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5NzEwNDc5Nw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-23T03:06:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/697104797",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493172470"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493172470"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'd like to keep txrequest mostly about the decision logic and data structure, while leaving net_processing responsible for the actual policy choices (\"what delays are given to which peers/requests\", \"what timeouts are used\", \"when exactly is a peer considered preferred\", \"when exactly is a peer considered overloaded\", \"how many announcements can be tracked per peer\").\r\n\r\nOf course, the explanation here is ideally as comprehensive as possible and not full of \"See some random comment in net_processing for the details\" references. Still, do you think it would be reasonable to say instead:\r\n\r\n> Whether it's from a \"preferred\" peer or not (what that means is up to the caller, but this is designed to correspond mostly to outbound peers, or others that are more trusted)\r\n\r\n?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-23T03:17:11Z",
      "diff_hunk" : "@@ -0,0 +1,226 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493172470",
      "id" : 493172470,
      "in_reply_to_id" : 492832470,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE3MjQ3MA==",
      "original_commit_id" : "2cac00639e5eb22eb6b076bcc001196d958a4f2e",
      "original_line" : 28,
      "original_position" : 28,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 494000631,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493172470",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493177000"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493177000"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Does anything limit the size of the returned vector? I think the main constraints are those in net_processing.cpp:RequestTx which could leave as many as 100k entries in CANDIDATE state for a given peer, so this could be a 4MB vector, which seems like it might be larger than desirable?\r\n\r\nIt's also constrained by how many txs can be INVed by a peer inbetween calls to GetRequestable, so in normal circumstances I'd expect this to be perfectly fine. I think you could get the worst case by quickly sending two max-size INV messages and two max-size NOTFOUND messages once the first request comes in.\r\n\r\n(I think this has to return a copy of the data items, because you want to iterate over them and request them, which would then modify the data structure, and that would invalidate the iterator you were using if you hadn't made a copy)",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-23T03:35:42Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the first marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the first mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ *   The overall effect of these rules is that an attacker that races announcements to us can delay\n+ *\n+ * \"First\" marker rules: the first marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the impact an attacker who races the network for many transaction can have.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and being influenceable by\n+ * attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // No copy constructors.\n+    TxRequestTracker(const TxRequestTracker&) = delete;\n+    TxRequestTracker& operator=(const TxRequestTracker&) = delete;\n+\n+    // Move constructors.\n+    TxRequestTracker(TxRequestTracker&&) = default;\n+    TxRequestTracker& operator=(TxRequestTracker&&) = default;\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their exptime value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, but they timed out, a\n+    //   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DeletedPeer(uint64_t uint64_t);\n+\n+    /** Deletes all entries for a given txhash.\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it. The is_wtxid flag of gtxid is ignored.\n+     */\n+    void ForgetTx(const GenTxid& gtxid);\n+\n+    /** Adds a new CANDIDATE entry.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that this means a second INV with the same txhash from the same peer will be ignored, even\n+     * if one is a txid and the other is wtxid (but that shouldn't happen, as BIP339 requires that all announced\n+     * inventory is exclusively using MSG_WTX). The new entry is given the specified preferred and reqtime values,\n+     * and takes it is_wtxid from the specified gtxid. It is eligible to get a first marker if overloaded is false\n+     * (but also subject to the other rules regarding the first marker).\n+     */\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred, bool overloaded,\n+        std::chrono::microseconds reqtime);\n+\n+    /** Converts the CANDIDATE entry for the provided peer and gtxid into a REQUESTED one.\n+     *\n+     * Exptime is set to the specified value. This can ONLY be called immediately after GetRequestable was called\n+     * (for the same peer), with only ForgetTx and other RequestedTx calls (both for other txhashes) in\n+     * between. Any other non-const operation removes the ability to call RequestedTx.\n+     */\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds exptime);\n+\n+    /** Converts any CANDIDATE or REQUESTED entry to a COMPLETED one, if one exists.\n+     *\n+     * It should be called whenever a transaction or NOTFOUND was received from a peer. When a good transaction is\n+     * received, ForgetTx should be called instead of (or in addition to) this operation.\n+     */\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid);\n+\n+    // The operations below inspect the data structure.\n+\n+    /** Find the txids to request now from peer.\n+     *\n+     * It does the following:\n+     *  - Convert all REQUESTED entries (for all txhashes/peers) with (exptime <= now) to COMPLETED entries.\n+     *  - Requestable entries are selected: CANDIDATE entries from the specified peer with (reqtime <= now) for\n+     *    which the specified peer is the best choice among all such CANDIDATE entries with the same txhash (subject\n+     *    to preference/first rules, and tiebreaking using a deterministic salted hash of peer and txhash).\n+     *  - The selected entries are sorted in order of announcement (even if multiple were added at the same time, or\n+     *    even when the clock went backwards while they were being added), converted to GenTxids using their\n+     *    is_wtxid flag, and returned.\n+     */\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493177000",
      "id" : 493177000,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE3NzAwMA==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 173,
      "original_position" : 205,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 493984643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493177000",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493179243"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493179243"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "\"Run a check on consistency of request times after a call to GetRequestable (requires the same timestamp as was passed to GetRequestable)\" might be a better description? (At first glance I thought it might have been timing the sanity check, or doing a limited sanity check that checked different things depending on how much time it was taking to run)",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-23T03:44:42Z",
      "diff_hunk" : "@@ -215,6 +215,12 @@ class TxRequestTracker {\n \n     /** Access to the internal PriorityComputer (for testing) */\n     const PriorityComputer& GetPriorityComputer() const;\n+\n+    /** Run internal consistency check (test only). */\n+    void SanityCheck() const;\n+\n+    /** Run a time-dependent consistency check (can only be called immediately after GetRequestable; test only). */\n+    void TimeSanityCheck(std::chrono::microseconds now) const;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493179243",
      "id" : 493179243,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE3OTI0Mw==",
      "original_commit_id" : "c50b25c2c4c63e1cfea6428913f35926282f3fd8",
      "original_line" : 223,
      "original_position" : 9,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 493984643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493179243",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493187263"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493187263"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Maybe this should be `overloaded == ... || g_txrequest.CountCandidates() >= 5000` or similar? I'm not sure I have a plausible enough scenario where this would be a benefit to justify the added code though.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-23T04:18:11Z",
      "diff_hunk" : "@@ -793,69 +726,24 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void RequestTx(NodeId nodeid, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n-\n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    if (g_txrequest.CountTracked(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+    auto delay = std::chrono::microseconds{0};\n+    bool preferred = state->fPreferredDownload;\n+    bool overloaded = g_txrequest.CountInFlight(nodeid) >= MAX_PEER_TX_IN_FLIGHT;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493187263",
      "id" : 493187263,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE4NzI2Mw==",
      "original_commit_id" : "c7601cdb31f9c86a4308cf36bbbc9c74c1078f53",
      "original_line" : 747,
      "original_position" : 178,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 493984643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493187263",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493190576"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493190576"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think if you were to make `RequestTx()` a method of `class PeerManager`, you could make `g_txrequest` be a private member `PeerManager::m_txrequest GUARDED_BY(cs_main)` instead of a global. OTOH, might be better to not do that until other globals that `PeerManager` methods rely on (like `mapNodeState`) are also moved. cc @jnewbery",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-23T04:30:45Z",
      "diff_hunk" : "@@ -793,69 +726,24 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void RequestTx(NodeId nodeid, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n-\n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493190576",
      "id" : 493190576,
      "line" : 865,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5MDU3Ng==",
      "original_commit_id" : "c7601cdb31f9c86a4308cf36bbbc9c74c1078f53",
      "original_line" : 865,
      "original_position" : 156,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 184,
      "pull_request_review_id" : 493984643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "LEFT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493190576",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493198222"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493198222"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Should replace this test with one that checks we start applying `OVERLOAD_PEER_TX_DELAY` ?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-23T05:00:55Z",
      "diff_hunk" : "@@ -121,38 +116,10 @@ def test_inv_block(self):\n         # * the first time it is re-requested from the outbound peer, plus\n         # * 2 seconds to avoid races\n         assert self.nodes[1].getpeerinfo()[0]['inbound'] == False\n-        timeout = 2 + (MAX_GETDATA_RANDOM_DELAY + INBOUND_PEER_TX_DELAY) + (\n-            GETDATA_TX_INTERVAL + MAX_GETDATA_RANDOM_DELAY)\n+        timeout = 2 + INBOUND_PEER_TX_DELAY + GETDATA_TX_INTERVAL\n         self.log.info(\"Tx should be received at node 1 after {} seconds\".format(timeout))\n         self.sync_mempools(timeout=timeout)\n \n-    def test_in_flight_max(self):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493198222",
      "id" : 493198222,
      "line" : 129,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5ODIyMg==",
      "original_commit_id" : "c7601cdb31f9c86a4308cf36bbbc9c74c1078f53",
      "original_line" : 129,
      "original_position" : 37,
      "original_start_line" : null,
      "path" : "test/functional/p2p_tx_download.py",
      "position" : 28,
      "pull_request_review_id" : 493984643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "LEFT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493198222",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493830506"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493830506"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@ajtowns Feel like writing such a test?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-23T19:05:24Z",
      "diff_hunk" : "@@ -121,38 +116,10 @@ def test_inv_block(self):\n         # * the first time it is re-requested from the outbound peer, plus\n         # * 2 seconds to avoid races\n         assert self.nodes[1].getpeerinfo()[0]['inbound'] == False\n-        timeout = 2 + (MAX_GETDATA_RANDOM_DELAY + INBOUND_PEER_TX_DELAY) + (\n-            GETDATA_TX_INTERVAL + MAX_GETDATA_RANDOM_DELAY)\n+        timeout = 2 + INBOUND_PEER_TX_DELAY + GETDATA_TX_INTERVAL\n         self.log.info(\"Tx should be received at node 1 after {} seconds\".format(timeout))\n         self.sync_mempools(timeout=timeout)\n \n-    def test_in_flight_max(self):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493830506",
      "id" : 493830506,
      "in_reply_to_id" : 493198222,
      "line" : 129,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgzMDUwNg==",
      "original_commit_id" : "c7601cdb31f9c86a4308cf36bbbc9c74c1078f53",
      "original_line" : 129,
      "original_position" : 37,
      "original_start_line" : null,
      "path" : "test/functional/p2p_tx_download.py",
      "position" : 28,
      "pull_request_review_id" : 494965962,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "LEFT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493830506",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493966435"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493966435"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done, approximately.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T00:10:18Z",
      "diff_hunk" : "@@ -0,0 +1,226 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493966435",
      "id" : 493966435,
      "in_reply_to_id" : 492832470,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk2NjQzNQ==",
      "original_commit_id" : "2cac00639e5eb22eb6b076bcc001196d958a4f2e",
      "original_line" : 28,
      "original_position" : 28,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495137408,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493966435",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493966501"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493966501"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Changed to \"expiry\".",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T00:10:29Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493966501",
      "id" : 493966501,
      "in_reply_to_id" : 493158786,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk2NjUwMQ==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 30,
      "original_position" : 30,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495137464,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493966501",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493966652"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493966652"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I was trying to refer to the specific section on the \"first\" marker. Made that more explicit.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T00:10:57Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493966652",
      "id" : 493966652,
      "in_reply_to_id" : 493160848,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk2NjY1Mg==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 29,
      "original_position" : 29,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495137619,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493966652",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493966692"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493966692"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T00:11:05Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493966692",
      "id" : 493966692,
      "in_reply_to_id" : 493161600,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk2NjY5Mg==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 69,
      "original_position" : 69,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495137670,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493966692",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493966778"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493966778"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Removed. It was a leftover of what turned into the last comment section.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T00:11:20Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the first marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the first mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ *   The overall effect of these rules is that an attacker that races announcements to us can delay",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493966778",
      "id" : 493966778,
      "in_reply_to_id" : 493162248,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk2Njc3OA==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 81,
      "original_position" : 81,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495137767,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493966778",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493966818"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493966818"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T00:11:26Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the first marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the first mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ *   The overall effect of these rules is that an attacker that races announcements to us can delay\n+ *\n+ * \"First\" marker rules: the first marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the impact an attacker who races the network for many transaction can have.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and being influenceable by\n+ * attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493966818",
      "id" : 493966818,
      "in_reply_to_id" : 493163586,
      "line" : 95,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk2NjgxOA==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 95,
      "original_position" : 106,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 95,
      "pull_request_review_id" : 495137808,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493966818",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493966899"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493966899"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done, approximately.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T00:11:41Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the first marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the first mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ *   The overall effect of these rules is that an attacker that races announcements to us can delay\n+ *\n+ * \"First\" marker rules: the first marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the impact an attacker who races the network for many transaction can have.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and being influenceable by",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493966899",
      "id" : 493966899,
      "in_reply_to_id" : 493163901,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk2Njg5OQ==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 92,
      "original_position" : 92,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495137901,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493966899",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493967057"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493967057"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Apparently that's not actually a 128-bit type ;)\r\n\r\nFixed.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T00:12:19Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the first marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the first mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ *   The overall effect of these rules is that an attacker that races announcements to us can delay\n+ *\n+ * \"First\" marker rules: the first marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the impact an attacker who races the network for many transaction can have.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and being influenceable by\n+ * attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // No copy constructors.\n+    TxRequestTracker(const TxRequestTracker&) = delete;\n+    TxRequestTracker& operator=(const TxRequestTracker&) = delete;\n+\n+    // Move constructors.\n+    TxRequestTracker(TxRequestTracker&&) = default;\n+    TxRequestTracker& operator=(TxRequestTracker&&) = default;\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their exptime value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, but they timed out, a\n+    //   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DeletedPeer(uint64_t uint64_t);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493967057",
      "id" : 493967057,
      "in_reply_to_id" : 493166644,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk2NzA1Nw==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 156,
      "original_position" : 156,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495138090,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493967057",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493968967"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493968967"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It's not **exactly** the same, I think. Calling member functions on a `TxRequestTracker` would incur a lookup in the vtable to find the code to execute. The current solution has link-time determined code flow, and only an extra indirection to find the object's storage.\r\n\r\nI don't think either is remotely relevant for performance here, and the subclass approach you suggest is probably somewhat lighter syntactically. I'm happy to change it if other reviewers agree.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T00:18:55Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the first marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the first mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ *   The overall effect of these rules is that an attacker that races announcements to us can delay\n+ *\n+ * \"First\" marker rules: the first marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the impact an attacker who races the network for many transaction can have.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and being influenceable by\n+ * attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493968967",
      "id" : 493968967,
      "in_reply_to_id" : 493168472,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk2ODk2Nw==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 122,
      "original_position" : 121,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495140122,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493968967",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493969150"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493969150"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Gone.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T00:19:27Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the first marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the first mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ *   The overall effect of these rules is that an attacker that races announcements to us can delay\n+ *\n+ * \"First\" marker rules: the first marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the impact an attacker who races the network for many transaction can have.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and being influenceable by\n+ * attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // No copy constructors.\n+    TxRequestTracker(const TxRequestTracker&) = delete;\n+    TxRequestTracker& operator=(const TxRequestTracker&) = delete;\n+\n+    // Move constructors.\n+    TxRequestTracker(TxRequestTracker&&) = default;\n+    TxRequestTracker& operator=(TxRequestTracker&&) = default;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493969150",
      "id" : 493969150,
      "in_reply_to_id" : 493169664,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk2OTE1MA==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 134,
      "original_position" : 134,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495140308,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493969150",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493969647"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493969647"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've added a commit that just reduces MAX_PEER_TX_ANNOUNCEMENTS; 100000 was ridiculous. It can be bypassed using the PF_RELAY permission.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T00:21:04Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the first marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the first mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ *   The overall effect of these rules is that an attacker that races announcements to us can delay\n+ *\n+ * \"First\" marker rules: the first marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the impact an attacker who races the network for many transaction can have.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and being influenceable by\n+ * attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // No copy constructors.\n+    TxRequestTracker(const TxRequestTracker&) = delete;\n+    TxRequestTracker& operator=(const TxRequestTracker&) = delete;\n+\n+    // Move constructors.\n+    TxRequestTracker(TxRequestTracker&&) = default;\n+    TxRequestTracker& operator=(TxRequestTracker&&) = default;\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their exptime value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, but they timed out, a\n+    //   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DeletedPeer(uint64_t uint64_t);\n+\n+    /** Deletes all entries for a given txhash.\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it. The is_wtxid flag of gtxid is ignored.\n+     */\n+    void ForgetTx(const GenTxid& gtxid);\n+\n+    /** Adds a new CANDIDATE entry.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that this means a second INV with the same txhash from the same peer will be ignored, even\n+     * if one is a txid and the other is wtxid (but that shouldn't happen, as BIP339 requires that all announced\n+     * inventory is exclusively using MSG_WTX). The new entry is given the specified preferred and reqtime values,\n+     * and takes it is_wtxid from the specified gtxid. It is eligible to get a first marker if overloaded is false\n+     * (but also subject to the other rules regarding the first marker).\n+     */\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred, bool overloaded,\n+        std::chrono::microseconds reqtime);\n+\n+    /** Converts the CANDIDATE entry for the provided peer and gtxid into a REQUESTED one.\n+     *\n+     * Exptime is set to the specified value. This can ONLY be called immediately after GetRequestable was called\n+     * (for the same peer), with only ForgetTx and other RequestedTx calls (both for other txhashes) in\n+     * between. Any other non-const operation removes the ability to call RequestedTx.\n+     */\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds exptime);\n+\n+    /** Converts any CANDIDATE or REQUESTED entry to a COMPLETED one, if one exists.\n+     *\n+     * It should be called whenever a transaction or NOTFOUND was received from a peer. When a good transaction is\n+     * received, ForgetTx should be called instead of (or in addition to) this operation.\n+     */\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid);\n+\n+    // The operations below inspect the data structure.\n+\n+    /** Find the txids to request now from peer.\n+     *\n+     * It does the following:\n+     *  - Convert all REQUESTED entries (for all txhashes/peers) with (exptime <= now) to COMPLETED entries.\n+     *  - Requestable entries are selected: CANDIDATE entries from the specified peer with (reqtime <= now) for\n+     *    which the specified peer is the best choice among all such CANDIDATE entries with the same txhash (subject\n+     *    to preference/first rules, and tiebreaking using a deterministic salted hash of peer and txhash).\n+     *  - The selected entries are sorted in order of announcement (even if multiple were added at the same time, or\n+     *    even when the clock went backwards while they were being added), converted to GenTxids using their\n+     *    is_wtxid flag, and returned.\n+     */\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493969647",
      "id" : 493969647,
      "in_reply_to_id" : 493177000,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk2OTY0Nw==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 173,
      "original_position" : 205,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495140823,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493969647",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493970079"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493970079"
         }
      },
      "author_association" : "MEMBER",
      "body" : "With MAX_PEER_TX_ANNOUNCEMENTS reduced, is that still needed?\r\n\r\nI'm a bit hesitant about this, as the number of announcements tracked for a peer is somewhat dependent on other peers' behavior.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T00:22:26Z",
      "diff_hunk" : "@@ -793,69 +726,24 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void RequestTx(NodeId nodeid, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n-\n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    if (g_txrequest.CountTracked(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+    auto delay = std::chrono::microseconds{0};\n+    bool preferred = state->fPreferredDownload;\n+    bool overloaded = g_txrequest.CountInFlight(nodeid) >= MAX_PEER_TX_IN_FLIGHT;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493970079",
      "id" : 493970079,
      "in_reply_to_id" : 493187263,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk3MDA3OQ==",
      "original_commit_id" : "c7601cdb31f9c86a4308cf36bbbc9c74c1078f53",
      "original_line" : 747,
      "original_position" : 178,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 495141294,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493970079",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493970217"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493970217"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Renamed to PostGetRequestableSanityCheck, and updated comment.\r\n\r\nIt's not just a consistency check of request times.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T00:23:02Z",
      "diff_hunk" : "@@ -215,6 +215,12 @@ class TxRequestTracker {\n \n     /** Access to the internal PriorityComputer (for testing) */\n     const PriorityComputer& GetPriorityComputer() const;\n+\n+    /** Run internal consistency check (test only). */\n+    void SanityCheck() const;\n+\n+    /** Run a time-dependent consistency check (can only be called immediately after GetRequestable; test only). */\n+    void TimeSanityCheck(std::chrono::microseconds now) const;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493970217",
      "id" : 493970217,
      "in_reply_to_id" : 493179243,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk3MDIxNw==",
      "original_commit_id" : "c50b25c2c4c63e1cfea6428913f35926282f3fd8",
      "original_line" : 223,
      "original_position" : 9,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495141467,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493970217",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493970343"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493970343"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I haven't paid too much attention to that, but I'm happy to change this if desirable.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T00:23:31Z",
      "diff_hunk" : "@@ -793,69 +726,24 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void RequestTx(NodeId nodeid, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n-\n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493970343",
      "id" : 493970343,
      "in_reply_to_id" : 493190576,
      "line" : 865,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk3MDM0Mw==",
      "original_commit_id" : "c7601cdb31f9c86a4308cf36bbbc9c74c1078f53",
      "original_line" : 865,
      "original_position" : 156,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 184,
      "pull_request_review_id" : 495141615,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "LEFT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493970343",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494035871"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494035871"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Ah, good point! That seems a sufficient reason, so going to mark this as resolved.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T04:46:23Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the first marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the first mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ *   The overall effect of these rules is that an attacker that races announcements to us can delay\n+ *\n+ * \"First\" marker rules: the first marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the impact an attacker who races the network for many transaction can have.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and being influenceable by\n+ * attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494035871",
      "id" : 494035871,
      "in_reply_to_id" : 493168472,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAzNTg3MQ==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 122,
      "original_position" : 121,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495216030,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494035871",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494039908"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494039908"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yeah, sounds good.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T05:01:46Z",
      "diff_hunk" : "@@ -793,69 +726,24 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void RequestTx(NodeId nodeid, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n-\n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    if (g_txrequest.CountTracked(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+    auto delay = std::chrono::microseconds{0};\n+    bool preferred = state->fPreferredDownload;\n+    bool overloaded = g_txrequest.CountInFlight(nodeid) >= MAX_PEER_TX_IN_FLIGHT;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494039908",
      "id" : 494039908,
      "in_reply_to_id" : 493187263,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAzOTkwOA==",
      "original_commit_id" : "c7601cdb31f9c86a4308cf36bbbc9c74c1078f53",
      "original_line" : 747,
      "original_position" : 178,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 495220833,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494039908",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494041957"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494041957"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Not sure I follow, the only asserts are comparisons between `entry.m_time` and `now` ? Or should I have said \"entry times\" because \"request\" times might only mean REQUESTED entries?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T05:09:51Z",
      "diff_hunk" : "@@ -215,6 +215,12 @@ class TxRequestTracker {\n \n     /** Access to the internal PriorityComputer (for testing) */\n     const PriorityComputer& GetPriorityComputer() const;\n+\n+    /** Run internal consistency check (test only). */\n+    void SanityCheck() const;\n+\n+    /** Run a time-dependent consistency check (can only be called immediately after GetRequestable; test only). */\n+    void TimeSanityCheck(std::chrono::microseconds now) const;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494041957",
      "id" : 494041957,
      "in_reply_to_id" : 493179243,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA0MTk1Nw==",
      "original_commit_id" : "c50b25c2c4c63e1cfea6428913f35926282f3fd8",
      "original_line" : 223,
      "original_position" : 9,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495223339,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494041957",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494043594"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494043594"
         }
      },
      "author_association" : "MEMBER",
      "body" : "m_time is the reqtime for CANDIDATE_*, but expiry for REQUESTED entries.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T05:16:04Z",
      "diff_hunk" : "@@ -215,6 +215,12 @@ class TxRequestTracker {\n \n     /** Access to the internal PriorityComputer (for testing) */\n     const PriorityComputer& GetPriorityComputer() const;\n+\n+    /** Run internal consistency check (test only). */\n+    void SanityCheck() const;\n+\n+    /** Run a time-dependent consistency check (can only be called immediately after GetRequestable; test only). */\n+    void TimeSanityCheck(std::chrono::microseconds now) const;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494043594",
      "id" : 494043594,
      "in_reply_to_id" : 493179243,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA0MzU5NA==",
      "original_commit_id" : "c50b25c2c4c63e1cfea6428913f35926282f3fd8",
      "original_line" : 223,
      "original_position" : 9,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495225257,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494043594",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494053379"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494053379"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Not sure if it's worth adding any explicit justification for picking that number. But for the record, my thinking is: if our peers use the same `INVENTORY_BROADCAST_INTERVAL`, `INVENTORY_BROADCAST_MAX` params as us (and assuming they also halve the interval when they consider us an outbound, ie when we consider them an inbound), then 5000 is about 16 minutes worth of INVs for our outbounds, and 5 minutes for our inbounds. (More presuming we actually receive txs and thus clear entries out, or already had them)",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T05:49:32Z",
      "diff_hunk" : "@@ -75,7 +75,7 @@ static const unsigned int MAX_INV_SZ = 50000;\n /** Maximum number of in-flight transactions from a peer */\n static constexpr int32_t MAX_PEER_TX_IN_FLIGHT = 100;\n /** Maximum number of announced transactions from a peer */\n-static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 2 * MAX_INV_SZ;\n+static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 5000;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494053379",
      "id" : 494053379,
      "line" : 81,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA1MzM3OQ==",
      "original_commit_id" : "06d708c7cb9b649ed6af0d95bd5e10c9e75e02d9",
      "original_line" : 81,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 15,
      "pull_request_review_id" : 495233660,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494053379",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494242666"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494242666"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yes, I think this would be an improvement for encapsulation and for being explicit about when the TxRequestManager is constructed/destructed. It's my understanding that global static objects can be constructed before main() or later.\r\n\r\nThere isn't any requirement to wait for `mapNodeState` to move to `PeerManager`.\r\n\r\nI have a branch that moves TxRequestTracker and RequestTx() to be members of PeerManager here: https://github.com/jnewbery/bitcoin/tree/pr19988.1. The move is in a separate commit in that branch for ease of review, but should be squashed into _Change transaction request logic to use txrequest_.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T11:36:53Z",
      "diff_hunk" : "@@ -793,69 +726,24 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void RequestTx(NodeId nodeid, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n-\n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494242666",
      "id" : 494242666,
      "in_reply_to_id" : 493190576,
      "line" : 865,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI0MjY2Ng==",
      "original_commit_id" : "c7601cdb31f9c86a4308cf36bbbc9c74c1078f53",
      "original_line" : 865,
      "original_position" : 156,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 184,
      "pull_request_review_id" : 495477045,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "LEFT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494242666",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494257310"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494257310"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Consider using the `default` syntax to indicate that you only included this in the cpp file so the `m_impl` unique ptr can be destructed:\r\n\r\n```suggestion\r\nTxRequestTracker::~TxRequestTracker() = default;\r\n```",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T12:00:49Z",
      "diff_hunk" : "@@ -0,0 +1,715 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+TxRequestTracker::PriorityComputer::PriorityComputer(bool deterministic) :\n+    m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+    m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+uint64_t TxRequestTracker::PriorityComputer::operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const\n+{\n+    uint64_t low_bits = 0;\n+    if (!first) {\n+        low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+    }\n+    return low_bits | uint64_t{!preferred} << 63;\n+}\n+\n+static const uint256 UINT256_ZERO;\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient\n+    //! implementation. Also note that the sorting order of EntryTxHash relies on the specific order of values in\n+    //! this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_DELAYED,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST.\n+        CANDIDATE_READY,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+\n+        //! An invalid State value that's larger than all valid ones.\n+        TOO_LARGE,\n+    };\n+\n+    /** A flag (in Entry::m_per_txhash) to indicate that for that txhash,\n+     *  new preferred announcements are not eligible to get the 'first' marker. */\n+    static constexpr uint8_t TXHASHINFO_NO_MORE_PREFERRED_FIRST = 1;\n+    /** A flag (in Entry::m_per_txhash) to indicate that for that txhash,\n+     *  new non-preferred announcements are not eligible to get the 'first' marker. */\n+    static constexpr uint8_t TXHASHINFO_NO_MORE_NONPREFERRED_FIRST = 2;\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxHash-based index.\n+    struct ByTxHash {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+    using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txhash;\n+        //! For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 56;\n+        //! Whether the request is preferred (giving it priority higher than non-preferred ones).\n+        const bool m_preferred : 1;\n+        //! Whether this is a wtxid request.\n+        const bool m_is_wtxid : 1;\n+        //! Whether this was: the very first announcement for this txhash, within the\n+        //! preferred or non-preferred ones, and no request had been made for this\n+        //! txhash from any peer at the time the announcement came in.\n+        const bool m_first : 1;\n+\n+        //! What state this announcement is in\n+        //! This is a uint8_t instead of a State to silence a GCC warning.\n+        uint8_t m_state : 3;\n+\n+        /** Per-txhash flags. These are stored in the last Entry for a given txhash (ByTxHash order).\n+         *  The values for other Entry objects can be arbitrary subsets of the actual flags. */\n+        mutable uint8_t m_per_txhash : 2;\n+\n+        //! Convert the m_state variable to a State enum.\n+        State GetState() const { return State(m_state); }\n+        //! Convert a State to a uint8_t and store it in m_state.\n+        void SetState(State state) { m_state = uint8_t(state); }\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txhash.\n+        bool IsSelected() const\n+        {\n+            return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+        }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const\n+        {\n+            return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+        }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const\n+        {\n+            return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+        }\n+\n+        //! Construct a new entry from scratch, initially in CANDIDATE_DELAYED state.\n+        Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+            uint64_t sequence, bool first) :\n+            m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+            m_is_wtxid(gtxid.IsWtxid()), m_first(first), m_state(uint8_t(State::CANDIDATE_DELAYED)),\n+            m_per_txhash(0) {}\n+\n+        //! Compute this Entry's priority.\n+        uint64_t ComputePriority(const PriorityComputer& computer) const\n+        {\n+            return computer(m_txhash, m_peer, m_preferred, m_first);\n+        }\n+\n+        //! Extract the EntryPeer from this Entry.\n+        EntryPeer ExtractPeer() const { return EntryPeer{m_peer, GetState() == State::CANDIDATE_BEST, m_txhash}; }\n+\n+        //! Extract the EntryTxHash from this Entry.\n+        EntryTxHash ExtractTxid(const PriorityComputer& computer) const\n+        {\n+            return EntryTxHash{\n+                m_txhash,\n+                GetState(),\n+                GetState() == State::CANDIDATE_READY ? ComputePriority(computer) : 0\n+            };\n+        }\n+\n+        //! Extract the EntryTime from this Entry.\n+        EntryTime ExtractTime() const { return EntryTime{IsWaiting() ? 0 : IsSelectable() ? 2 : 1, m_time}; }\n+    };\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    /** An extractor for EntryTxHash (with encapsulated PriorityComputer reference).\n+     *\n+     * See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+     * for more information about the key extraction concept.\n+     */\n+    class EntryTxHashExtractor {\n+        const PriorityComputer& m_computer;\n+    public:\n+        EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+        using result_type = EntryTxHash; // Needed to comply with key extractor interface\n+        result_type operator()(const Entry& entry) const { return entry.ExtractTxid(m_computer); }\n+    };\n+\n+    //! Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes).\n+    using Index = boost::multi_index_container<\n+        Entry,\n+        boost::multi_index::indexed_by<\n+            boost::multi_index::ordered_unique<\n+                boost::multi_index::tag<ByPeer>,\n+                boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTxHash>,\n+                EntryTxHashExtractor\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTime>,\n+                boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>\n+            >\n+        >\n+    >;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Per-peer statistics object.\n+    struct PeerInfo {\n+        size_t m_total = 0; //!< Total number of entries for this peer.\n+        size_t m_requested = 0; //!< Total number of REQUESTED entries for this peer.\n+\n+        friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+        {\n+            return std::tie(a.m_total, a.m_requested) == std::tie(b.m_total, b.m_requested);\n+        }\n+    };\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo and m_per_txhash up to date.\n+    template<typename Tag>\n+    typename Index::index<Tag>::type::iterator Erase(typename Index::index<Tag>::type::iterator it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        // As it may possibly be the last-sorted Entry for a given txhash, propagate its per-txhash flags to its\n+        // predecessor (if it belongs to the same txhash).\n+        auto bytxhashit = m_index.project<ByTxHash>(it);\n+        if (bytxhashit != m_index.get<ByTxHash>().begin() &&\n+            bytxhashit->m_txhash == std::prev(bytxhashit)->m_txhash) {\n+            std::prev(bytxhashit)->m_per_txhash |= bytxhashit->m_per_txhash;\n+        }\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo and m_per_txhash up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(typename Index::index<Tag>::type::iterator it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        // It's possible that it used to be the last-sorted Entry for its txhash, so propagate its\n+        // flags to its predecessor (which would then become the new last-sorted Entry).\n+        auto bytxhashit = m_index.project<ByTxHash>(it);\n+        if (bytxhashit != m_index.get<ByTxHash>().begin() &&\n+            bytxhashit->m_txhash == std::prev(bytxhashit)->m_txhash) {\n+            std::prev(bytxhashit)->m_per_txhash |= bytxhashit->m_per_txhash;\n+        }\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        // It's possible that it is now the new last-sorted Entry for its txhash, so propagate flags\n+        // from its predecessor to it.\n+        bytxhashit = m_index.project<ByTxHash>(it);\n+        if (bytxhashit != m_index.get<ByTxHash>().begin() &&\n+            bytxhashit->m_txhash == std::prev(bytxhashit)->m_txhash) {\n+            bytxhashit->m_per_txhash |= std::prev(bytxhashit)->m_per_txhash;\n+        }\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(typename Index::index<ByTxHash>::type::iterator it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txid, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txid that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txid already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = std::prev(it)->ComputePriority(m_computer);\n+            uint64_t priority_new = it->ComputePriority(m_computer);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(typename Index::index<ByTxHash>::type::iterator it, State new_state)\n+    {\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in\n+            // the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Entry for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(typename Index::index<ByTxHash>::type::iterator it)\n+    {\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED entries.\n+\n+        // If this Entry's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Entry's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    //! Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txid, they are all\n+    //! deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+    //! CANDIDATE_BEST. Returns whether the Entry still exists.\n+    bool MakeCompleted(typename Index::index<ByTxHash>::type::iterator it)\n+    {\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED entry for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the entry COMPLETED, and select the next best entry (the first CANDIDATE_READY) if needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to EntryTxHashExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(\n+                boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>(),\n+                std::less<EntryPeer>()\n+            ),\n+            boost::make_tuple(\n+                EntryTxHashExtractor(m_computer),\n+                std::less<EntryTxHash>()\n+            ),\n+            boost::make_tuple(\n+                boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>(),\n+                std::less<EntryTime>()\n+            )\n+        )) {}\n+\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxHashExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DeletedPeer(uint64_t peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+            // CANDIDATE_BEST, or delete all of a txid's entries if no non-COMPLETED ones are left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTx(const GenTxid& gtxid)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == gtxid.GetHash()) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred, bool overloaded,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST entry for this (txid, peer) combination. The case where there is\n+        // a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+        // automatically.\n+        if (m_index.get<ByPeer>().count(EntryPeer{peer, true, gtxid.GetHash()})) return;\n+\n+        // Find last entry for this txhash, and extract per_txhash information from it.\n+        uint8_t per_txhash = 0;\n+        typename Index::index<ByTxHash>::type::iterator it_last = m_index.get<ByTxHash>().end();\n+        // First find the first entry past this txhash.\n+        it_last = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0});\n+        if (it_last != m_index.get<ByTxHash>().begin() && std::prev(it_last)->m_txhash == gtxid.GetHash()) {\n+            // Its predecessor exists, and has the right txhash. Remember it, and OR in its flags.\n+            it_last--;\n+            per_txhash |= it_last->m_per_txhash;\n+        } else {\n+            // No entry for this txhash exists yet.\n+            it_last = m_index.get<ByTxHash>().end();\n+        }\n+\n+        // Determine whether the new announcement's Entry will get the first marker, and update\n+        // the per_txhash information to be stored (but note that per_txhash isn't actually stored\n+        // until after the emplace below succeeds).\n+        bool first = false;\n+        if (!overloaded) {\n+            if (preferred && !(per_txhash & TXHASHINFO_NO_MORE_PREFERRED_FIRST)) {\n+                first = true;\n+                per_txhash |= TXHASHINFO_NO_MORE_PREFERRED_FIRST;\n+            } else if (!preferred && !(per_txhash & TXHASHINFO_NO_MORE_NONPREFERRED_FIRST)) {\n+                first = true;\n+                per_txhash |= TXHASHINFO_NO_MORE_NONPREFERRED_FIRST;\n+            }\n+        }\n+\n+        // Try creating the entry with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST entry already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_sequence, first);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+\n+        // Update m_per_txhash of the new last Entry (either the newly created one, or it_last).\n+        auto it = m_index.project<ByTxHash>(ret.first);\n+        if (it_last == m_index.get<ByTxHash>().end() || std::next(it_last) == it) it_last = it;\n+        it_last->m_per_txhash |= per_txhash;\n+    }\n+\n+    //! Find the txids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now)\n+    {\n+        // Move time.\n+        SetTimePoint(now);\n+\n+        // Find all CANDIDATE_BEST entries for this peer.\n+        std::vector<std::pair<uint64_t, const Entry*>> selected;\n+        auto it_peer = m_index.get<ByPeer>().lower_bound(EntryPeer{peer, true, UINT256_ZERO});\n+        while (it_peer != m_index.get<ByPeer>().end() && it_peer->m_peer == peer &&\n+            it_peer->GetState() == State::CANDIDATE_BEST) {\n+            selected.emplace_back(it_peer->m_sequence, &*it_peer);\n+            ++it_peer;\n+        }\n+\n+        // Return them, sorted by sequence number.\n+        std::sort(selected.begin(), selected.end());\n+        std::vector<GenTxid> ret;\n+        for (const auto& item : selected) {\n+            ret.emplace_back(item.second->m_is_wtxid, item.second->m_txhash);\n+        }\n+        return ret;\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds expiry)\n+    {\n+        auto it = m_index.get<ByPeer>().find(EntryPeer{peer, true, gtxid.GetHash()});\n+        // RequestedTx can only be called on CANDIDATE_BEST entries (this is implied by its condition that it can only be\n+        // called on txids returned by GetRequestable (and only AlreadyHave and RequestedTx can be called in between,\n+        // which preserve the state of other txids).\n+        assert(it != m_index.get<ByPeer>().end());\n+        assert(it->GetState() == State::CANDIDATE_BEST);\n+        Modify<ByPeer>(it, [expiry](Entry& entry) {\n+            entry.SetState(State::REQUESTED);\n+            entry.m_time = expiry;\n+        });\n+\n+        // Update the m_per_txhash (of the last Entry for this txhash) to reflect that new ones are no longer\n+        // eligible for the \"first\" marker.\n+        auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0}));\n+        assert(it_last->m_txhash == gtxid.GetHash());\n+        it_last->m_per_txhash |= TXHASHINFO_NO_MORE_PREFERRED_FIRST | TXHASHINFO_NO_MORE_NONPREFERRED_FIRST;\n+    }\n+\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid)\n+    {\n+        // We need to search the ByPeer index for both (peer, false, txid) and (peer, true, txid).\n+        auto it = m_index.get<ByPeer>().find(EntryPeer{peer, false, gtxid.GetHash()});\n+        if (it == m_index.get<ByPeer>().end()) {\n+            it = m_index.get<ByPeer>().find(EntryPeer{peer, true, gtxid.GetHash()});\n+        }\n+        if (it != m_index.get<ByPeer>().end()) MakeCompleted(m_index.project<ByTxHash>(it));\n+    }\n+\n+    size_t CountInFlight(uint64_t peer) const\n+    {\n+        auto it = m_peerinfo.find(peer);\n+        if (it != m_peerinfo.end()) return it->second.m_requested;\n+        return 0;\n+    }\n+\n+    size_t CountTracked(uint64_t peer) const\n+    {\n+        auto it = m_peerinfo.find(peer);\n+        if (it != m_peerinfo.end()) return it->second.m_total;\n+        return 0;\n+    }\n+\n+    //! Count how many announcements are being tracked in total across all peers and transactions.\n+    size_t Size() const { return m_index.size(); }\n+\n+    //! Access to the internal PriorityComputer (for testing)\n+    const PriorityComputer& GetPriorityComputer() const { return m_computer; }\n+\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata.\n+        // This verifies the data in it, including the invariant\n+        // that no entries with m_total_announcements==0 exist.\n+        std::unordered_map<uint64_t, PeerInfo> peerinfo;\n+        for (const auto& a : m_index) {\n+            auto& entry = peerinfo[a.m_peer];\n+            ++entry.m_total;\n+            entry.m_requested += (a.GetState() == State::REQUESTED);\n+        }\n+        assert(m_peerinfo == peerinfo);\n+\n+        struct Counts {\n+            //! Number of CANDIDATE_DELAYED entries for this txhash.\n+            size_t m_candidate_delayed = 0;\n+            //! Number of CANDIDATE_READY entries for this txhash.\n+            size_t m_candidate_ready = 0;\n+            //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+            size_t m_candidate_best = 0;\n+            //! Number of REQUESTED entries for this txhash.\n+            size_t m_requested = 0;\n+            //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+            uint64_t m_priority_candidate_best = 0;\n+            //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+            uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+            //! All peers we have an entry for this txhash for.\n+            std::vector<uint64_t> m_peers;\n+            //! Whether any preferred first entry exists.\n+            bool m_any_preferred_first = false;\n+            //! Whether any non-preferred first entry exists.\n+            bool m_any_nonpreferred_first = false;\n+            //! OR of all m_per_txhash flags.\n+            uint8_t m_or_all_per_txhash = 0;\n+        };\n+\n+        std::map<uint256, Counts> table;\n+        for (const auto& a : m_index) {\n+            auto& entry = table[a.m_txhash];\n+            // Classify how many types peers we have for this txid.\n+            entry.m_candidate_delayed += (a.GetState() == State::CANDIDATE_DELAYED);\n+            entry.m_candidate_ready += (a.GetState() == State::CANDIDATE_READY);\n+            entry.m_candidate_best += (a.GetState() == State::CANDIDATE_BEST);\n+            entry.m_requested += (a.GetState() == State::REQUESTED);\n+            // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+            if (a.GetState() == State::CANDIDATE_BEST) {\n+                entry.m_priority_candidate_best = a.ComputePriority(m_computer);\n+            }\n+            if (a.GetState() == State::CANDIDATE_READY) {\n+                entry.m_priority_best_candidate_ready = std::min(entry.m_priority_best_candidate_ready,\n+                    a.ComputePriority(m_computer));\n+            }\n+            // Also keep track of which peers this txid has an entry for (so we can detect duplicates).\n+            entry.m_peers.push_back(a.m_peer);\n+            // Track preferred/first.\n+            entry.m_any_preferred_first |= (a.m_first && a.m_preferred);\n+            entry.m_any_nonpreferred_first |= (a.m_first && !a.m_preferred);\n+            entry.m_or_all_per_txhash |= a.m_per_txhash;\n+        }\n+        for (auto& entry : table) {\n+            auto& c = entry.second;\n+            // Cannot have only COMPLETED peers (txid should have been deleted)\n+            assert(c.m_candidate_delayed + c.m_candidate_ready + c.m_candidate_best + c.m_requested > 0);\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(c.m_candidate_best + c.m_requested <= 1);\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (c.m_candidate_ready > 0) {\n+                assert(c.m_candidate_best + c.m_requested == 1);\n+            }\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good as the best CANDIDATE_READY.\n+            if (c.m_candidate_ready && c.m_candidate_best) {\n+                assert(c.m_priority_candidate_best <= c.m_priority_best_candidate_ready);\n+            }\n+            // Detect duplicate (peer, txid) entries\n+            std::sort(c.m_peers.begin(), c.m_peers.end());\n+            assert(std::adjacent_find(c.m_peers.begin(), c.m_peers.end()) == c.m_peers.end());\n+            // Verify all per_txhash flags.\n+            uint8_t expected_per_txhash = 0;\n+            if (c.m_any_preferred_first || c.m_requested) {\n+                expected_per_txhash |= TXHASHINFO_NO_MORE_PREFERRED_FIRST;\n+            }\n+            if (c.m_any_nonpreferred_first || c.m_requested) {\n+                expected_per_txhash |= TXHASHINFO_NO_MORE_NONPREFERRED_FIRST;\n+            }\n+            // All expected flags must be present, but there can be more. If a node went from REQUESTED to\n+            // COMPLETED, or was deleted, our expected_per_txhash may miss the relevant bits.\n+            assert((expected_per_txhash & ~c.m_or_all_per_txhash) == 0);\n+            // No entry can have flags that are a superset of the actual ones (they're always ORed into the actual\n+            // one).\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{entry.first, State::TOO_LARGE, 0}));\n+            assert(it_last->m_txhash == entry.first);\n+            assert(c.m_or_all_per_txhash == it_last->m_per_txhash);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+};\n+\n+TxRequestTracker::TxRequestTracker(bool deterministic)\n+{\n+    m_impl = MakeUnique<TxRequestTracker::Impl>(deterministic);\n+}\n+\n+TxRequestTracker::~TxRequestTracker() {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494257310",
      "id" : 494257310,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI1NzMxMA==",
      "original_commit_id" : "7949d08406774f27fd0291c2aa046ecdf985c191",
      "original_line" : 676,
      "original_position" : 676,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 495495274,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494257310",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494323998"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494323998"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It looks like this is only in the header so that the unit and fuzz tests can call `GetPriorityComputer()` and get the computer, and the only reason they do that is so they can call `PriorityComputer::operator()()`.\r\n\r\nCould you move all this to the implementation file, and add a public method `ComputePriority` to by used by the tests that calculates the priority internally and returns it?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T13:38:39Z",
      "diff_hunk" : "@@ -0,0 +1,222 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the \"first\" marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the \"first\" mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ * \"First\" marker rules: the \"first\" marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the extent to which attackers that race the network in announcing all transactions\n+ *              can break chains of dependent transactions.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and avoiding influenceable\n+ * by attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494323998",
      "id" : 494323998,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMyMzk5OA==",
      "original_commit_id" : "7949d08406774f27fd0291c2aa046ecdf985c191",
      "original_line" : 112,
      "original_position" : 112,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495579753,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494323998",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494348645"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494348645"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Consider using an initializer list here instead of setting `m_impl` in the ctor function body.\r\n\r\nIf you did that, you could make `m_impl` const, which is fine since you've deleted the move constructor and assignment.\r\n\r\n`const unique_ptr` communicates that _this_ `m_impl` is always the object that `TxRequestTracker` owns. See Herb Sutter's Leak-Freedom talk at https://youtu.be/JfmTagWcqoE?t=571\r\n\r\n```diff\r\ndiff --git a/src/txrequest.cpp b/src/txrequest.cpp\r\nindex f6c387f8f4..b7d90a1ba5 100644\r\n--- a/src/txrequest.cpp\r\n+++ b/src/txrequest.cpp\r\n@@ -668,10 +668,8 @@ public:\r\n     }\r\n };\r\n \r\n-TxRequestTracker::TxRequestTracker(bool deterministic)\r\n-{\r\n-    m_impl = MakeUnique<TxRequestTracker::Impl>(deterministic);\r\n-}\r\n+TxRequestTracker::TxRequestTracker(bool deterministic) :\r\n+    m_impl{MakeUnique<TxRequestTracker::Impl>(deterministic)} {}\r\n \r\n TxRequestTracker::~TxRequestTracker() {}\r\n \r\ndiff --git a/src/txrequest.h b/src/txrequest.h\r\nindex 6e892eebe1..83f6dbe2fe 100644\r\n--- a/src/txrequest.h\r\n+++ b/src/txrequest.h\r\n@@ -119,7 +119,7 @@ public:\r\n private:\r\n     // Avoid littering this header file with implementation details.\r\n     class Impl;\r\n-    std::unique_ptr<Impl> m_impl;\r\n+    const std::unique_ptr<Impl> m_impl;\r\n \r\n public:\r\n     //! Construct a TxRequestTracker.\r\n```",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T14:06:12Z",
      "diff_hunk" : "@@ -0,0 +1,715 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+TxRequestTracker::PriorityComputer::PriorityComputer(bool deterministic) :\n+    m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+    m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+uint64_t TxRequestTracker::PriorityComputer::operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const\n+{\n+    uint64_t low_bits = 0;\n+    if (!first) {\n+        low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+    }\n+    return low_bits | uint64_t{!preferred} << 63;\n+}\n+\n+static const uint256 UINT256_ZERO;\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient\n+    //! implementation. Also note that the sorting order of EntryTxHash relies on the specific order of values in\n+    //! this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_DELAYED,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST.\n+        CANDIDATE_READY,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+\n+        //! An invalid State value that's larger than all valid ones.\n+        TOO_LARGE,\n+    };\n+\n+    /** A flag (in Entry::m_per_txhash) to indicate that for that txhash,\n+     *  new preferred announcements are not eligible to get the 'first' marker. */\n+    static constexpr uint8_t TXHASHINFO_NO_MORE_PREFERRED_FIRST = 1;\n+    /** A flag (in Entry::m_per_txhash) to indicate that for that txhash,\n+     *  new non-preferred announcements are not eligible to get the 'first' marker. */\n+    static constexpr uint8_t TXHASHINFO_NO_MORE_NONPREFERRED_FIRST = 2;\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxHash-based index.\n+    struct ByTxHash {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+    using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txhash;\n+        //! For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 56;\n+        //! Whether the request is preferred (giving it priority higher than non-preferred ones).\n+        const bool m_preferred : 1;\n+        //! Whether this is a wtxid request.\n+        const bool m_is_wtxid : 1;\n+        //! Whether this was: the very first announcement for this txhash, within the\n+        //! preferred or non-preferred ones, and no request had been made for this\n+        //! txhash from any peer at the time the announcement came in.\n+        const bool m_first : 1;\n+\n+        //! What state this announcement is in\n+        //! This is a uint8_t instead of a State to silence a GCC warning.\n+        uint8_t m_state : 3;\n+\n+        /** Per-txhash flags. These are stored in the last Entry for a given txhash (ByTxHash order).\n+         *  The values for other Entry objects can be arbitrary subsets of the actual flags. */\n+        mutable uint8_t m_per_txhash : 2;\n+\n+        //! Convert the m_state variable to a State enum.\n+        State GetState() const { return State(m_state); }\n+        //! Convert a State to a uint8_t and store it in m_state.\n+        void SetState(State state) { m_state = uint8_t(state); }\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txhash.\n+        bool IsSelected() const\n+        {\n+            return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+        }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const\n+        {\n+            return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+        }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const\n+        {\n+            return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+        }\n+\n+        //! Construct a new entry from scratch, initially in CANDIDATE_DELAYED state.\n+        Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+            uint64_t sequence, bool first) :\n+            m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+            m_is_wtxid(gtxid.IsWtxid()), m_first(first), m_state(uint8_t(State::CANDIDATE_DELAYED)),\n+            m_per_txhash(0) {}\n+\n+        //! Compute this Entry's priority.\n+        uint64_t ComputePriority(const PriorityComputer& computer) const\n+        {\n+            return computer(m_txhash, m_peer, m_preferred, m_first);\n+        }\n+\n+        //! Extract the EntryPeer from this Entry.\n+        EntryPeer ExtractPeer() const { return EntryPeer{m_peer, GetState() == State::CANDIDATE_BEST, m_txhash}; }\n+\n+        //! Extract the EntryTxHash from this Entry.\n+        EntryTxHash ExtractTxid(const PriorityComputer& computer) const\n+        {\n+            return EntryTxHash{\n+                m_txhash,\n+                GetState(),\n+                GetState() == State::CANDIDATE_READY ? ComputePriority(computer) : 0\n+            };\n+        }\n+\n+        //! Extract the EntryTime from this Entry.\n+        EntryTime ExtractTime() const { return EntryTime{IsWaiting() ? 0 : IsSelectable() ? 2 : 1, m_time}; }\n+    };\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    /** An extractor for EntryTxHash (with encapsulated PriorityComputer reference).\n+     *\n+     * See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+     * for more information about the key extraction concept.\n+     */\n+    class EntryTxHashExtractor {\n+        const PriorityComputer& m_computer;\n+    public:\n+        EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+        using result_type = EntryTxHash; // Needed to comply with key extractor interface\n+        result_type operator()(const Entry& entry) const { return entry.ExtractTxid(m_computer); }\n+    };\n+\n+    //! Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes).\n+    using Index = boost::multi_index_container<\n+        Entry,\n+        boost::multi_index::indexed_by<\n+            boost::multi_index::ordered_unique<\n+                boost::multi_index::tag<ByPeer>,\n+                boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTxHash>,\n+                EntryTxHashExtractor\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTime>,\n+                boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>\n+            >\n+        >\n+    >;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Per-peer statistics object.\n+    struct PeerInfo {\n+        size_t m_total = 0; //!< Total number of entries for this peer.\n+        size_t m_requested = 0; //!< Total number of REQUESTED entries for this peer.\n+\n+        friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+        {\n+            return std::tie(a.m_total, a.m_requested) == std::tie(b.m_total, b.m_requested);\n+        }\n+    };\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo and m_per_txhash up to date.\n+    template<typename Tag>\n+    typename Index::index<Tag>::type::iterator Erase(typename Index::index<Tag>::type::iterator it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        // As it may possibly be the last-sorted Entry for a given txhash, propagate its per-txhash flags to its\n+        // predecessor (if it belongs to the same txhash).\n+        auto bytxhashit = m_index.project<ByTxHash>(it);\n+        if (bytxhashit != m_index.get<ByTxHash>().begin() &&\n+            bytxhashit->m_txhash == std::prev(bytxhashit)->m_txhash) {\n+            std::prev(bytxhashit)->m_per_txhash |= bytxhashit->m_per_txhash;\n+        }\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo and m_per_txhash up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(typename Index::index<Tag>::type::iterator it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        // It's possible that it used to be the last-sorted Entry for its txhash, so propagate its\n+        // flags to its predecessor (which would then become the new last-sorted Entry).\n+        auto bytxhashit = m_index.project<ByTxHash>(it);\n+        if (bytxhashit != m_index.get<ByTxHash>().begin() &&\n+            bytxhashit->m_txhash == std::prev(bytxhashit)->m_txhash) {\n+            std::prev(bytxhashit)->m_per_txhash |= bytxhashit->m_per_txhash;\n+        }\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        // It's possible that it is now the new last-sorted Entry for its txhash, so propagate flags\n+        // from its predecessor to it.\n+        bytxhashit = m_index.project<ByTxHash>(it);\n+        if (bytxhashit != m_index.get<ByTxHash>().begin() &&\n+            bytxhashit->m_txhash == std::prev(bytxhashit)->m_txhash) {\n+            bytxhashit->m_per_txhash |= std::prev(bytxhashit)->m_per_txhash;\n+        }\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(typename Index::index<ByTxHash>::type::iterator it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txid, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txid that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txid already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = std::prev(it)->ComputePriority(m_computer);\n+            uint64_t priority_new = it->ComputePriority(m_computer);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(typename Index::index<ByTxHash>::type::iterator it, State new_state)\n+    {\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in\n+            // the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Entry for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(typename Index::index<ByTxHash>::type::iterator it)\n+    {\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED entries.\n+\n+        // If this Entry's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Entry's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    //! Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txid, they are all\n+    //! deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+    //! CANDIDATE_BEST. Returns whether the Entry still exists.\n+    bool MakeCompleted(typename Index::index<ByTxHash>::type::iterator it)\n+    {\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED entry for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the entry COMPLETED, and select the next best entry (the first CANDIDATE_READY) if needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to EntryTxHashExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(\n+                boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>(),\n+                std::less<EntryPeer>()\n+            ),\n+            boost::make_tuple(\n+                EntryTxHashExtractor(m_computer),\n+                std::less<EntryTxHash>()\n+            ),\n+            boost::make_tuple(\n+                boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>(),\n+                std::less<EntryTime>()\n+            )\n+        )) {}\n+\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxHashExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DeletedPeer(uint64_t peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+            // CANDIDATE_BEST, or delete all of a txid's entries if no non-COMPLETED ones are left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTx(const GenTxid& gtxid)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == gtxid.GetHash()) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred, bool overloaded,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST entry for this (txid, peer) combination. The case where there is\n+        // a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+        // automatically.\n+        if (m_index.get<ByPeer>().count(EntryPeer{peer, true, gtxid.GetHash()})) return;\n+\n+        // Find last entry for this txhash, and extract per_txhash information from it.\n+        uint8_t per_txhash = 0;\n+        typename Index::index<ByTxHash>::type::iterator it_last = m_index.get<ByTxHash>().end();\n+        // First find the first entry past this txhash.\n+        it_last = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0});\n+        if (it_last != m_index.get<ByTxHash>().begin() && std::prev(it_last)->m_txhash == gtxid.GetHash()) {\n+            // Its predecessor exists, and has the right txhash. Remember it, and OR in its flags.\n+            it_last--;\n+            per_txhash |= it_last->m_per_txhash;\n+        } else {\n+            // No entry for this txhash exists yet.\n+            it_last = m_index.get<ByTxHash>().end();\n+        }\n+\n+        // Determine whether the new announcement's Entry will get the first marker, and update\n+        // the per_txhash information to be stored (but note that per_txhash isn't actually stored\n+        // until after the emplace below succeeds).\n+        bool first = false;\n+        if (!overloaded) {\n+            if (preferred && !(per_txhash & TXHASHINFO_NO_MORE_PREFERRED_FIRST)) {\n+                first = true;\n+                per_txhash |= TXHASHINFO_NO_MORE_PREFERRED_FIRST;\n+            } else if (!preferred && !(per_txhash & TXHASHINFO_NO_MORE_NONPREFERRED_FIRST)) {\n+                first = true;\n+                per_txhash |= TXHASHINFO_NO_MORE_NONPREFERRED_FIRST;\n+            }\n+        }\n+\n+        // Try creating the entry with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST entry already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_sequence, first);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+\n+        // Update m_per_txhash of the new last Entry (either the newly created one, or it_last).\n+        auto it = m_index.project<ByTxHash>(ret.first);\n+        if (it_last == m_index.get<ByTxHash>().end() || std::next(it_last) == it) it_last = it;\n+        it_last->m_per_txhash |= per_txhash;\n+    }\n+\n+    //! Find the txids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now)\n+    {\n+        // Move time.\n+        SetTimePoint(now);\n+\n+        // Find all CANDIDATE_BEST entries for this peer.\n+        std::vector<std::pair<uint64_t, const Entry*>> selected;\n+        auto it_peer = m_index.get<ByPeer>().lower_bound(EntryPeer{peer, true, UINT256_ZERO});\n+        while (it_peer != m_index.get<ByPeer>().end() && it_peer->m_peer == peer &&\n+            it_peer->GetState() == State::CANDIDATE_BEST) {\n+            selected.emplace_back(it_peer->m_sequence, &*it_peer);\n+            ++it_peer;\n+        }\n+\n+        // Return them, sorted by sequence number.\n+        std::sort(selected.begin(), selected.end());\n+        std::vector<GenTxid> ret;\n+        for (const auto& item : selected) {\n+            ret.emplace_back(item.second->m_is_wtxid, item.second->m_txhash);\n+        }\n+        return ret;\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds expiry)\n+    {\n+        auto it = m_index.get<ByPeer>().find(EntryPeer{peer, true, gtxid.GetHash()});\n+        // RequestedTx can only be called on CANDIDATE_BEST entries (this is implied by its condition that it can only be\n+        // called on txids returned by GetRequestable (and only AlreadyHave and RequestedTx can be called in between,\n+        // which preserve the state of other txids).\n+        assert(it != m_index.get<ByPeer>().end());\n+        assert(it->GetState() == State::CANDIDATE_BEST);\n+        Modify<ByPeer>(it, [expiry](Entry& entry) {\n+            entry.SetState(State::REQUESTED);\n+            entry.m_time = expiry;\n+        });\n+\n+        // Update the m_per_txhash (of the last Entry for this txhash) to reflect that new ones are no longer\n+        // eligible for the \"first\" marker.\n+        auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0}));\n+        assert(it_last->m_txhash == gtxid.GetHash());\n+        it_last->m_per_txhash |= TXHASHINFO_NO_MORE_PREFERRED_FIRST | TXHASHINFO_NO_MORE_NONPREFERRED_FIRST;\n+    }\n+\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid)\n+    {\n+        // We need to search the ByPeer index for both (peer, false, txid) and (peer, true, txid).\n+        auto it = m_index.get<ByPeer>().find(EntryPeer{peer, false, gtxid.GetHash()});\n+        if (it == m_index.get<ByPeer>().end()) {\n+            it = m_index.get<ByPeer>().find(EntryPeer{peer, true, gtxid.GetHash()});\n+        }\n+        if (it != m_index.get<ByPeer>().end()) MakeCompleted(m_index.project<ByTxHash>(it));\n+    }\n+\n+    size_t CountInFlight(uint64_t peer) const\n+    {\n+        auto it = m_peerinfo.find(peer);\n+        if (it != m_peerinfo.end()) return it->second.m_requested;\n+        return 0;\n+    }\n+\n+    size_t CountTracked(uint64_t peer) const\n+    {\n+        auto it = m_peerinfo.find(peer);\n+        if (it != m_peerinfo.end()) return it->second.m_total;\n+        return 0;\n+    }\n+\n+    //! Count how many announcements are being tracked in total across all peers and transactions.\n+    size_t Size() const { return m_index.size(); }\n+\n+    //! Access to the internal PriorityComputer (for testing)\n+    const PriorityComputer& GetPriorityComputer() const { return m_computer; }\n+\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata.\n+        // This verifies the data in it, including the invariant\n+        // that no entries with m_total_announcements==0 exist.\n+        std::unordered_map<uint64_t, PeerInfo> peerinfo;\n+        for (const auto& a : m_index) {\n+            auto& entry = peerinfo[a.m_peer];\n+            ++entry.m_total;\n+            entry.m_requested += (a.GetState() == State::REQUESTED);\n+        }\n+        assert(m_peerinfo == peerinfo);\n+\n+        struct Counts {\n+            //! Number of CANDIDATE_DELAYED entries for this txhash.\n+            size_t m_candidate_delayed = 0;\n+            //! Number of CANDIDATE_READY entries for this txhash.\n+            size_t m_candidate_ready = 0;\n+            //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+            size_t m_candidate_best = 0;\n+            //! Number of REQUESTED entries for this txhash.\n+            size_t m_requested = 0;\n+            //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+            uint64_t m_priority_candidate_best = 0;\n+            //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+            uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+            //! All peers we have an entry for this txhash for.\n+            std::vector<uint64_t> m_peers;\n+            //! Whether any preferred first entry exists.\n+            bool m_any_preferred_first = false;\n+            //! Whether any non-preferred first entry exists.\n+            bool m_any_nonpreferred_first = false;\n+            //! OR of all m_per_txhash flags.\n+            uint8_t m_or_all_per_txhash = 0;\n+        };\n+\n+        std::map<uint256, Counts> table;\n+        for (const auto& a : m_index) {\n+            auto& entry = table[a.m_txhash];\n+            // Classify how many types peers we have for this txid.\n+            entry.m_candidate_delayed += (a.GetState() == State::CANDIDATE_DELAYED);\n+            entry.m_candidate_ready += (a.GetState() == State::CANDIDATE_READY);\n+            entry.m_candidate_best += (a.GetState() == State::CANDIDATE_BEST);\n+            entry.m_requested += (a.GetState() == State::REQUESTED);\n+            // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+            if (a.GetState() == State::CANDIDATE_BEST) {\n+                entry.m_priority_candidate_best = a.ComputePriority(m_computer);\n+            }\n+            if (a.GetState() == State::CANDIDATE_READY) {\n+                entry.m_priority_best_candidate_ready = std::min(entry.m_priority_best_candidate_ready,\n+                    a.ComputePriority(m_computer));\n+            }\n+            // Also keep track of which peers this txid has an entry for (so we can detect duplicates).\n+            entry.m_peers.push_back(a.m_peer);\n+            // Track preferred/first.\n+            entry.m_any_preferred_first |= (a.m_first && a.m_preferred);\n+            entry.m_any_nonpreferred_first |= (a.m_first && !a.m_preferred);\n+            entry.m_or_all_per_txhash |= a.m_per_txhash;\n+        }\n+        for (auto& entry : table) {\n+            auto& c = entry.second;\n+            // Cannot have only COMPLETED peers (txid should have been deleted)\n+            assert(c.m_candidate_delayed + c.m_candidate_ready + c.m_candidate_best + c.m_requested > 0);\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(c.m_candidate_best + c.m_requested <= 1);\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (c.m_candidate_ready > 0) {\n+                assert(c.m_candidate_best + c.m_requested == 1);\n+            }\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good as the best CANDIDATE_READY.\n+            if (c.m_candidate_ready && c.m_candidate_best) {\n+                assert(c.m_priority_candidate_best <= c.m_priority_best_candidate_ready);\n+            }\n+            // Detect duplicate (peer, txid) entries\n+            std::sort(c.m_peers.begin(), c.m_peers.end());\n+            assert(std::adjacent_find(c.m_peers.begin(), c.m_peers.end()) == c.m_peers.end());\n+            // Verify all per_txhash flags.\n+            uint8_t expected_per_txhash = 0;\n+            if (c.m_any_preferred_first || c.m_requested) {\n+                expected_per_txhash |= TXHASHINFO_NO_MORE_PREFERRED_FIRST;\n+            }\n+            if (c.m_any_nonpreferred_first || c.m_requested) {\n+                expected_per_txhash |= TXHASHINFO_NO_MORE_NONPREFERRED_FIRST;\n+            }\n+            // All expected flags must be present, but there can be more. If a node went from REQUESTED to\n+            // COMPLETED, or was deleted, our expected_per_txhash may miss the relevant bits.\n+            assert((expected_per_txhash & ~c.m_or_all_per_txhash) == 0);\n+            // No entry can have flags that are a superset of the actual ones (they're always ORed into the actual\n+            // one).\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{entry.first, State::TOO_LARGE, 0}));\n+            assert(it_last->m_txhash == entry.first);\n+            assert(c.m_or_all_per_txhash == it_last->m_per_txhash);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+};\n+\n+TxRequestTracker::TxRequestTracker(bool deterministic)\n+{\n+    m_impl = MakeUnique<TxRequestTracker::Impl>(deterministic);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494348645",
      "id" : 494348645,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM0ODY0NQ==",
      "original_commit_id" : "7949d08406774f27fd0291c2aa046ecdf985c191",
      "original_line" : 673,
      "original_position" : 673,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 495579753,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494348645",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494469813"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494469813"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`Deleted`(past tense) is a bit weird since it's actually deleting the peer.\r\n\r\nAt a risk of making it too verbose via self-documenting:\r\n`DeletePeerEntries`?\r\n\r\nAlternatively we can name it like some of the other functions e.g. `ReceivedInv` et. al:\r\n`DisconnectedPeer` describing when it's to be called and leaving the first sentence in the comment.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T16:55:02Z",
      "diff_hunk" : "@@ -0,0 +1,213 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the \"first\" marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the \"first\" mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ * \"First\" marker rules: the \"first\" marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the extent to which attackers that race the network in announcing all transactions\n+ *              can break chains of dependent transactions.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and avoiding influenceable\n+ * by attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, but they timed out, a\n+    //   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DeletedPeer(uint64_t peer);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494469813",
      "id" : 494469813,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ2OTgxMw==",
      "original_commit_id" : "164f50402475175d6fc839ae2798817e8da7c68f",
      "original_line" : 138,
      "original_position" : 149,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495769842,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494469813",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494471997"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494471997"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n     * whatever reason we no longer care about it. Only the hash field of gtxid is used.\r\n```",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T16:58:35Z",
      "diff_hunk" : "@@ -0,0 +1,213 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the \"first\" marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the \"first\" mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ * \"First\" marker rules: the \"first\" marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the extent to which attackers that race the network in announcing all transactions\n+ *              can break chains of dependent transactions.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and avoiding influenceable\n+ * by attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, but they timed out, a\n+    //   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DeletedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash.\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it. The is_wtxid flag of gtxid is ignored.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494471997",
      "id" : 494471997,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ3MTk5Nw==",
      "original_commit_id" : "164f50402475175d6fc839ae2798817e8da7c68f",
      "original_line" : 143,
      "original_position" : 154,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495769842,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494471997",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494473828"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494473828"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Maybe talk about what it's used for instead of what it's not, or just change the interface to make it clear.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T17:01:38Z",
      "diff_hunk" : "@@ -0,0 +1,213 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the \"first\" marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the \"first\" mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ * \"First\" marker rules: the \"first\" marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the extent to which attackers that race the network in announcing all transactions\n+ *              can break chains of dependent transactions.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and avoiding influenceable\n+ * by attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, but they timed out, a\n+    //   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DeletedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash.\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it. The is_wtxid flag of gtxid is ignored.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494473828",
      "id" : 494473828,
      "in_reply_to_id" : 494471997,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ3MzgyOA==",
      "original_commit_id" : "164f50402475175d6fc839ae2798817e8da7c68f",
      "original_line" : 143,
      "original_position" : 154,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495769842,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494473828",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494477588"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494477588"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`COMPLETED` sounds more like `FAILED`.\r\n\r\n`COMPLETED` is also hit when the transaction is received properly, no?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T17:08:07Z",
      "diff_hunk" : "@@ -0,0 +1,213 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the \"first\" marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the \"first\" mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ * \"First\" marker rules: the \"first\" marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the extent to which attackers that race the network in announcing all transactions\n+ *              can break chains of dependent transactions.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and avoiding influenceable\n+ * by attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, but they timed out, a",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494477588",
      "id" : 494477588,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ3NzU4OA==",
      "original_commit_id" : "164f50402475175d6fc839ae2798817e8da7c68f",
      "original_line" : 127,
      "original_position" : 138,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495769842,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494477588",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494485317"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494485317"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n    std::vector<GenTxid> ExpireReqestedAndGetRequestable(uint64_t peer, std::chrono::microseconds now);\r\n```\r\n\r\nto make it less reliant on comments for intent",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T17:20:59Z",
      "diff_hunk" : "@@ -0,0 +1,213 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the \"first\" marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the \"first\" mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ * \"First\" marker rules: the \"first\" marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the extent to which attackers that race the network in announcing all transactions\n+ *              can break chains of dependent transactions.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and avoiding influenceable\n+ * by attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, but they timed out, a\n+    //   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DeletedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash.\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it. The is_wtxid flag of gtxid is ignored.\n+     */\n+    void ForgetTx(const GenTxid& gtxid);\n+\n+    /** Adds a new CANDIDATE entry.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that this means a second INV with the same txhash from the same peer will be ignored, even\n+     * if one is a txid and the other is wtxid (but that shouldn't happen, as BIP339 requires that all announced\n+     * inventory is exclusively using MSG_WTX). The new entry is given the specified preferred and reqtime values,\n+     * and takes it is_wtxid from the specified gtxid. It is eligible to get a first marker if overloaded is false\n+     * (but also subject to the other rules regarding the first marker).\n+     */\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred, bool overloaded,\n+        std::chrono::microseconds reqtime);\n+\n+    /** Converts the CANDIDATE entry for the provided peer and gtxid into a REQUESTED one.\n+     *\n+     * Expiry is set to the specified value. This can ONLY be called immediately after GetRequestable was called\n+     * (for the same peer), with only ForgetTx and other RequestedTx calls (both for other txhashes) in\n+     * between. Any other non-const operation removes the ability to call RequestedTx.\n+     */\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds expiry);\n+\n+    /** Converts any CANDIDATE or REQUESTED entry to a COMPLETED one, if one exists.\n+     *\n+     * It should be called whenever a transaction or NOTFOUND was received from a peer. When a good transaction is\n+     * received, ForgetTx should be called instead of (or in addition to) this operation.\n+     */\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid);\n+\n+    // The operations below inspect the data structure.\n+\n+    /** Find the txids to request now from peer.\n+     *\n+     * It does the following:\n+     *  - Convert all REQUESTED entries (for all txhashes/peers) with (expiry <= now) to COMPLETED entries.\n+     *  - Requestable entries are selected: CANDIDATE entries from the specified peer with (reqtime <= now) for\n+     *    which the specified peer is the best choice among all such CANDIDATE entries with the same txhash (subject\n+     *    to preference/first rules, and tiebreaking using a deterministic salted hash of peer and txhash).\n+     *  - The selected entries are sorted in order of announcement (even if multiple were added at the same time, or\n+     *    even when the clock went backwards while they were being added), converted to GenTxids using their\n+     *    is_wtxid flag, and returned.\n+     */\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494485317",
      "id" : 494485317,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ4NTMxNw==",
      "original_commit_id" : "164f50402475175d6fc839ae2798817e8da7c68f",
      "original_line" : 173,
      "original_position" : 198,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495769842,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494485317",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494488392"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494488392"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Wouldn't hurt to make this block not publicly callable somehow.\r\n\r\nJust an idea in case it's not crazy: https://stackoverflow.com/a/23267346",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T17:26:07Z",
      "diff_hunk" : "@@ -208,6 +208,15 @@ class TxRequestTracker {\n \n     /** Access to the internal PriorityComputer (for testing) */\n     const PriorityComputer& GetPriorityComputer() const;\n+\n+    /** Run internal consistency check (testing only). */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494488392",
      "id" : 494488392,
      "line" : 196,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ4ODM5Mg==",
      "original_commit_id" : "71f551d840deaae3c30bb08a2c7a2248b043dbac",
      "original_line" : 196,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 196,
      "pull_request_review_id" : 495769842,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494488392",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494491883"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494491883"
         }
      },
      "author_association" : "MEMBER",
      "body" : "tangentially-related nit: Comments above function are getting pretty stale.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T17:32:00Z",
      "diff_hunk" : "@@ -1201,6 +1201,13 @@ void PeerManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock, co\n             }\n         }\n     }\n+    {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494491883",
      "id" : 494491883,
      "line" : 1230,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ5MTg4Mw==",
      "original_commit_id" : "3454757a66a82665b55aacbc1e53d75aafa82766",
      "original_line" : 1230,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 259,
      "pull_request_review_id" : 495769842,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494491883",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494492919"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494492919"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T17:33:49Z",
      "diff_hunk" : "@@ -793,69 +726,24 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void RequestTx(NodeId nodeid, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n-\n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494492919",
      "id" : 494492919,
      "in_reply_to_id" : 493190576,
      "line" : 865,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ5MjkxOQ==",
      "original_commit_id" : "c7601cdb31f9c86a4308cf36bbbc9c74c1078f53",
      "original_line" : 865,
      "original_position" : 156,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 184,
      "pull_request_review_id" : 495799717,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "LEFT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494492919",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494493059"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494493059"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Of course! Done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T17:34:03Z",
      "diff_hunk" : "@@ -0,0 +1,715 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+TxRequestTracker::PriorityComputer::PriorityComputer(bool deterministic) :\n+    m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+    m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+uint64_t TxRequestTracker::PriorityComputer::operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const\n+{\n+    uint64_t low_bits = 0;\n+    if (!first) {\n+        low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+    }\n+    return low_bits | uint64_t{!preferred} << 63;\n+}\n+\n+static const uint256 UINT256_ZERO;\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient\n+    //! implementation. Also note that the sorting order of EntryTxHash relies on the specific order of values in\n+    //! this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_DELAYED,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST.\n+        CANDIDATE_READY,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+\n+        //! An invalid State value that's larger than all valid ones.\n+        TOO_LARGE,\n+    };\n+\n+    /** A flag (in Entry::m_per_txhash) to indicate that for that txhash,\n+     *  new preferred announcements are not eligible to get the 'first' marker. */\n+    static constexpr uint8_t TXHASHINFO_NO_MORE_PREFERRED_FIRST = 1;\n+    /** A flag (in Entry::m_per_txhash) to indicate that for that txhash,\n+     *  new non-preferred announcements are not eligible to get the 'first' marker. */\n+    static constexpr uint8_t TXHASHINFO_NO_MORE_NONPREFERRED_FIRST = 2;\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxHash-based index.\n+    struct ByTxHash {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+    using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txhash;\n+        //! For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 56;\n+        //! Whether the request is preferred (giving it priority higher than non-preferred ones).\n+        const bool m_preferred : 1;\n+        //! Whether this is a wtxid request.\n+        const bool m_is_wtxid : 1;\n+        //! Whether this was: the very first announcement for this txhash, within the\n+        //! preferred or non-preferred ones, and no request had been made for this\n+        //! txhash from any peer at the time the announcement came in.\n+        const bool m_first : 1;\n+\n+        //! What state this announcement is in\n+        //! This is a uint8_t instead of a State to silence a GCC warning.\n+        uint8_t m_state : 3;\n+\n+        /** Per-txhash flags. These are stored in the last Entry for a given txhash (ByTxHash order).\n+         *  The values for other Entry objects can be arbitrary subsets of the actual flags. */\n+        mutable uint8_t m_per_txhash : 2;\n+\n+        //! Convert the m_state variable to a State enum.\n+        State GetState() const { return State(m_state); }\n+        //! Convert a State to a uint8_t and store it in m_state.\n+        void SetState(State state) { m_state = uint8_t(state); }\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txhash.\n+        bool IsSelected() const\n+        {\n+            return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+        }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const\n+        {\n+            return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+        }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const\n+        {\n+            return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+        }\n+\n+        //! Construct a new entry from scratch, initially in CANDIDATE_DELAYED state.\n+        Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+            uint64_t sequence, bool first) :\n+            m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+            m_is_wtxid(gtxid.IsWtxid()), m_first(first), m_state(uint8_t(State::CANDIDATE_DELAYED)),\n+            m_per_txhash(0) {}\n+\n+        //! Compute this Entry's priority.\n+        uint64_t ComputePriority(const PriorityComputer& computer) const\n+        {\n+            return computer(m_txhash, m_peer, m_preferred, m_first);\n+        }\n+\n+        //! Extract the EntryPeer from this Entry.\n+        EntryPeer ExtractPeer() const { return EntryPeer{m_peer, GetState() == State::CANDIDATE_BEST, m_txhash}; }\n+\n+        //! Extract the EntryTxHash from this Entry.\n+        EntryTxHash ExtractTxid(const PriorityComputer& computer) const\n+        {\n+            return EntryTxHash{\n+                m_txhash,\n+                GetState(),\n+                GetState() == State::CANDIDATE_READY ? ComputePriority(computer) : 0\n+            };\n+        }\n+\n+        //! Extract the EntryTime from this Entry.\n+        EntryTime ExtractTime() const { return EntryTime{IsWaiting() ? 0 : IsSelectable() ? 2 : 1, m_time}; }\n+    };\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    /** An extractor for EntryTxHash (with encapsulated PriorityComputer reference).\n+     *\n+     * See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+     * for more information about the key extraction concept.\n+     */\n+    class EntryTxHashExtractor {\n+        const PriorityComputer& m_computer;\n+    public:\n+        EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+        using result_type = EntryTxHash; // Needed to comply with key extractor interface\n+        result_type operator()(const Entry& entry) const { return entry.ExtractTxid(m_computer); }\n+    };\n+\n+    //! Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes).\n+    using Index = boost::multi_index_container<\n+        Entry,\n+        boost::multi_index::indexed_by<\n+            boost::multi_index::ordered_unique<\n+                boost::multi_index::tag<ByPeer>,\n+                boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTxHash>,\n+                EntryTxHashExtractor\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTime>,\n+                boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>\n+            >\n+        >\n+    >;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Per-peer statistics object.\n+    struct PeerInfo {\n+        size_t m_total = 0; //!< Total number of entries for this peer.\n+        size_t m_requested = 0; //!< Total number of REQUESTED entries for this peer.\n+\n+        friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+        {\n+            return std::tie(a.m_total, a.m_requested) == std::tie(b.m_total, b.m_requested);\n+        }\n+    };\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo and m_per_txhash up to date.\n+    template<typename Tag>\n+    typename Index::index<Tag>::type::iterator Erase(typename Index::index<Tag>::type::iterator it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        // As it may possibly be the last-sorted Entry for a given txhash, propagate its per-txhash flags to its\n+        // predecessor (if it belongs to the same txhash).\n+        auto bytxhashit = m_index.project<ByTxHash>(it);\n+        if (bytxhashit != m_index.get<ByTxHash>().begin() &&\n+            bytxhashit->m_txhash == std::prev(bytxhashit)->m_txhash) {\n+            std::prev(bytxhashit)->m_per_txhash |= bytxhashit->m_per_txhash;\n+        }\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo and m_per_txhash up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(typename Index::index<Tag>::type::iterator it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        // It's possible that it used to be the last-sorted Entry for its txhash, so propagate its\n+        // flags to its predecessor (which would then become the new last-sorted Entry).\n+        auto bytxhashit = m_index.project<ByTxHash>(it);\n+        if (bytxhashit != m_index.get<ByTxHash>().begin() &&\n+            bytxhashit->m_txhash == std::prev(bytxhashit)->m_txhash) {\n+            std::prev(bytxhashit)->m_per_txhash |= bytxhashit->m_per_txhash;\n+        }\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        // It's possible that it is now the new last-sorted Entry for its txhash, so propagate flags\n+        // from its predecessor to it.\n+        bytxhashit = m_index.project<ByTxHash>(it);\n+        if (bytxhashit != m_index.get<ByTxHash>().begin() &&\n+            bytxhashit->m_txhash == std::prev(bytxhashit)->m_txhash) {\n+            bytxhashit->m_per_txhash |= std::prev(bytxhashit)->m_per_txhash;\n+        }\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(typename Index::index<ByTxHash>::type::iterator it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txid, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txid that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txid already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = std::prev(it)->ComputePriority(m_computer);\n+            uint64_t priority_new = it->ComputePriority(m_computer);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(typename Index::index<ByTxHash>::type::iterator it, State new_state)\n+    {\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in\n+            // the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Entry for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(typename Index::index<ByTxHash>::type::iterator it)\n+    {\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED entries.\n+\n+        // If this Entry's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Entry's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    //! Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txid, they are all\n+    //! deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+    //! CANDIDATE_BEST. Returns whether the Entry still exists.\n+    bool MakeCompleted(typename Index::index<ByTxHash>::type::iterator it)\n+    {\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED entry for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the entry COMPLETED, and select the next best entry (the first CANDIDATE_READY) if needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to EntryTxHashExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(\n+                boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>(),\n+                std::less<EntryPeer>()\n+            ),\n+            boost::make_tuple(\n+                EntryTxHashExtractor(m_computer),\n+                std::less<EntryTxHash>()\n+            ),\n+            boost::make_tuple(\n+                boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>(),\n+                std::less<EntryTime>()\n+            )\n+        )) {}\n+\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxHashExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DeletedPeer(uint64_t peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+            // CANDIDATE_BEST, or delete all of a txid's entries if no non-COMPLETED ones are left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTx(const GenTxid& gtxid)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == gtxid.GetHash()) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred, bool overloaded,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST entry for this (txid, peer) combination. The case where there is\n+        // a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+        // automatically.\n+        if (m_index.get<ByPeer>().count(EntryPeer{peer, true, gtxid.GetHash()})) return;\n+\n+        // Find last entry for this txhash, and extract per_txhash information from it.\n+        uint8_t per_txhash = 0;\n+        typename Index::index<ByTxHash>::type::iterator it_last = m_index.get<ByTxHash>().end();\n+        // First find the first entry past this txhash.\n+        it_last = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0});\n+        if (it_last != m_index.get<ByTxHash>().begin() && std::prev(it_last)->m_txhash == gtxid.GetHash()) {\n+            // Its predecessor exists, and has the right txhash. Remember it, and OR in its flags.\n+            it_last--;\n+            per_txhash |= it_last->m_per_txhash;\n+        } else {\n+            // No entry for this txhash exists yet.\n+            it_last = m_index.get<ByTxHash>().end();\n+        }\n+\n+        // Determine whether the new announcement's Entry will get the first marker, and update\n+        // the per_txhash information to be stored (but note that per_txhash isn't actually stored\n+        // until after the emplace below succeeds).\n+        bool first = false;\n+        if (!overloaded) {\n+            if (preferred && !(per_txhash & TXHASHINFO_NO_MORE_PREFERRED_FIRST)) {\n+                first = true;\n+                per_txhash |= TXHASHINFO_NO_MORE_PREFERRED_FIRST;\n+            } else if (!preferred && !(per_txhash & TXHASHINFO_NO_MORE_NONPREFERRED_FIRST)) {\n+                first = true;\n+                per_txhash |= TXHASHINFO_NO_MORE_NONPREFERRED_FIRST;\n+            }\n+        }\n+\n+        // Try creating the entry with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST entry already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_sequence, first);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+\n+        // Update m_per_txhash of the new last Entry (either the newly created one, or it_last).\n+        auto it = m_index.project<ByTxHash>(ret.first);\n+        if (it_last == m_index.get<ByTxHash>().end() || std::next(it_last) == it) it_last = it;\n+        it_last->m_per_txhash |= per_txhash;\n+    }\n+\n+    //! Find the txids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now)\n+    {\n+        // Move time.\n+        SetTimePoint(now);\n+\n+        // Find all CANDIDATE_BEST entries for this peer.\n+        std::vector<std::pair<uint64_t, const Entry*>> selected;\n+        auto it_peer = m_index.get<ByPeer>().lower_bound(EntryPeer{peer, true, UINT256_ZERO});\n+        while (it_peer != m_index.get<ByPeer>().end() && it_peer->m_peer == peer &&\n+            it_peer->GetState() == State::CANDIDATE_BEST) {\n+            selected.emplace_back(it_peer->m_sequence, &*it_peer);\n+            ++it_peer;\n+        }\n+\n+        // Return them, sorted by sequence number.\n+        std::sort(selected.begin(), selected.end());\n+        std::vector<GenTxid> ret;\n+        for (const auto& item : selected) {\n+            ret.emplace_back(item.second->m_is_wtxid, item.second->m_txhash);\n+        }\n+        return ret;\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds expiry)\n+    {\n+        auto it = m_index.get<ByPeer>().find(EntryPeer{peer, true, gtxid.GetHash()});\n+        // RequestedTx can only be called on CANDIDATE_BEST entries (this is implied by its condition that it can only be\n+        // called on txids returned by GetRequestable (and only AlreadyHave and RequestedTx can be called in between,\n+        // which preserve the state of other txids).\n+        assert(it != m_index.get<ByPeer>().end());\n+        assert(it->GetState() == State::CANDIDATE_BEST);\n+        Modify<ByPeer>(it, [expiry](Entry& entry) {\n+            entry.SetState(State::REQUESTED);\n+            entry.m_time = expiry;\n+        });\n+\n+        // Update the m_per_txhash (of the last Entry for this txhash) to reflect that new ones are no longer\n+        // eligible for the \"first\" marker.\n+        auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0}));\n+        assert(it_last->m_txhash == gtxid.GetHash());\n+        it_last->m_per_txhash |= TXHASHINFO_NO_MORE_PREFERRED_FIRST | TXHASHINFO_NO_MORE_NONPREFERRED_FIRST;\n+    }\n+\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid)\n+    {\n+        // We need to search the ByPeer index for both (peer, false, txid) and (peer, true, txid).\n+        auto it = m_index.get<ByPeer>().find(EntryPeer{peer, false, gtxid.GetHash()});\n+        if (it == m_index.get<ByPeer>().end()) {\n+            it = m_index.get<ByPeer>().find(EntryPeer{peer, true, gtxid.GetHash()});\n+        }\n+        if (it != m_index.get<ByPeer>().end()) MakeCompleted(m_index.project<ByTxHash>(it));\n+    }\n+\n+    size_t CountInFlight(uint64_t peer) const\n+    {\n+        auto it = m_peerinfo.find(peer);\n+        if (it != m_peerinfo.end()) return it->second.m_requested;\n+        return 0;\n+    }\n+\n+    size_t CountTracked(uint64_t peer) const\n+    {\n+        auto it = m_peerinfo.find(peer);\n+        if (it != m_peerinfo.end()) return it->second.m_total;\n+        return 0;\n+    }\n+\n+    //! Count how many announcements are being tracked in total across all peers and transactions.\n+    size_t Size() const { return m_index.size(); }\n+\n+    //! Access to the internal PriorityComputer (for testing)\n+    const PriorityComputer& GetPriorityComputer() const { return m_computer; }\n+\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata.\n+        // This verifies the data in it, including the invariant\n+        // that no entries with m_total_announcements==0 exist.\n+        std::unordered_map<uint64_t, PeerInfo> peerinfo;\n+        for (const auto& a : m_index) {\n+            auto& entry = peerinfo[a.m_peer];\n+            ++entry.m_total;\n+            entry.m_requested += (a.GetState() == State::REQUESTED);\n+        }\n+        assert(m_peerinfo == peerinfo);\n+\n+        struct Counts {\n+            //! Number of CANDIDATE_DELAYED entries for this txhash.\n+            size_t m_candidate_delayed = 0;\n+            //! Number of CANDIDATE_READY entries for this txhash.\n+            size_t m_candidate_ready = 0;\n+            //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+            size_t m_candidate_best = 0;\n+            //! Number of REQUESTED entries for this txhash.\n+            size_t m_requested = 0;\n+            //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+            uint64_t m_priority_candidate_best = 0;\n+            //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+            uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+            //! All peers we have an entry for this txhash for.\n+            std::vector<uint64_t> m_peers;\n+            //! Whether any preferred first entry exists.\n+            bool m_any_preferred_first = false;\n+            //! Whether any non-preferred first entry exists.\n+            bool m_any_nonpreferred_first = false;\n+            //! OR of all m_per_txhash flags.\n+            uint8_t m_or_all_per_txhash = 0;\n+        };\n+\n+        std::map<uint256, Counts> table;\n+        for (const auto& a : m_index) {\n+            auto& entry = table[a.m_txhash];\n+            // Classify how many types peers we have for this txid.\n+            entry.m_candidate_delayed += (a.GetState() == State::CANDIDATE_DELAYED);\n+            entry.m_candidate_ready += (a.GetState() == State::CANDIDATE_READY);\n+            entry.m_candidate_best += (a.GetState() == State::CANDIDATE_BEST);\n+            entry.m_requested += (a.GetState() == State::REQUESTED);\n+            // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+            if (a.GetState() == State::CANDIDATE_BEST) {\n+                entry.m_priority_candidate_best = a.ComputePriority(m_computer);\n+            }\n+            if (a.GetState() == State::CANDIDATE_READY) {\n+                entry.m_priority_best_candidate_ready = std::min(entry.m_priority_best_candidate_ready,\n+                    a.ComputePriority(m_computer));\n+            }\n+            // Also keep track of which peers this txid has an entry for (so we can detect duplicates).\n+            entry.m_peers.push_back(a.m_peer);\n+            // Track preferred/first.\n+            entry.m_any_preferred_first |= (a.m_first && a.m_preferred);\n+            entry.m_any_nonpreferred_first |= (a.m_first && !a.m_preferred);\n+            entry.m_or_all_per_txhash |= a.m_per_txhash;\n+        }\n+        for (auto& entry : table) {\n+            auto& c = entry.second;\n+            // Cannot have only COMPLETED peers (txid should have been deleted)\n+            assert(c.m_candidate_delayed + c.m_candidate_ready + c.m_candidate_best + c.m_requested > 0);\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(c.m_candidate_best + c.m_requested <= 1);\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (c.m_candidate_ready > 0) {\n+                assert(c.m_candidate_best + c.m_requested == 1);\n+            }\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good as the best CANDIDATE_READY.\n+            if (c.m_candidate_ready && c.m_candidate_best) {\n+                assert(c.m_priority_candidate_best <= c.m_priority_best_candidate_ready);\n+            }\n+            // Detect duplicate (peer, txid) entries\n+            std::sort(c.m_peers.begin(), c.m_peers.end());\n+            assert(std::adjacent_find(c.m_peers.begin(), c.m_peers.end()) == c.m_peers.end());\n+            // Verify all per_txhash flags.\n+            uint8_t expected_per_txhash = 0;\n+            if (c.m_any_preferred_first || c.m_requested) {\n+                expected_per_txhash |= TXHASHINFO_NO_MORE_PREFERRED_FIRST;\n+            }\n+            if (c.m_any_nonpreferred_first || c.m_requested) {\n+                expected_per_txhash |= TXHASHINFO_NO_MORE_NONPREFERRED_FIRST;\n+            }\n+            // All expected flags must be present, but there can be more. If a node went from REQUESTED to\n+            // COMPLETED, or was deleted, our expected_per_txhash may miss the relevant bits.\n+            assert((expected_per_txhash & ~c.m_or_all_per_txhash) == 0);\n+            // No entry can have flags that are a superset of the actual ones (they're always ORed into the actual\n+            // one).\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{entry.first, State::TOO_LARGE, 0}));\n+            assert(it_last->m_txhash == entry.first);\n+            assert(c.m_or_all_per_txhash == it_last->m_per_txhash);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+};\n+\n+TxRequestTracker::TxRequestTracker(bool deterministic)\n+{\n+    m_impl = MakeUnique<TxRequestTracker::Impl>(deterministic);\n+}\n+\n+TxRequestTracker::~TxRequestTracker() {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494493059",
      "id" : 494493059,
      "in_reply_to_id" : 494257310,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ5MzA1OQ==",
      "original_commit_id" : "7949d08406774f27fd0291c2aa046ecdf985c191",
      "original_line" : 676,
      "original_position" : 676,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 495799893,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494493059",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494493201"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494493201"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nice, done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T17:34:13Z",
      "diff_hunk" : "@@ -0,0 +1,222 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the \"first\" marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the \"first\" mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ * \"First\" marker rules: the \"first\" marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the extent to which attackers that race the network in announcing all transactions\n+ *              can break chains of dependent transactions.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and avoiding influenceable\n+ * by attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494493201",
      "id" : 494493201,
      "in_reply_to_id" : 494323998,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ5MzIwMQ==",
      "original_commit_id" : "7949d08406774f27fd0291c2aa046ecdf985c191",
      "original_line" : 112,
      "original_position" : 112,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495800023,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494493201",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494493318"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494493318"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T17:34:23Z",
      "diff_hunk" : "@@ -0,0 +1,715 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+TxRequestTracker::PriorityComputer::PriorityComputer(bool deterministic) :\n+    m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+    m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+uint64_t TxRequestTracker::PriorityComputer::operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const\n+{\n+    uint64_t low_bits = 0;\n+    if (!first) {\n+        low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+    }\n+    return low_bits | uint64_t{!preferred} << 63;\n+}\n+\n+static const uint256 UINT256_ZERO;\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient\n+    //! implementation. Also note that the sorting order of EntryTxHash relies on the specific order of values in\n+    //! this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_DELAYED,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST.\n+        CANDIDATE_READY,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+\n+        //! An invalid State value that's larger than all valid ones.\n+        TOO_LARGE,\n+    };\n+\n+    /** A flag (in Entry::m_per_txhash) to indicate that for that txhash,\n+     *  new preferred announcements are not eligible to get the 'first' marker. */\n+    static constexpr uint8_t TXHASHINFO_NO_MORE_PREFERRED_FIRST = 1;\n+    /** A flag (in Entry::m_per_txhash) to indicate that for that txhash,\n+     *  new non-preferred announcements are not eligible to get the 'first' marker. */\n+    static constexpr uint8_t TXHASHINFO_NO_MORE_NONPREFERRED_FIRST = 2;\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxHash-based index.\n+    struct ByTxHash {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+    using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txhash;\n+        //! For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 56;\n+        //! Whether the request is preferred (giving it priority higher than non-preferred ones).\n+        const bool m_preferred : 1;\n+        //! Whether this is a wtxid request.\n+        const bool m_is_wtxid : 1;\n+        //! Whether this was: the very first announcement for this txhash, within the\n+        //! preferred or non-preferred ones, and no request had been made for this\n+        //! txhash from any peer at the time the announcement came in.\n+        const bool m_first : 1;\n+\n+        //! What state this announcement is in\n+        //! This is a uint8_t instead of a State to silence a GCC warning.\n+        uint8_t m_state : 3;\n+\n+        /** Per-txhash flags. These are stored in the last Entry for a given txhash (ByTxHash order).\n+         *  The values for other Entry objects can be arbitrary subsets of the actual flags. */\n+        mutable uint8_t m_per_txhash : 2;\n+\n+        //! Convert the m_state variable to a State enum.\n+        State GetState() const { return State(m_state); }\n+        //! Convert a State to a uint8_t and store it in m_state.\n+        void SetState(State state) { m_state = uint8_t(state); }\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txhash.\n+        bool IsSelected() const\n+        {\n+            return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+        }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const\n+        {\n+            return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+        }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const\n+        {\n+            return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+        }\n+\n+        //! Construct a new entry from scratch, initially in CANDIDATE_DELAYED state.\n+        Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+            uint64_t sequence, bool first) :\n+            m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+            m_is_wtxid(gtxid.IsWtxid()), m_first(first), m_state(uint8_t(State::CANDIDATE_DELAYED)),\n+            m_per_txhash(0) {}\n+\n+        //! Compute this Entry's priority.\n+        uint64_t ComputePriority(const PriorityComputer& computer) const\n+        {\n+            return computer(m_txhash, m_peer, m_preferred, m_first);\n+        }\n+\n+        //! Extract the EntryPeer from this Entry.\n+        EntryPeer ExtractPeer() const { return EntryPeer{m_peer, GetState() == State::CANDIDATE_BEST, m_txhash}; }\n+\n+        //! Extract the EntryTxHash from this Entry.\n+        EntryTxHash ExtractTxid(const PriorityComputer& computer) const\n+        {\n+            return EntryTxHash{\n+                m_txhash,\n+                GetState(),\n+                GetState() == State::CANDIDATE_READY ? ComputePriority(computer) : 0\n+            };\n+        }\n+\n+        //! Extract the EntryTime from this Entry.\n+        EntryTime ExtractTime() const { return EntryTime{IsWaiting() ? 0 : IsSelectable() ? 2 : 1, m_time}; }\n+    };\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    /** An extractor for EntryTxHash (with encapsulated PriorityComputer reference).\n+     *\n+     * See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+     * for more information about the key extraction concept.\n+     */\n+    class EntryTxHashExtractor {\n+        const PriorityComputer& m_computer;\n+    public:\n+        EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+        using result_type = EntryTxHash; // Needed to comply with key extractor interface\n+        result_type operator()(const Entry& entry) const { return entry.ExtractTxid(m_computer); }\n+    };\n+\n+    //! Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes).\n+    using Index = boost::multi_index_container<\n+        Entry,\n+        boost::multi_index::indexed_by<\n+            boost::multi_index::ordered_unique<\n+                boost::multi_index::tag<ByPeer>,\n+                boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTxHash>,\n+                EntryTxHashExtractor\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTime>,\n+                boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>\n+            >\n+        >\n+    >;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Per-peer statistics object.\n+    struct PeerInfo {\n+        size_t m_total = 0; //!< Total number of entries for this peer.\n+        size_t m_requested = 0; //!< Total number of REQUESTED entries for this peer.\n+\n+        friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+        {\n+            return std::tie(a.m_total, a.m_requested) == std::tie(b.m_total, b.m_requested);\n+        }\n+    };\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo and m_per_txhash up to date.\n+    template<typename Tag>\n+    typename Index::index<Tag>::type::iterator Erase(typename Index::index<Tag>::type::iterator it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        // As it may possibly be the last-sorted Entry for a given txhash, propagate its per-txhash flags to its\n+        // predecessor (if it belongs to the same txhash).\n+        auto bytxhashit = m_index.project<ByTxHash>(it);\n+        if (bytxhashit != m_index.get<ByTxHash>().begin() &&\n+            bytxhashit->m_txhash == std::prev(bytxhashit)->m_txhash) {\n+            std::prev(bytxhashit)->m_per_txhash |= bytxhashit->m_per_txhash;\n+        }\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo and m_per_txhash up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(typename Index::index<Tag>::type::iterator it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        // It's possible that it used to be the last-sorted Entry for its txhash, so propagate its\n+        // flags to its predecessor (which would then become the new last-sorted Entry).\n+        auto bytxhashit = m_index.project<ByTxHash>(it);\n+        if (bytxhashit != m_index.get<ByTxHash>().begin() &&\n+            bytxhashit->m_txhash == std::prev(bytxhashit)->m_txhash) {\n+            std::prev(bytxhashit)->m_per_txhash |= bytxhashit->m_per_txhash;\n+        }\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        // It's possible that it is now the new last-sorted Entry for its txhash, so propagate flags\n+        // from its predecessor to it.\n+        bytxhashit = m_index.project<ByTxHash>(it);\n+        if (bytxhashit != m_index.get<ByTxHash>().begin() &&\n+            bytxhashit->m_txhash == std::prev(bytxhashit)->m_txhash) {\n+            bytxhashit->m_per_txhash |= std::prev(bytxhashit)->m_per_txhash;\n+        }\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(typename Index::index<ByTxHash>::type::iterator it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txid, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txid that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txid already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = std::prev(it)->ComputePriority(m_computer);\n+            uint64_t priority_new = it->ComputePriority(m_computer);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(typename Index::index<ByTxHash>::type::iterator it, State new_state)\n+    {\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in\n+            // the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Entry for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(typename Index::index<ByTxHash>::type::iterator it)\n+    {\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED entries.\n+\n+        // If this Entry's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Entry's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    //! Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txid, they are all\n+    //! deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+    //! CANDIDATE_BEST. Returns whether the Entry still exists.\n+    bool MakeCompleted(typename Index::index<ByTxHash>::type::iterator it)\n+    {\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED entry for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the entry COMPLETED, and select the next best entry (the first CANDIDATE_READY) if needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to EntryTxHashExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(\n+                boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>(),\n+                std::less<EntryPeer>()\n+            ),\n+            boost::make_tuple(\n+                EntryTxHashExtractor(m_computer),\n+                std::less<EntryTxHash>()\n+            ),\n+            boost::make_tuple(\n+                boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>(),\n+                std::less<EntryTime>()\n+            )\n+        )) {}\n+\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxHashExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DeletedPeer(uint64_t peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+            // CANDIDATE_BEST, or delete all of a txid's entries if no non-COMPLETED ones are left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTx(const GenTxid& gtxid)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == gtxid.GetHash()) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred, bool overloaded,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST entry for this (txid, peer) combination. The case where there is\n+        // a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+        // automatically.\n+        if (m_index.get<ByPeer>().count(EntryPeer{peer, true, gtxid.GetHash()})) return;\n+\n+        // Find last entry for this txhash, and extract per_txhash information from it.\n+        uint8_t per_txhash = 0;\n+        typename Index::index<ByTxHash>::type::iterator it_last = m_index.get<ByTxHash>().end();\n+        // First find the first entry past this txhash.\n+        it_last = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0});\n+        if (it_last != m_index.get<ByTxHash>().begin() && std::prev(it_last)->m_txhash == gtxid.GetHash()) {\n+            // Its predecessor exists, and has the right txhash. Remember it, and OR in its flags.\n+            it_last--;\n+            per_txhash |= it_last->m_per_txhash;\n+        } else {\n+            // No entry for this txhash exists yet.\n+            it_last = m_index.get<ByTxHash>().end();\n+        }\n+\n+        // Determine whether the new announcement's Entry will get the first marker, and update\n+        // the per_txhash information to be stored (but note that per_txhash isn't actually stored\n+        // until after the emplace below succeeds).\n+        bool first = false;\n+        if (!overloaded) {\n+            if (preferred && !(per_txhash & TXHASHINFO_NO_MORE_PREFERRED_FIRST)) {\n+                first = true;\n+                per_txhash |= TXHASHINFO_NO_MORE_PREFERRED_FIRST;\n+            } else if (!preferred && !(per_txhash & TXHASHINFO_NO_MORE_NONPREFERRED_FIRST)) {\n+                first = true;\n+                per_txhash |= TXHASHINFO_NO_MORE_NONPREFERRED_FIRST;\n+            }\n+        }\n+\n+        // Try creating the entry with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST entry already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_sequence, first);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+\n+        // Update m_per_txhash of the new last Entry (either the newly created one, or it_last).\n+        auto it = m_index.project<ByTxHash>(ret.first);\n+        if (it_last == m_index.get<ByTxHash>().end() || std::next(it_last) == it) it_last = it;\n+        it_last->m_per_txhash |= per_txhash;\n+    }\n+\n+    //! Find the txids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now)\n+    {\n+        // Move time.\n+        SetTimePoint(now);\n+\n+        // Find all CANDIDATE_BEST entries for this peer.\n+        std::vector<std::pair<uint64_t, const Entry*>> selected;\n+        auto it_peer = m_index.get<ByPeer>().lower_bound(EntryPeer{peer, true, UINT256_ZERO});\n+        while (it_peer != m_index.get<ByPeer>().end() && it_peer->m_peer == peer &&\n+            it_peer->GetState() == State::CANDIDATE_BEST) {\n+            selected.emplace_back(it_peer->m_sequence, &*it_peer);\n+            ++it_peer;\n+        }\n+\n+        // Return them, sorted by sequence number.\n+        std::sort(selected.begin(), selected.end());\n+        std::vector<GenTxid> ret;\n+        for (const auto& item : selected) {\n+            ret.emplace_back(item.second->m_is_wtxid, item.second->m_txhash);\n+        }\n+        return ret;\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds expiry)\n+    {\n+        auto it = m_index.get<ByPeer>().find(EntryPeer{peer, true, gtxid.GetHash()});\n+        // RequestedTx can only be called on CANDIDATE_BEST entries (this is implied by its condition that it can only be\n+        // called on txids returned by GetRequestable (and only AlreadyHave and RequestedTx can be called in between,\n+        // which preserve the state of other txids).\n+        assert(it != m_index.get<ByPeer>().end());\n+        assert(it->GetState() == State::CANDIDATE_BEST);\n+        Modify<ByPeer>(it, [expiry](Entry& entry) {\n+            entry.SetState(State::REQUESTED);\n+            entry.m_time = expiry;\n+        });\n+\n+        // Update the m_per_txhash (of the last Entry for this txhash) to reflect that new ones are no longer\n+        // eligible for the \"first\" marker.\n+        auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0}));\n+        assert(it_last->m_txhash == gtxid.GetHash());\n+        it_last->m_per_txhash |= TXHASHINFO_NO_MORE_PREFERRED_FIRST | TXHASHINFO_NO_MORE_NONPREFERRED_FIRST;\n+    }\n+\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid)\n+    {\n+        // We need to search the ByPeer index for both (peer, false, txid) and (peer, true, txid).\n+        auto it = m_index.get<ByPeer>().find(EntryPeer{peer, false, gtxid.GetHash()});\n+        if (it == m_index.get<ByPeer>().end()) {\n+            it = m_index.get<ByPeer>().find(EntryPeer{peer, true, gtxid.GetHash()});\n+        }\n+        if (it != m_index.get<ByPeer>().end()) MakeCompleted(m_index.project<ByTxHash>(it));\n+    }\n+\n+    size_t CountInFlight(uint64_t peer) const\n+    {\n+        auto it = m_peerinfo.find(peer);\n+        if (it != m_peerinfo.end()) return it->second.m_requested;\n+        return 0;\n+    }\n+\n+    size_t CountTracked(uint64_t peer) const\n+    {\n+        auto it = m_peerinfo.find(peer);\n+        if (it != m_peerinfo.end()) return it->second.m_total;\n+        return 0;\n+    }\n+\n+    //! Count how many announcements are being tracked in total across all peers and transactions.\n+    size_t Size() const { return m_index.size(); }\n+\n+    //! Access to the internal PriorityComputer (for testing)\n+    const PriorityComputer& GetPriorityComputer() const { return m_computer; }\n+\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata.\n+        // This verifies the data in it, including the invariant\n+        // that no entries with m_total_announcements==0 exist.\n+        std::unordered_map<uint64_t, PeerInfo> peerinfo;\n+        for (const auto& a : m_index) {\n+            auto& entry = peerinfo[a.m_peer];\n+            ++entry.m_total;\n+            entry.m_requested += (a.GetState() == State::REQUESTED);\n+        }\n+        assert(m_peerinfo == peerinfo);\n+\n+        struct Counts {\n+            //! Number of CANDIDATE_DELAYED entries for this txhash.\n+            size_t m_candidate_delayed = 0;\n+            //! Number of CANDIDATE_READY entries for this txhash.\n+            size_t m_candidate_ready = 0;\n+            //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+            size_t m_candidate_best = 0;\n+            //! Number of REQUESTED entries for this txhash.\n+            size_t m_requested = 0;\n+            //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+            uint64_t m_priority_candidate_best = 0;\n+            //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+            uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+            //! All peers we have an entry for this txhash for.\n+            std::vector<uint64_t> m_peers;\n+            //! Whether any preferred first entry exists.\n+            bool m_any_preferred_first = false;\n+            //! Whether any non-preferred first entry exists.\n+            bool m_any_nonpreferred_first = false;\n+            //! OR of all m_per_txhash flags.\n+            uint8_t m_or_all_per_txhash = 0;\n+        };\n+\n+        std::map<uint256, Counts> table;\n+        for (const auto& a : m_index) {\n+            auto& entry = table[a.m_txhash];\n+            // Classify how many types peers we have for this txid.\n+            entry.m_candidate_delayed += (a.GetState() == State::CANDIDATE_DELAYED);\n+            entry.m_candidate_ready += (a.GetState() == State::CANDIDATE_READY);\n+            entry.m_candidate_best += (a.GetState() == State::CANDIDATE_BEST);\n+            entry.m_requested += (a.GetState() == State::REQUESTED);\n+            // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+            if (a.GetState() == State::CANDIDATE_BEST) {\n+                entry.m_priority_candidate_best = a.ComputePriority(m_computer);\n+            }\n+            if (a.GetState() == State::CANDIDATE_READY) {\n+                entry.m_priority_best_candidate_ready = std::min(entry.m_priority_best_candidate_ready,\n+                    a.ComputePriority(m_computer));\n+            }\n+            // Also keep track of which peers this txid has an entry for (so we can detect duplicates).\n+            entry.m_peers.push_back(a.m_peer);\n+            // Track preferred/first.\n+            entry.m_any_preferred_first |= (a.m_first && a.m_preferred);\n+            entry.m_any_nonpreferred_first |= (a.m_first && !a.m_preferred);\n+            entry.m_or_all_per_txhash |= a.m_per_txhash;\n+        }\n+        for (auto& entry : table) {\n+            auto& c = entry.second;\n+            // Cannot have only COMPLETED peers (txid should have been deleted)\n+            assert(c.m_candidate_delayed + c.m_candidate_ready + c.m_candidate_best + c.m_requested > 0);\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(c.m_candidate_best + c.m_requested <= 1);\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (c.m_candidate_ready > 0) {\n+                assert(c.m_candidate_best + c.m_requested == 1);\n+            }\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good as the best CANDIDATE_READY.\n+            if (c.m_candidate_ready && c.m_candidate_best) {\n+                assert(c.m_priority_candidate_best <= c.m_priority_best_candidate_ready);\n+            }\n+            // Detect duplicate (peer, txid) entries\n+            std::sort(c.m_peers.begin(), c.m_peers.end());\n+            assert(std::adjacent_find(c.m_peers.begin(), c.m_peers.end()) == c.m_peers.end());\n+            // Verify all per_txhash flags.\n+            uint8_t expected_per_txhash = 0;\n+            if (c.m_any_preferred_first || c.m_requested) {\n+                expected_per_txhash |= TXHASHINFO_NO_MORE_PREFERRED_FIRST;\n+            }\n+            if (c.m_any_nonpreferred_first || c.m_requested) {\n+                expected_per_txhash |= TXHASHINFO_NO_MORE_NONPREFERRED_FIRST;\n+            }\n+            // All expected flags must be present, but there can be more. If a node went from REQUESTED to\n+            // COMPLETED, or was deleted, our expected_per_txhash may miss the relevant bits.\n+            assert((expected_per_txhash & ~c.m_or_all_per_txhash) == 0);\n+            // No entry can have flags that are a superset of the actual ones (they're always ORed into the actual\n+            // one).\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{entry.first, State::TOO_LARGE, 0}));\n+            assert(it_last->m_txhash == entry.first);\n+            assert(c.m_or_all_per_txhash == it_last->m_per_txhash);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+};\n+\n+TxRequestTracker::TxRequestTracker(bool deterministic)\n+{\n+    m_impl = MakeUnique<TxRequestTracker::Impl>(deterministic);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494493318",
      "id" : 494493318,
      "in_reply_to_id" : 494348645,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ5MzMxOA==",
      "original_commit_id" : "7949d08406774f27fd0291c2aa046ecdf985c191",
      "original_line" : 673,
      "original_position" : 673,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 495800143,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494493318",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494495109"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494495109"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The witness-ness of GenTxid doesn't matter. I find the interface distracting since it needs to be passed in.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T17:37:26Z",
      "diff_hunk" : "@@ -2869,8 +2876,15 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n \n         TxValidationState state;\n \n+        if (wtxid != txid) {\n+            // Regardless of whether the transaction we received is valid and acceptable or not,\n+            // we don't need the version with this exact witness anymore.\n+            m_txrequest.ForgetTx(GenTxid{true, wtxid});",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494495109",
      "id" : 494495109,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ5NTEwOQ==",
      "original_commit_id" : "cb2aa36ac613953916ca5eba69b7260006873358",
      "original_line" : 2882,
      "original_position" : 21,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 495769842,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494495109",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494504239"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494504239"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'd prefer to move these into a friend `TxRequestTrackerTester` class (I thought I'd left a review comment suggesting that, but I appear to have lost it).",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T17:53:13Z",
      "diff_hunk" : "@@ -208,6 +208,15 @@ class TxRequestTracker {\n \n     /** Access to the internal PriorityComputer (for testing) */\n     const PriorityComputer& GetPriorityComputer() const;\n+\n+    /** Run internal consistency check (testing only). */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494504239",
      "id" : 494504239,
      "in_reply_to_id" : 494488392,
      "line" : 196,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUwNDIzOQ==",
      "original_commit_id" : "71f551d840deaae3c30bb08a2c7a2248b043dbac",
      "original_line" : 196,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 196,
      "pull_request_review_id" : 495814053,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494504239",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494514532"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494514532"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ah, my thinking behind the name was the caller informing TxRequestTracker \"Hey I have deleted peer X, you may want to forget about them\".\r\n\r\nDisconnectedPeer sounds better.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T18:11:16Z",
      "diff_hunk" : "@@ -0,0 +1,213 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the \"first\" marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the \"first\" mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ * \"First\" marker rules: the \"first\" marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the extent to which attackers that race the network in announcing all transactions\n+ *              can break chains of dependent transactions.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and avoiding influenceable\n+ * by attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, but they timed out, a\n+    //   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DeletedPeer(uint64_t peer);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494514532",
      "id" : 494514532,
      "in_reply_to_id" : 494469813,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUxNDUzMg==",
      "original_commit_id" : "164f50402475175d6fc839ae2798817e8da7c68f",
      "original_line" : 138,
      "original_position" : 149,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495829638,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494514532",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494515427"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494515427"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm not sure what you're suggesting here. FAILED seems like a bad name as it indeed doesn't imply failure.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T18:12:52Z",
      "diff_hunk" : "@@ -0,0 +1,213 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the \"first\" marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the \"first\" mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ * \"First\" marker rules: the \"first\" marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the extent to which attackers that race the network in announcing all transactions\n+ *              can break chains of dependent transactions.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and avoiding influenceable\n+ * by attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, but they timed out, a",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494515427",
      "id" : 494515427,
      "in_reply_to_id" : 494477588,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUxNTQyNw==",
      "original_commit_id" : "164f50402475175d6fc839ae2798817e8da7c68f",
      "original_line" : 127,
      "original_position" : 138,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495831556,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494515427",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494517514"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494517514"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm not entirely sure, as the caller really doesn't care about the fact that it also expires things. It just wants to know what should be requested.\r\n\r\nIt's not an implementation detail, as the effect of expiration is observable (CountInFlight, CountTracked() and Size() go  down), but I think that makes just specification details rather than the caller's intent.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T18:16:36Z",
      "diff_hunk" : "@@ -0,0 +1,213 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the \"first\" marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the \"first\" mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ * \"First\" marker rules: the \"first\" marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the extent to which attackers that race the network in announcing all transactions\n+ *              can break chains of dependent transactions.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and avoiding influenceable\n+ * by attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, but they timed out, a\n+    //   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DeletedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash.\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it. The is_wtxid flag of gtxid is ignored.\n+     */\n+    void ForgetTx(const GenTxid& gtxid);\n+\n+    /** Adds a new CANDIDATE entry.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that this means a second INV with the same txhash from the same peer will be ignored, even\n+     * if one is a txid and the other is wtxid (but that shouldn't happen, as BIP339 requires that all announced\n+     * inventory is exclusively using MSG_WTX). The new entry is given the specified preferred and reqtime values,\n+     * and takes it is_wtxid from the specified gtxid. It is eligible to get a first marker if overloaded is false\n+     * (but also subject to the other rules regarding the first marker).\n+     */\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred, bool overloaded,\n+        std::chrono::microseconds reqtime);\n+\n+    /** Converts the CANDIDATE entry for the provided peer and gtxid into a REQUESTED one.\n+     *\n+     * Expiry is set to the specified value. This can ONLY be called immediately after GetRequestable was called\n+     * (for the same peer), with only ForgetTx and other RequestedTx calls (both for other txhashes) in\n+     * between. Any other non-const operation removes the ability to call RequestedTx.\n+     */\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds expiry);\n+\n+    /** Converts any CANDIDATE or REQUESTED entry to a COMPLETED one, if one exists.\n+     *\n+     * It should be called whenever a transaction or NOTFOUND was received from a peer. When a good transaction is\n+     * received, ForgetTx should be called instead of (or in addition to) this operation.\n+     */\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid);\n+\n+    // The operations below inspect the data structure.\n+\n+    /** Find the txids to request now from peer.\n+     *\n+     * It does the following:\n+     *  - Convert all REQUESTED entries (for all txhashes/peers) with (expiry <= now) to COMPLETED entries.\n+     *  - Requestable entries are selected: CANDIDATE entries from the specified peer with (reqtime <= now) for\n+     *    which the specified peer is the best choice among all such CANDIDATE entries with the same txhash (subject\n+     *    to preference/first rules, and tiebreaking using a deterministic salted hash of peer and txhash).\n+     *  - The selected entries are sorted in order of announcement (even if multiple were added at the same time, or\n+     *    even when the clock went backwards while they were being added), converted to GenTxids using their\n+     *    is_wtxid flag, and returned.\n+     */\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494517514",
      "id" : 494517514,
      "in_reply_to_id" : 494485317,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUxNzUxNA==",
      "original_commit_id" : "164f50402475175d6fc839ae2798817e8da7c68f",
      "original_line" : 173,
      "original_position" : 198,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495835805,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494517514",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494517808"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494517808"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@jnewbery How do you suggest to do that in combination with the impl pattern?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T18:17:09Z",
      "diff_hunk" : "@@ -208,6 +208,15 @@ class TxRequestTracker {\n \n     /** Access to the internal PriorityComputer (for testing) */\n     const PriorityComputer& GetPriorityComputer() const;\n+\n+    /** Run internal consistency check (testing only). */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494517808",
      "id" : 494517808,
      "in_reply_to_id" : 494488392,
      "line" : 196,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUxNzgwOA==",
      "original_commit_id" : "71f551d840deaae3c30bb08a2c7a2248b043dbac",
      "original_line" : 196,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 196,
      "pull_request_review_id" : 495836489,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494517808",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494520862"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494520862"
         }
      },
      "author_association" : "MEMBER",
      "body" : "apologies I wrote my comment in two frame of minds. I mean to say the comment doesn't mention \"success\" as a possibility to transition to this state. Update the comment and I'm happy.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T18:22:20Z",
      "diff_hunk" : "@@ -0,0 +1,213 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the \"first\" marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the \"first\" mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ * \"First\" marker rules: the \"first\" marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the extent to which attackers that race the network in announcing all transactions\n+ *              can break chains of dependent transactions.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and avoiding influenceable\n+ * by attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, but they timed out, a",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494520862",
      "id" : 494520862,
      "in_reply_to_id" : 494477588,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUyMDg2Mg==",
      "original_commit_id" : "164f50402475175d6fc839ae2798817e8da7c68f",
      "original_line" : 127,
      "original_position" : 138,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495841657,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494520862",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494541577"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494541577"
         }
      },
      "author_association" : "MEMBER",
      "body" : "My hope here was that making TxRequestTracker deal solely with GenTxids would simplify the interface. The caller just has these gtxids that it hands to TxRequestTracker, and gets gtxids back. The idea was that the knowledge about when the is_wtxid flag mattered in certain contexts could be restricted to TxRequestTracker. I don't this idea really works. This optimization (in \"Expedite removal\") specifically breaks it: it's calling ForgetTx in a situation where we actually don't have the tx already, relying on the fact that if txid and wtxid differ, it must be a witness transaction, and thus we certainly don't need other transactions with the same witness.\r\n\r\nI think there are two solutions to it:\r\n* Add to ForgetTx logic that if a txid is provided, it deletes both txid and wtxid announcements, but if a wtxid is provided only wtxid announcements are deleted. This would avoid some of the complexity here in net_processing, but technically break the amortized O(1) complexity claim - you could call ForgetTx(wtxid) repeatedly, and it would every time consume time proportional to the number of txid announcements with the same hash.\r\n* Give up on the perfect abstraction, and just make ForgetTx take a txhash (and rename it to ForgetTxHash, I guess).",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T18:53:08Z",
      "diff_hunk" : "@@ -2869,8 +2876,15 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n \n         TxValidationState state;\n \n+        if (wtxid != txid) {\n+            // Regardless of whether the transaction we received is valid and acceptable or not,\n+            // we don't need the version with this exact witness anymore.\n+            m_txrequest.ForgetTx(GenTxid{true, wtxid});",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494541577",
      "id" : 494541577,
      "in_reply_to_id" : 494495109,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU0MTU3Nw==",
      "original_commit_id" : "cb2aa36ac613953916ca5eba69b7260006873358",
      "original_line" : 2882,
      "original_position" : 21,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 495863521,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494541577",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494614814"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494614814"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Hmmm yes, very good question! I wonder if something along the lines of https://stackoverflow.com/a/34054983/933705 might work (but then again, it might not be worth it just to avoid putting these three test helper functions in the public interface).",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T21:15:15Z",
      "diff_hunk" : "@@ -208,6 +208,15 @@ class TxRequestTracker {\n \n     /** Access to the internal PriorityComputer (for testing) */\n     const PriorityComputer& GetPriorityComputer() const;\n+\n+    /** Run internal consistency check (testing only). */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494614814",
      "id" : 494614814,
      "in_reply_to_id" : 494488392,
      "line" : 196,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYxNDgxNA==",
      "original_commit_id" : "71f551d840deaae3c30bb08a2c7a2248b043dbac",
      "original_line" : 196,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 196,
      "pull_request_review_id" : 495956440,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494614814",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494669129"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494669129"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Renamed to `DisconnectedPeer`.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T23:43:50Z",
      "diff_hunk" : "@@ -0,0 +1,213 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the \"first\" marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the \"first\" mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ * \"First\" marker rules: the \"first\" marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the extent to which attackers that race the network in announcing all transactions\n+ *              can break chains of dependent transactions.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and avoiding influenceable\n+ * by attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, but they timed out, a\n+    //   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DeletedPeer(uint64_t peer);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494669129",
      "id" : 494669129,
      "in_reply_to_id" : 494469813,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY2OTEyOQ==",
      "original_commit_id" : "164f50402475175d6fc839ae2798817e8da7c68f",
      "original_line" : 138,
      "original_position" : 149,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 496020423,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494669129",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494669252"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494669252"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Changed the interface to take just a uint256.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T23:44:13Z",
      "diff_hunk" : "@@ -0,0 +1,213 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the \"first\" marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the \"first\" mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ * \"First\" marker rules: the \"first\" marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the extent to which attackers that race the network in announcing all transactions\n+ *              can break chains of dependent transactions.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and avoiding influenceable\n+ * by attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, but they timed out, a\n+    //   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DeletedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash.\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it. The is_wtxid flag of gtxid is ignored.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494669252",
      "id" : 494669252,
      "in_reply_to_id" : 494471997,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY2OTI1Mg==",
      "original_commit_id" : "164f50402475175d6fc839ae2798817e8da7c68f",
      "original_line" : 143,
      "original_position" : 154,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 496020543,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494669252",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494669300"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494669300"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done. Better?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T23:44:24Z",
      "diff_hunk" : "@@ -0,0 +1,213 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the \"first\" marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the \"first\" mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ * \"First\" marker rules: the \"first\" marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the extent to which attackers that race the network in announcing all transactions\n+ *              can break chains of dependent transactions.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and avoiding influenceable\n+ * by attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, but they timed out, a",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494669300",
      "id" : 494669300,
      "in_reply_to_id" : 494477588,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY2OTMwMA==",
      "original_commit_id" : "164f50402475175d6fc839ae2798817e8da7c68f",
      "original_line" : 127,
      "original_position" : 138,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 496020609,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494669300",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494669912"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494669912"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think it's not unreasonable to have sanity checking functions for involved data structures in code that actually deals with that data structure. It could possibly be called at runtime using something something similar to `-checkmempool` too if we wanted.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T23:46:29Z",
      "diff_hunk" : "@@ -208,6 +208,15 @@ class TxRequestTracker {\n \n     /** Access to the internal PriorityComputer (for testing) */\n     const PriorityComputer& GetPriorityComputer() const;\n+\n+    /** Run internal consistency check (testing only). */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494669912",
      "id" : 494669912,
      "in_reply_to_id" : 494488392,
      "line" : 196,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY2OTkxMg==",
      "original_commit_id" : "71f551d840deaae3c30bb08a2c7a2248b043dbac",
      "original_line" : 196,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 196,
      "pull_request_review_id" : 496021232,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494669912",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494669962"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494669962"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Updated.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T23:46:38Z",
      "diff_hunk" : "@@ -1201,6 +1201,13 @@ void PeerManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock, co\n             }\n         }\n     }\n+    {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494669962",
      "id" : 494669962,
      "in_reply_to_id" : 494491883,
      "line" : 1230,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY2OTk2Mg==",
      "original_commit_id" : "3454757a66a82665b55aacbc1e53d75aafa82766",
      "original_line" : 1230,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 259,
      "pull_request_review_id" : 496021281,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494669962",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494671048"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494671048"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ok, I've looked into this more, and I believe the code looks a lot better with `ForgetTxHash` that just takes a uint256. This means the caller needs to understand the semantics for when calling with a txid/wtxid is fine, but that was the case already - just less obviously so. So I've switched the code to that.\r\n\r\nI've also removed the \"if (txid != wtxid) ForgetTx(wtxid);\" optimization. I think it's equivalent to just calling ForgetTxHash now with whatever is added to mempool/orphanpool/recentrejects, and the latter is far more obviously correct anyway (these things will be treated as AlreadyHaveTx() anyway, so deleting them early isn't going to change anything).",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-24T23:50:16Z",
      "diff_hunk" : "@@ -2869,8 +2876,15 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n \n         TxValidationState state;\n \n+        if (wtxid != txid) {\n+            // Regardless of whether the transaction we received is valid and acceptable or not,\n+            // we don't need the version with this exact witness anymore.\n+            m_txrequest.ForgetTx(GenTxid{true, wtxid});",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494671048",
      "id" : 494671048,
      "in_reply_to_id" : 494495109,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY3MTA0OA==",
      "original_commit_id" : "cb2aa36ac613953916ca5eba69b7260006873358",
      "original_line" : 2882,
      "original_position" : 21,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 496022530,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494671048",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494688751"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494688751"
         }
      },
      "author_association" : "MEMBER",
      "body" : "yes, thank you",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-25T00:56:04Z",
      "diff_hunk" : "@@ -0,0 +1,213 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the \"first\" marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the \"first\" mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ * \"First\" marker rules: the \"first\" marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the extent to which attackers that race the network in announcing all transactions\n+ *              can break chains of dependent transactions.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and avoiding influenceable\n+ * by attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, but they timed out, a",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494688751",
      "id" : 494688751,
      "in_reply_to_id" : 494477588,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY4ODc1MQ==",
      "original_commit_id" : "164f50402475175d6fc839ae2798817e8da7c68f",
      "original_line" : 127,
      "original_position" : 138,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 496043672,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494688751",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494725595"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494725595"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Maybe \"chose the first (non-overloaded) peer to have announced the transaction (managed by the \"first\" marker, see below)\" would be a better description -- ie focus on the aim, rather than the mechanism?\r\n\r\nMight make sense to follow the \"Rationale: in non-attack scenarios...\" with \"This is implemented via using a \"first\" marker, with the following rules:\" rather than having those rules be in a separate section a bit lower.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-25T03:23:47Z",
      "diff_hunk" : "@@ -0,0 +1,199 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494725595",
      "id" : 494725595,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcyNTU5NQ==",
      "original_commit_id" : "fd9f5c7653c19520d9fb18f232d3aa2cc1cb3972",
      "original_line" : 90,
      "original_position" : 78,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495233660,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494725595",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494726175"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494726175"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "\"avoiding influenceable\" doesn't make sense?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-25T03:26:09Z",
      "diff_hunk" : "@@ -0,0 +1,199 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the \"first\" marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the \"first\" mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ * \"First\" marker rules: the \"first\" marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the extent to which attackers that race the network in announcing all transactions\n+ *              can break chains of dependent transactions.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and avoiding influenceable",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494726175",
      "id" : 494726175,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcyNjE3NQ==",
      "original_commit_id" : "fd9f5c7653c19520d9fb18f232d3aa2cc1cb3972",
      "original_line" : 93,
      "original_position" : 93,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495233660,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494726175",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494767822"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494767822"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Since `Impl` is now only defined in the `cpp` file, I think you can reasonably move `State` and the like outside of the class, ideally sticking it in an anonymous namespace so the internal class methods get internal linkage. Main benefit would be that it's easier to see what the actual data being put in `Impl` is, I think.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-25T06:11:25Z",
      "diff_hunk" : "@@ -0,0 +1,590 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+static const uint256 UINT256_ZERO;\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient\n+    //! implementation. Also note that the sorting order of EntryTxHash relies on the specific order of values in\n+    //! this enum.\n+    enum class State : uint8_t {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494767822",
      "id" : 494767822,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2NzgyMg==",
      "original_commit_id" : "fd9f5c7653c19520d9fb18f232d3aa2cc1cb3972",
      "original_line" : 32,
      "original_position" : 32,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 495233660,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494767822",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494769750"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494769750"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I agree. That seems reasonable.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-25T06:17:04Z",
      "diff_hunk" : "@@ -208,6 +208,15 @@ class TxRequestTracker {\n \n     /** Access to the internal PriorityComputer (for testing) */\n     const PriorityComputer& GetPriorityComputer() const;\n+\n+    /** Run internal consistency check (testing only). */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494769750",
      "id" : 494769750,
      "in_reply_to_id" : 494488392,
      "line" : 196,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2OTc1MA==",
      "original_commit_id" : "71f551d840deaae3c30bb08a2c7a2248b043dbac",
      "original_line" : 196,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 196,
      "pull_request_review_id" : 496136482,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494769750",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494771653"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494771653"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This isn't templated, so `typename` isn't needed, I think? Making an alias for the iterators in general might be useful: `template<typename Tag> using IndexIter = typename Index::index<Tag>::type::iterator;` and `void PromoteCandidateReady(IndexIter<ByTxHash> it)`?\r\n",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-25T06:22:40Z",
      "diff_hunk" : "@@ -0,0 +1,590 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+static const uint256 UINT256_ZERO;\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient\n+    //! implementation. Also note that the sorting order of EntryTxHash relies on the specific order of values in\n+    //! this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_DELAYED,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST.\n+        CANDIDATE_READY,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+\n+        //! An invalid State value that's larger than all valid ones.\n+        TOO_LARGE,\n+    };\n+\n+    /** A flag (in Entry::m_per_txhash) to indicate that for that txhash,\n+     *  new preferred announcements are not eligible to get the 'first' marker. */\n+    static constexpr uint8_t TXHASHINFO_NO_MORE_PREFERRED_FIRST = 1;\n+    /** A flag (in Entry::m_per_txhash) to indicate that for that txhash,\n+     *  new non-preferred announcements are not eligible to get the 'first' marker. */\n+    static constexpr uint8_t TXHASHINFO_NO_MORE_NONPREFERRED_FIRST = 2;\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxHash-based index.\n+    struct ByTxHash {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+    using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic) :\n+            m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+            m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const\n+        {\n+            uint64_t low_bits = 0;\n+            if (!first) {\n+                low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+            }\n+            return low_bits | uint64_t{!preferred} << 63;\n+        }\n+    };\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txhash;\n+        //! For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 56;\n+        //! Whether the request is preferred (giving it priority higher than non-preferred ones).\n+        const bool m_preferred : 1;\n+        //! Whether this is a wtxid request.\n+        const bool m_is_wtxid : 1;\n+        //! Whether this was: the very first announcement for this txhash, within the\n+        //! preferred or non-preferred ones, and no request had been made for this\n+        //! txhash from any peer at the time the announcement came in.\n+        const bool m_first : 1;\n+\n+        //! What state this announcement is in\n+        //! This is a uint8_t instead of a State to silence a GCC warning.\n+        uint8_t m_state : 3;\n+\n+        /** Per-txhash flags. These are stored in the last Entry for a given txhash (ByTxHash order).\n+         *  The values for other Entry objects can be arbitrary subsets of the actual flags. */\n+        mutable uint8_t m_per_txhash : 2;\n+\n+        //! Convert the m_state variable to a State enum.\n+        State GetState() const { return State(m_state); }\n+        //! Convert a State to a uint8_t and store it in m_state.\n+        void SetState(State state) { m_state = uint8_t(state); }\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txhash.\n+        bool IsSelected() const\n+        {\n+            return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+        }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const\n+        {\n+            return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+        }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const\n+        {\n+            return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+        }\n+\n+        //! Construct a new entry from scratch, initially in CANDIDATE_DELAYED state.\n+        Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+            uint64_t sequence, bool first) :\n+            m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+            m_is_wtxid(gtxid.IsWtxid()), m_first(first), m_state(uint8_t(State::CANDIDATE_DELAYED)),\n+            m_per_txhash(0) {}\n+\n+        //! Compute this Entry's priority.\n+        uint64_t ComputePriority(const PriorityComputer& computer) const\n+        {\n+            return computer(m_txhash, m_peer, m_preferred, m_first);\n+        }\n+\n+        //! Extract the EntryPeer from this Entry.\n+        EntryPeer ExtractPeer() const { return EntryPeer{m_peer, GetState() == State::CANDIDATE_BEST, m_txhash}; }\n+\n+        //! Extract the EntryTxHash from this Entry.\n+        EntryTxHash ExtractTxid(const PriorityComputer& computer) const\n+        {\n+            return EntryTxHash{\n+                m_txhash,\n+                GetState(),\n+                GetState() == State::CANDIDATE_READY ? ComputePriority(computer) : 0\n+            };\n+        }\n+\n+        //! Extract the EntryTime from this Entry.\n+        EntryTime ExtractTime() const { return EntryTime{IsWaiting() ? 0 : IsSelectable() ? 2 : 1, m_time}; }\n+    };\n+\n+    /** An extractor for EntryTxHash (with encapsulated PriorityComputer reference).\n+     *\n+     * See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+     * for more information about the key extraction concept.\n+     */\n+    class EntryTxHashExtractor {\n+        const PriorityComputer& m_computer;\n+    public:\n+        EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+        using result_type = EntryTxHash; // Needed to comply with key extractor interface\n+        result_type operator()(const Entry& entry) const { return entry.ExtractTxid(m_computer); }\n+    };\n+\n+    //! Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes).\n+    using Index = boost::multi_index_container<\n+        Entry,\n+        boost::multi_index::indexed_by<\n+            boost::multi_index::ordered_unique<\n+                boost::multi_index::tag<ByPeer>,\n+                boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTxHash>,\n+                EntryTxHashExtractor\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTime>,\n+                boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>\n+            >\n+        >\n+    >;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Per-peer statistics object.\n+    struct PeerInfo {\n+        size_t m_total = 0; //!< Total number of entries for this peer.\n+        size_t m_requested = 0; //!< Total number of REQUESTED entries for this peer.\n+\n+        friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+        {\n+            return std::tie(a.m_total, a.m_requested) == std::tie(b.m_total, b.m_requested);\n+        }\n+    };\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo and m_per_txhash up to date.\n+    template<typename Tag>\n+    typename Index::index<Tag>::type::iterator Erase(typename Index::index<Tag>::type::iterator it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        // As it may possibly be the last-sorted Entry for a given txhash, propagate its per-txhash flags to its\n+        // predecessor (if it belongs to the same txhash).\n+        auto bytxhashit = m_index.project<ByTxHash>(it);\n+        if (bytxhashit != m_index.get<ByTxHash>().begin() &&\n+            bytxhashit->m_txhash == std::prev(bytxhashit)->m_txhash) {\n+            std::prev(bytxhashit)->m_per_txhash |= bytxhashit->m_per_txhash;\n+        }\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo and m_per_txhash up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(typename Index::index<Tag>::type::iterator it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        // It's possible that it used to be the last-sorted Entry for its txhash, so propagate its\n+        // flags to its predecessor (which would then become the new last-sorted Entry).\n+        auto bytxhashit = m_index.project<ByTxHash>(it);\n+        if (bytxhashit != m_index.get<ByTxHash>().begin() &&\n+            bytxhashit->m_txhash == std::prev(bytxhashit)->m_txhash) {\n+            std::prev(bytxhashit)->m_per_txhash |= bytxhashit->m_per_txhash;\n+        }\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        // It's possible that it is now the new last-sorted Entry for its txhash, so propagate flags\n+        // from its predecessor to it.\n+        bytxhashit = m_index.project<ByTxHash>(it);\n+        if (bytxhashit != m_index.get<ByTxHash>().begin() &&\n+            bytxhashit->m_txhash == std::prev(bytxhashit)->m_txhash) {\n+            bytxhashit->m_per_txhash |= std::prev(bytxhashit)->m_per_txhash;\n+        }\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(typename Index::index<ByTxHash>::type::iterator it)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494771653",
      "id" : 494771653,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc3MTY1Mw==",
      "original_commit_id" : "fd9f5c7653c19520d9fb18f232d3aa2cc1cb3972",
      "original_line" : 272,
      "original_position" : 272,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 495233660,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494771653",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494799280"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494799280"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "The comments in txrequest.h are great. I feel like txrequest.cpp could use more though -- there's no real overview of how the optimised data structures are laid out though, and what the deeper invariants are. Maybe it would make sense to use the `SanityCheck` functions as a way of documenting them? Many of the comments are already there and sufficient, but maybe make it the first function in the class, and make it a bit more readable? If you construct the `Counts` and `PeerInfo` maps in separate, static `GenSanityCheckFoo` functions, what's left seems pretty close to documentation:\r\n\r\n```c++\r\n// m_peerinfo can be exactly recalculated from the Index.\r\n//\r\n// This verifies the data in it, including the invariant\r\n// that no entries with m_total_announcements==0 exist.\r\nassert(m_peerinfo == GenSanityCheckPeerInfo(m_index));\r\n\r\nfor (auto& el : GenSanityCheckCounts(m_index, m_computer)) {\r\n    const uint256& hash = el.first;\r\n    Counts& c = el.second;\r\n    // Cannot have only COMPLETED peers (txid should have been deleted)\r\n    assert(c.m_candidate_delayed + c.m_candidate_ready + c.m_candidate_best + c.m_requested > 0);\r\n```",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-25T07:28:07Z",
      "diff_hunk" : "@@ -555,6 +555,124 @@ class TxRequestTracker::Impl {\n \n     //! Count how many announcements are being tracked in total across all peers and transactions.\n     size_t Size() const { return m_index.size(); }\n+\n+    uint64_t ComputePriority(const uint256& txhash, uint64_t peer, bool preferred, bool first) const\n+    {\n+        return m_computer(txhash, peer, preferred, first);\n+    }\n+\n+    void SanityCheck() const\n+    {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494799280",
      "id" : 494799280,
      "line" : 680,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc5OTI4MA==",
      "original_commit_id" : "512e0f9076b5d22f44d2a6dbf4eaacc1bdeb789b",
      "original_line" : 680,
      "original_position" : 11,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 680,
      "pull_request_review_id" : 495233660,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494799280",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494803585"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494803585"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`for (const Entry& entry : m_index) {    Counts& counts = table[entry.m_txhash];` ?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-25T07:36:52Z",
      "diff_hunk" : "@@ -555,6 +555,124 @@ class TxRequestTracker::Impl {\n \n     //! Count how many announcements are being tracked in total across all peers and transactions.\n     size_t Size() const { return m_index.size(); }\n+\n+    uint64_t ComputePriority(const uint256& txhash, uint64_t peer, bool preferred, bool first) const\n+    {\n+        return m_computer(txhash, peer, preferred, first);\n+    }\n+\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata.\n+        // This verifies the data in it, including the invariant\n+        // that no entries with m_total_announcements==0 exist.\n+        std::unordered_map<uint64_t, PeerInfo> peerinfo;\n+        for (const auto& a : m_index) {\n+            auto& entry = peerinfo[a.m_peer];\n+            ++entry.m_total;\n+            entry.m_requested += (a.GetState() == State::REQUESTED);\n+        }\n+        assert(m_peerinfo == peerinfo);\n+\n+        struct Counts {\n+            //! Number of CANDIDATE_DELAYED entries for this txhash.\n+            size_t m_candidate_delayed = 0;\n+            //! Number of CANDIDATE_READY entries for this txhash.\n+            size_t m_candidate_ready = 0;\n+            //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+            size_t m_candidate_best = 0;\n+            //! Number of REQUESTED entries for this txhash.\n+            size_t m_requested = 0;\n+            //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+            uint64_t m_priority_candidate_best = 0;\n+            //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+            uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+            //! All peers we have an entry for this txhash for.\n+            std::vector<uint64_t> m_peers;\n+            //! Whether any preferred first entry exists.\n+            bool m_any_preferred_first = false;\n+            //! Whether any non-preferred first entry exists.\n+            bool m_any_nonpreferred_first = false;\n+            //! OR of all m_per_txhash flags.\n+            uint8_t m_or_all_per_txhash = 0;\n+        };\n+\n+        std::map<uint256, Counts> table;\n+        for (const auto& a : m_index) {\n+            auto& entry = table[a.m_txhash];",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494803585",
      "id" : 494803585,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDgwMzU4NQ==",
      "original_commit_id" : "512e0f9076b5d22f44d2a6dbf4eaacc1bdeb789b",
      "original_line" : 602,
      "original_position" : 48,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 495233660,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494803585",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494820447"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494820447"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`= (1 << 1)` ? Maybe I'm dumb but it took me a bit to realise these are getting or'ed together. Seems slightly weird to have `m_per_txhash : 2` instead of `m_last_preferred : 1` and `m_last_nonpreferred : 1` (\"If you ain't first, you're last\" - Ricky Bobby), but I guess it simplifies the code that updates these values enough to make sense.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-25T08:09:20Z",
      "diff_hunk" : "@@ -0,0 +1,590 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+static const uint256 UINT256_ZERO;\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient\n+    //! implementation. Also note that the sorting order of EntryTxHash relies on the specific order of values in\n+    //! this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_DELAYED,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST.\n+        CANDIDATE_READY,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+\n+        //! An invalid State value that's larger than all valid ones.\n+        TOO_LARGE,\n+    };\n+\n+    /** A flag (in Entry::m_per_txhash) to indicate that for that txhash,\n+     *  new preferred announcements are not eligible to get the 'first' marker. */\n+    static constexpr uint8_t TXHASHINFO_NO_MORE_PREFERRED_FIRST = 1;\n+    /** A flag (in Entry::m_per_txhash) to indicate that for that txhash,\n+     *  new non-preferred announcements are not eligible to get the 'first' marker. */\n+    static constexpr uint8_t TXHASHINFO_NO_MORE_NONPREFERRED_FIRST = 2;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494820447",
      "id" : 494820447,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDgyMDQ0Nw==",
      "original_commit_id" : "fd9f5c7653c19520d9fb18f232d3aa2cc1cb3972",
      "original_line" : 54,
      "original_position" : 54,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 495233660,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494820447",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494836609"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494836609"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Might make sense to drop this method and move the logic directly into `EntryTxHashExtractor`. If done that way, then can move the `PriorityComputer` definition after `Entry` and move the`Entry::ComputePriority` logic into a `PriorityComputer::ComputePriority(const Entry&) const` method (changing the `entry.ComputePriority(computer)` calls to `computer.ComputePriority(entry)` calls). That pretty much lets the definition of `Entry` be the first thing in the file which seems a lot more logical.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-25T08:38:42Z",
      "diff_hunk" : "@@ -0,0 +1,590 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+static const uint256 UINT256_ZERO;\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient\n+    //! implementation. Also note that the sorting order of EntryTxHash relies on the specific order of values in\n+    //! this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_DELAYED,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST.\n+        CANDIDATE_READY,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+\n+        //! An invalid State value that's larger than all valid ones.\n+        TOO_LARGE,\n+    };\n+\n+    /** A flag (in Entry::m_per_txhash) to indicate that for that txhash,\n+     *  new preferred announcements are not eligible to get the 'first' marker. */\n+    static constexpr uint8_t TXHASHINFO_NO_MORE_PREFERRED_FIRST = 1;\n+    /** A flag (in Entry::m_per_txhash) to indicate that for that txhash,\n+     *  new non-preferred announcements are not eligible to get the 'first' marker. */\n+    static constexpr uint8_t TXHASHINFO_NO_MORE_NONPREFERRED_FIRST = 2;\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxHash-based index.\n+    struct ByTxHash {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+    using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic) :\n+            m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+            m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const\n+        {\n+            uint64_t low_bits = 0;\n+            if (!first) {\n+                low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+            }\n+            return low_bits | uint64_t{!preferred} << 63;\n+        }\n+    };\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txhash;\n+        //! For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 56;\n+        //! Whether the request is preferred (giving it priority higher than non-preferred ones).\n+        const bool m_preferred : 1;\n+        //! Whether this is a wtxid request.\n+        const bool m_is_wtxid : 1;\n+        //! Whether this was: the very first announcement for this txhash, within the\n+        //! preferred or non-preferred ones, and no request had been made for this\n+        //! txhash from any peer at the time the announcement came in.\n+        const bool m_first : 1;\n+\n+        //! What state this announcement is in\n+        //! This is a uint8_t instead of a State to silence a GCC warning.\n+        uint8_t m_state : 3;\n+\n+        /** Per-txhash flags. These are stored in the last Entry for a given txhash (ByTxHash order).\n+         *  The values for other Entry objects can be arbitrary subsets of the actual flags. */\n+        mutable uint8_t m_per_txhash : 2;\n+\n+        //! Convert the m_state variable to a State enum.\n+        State GetState() const { return State(m_state); }\n+        //! Convert a State to a uint8_t and store it in m_state.\n+        void SetState(State state) { m_state = uint8_t(state); }\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txhash.\n+        bool IsSelected() const\n+        {\n+            return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+        }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const\n+        {\n+            return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+        }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const\n+        {\n+            return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+        }\n+\n+        //! Construct a new entry from scratch, initially in CANDIDATE_DELAYED state.\n+        Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+            uint64_t sequence, bool first) :\n+            m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+            m_is_wtxid(gtxid.IsWtxid()), m_first(first), m_state(uint8_t(State::CANDIDATE_DELAYED)),\n+            m_per_txhash(0) {}\n+\n+        //! Compute this Entry's priority.\n+        uint64_t ComputePriority(const PriorityComputer& computer) const\n+        {\n+            return computer(m_txhash, m_peer, m_preferred, m_first);\n+        }\n+\n+        //! Extract the EntryPeer from this Entry.\n+        EntryPeer ExtractPeer() const { return EntryPeer{m_peer, GetState() == State::CANDIDATE_BEST, m_txhash}; }\n+\n+        //! Extract the EntryTxHash from this Entry.\n+        EntryTxHash ExtractTxid(const PriorityComputer& computer) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494836609",
      "id" : 494836609,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDgzNjYwOQ==",
      "original_commit_id" : "fd9f5c7653c19520d9fb18f232d3aa2cc1cb3972",
      "original_line" : 166,
      "original_position" : 166,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 495233660,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494836609",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494871473"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494871473"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`(txid,peer)`",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-25T09:40:09Z",
      "diff_hunk" : "@@ -0,0 +1,590 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+static const uint256 UINT256_ZERO;\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The various states a (txid,node) pair can be in.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494871473",
      "id" : 494871473,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg3MTQ3Mw==",
      "original_commit_id" : "fd9f5c7653c19520d9fb18f232d3aa2cc1cb3972",
      "original_line" : 28,
      "original_position" : 28,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 495233660,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494871473",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495299330"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495299330"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I added some rationale.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-25T22:56:42Z",
      "diff_hunk" : "@@ -75,7 +75,7 @@ static const unsigned int MAX_INV_SZ = 50000;\n /** Maximum number of in-flight transactions from a peer */\n static constexpr int32_t MAX_PEER_TX_IN_FLIGHT = 100;\n /** Maximum number of announced transactions from a peer */\n-static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 2 * MAX_INV_SZ;\n+static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 5000;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495299330",
      "id" : 495299330,
      "in_reply_to_id" : 494053379,
      "line" : 81,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI5OTMzMA==",
      "original_commit_id" : "06d708c7cb9b649ed6af0d95bd5e10c9e75e02d9",
      "original_line" : 81,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 15,
      "pull_request_review_id" : 496904527,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495299330",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495299926"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495299926"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've merged the \"first\" marker section into this bulletpoint, and incorporated your suggested text.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-25T22:57:46Z",
      "diff_hunk" : "@@ -0,0 +1,199 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495299926",
      "id" : 495299926,
      "in_reply_to_id" : 494725595,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI5OTkyNg==",
      "original_commit_id" : "fd9f5c7653c19520d9fb18f232d3aa2cc1cb3972",
      "original_line" : 90,
      "original_position" : 78,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 496904775,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495299926",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495300276"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495300276"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It are English perfect.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-25T22:58:20Z",
      "diff_hunk" : "@@ -0,0 +1,199 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the \"first\" marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the \"first\" mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ * \"First\" marker rules: the \"first\" marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the extent to which attackers that race the network in announcing all transactions\n+ *              can break chains of dependent transactions.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and avoiding influenceable",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495300276",
      "id" : 495300276,
      "in_reply_to_id" : 494726175,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMwMDI3Ng==",
      "original_commit_id" : "fd9f5c7653c19520d9fb18f232d3aa2cc1cb3972",
      "original_line" : 93,
      "original_position" : 93,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 496904900,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495300276",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495300611"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495300611"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I like that. Moved all the type definitions out of `::Impl`.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-25T22:58:53Z",
      "diff_hunk" : "@@ -0,0 +1,590 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+static const uint256 UINT256_ZERO;\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient\n+    //! implementation. Also note that the sorting order of EntryTxHash relies on the specific order of values in\n+    //! this enum.\n+    enum class State : uint8_t {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495300611",
      "id" : 495300611,
      "in_reply_to_id" : 494767822,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMwMDYxMQ==",
      "original_commit_id" : "fd9f5c7653c19520d9fb18f232d3aa2cc1cb3972",
      "original_line" : 32,
      "original_position" : 32,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 496905051,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495300611",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495301113"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495301113"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm pretty sure it was needed at some point.\r\n\r\nI've added an Iter<Tag> type alias as suggested (outside of `Impl`, yay).",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-25T22:59:40Z",
      "diff_hunk" : "@@ -0,0 +1,590 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+static const uint256 UINT256_ZERO;\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient\n+    //! implementation. Also note that the sorting order of EntryTxHash relies on the specific order of values in\n+    //! this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_DELAYED,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST.\n+        CANDIDATE_READY,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+\n+        //! An invalid State value that's larger than all valid ones.\n+        TOO_LARGE,\n+    };\n+\n+    /** A flag (in Entry::m_per_txhash) to indicate that for that txhash,\n+     *  new preferred announcements are not eligible to get the 'first' marker. */\n+    static constexpr uint8_t TXHASHINFO_NO_MORE_PREFERRED_FIRST = 1;\n+    /** A flag (in Entry::m_per_txhash) to indicate that for that txhash,\n+     *  new non-preferred announcements are not eligible to get the 'first' marker. */\n+    static constexpr uint8_t TXHASHINFO_NO_MORE_NONPREFERRED_FIRST = 2;\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxHash-based index.\n+    struct ByTxHash {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+    using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic) :\n+            m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+            m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const\n+        {\n+            uint64_t low_bits = 0;\n+            if (!first) {\n+                low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+            }\n+            return low_bits | uint64_t{!preferred} << 63;\n+        }\n+    };\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txhash;\n+        //! For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 56;\n+        //! Whether the request is preferred (giving it priority higher than non-preferred ones).\n+        const bool m_preferred : 1;\n+        //! Whether this is a wtxid request.\n+        const bool m_is_wtxid : 1;\n+        //! Whether this was: the very first announcement for this txhash, within the\n+        //! preferred or non-preferred ones, and no request had been made for this\n+        //! txhash from any peer at the time the announcement came in.\n+        const bool m_first : 1;\n+\n+        //! What state this announcement is in\n+        //! This is a uint8_t instead of a State to silence a GCC warning.\n+        uint8_t m_state : 3;\n+\n+        /** Per-txhash flags. These are stored in the last Entry for a given txhash (ByTxHash order).\n+         *  The values for other Entry objects can be arbitrary subsets of the actual flags. */\n+        mutable uint8_t m_per_txhash : 2;\n+\n+        //! Convert the m_state variable to a State enum.\n+        State GetState() const { return State(m_state); }\n+        //! Convert a State to a uint8_t and store it in m_state.\n+        void SetState(State state) { m_state = uint8_t(state); }\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txhash.\n+        bool IsSelected() const\n+        {\n+            return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+        }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const\n+        {\n+            return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+        }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const\n+        {\n+            return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+        }\n+\n+        //! Construct a new entry from scratch, initially in CANDIDATE_DELAYED state.\n+        Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+            uint64_t sequence, bool first) :\n+            m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+            m_is_wtxid(gtxid.IsWtxid()), m_first(first), m_state(uint8_t(State::CANDIDATE_DELAYED)),\n+            m_per_txhash(0) {}\n+\n+        //! Compute this Entry's priority.\n+        uint64_t ComputePriority(const PriorityComputer& computer) const\n+        {\n+            return computer(m_txhash, m_peer, m_preferred, m_first);\n+        }\n+\n+        //! Extract the EntryPeer from this Entry.\n+        EntryPeer ExtractPeer() const { return EntryPeer{m_peer, GetState() == State::CANDIDATE_BEST, m_txhash}; }\n+\n+        //! Extract the EntryTxHash from this Entry.\n+        EntryTxHash ExtractTxid(const PriorityComputer& computer) const\n+        {\n+            return EntryTxHash{\n+                m_txhash,\n+                GetState(),\n+                GetState() == State::CANDIDATE_READY ? ComputePriority(computer) : 0\n+            };\n+        }\n+\n+        //! Extract the EntryTime from this Entry.\n+        EntryTime ExtractTime() const { return EntryTime{IsWaiting() ? 0 : IsSelectable() ? 2 : 1, m_time}; }\n+    };\n+\n+    /** An extractor for EntryTxHash (with encapsulated PriorityComputer reference).\n+     *\n+     * See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+     * for more information about the key extraction concept.\n+     */\n+    class EntryTxHashExtractor {\n+        const PriorityComputer& m_computer;\n+    public:\n+        EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+        using result_type = EntryTxHash; // Needed to comply with key extractor interface\n+        result_type operator()(const Entry& entry) const { return entry.ExtractTxid(m_computer); }\n+    };\n+\n+    //! Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes).\n+    using Index = boost::multi_index_container<\n+        Entry,\n+        boost::multi_index::indexed_by<\n+            boost::multi_index::ordered_unique<\n+                boost::multi_index::tag<ByPeer>,\n+                boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTxHash>,\n+                EntryTxHashExtractor\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTime>,\n+                boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>\n+            >\n+        >\n+    >;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Per-peer statistics object.\n+    struct PeerInfo {\n+        size_t m_total = 0; //!< Total number of entries for this peer.\n+        size_t m_requested = 0; //!< Total number of REQUESTED entries for this peer.\n+\n+        friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+        {\n+            return std::tie(a.m_total, a.m_requested) == std::tie(b.m_total, b.m_requested);\n+        }\n+    };\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo and m_per_txhash up to date.\n+    template<typename Tag>\n+    typename Index::index<Tag>::type::iterator Erase(typename Index::index<Tag>::type::iterator it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        // As it may possibly be the last-sorted Entry for a given txhash, propagate its per-txhash flags to its\n+        // predecessor (if it belongs to the same txhash).\n+        auto bytxhashit = m_index.project<ByTxHash>(it);\n+        if (bytxhashit != m_index.get<ByTxHash>().begin() &&\n+            bytxhashit->m_txhash == std::prev(bytxhashit)->m_txhash) {\n+            std::prev(bytxhashit)->m_per_txhash |= bytxhashit->m_per_txhash;\n+        }\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo and m_per_txhash up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(typename Index::index<Tag>::type::iterator it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        // It's possible that it used to be the last-sorted Entry for its txhash, so propagate its\n+        // flags to its predecessor (which would then become the new last-sorted Entry).\n+        auto bytxhashit = m_index.project<ByTxHash>(it);\n+        if (bytxhashit != m_index.get<ByTxHash>().begin() &&\n+            bytxhashit->m_txhash == std::prev(bytxhashit)->m_txhash) {\n+            std::prev(bytxhashit)->m_per_txhash |= bytxhashit->m_per_txhash;\n+        }\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        // It's possible that it is now the new last-sorted Entry for its txhash, so propagate flags\n+        // from its predecessor to it.\n+        bytxhashit = m_index.project<ByTxHash>(it);\n+        if (bytxhashit != m_index.get<ByTxHash>().begin() &&\n+            bytxhashit->m_txhash == std::prev(bytxhashit)->m_txhash) {\n+            bytxhashit->m_per_txhash |= std::prev(bytxhashit)->m_per_txhash;\n+        }\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(typename Index::index<ByTxHash>::type::iterator it)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495301113",
      "id" : 495301113,
      "in_reply_to_id" : 494771653,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMwMTExMw==",
      "original_commit_id" : "fd9f5c7653c19520d9fb18f232d3aa2cc1cb3972",
      "original_line" : 272,
      "original_position" : 272,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 496905253,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495301113",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495301338"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495301338"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I haven't addressed this yet.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-25T22:59:59Z",
      "diff_hunk" : "@@ -555,6 +555,124 @@ class TxRequestTracker::Impl {\n \n     //! Count how many announcements are being tracked in total across all peers and transactions.\n     size_t Size() const { return m_index.size(); }\n+\n+    uint64_t ComputePriority(const uint256& txhash, uint64_t peer, bool preferred, bool first) const\n+    {\n+        return m_computer(txhash, peer, preferred, first);\n+    }\n+\n+    void SanityCheck() const\n+    {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495301338",
      "id" : 495301338,
      "in_reply_to_id" : 494799280,
      "line" : 680,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMwMTMzOA==",
      "original_commit_id" : "512e0f9076b5d22f44d2a6dbf4eaacc1bdeb789b",
      "original_line" : 680,
      "original_position" : 11,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 680,
      "pull_request_review_id" : 496905336,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495301338",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495301559"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495301559"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've changed it to `c` for Counts objects and `e` for Entry objects.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-25T23:00:22Z",
      "diff_hunk" : "@@ -555,6 +555,124 @@ class TxRequestTracker::Impl {\n \n     //! Count how many announcements are being tracked in total across all peers and transactions.\n     size_t Size() const { return m_index.size(); }\n+\n+    uint64_t ComputePriority(const uint256& txhash, uint64_t peer, bool preferred, bool first) const\n+    {\n+        return m_computer(txhash, peer, preferred, first);\n+    }\n+\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata.\n+        // This verifies the data in it, including the invariant\n+        // that no entries with m_total_announcements==0 exist.\n+        std::unordered_map<uint64_t, PeerInfo> peerinfo;\n+        for (const auto& a : m_index) {\n+            auto& entry = peerinfo[a.m_peer];\n+            ++entry.m_total;\n+            entry.m_requested += (a.GetState() == State::REQUESTED);\n+        }\n+        assert(m_peerinfo == peerinfo);\n+\n+        struct Counts {\n+            //! Number of CANDIDATE_DELAYED entries for this txhash.\n+            size_t m_candidate_delayed = 0;\n+            //! Number of CANDIDATE_READY entries for this txhash.\n+            size_t m_candidate_ready = 0;\n+            //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+            size_t m_candidate_best = 0;\n+            //! Number of REQUESTED entries for this txhash.\n+            size_t m_requested = 0;\n+            //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+            uint64_t m_priority_candidate_best = 0;\n+            //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+            uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+            //! All peers we have an entry for this txhash for.\n+            std::vector<uint64_t> m_peers;\n+            //! Whether any preferred first entry exists.\n+            bool m_any_preferred_first = false;\n+            //! Whether any non-preferred first entry exists.\n+            bool m_any_nonpreferred_first = false;\n+            //! OR of all m_per_txhash flags.\n+            uint8_t m_or_all_per_txhash = 0;\n+        };\n+\n+        std::map<uint256, Counts> table;\n+        for (const auto& a : m_index) {\n+            auto& entry = table[a.m_txhash];",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495301559",
      "id" : 495301559,
      "in_reply_to_id" : 494803585,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMwMTU1OQ==",
      "original_commit_id" : "512e0f9076b5d22f44d2a6dbf4eaacc1bdeb789b",
      "original_line" : 602,
      "original_position" : 48,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 496905427,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495301559",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495301867"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495301867"
         }
      },
      "author_association" : "MEMBER",
      "body" : "At some point I had more flags than 2. I've changed it to two bools now (this makes the SanityCheck code for it a lot more readable in particular).",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-25T23:00:56Z",
      "diff_hunk" : "@@ -0,0 +1,590 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+static const uint256 UINT256_ZERO;\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient\n+    //! implementation. Also note that the sorting order of EntryTxHash relies on the specific order of values in\n+    //! this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_DELAYED,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST.\n+        CANDIDATE_READY,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+\n+        //! An invalid State value that's larger than all valid ones.\n+        TOO_LARGE,\n+    };\n+\n+    /** A flag (in Entry::m_per_txhash) to indicate that for that txhash,\n+     *  new preferred announcements are not eligible to get the 'first' marker. */\n+    static constexpr uint8_t TXHASHINFO_NO_MORE_PREFERRED_FIRST = 1;\n+    /** A flag (in Entry::m_per_txhash) to indicate that for that txhash,\n+     *  new non-preferred announcements are not eligible to get the 'first' marker. */\n+    static constexpr uint8_t TXHASHINFO_NO_MORE_NONPREFERRED_FIRST = 2;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495301867",
      "id" : 495301867,
      "in_reply_to_id" : 494820447,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMwMTg2Nw==",
      "original_commit_id" : "fd9f5c7653c19520d9fb18f232d3aa2cc1cb3972",
      "original_line" : 54,
      "original_position" : 54,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 496905559,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495301867",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495302373"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495302373"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yep, done. To match the \"functor\" concept I'm overloading `operator()` instead of having a `ComputePriority` function.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-25T23:01:51Z",
      "diff_hunk" : "@@ -0,0 +1,590 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+static const uint256 UINT256_ZERO;\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient\n+    //! implementation. Also note that the sorting order of EntryTxHash relies on the specific order of values in\n+    //! this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_DELAYED,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST.\n+        CANDIDATE_READY,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+\n+        //! An invalid State value that's larger than all valid ones.\n+        TOO_LARGE,\n+    };\n+\n+    /** A flag (in Entry::m_per_txhash) to indicate that for that txhash,\n+     *  new preferred announcements are not eligible to get the 'first' marker. */\n+    static constexpr uint8_t TXHASHINFO_NO_MORE_PREFERRED_FIRST = 1;\n+    /** A flag (in Entry::m_per_txhash) to indicate that for that txhash,\n+     *  new non-preferred announcements are not eligible to get the 'first' marker. */\n+    static constexpr uint8_t TXHASHINFO_NO_MORE_NONPREFERRED_FIRST = 2;\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxHash-based index.\n+    struct ByTxHash {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+    using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic) :\n+            m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+            m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const\n+        {\n+            uint64_t low_bits = 0;\n+            if (!first) {\n+                low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+            }\n+            return low_bits | uint64_t{!preferred} << 63;\n+        }\n+    };\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txhash;\n+        //! For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 56;\n+        //! Whether the request is preferred (giving it priority higher than non-preferred ones).\n+        const bool m_preferred : 1;\n+        //! Whether this is a wtxid request.\n+        const bool m_is_wtxid : 1;\n+        //! Whether this was: the very first announcement for this txhash, within the\n+        //! preferred or non-preferred ones, and no request had been made for this\n+        //! txhash from any peer at the time the announcement came in.\n+        const bool m_first : 1;\n+\n+        //! What state this announcement is in\n+        //! This is a uint8_t instead of a State to silence a GCC warning.\n+        uint8_t m_state : 3;\n+\n+        /** Per-txhash flags. These are stored in the last Entry for a given txhash (ByTxHash order).\n+         *  The values for other Entry objects can be arbitrary subsets of the actual flags. */\n+        mutable uint8_t m_per_txhash : 2;\n+\n+        //! Convert the m_state variable to a State enum.\n+        State GetState() const { return State(m_state); }\n+        //! Convert a State to a uint8_t and store it in m_state.\n+        void SetState(State state) { m_state = uint8_t(state); }\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txhash.\n+        bool IsSelected() const\n+        {\n+            return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+        }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const\n+        {\n+            return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+        }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const\n+        {\n+            return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+        }\n+\n+        //! Construct a new entry from scratch, initially in CANDIDATE_DELAYED state.\n+        Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+            uint64_t sequence, bool first) :\n+            m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+            m_is_wtxid(gtxid.IsWtxid()), m_first(first), m_state(uint8_t(State::CANDIDATE_DELAYED)),\n+            m_per_txhash(0) {}\n+\n+        //! Compute this Entry's priority.\n+        uint64_t ComputePriority(const PriorityComputer& computer) const\n+        {\n+            return computer(m_txhash, m_peer, m_preferred, m_first);\n+        }\n+\n+        //! Extract the EntryPeer from this Entry.\n+        EntryPeer ExtractPeer() const { return EntryPeer{m_peer, GetState() == State::CANDIDATE_BEST, m_txhash}; }\n+\n+        //! Extract the EntryTxHash from this Entry.\n+        EntryTxHash ExtractTxid(const PriorityComputer& computer) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495302373",
      "id" : 495302373,
      "in_reply_to_id" : 494836609,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMwMjM3Mw==",
      "original_commit_id" : "fd9f5c7653c19520d9fb18f232d3aa2cc1cb3972",
      "original_line" : 166,
      "original_position" : 166,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 496905797,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495302373",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495302543"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495302543"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`(txhash,peer)` actually, fixed in many places.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-25T23:02:08Z",
      "diff_hunk" : "@@ -0,0 +1,590 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+static const uint256 UINT256_ZERO;\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The various states a (txid,node) pair can be in.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495302543",
      "id" : 495302543,
      "in_reply_to_id" : 494871473,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMwMjU0Mw==",
      "original_commit_id" : "fd9f5c7653c19520d9fb18f232d3aa2cc1cb3972",
      "original_line" : 28,
      "original_position" : 28,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 496905887,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495302543",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495415363"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495415363"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "They is now anyhoo",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-26T04:55:48Z",
      "diff_hunk" : "@@ -0,0 +1,199 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the \"first\" marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the \"first\" mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ * \"First\" marker rules: the \"first\" marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the extent to which attackers that race the network in announcing all transactions\n+ *              can break chains of dependent transactions.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and avoiding influenceable",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495415363",
      "id" : 495415363,
      "in_reply_to_id" : 494726175,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQxNTM2Mw==",
      "original_commit_id" : "fd9f5c7653c19520d9fb18f232d3aa2cc1cb3972",
      "original_line" : 93,
      "original_position" : 93,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 496941003,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495415363",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495415539"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495415539"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Similar change would be good for the `peerinfo` reconstruction; it has `auto& entry =` for a `PeerInfo`.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-26T04:58:34Z",
      "diff_hunk" : "@@ -555,6 +555,124 @@ class TxRequestTracker::Impl {\n \n     //! Count how many announcements are being tracked in total across all peers and transactions.\n     size_t Size() const { return m_index.size(); }\n+\n+    uint64_t ComputePriority(const uint256& txhash, uint64_t peer, bool preferred, bool first) const\n+    {\n+        return m_computer(txhash, peer, preferred, first);\n+    }\n+\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata.\n+        // This verifies the data in it, including the invariant\n+        // that no entries with m_total_announcements==0 exist.\n+        std::unordered_map<uint64_t, PeerInfo> peerinfo;\n+        for (const auto& a : m_index) {\n+            auto& entry = peerinfo[a.m_peer];\n+            ++entry.m_total;\n+            entry.m_requested += (a.GetState() == State::REQUESTED);\n+        }\n+        assert(m_peerinfo == peerinfo);\n+\n+        struct Counts {\n+            //! Number of CANDIDATE_DELAYED entries for this txhash.\n+            size_t m_candidate_delayed = 0;\n+            //! Number of CANDIDATE_READY entries for this txhash.\n+            size_t m_candidate_ready = 0;\n+            //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+            size_t m_candidate_best = 0;\n+            //! Number of REQUESTED entries for this txhash.\n+            size_t m_requested = 0;\n+            //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+            uint64_t m_priority_candidate_best = 0;\n+            //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+            uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+            //! All peers we have an entry for this txhash for.\n+            std::vector<uint64_t> m_peers;\n+            //! Whether any preferred first entry exists.\n+            bool m_any_preferred_first = false;\n+            //! Whether any non-preferred first entry exists.\n+            bool m_any_nonpreferred_first = false;\n+            //! OR of all m_per_txhash flags.\n+            uint8_t m_or_all_per_txhash = 0;\n+        };\n+\n+        std::map<uint256, Counts> table;\n+        for (const auto& a : m_index) {\n+            auto& entry = table[a.m_txhash];",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495415539",
      "id" : 495415539,
      "in_reply_to_id" : 494803585,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQxNTUzOQ==",
      "original_commit_id" : "512e0f9076b5d22f44d2a6dbf4eaacc1bdeb789b",
      "original_line" : 602,
      "original_position" : 48,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 496941126,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495415539",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495415682"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495415682"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Rationale looks fine to me :+1:",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-26T05:00:26Z",
      "diff_hunk" : "@@ -75,7 +75,7 @@ static const unsigned int MAX_INV_SZ = 50000;\n /** Maximum number of in-flight transactions from a peer */\n static constexpr int32_t MAX_PEER_TX_IN_FLIGHT = 100;\n /** Maximum number of announced transactions from a peer */\n-static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 2 * MAX_INV_SZ;\n+static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 5000;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495415682",
      "id" : 495415682,
      "in_reply_to_id" : 494053379,
      "line" : 81,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQxNTY4Mg==",
      "original_commit_id" : "06d708c7cb9b649ed6af0d95bd5e10c9e75e02d9",
      "original_line" : 81,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 15,
      "pull_request_review_id" : 496941223,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495415682",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495416992"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495416992"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "\"The \"first\" marker is given to announcements for which at the time they are received:\" -> \"given to announcements at the time they are received, provided:\" might be clearer?\r\n\r\n\"(within the class of preferred or non-preferred announcements)\" -- everywhere else refers to preferred peers, not announcements. Might make sense to explicitly clarify that a peer may switch its preferred status at any time, but that preferred status is sticky to announcements so if a peer is now non-preferred earlier announcements when it was preferred will still be prioritised, and vice-versa? I think that scenario is exercised by the fuzzer but not by net_processing?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-26T05:17:58Z",
      "diff_hunk" : "@@ -0,0 +1,199 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495416992",
      "id" : 495416992,
      "in_reply_to_id" : 494725595,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQxNjk5Mg==",
      "original_commit_id" : "fd9f5c7653c19520d9fb18f232d3aa2cc1cb3972",
      "original_line" : 90,
      "original_position" : 78,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 496942593,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495416992",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495541641"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495541641"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done, and addressed the \"preferredness\" being changeable in the first section.\r\n\r\nYou're right that fuzzer tests this, but isn't reachable through the current net_processing layer.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-27T07:41:43Z",
      "diff_hunk" : "@@ -0,0 +1,199 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495541641",
      "id" : 495541641,
      "in_reply_to_id" : 494725595,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU0MTY0MQ==",
      "original_commit_id" : "fd9f5c7653c19520d9fb18f232d3aa2cc1cb3972",
      "original_line" : 90,
      "original_position" : 78,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 497059678,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495541641",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I think using `.CountInFlight()` isn't actually the right way to determine being overloaded. If a peer dumps 5000 INVs on us at once, they'll all be inserted at a time when inflight==0, and thus all be eligible to get the \"first\" marker, and won't get any delay penalty.\r\n\r\nOn the other hand, I think using `CountTracked` is suboptimal as well, as it includes entries in COMPLETED state as well, which have no bearing on how loaded the peer currently is.\r\n\r\nI think we should use inflight + (entries in CANDIDATE_* state). There is something to be said about excluding CANDIDATE_READY, as those are requests that will most likely go to other peers, but that would complicate specification significantly (as CANDIDATE_READY isn't observable right now). Also, CANDIDATE_DELAY is sometimes also subject to this, but it's too early to tell.",
      "created_at" : "2020-09-27T16:56:54Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#issuecomment-699660003",
      "id" : 699660003,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19988",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5OTY2MDAwMw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-27T16:56:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/699660003",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495600473"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495600473"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-27T18:24:22Z",
      "diff_hunk" : "@@ -121,38 +116,10 @@ def test_inv_block(self):\n         # * the first time it is re-requested from the outbound peer, plus\n         # * 2 seconds to avoid races\n         assert self.nodes[1].getpeerinfo()[0]['inbound'] == False\n-        timeout = 2 + (MAX_GETDATA_RANDOM_DELAY + INBOUND_PEER_TX_DELAY) + (\n-            GETDATA_TX_INTERVAL + MAX_GETDATA_RANDOM_DELAY)\n+        timeout = 2 + INBOUND_PEER_TX_DELAY + GETDATA_TX_INTERVAL\n         self.log.info(\"Tx should be received at node 1 after {} seconds\".format(timeout))\n         self.sync_mempools(timeout=timeout)\n \n-    def test_in_flight_max(self):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495600473",
      "id" : 495600473,
      "in_reply_to_id" : 493198222,
      "line" : 129,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYwMDQ3Mw==",
      "original_commit_id" : "c7601cdb31f9c86a4308cf36bbbc9c74c1078f53",
      "original_line" : 129,
      "original_position" : 37,
      "original_start_line" : null,
      "path" : "test/functional/p2p_tx_download.py",
      "position" : 28,
      "pull_request_review_id" : 497100405,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "LEFT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495600473",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I've made that change, and re-instated a \"max in flight\" P2P test.",
      "created_at" : "2020-09-27T18:25:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#issuecomment-699670117",
      "id" : 699670117,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19988",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5OTY3MDExNw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-27T18:25:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/699670117",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495641913"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495641913"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> I think using `.CountInFlight()` isn't actually the right way to determine being overloaded. If a peer dumps 5000 INVs on us at once, they'll all be inserted at a time when `inflight==0`, and thus all be eligible to get the \"first\" marker, and won't get any delay penalty.\r\n\r\nI'm not sure the original behaviour didn't make more sense? If you have a peer that drops 5000 INVs at once, then gets requests for all of them 2s later, and replies to all those requests before sending any further INVs, is there any reason to consider that peer to be overloaded?\r\n\r\nI think we're not worrying about attackers getting the \"first\" flag -- that's addressed by limiting the impact to one attacker per txid -- but even if we were, I don't think this makes sense as an attack? You're blocking 5000 txs for a single 60 second period, but your other peers are only going to announce ~1000 txs each over that period, and you have to successfully race them to be the first to announce the tx for it to matter. But if you're able to ensure you announce first, then all you need to do is announce first by 2-6 seconds, and you delay a request from honest peers by 54-58 seconds rather than 60 seconds?\r\n\r\nOTOH, I don't think delaying a huge batch of 4900 txs by (an additional) 2s is much of a problem either.\r\n\r\nEither way, it may make sense for `noban` or `relay` permission to override considering a peer to be `overloaded`?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-28T00:51:36Z",
      "diff_hunk" : "@@ -793,73 +724,35 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest\n+    NodeId nodeid = node.GetId();\n+    if (m_txrequest.CountTracked(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"overloaded\": if at least MAX_PEER_TX_LOAD requests are in flight and requestable combined.\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or PF_NOBAN permission)\n+    // - \"reqtime\": immediately if none of the penalties below apply, otherwise current time plus:\n+    //   - INBOUND_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for announcements from txid peers while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from overloaded peers\n+    auto delay = std::chrono::microseconds{0};\n+    bool preferred = state->fPreferredDownload;\n+    bool overloaded = m_txrequest.CountLoad(nodeid) >= MAX_PEER_TX_LOAD;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495641913",
      "id" : 495641913,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MTkxMw==",
      "original_commit_id" : "242146dce083d047b88b66b20d72fa92587bddbc",
      "original_line" : 751,
      "original_position" : 192,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 497133137,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495641913",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495646456"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495646456"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I wonder if it wouldn't make more sense to move the `overloaded` judgement entirely into `ReceivedInv` and instead pass the peer's `MAX_PEER_TX_LOAD` in and have `OVERLOADED_PEER_TX_DELAY` passed in when constructing`m_txrequest`. So `ReceivedInv` would then do `if (CountLoad(peer) > max_load) { first = false; reqtime += m_overloaded_delay; }`.\r\n\r\nThe reason I say that is I think the \"first\" marker logic doesn't really make sense if you don't bump the reqtime for overloaded peers -- you'd end up with the overloaded peer being selected while the first non-overloaded peer was still waiting for its reqtime to arrive.\r\n\r\nThe `!preferred` delay could also be handled the same way. I guess you'd need to pass in `current_time` and `peer_delay = TXID_RELAY_DELAY` (when appropriate) (so to speak) for that work. Again, there needs to be a positive delay for `!preferred` peers or the logic won't work right, and while it can vary amongst announcements in limited ways without breaking things, I think it would be hard to do that correctly, so being set at the txrequest level wouldn't be a big problem.\r\n\r\nThat might also have the advantage of being able to pass in `delay == 0` rather than `reqtime == microseconds::min()` which seems a little bit more obvious.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-28T01:20:33Z",
      "diff_hunk" : "@@ -793,73 +724,35 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest\n+    NodeId nodeid = node.GetId();\n+    if (m_txrequest.CountTracked(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"overloaded\": if at least MAX_PEER_TX_LOAD requests are in flight and requestable combined.\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or PF_NOBAN permission)\n+    // - \"reqtime\": immediately if none of the penalties below apply, otherwise current time plus:\n+    //   - INBOUND_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for announcements from txid peers while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from overloaded peers\n+    auto delay = std::chrono::microseconds{0};\n+    bool preferred = state->fPreferredDownload;\n+    bool overloaded = m_txrequest.CountLoad(nodeid) >= MAX_PEER_TX_LOAD;\n+    if (!preferred) delay += INBOUND_PEER_TX_DELAY;\n+    if (!state->m_wtxid_relay && g_wtxid_relay_peers > 0) delay += TXID_RELAY_DELAY;\n+    if (overloaded) delay += OVERLOADED_PEER_TX_DELAY;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495646456",
      "id" : 495646456,
      "line" : 777,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0NjQ1Ng==",
      "original_commit_id" : "242146dce083d047b88b66b20d72fa92587bddbc",
      "original_line" : 777,
      "original_position" : 195,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 220,
      "pull_request_review_id" : 497133137,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495646456",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495662860"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495662860"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The reason I don't like using just in-flight is that it has this strong dependency on local ordering of events.\r\n\r\nIf you receive 100 INVs, then do a round of `SendMessages`, and request them, followed by 4900 of them, they get punished (no `first`, penalty `OVERLOADED_PEER_TX_DELAY`).\r\n\r\nIf you receive 100 INVs, then 4900 INVs, and then do a round of `SendMessages`, they don't get punished.\r\n\r\n> I think we're not worrying about attackers getting the \"first\" flag\r\n\r\nOnly minimally, but I think we are. There are plenty of spy peers that do weird things, and if they announce abundantly, they can interfere somewhat with ordering of dependent transactions (after the `first` request, they go out randomly, so parents and children may go to different peers, and the parent may arrive first).\r\n\r\n> OTOH, I don't think delaying a huge batch of 4900 txs by (an additional) 2s is much of a problem either.\r\n\r\nJudging by actual numbers, having 100 candidates simultaneously for any non-obviously-broken-peer basically doesn't happen.\r\n\r\n> Either way, it may make sense for noban or relay permission to override considering a peer to be overloaded?\r\n\r\nYes, that may be a good idea.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-28T02:44:36Z",
      "diff_hunk" : "@@ -793,73 +724,35 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest\n+    NodeId nodeid = node.GetId();\n+    if (m_txrequest.CountTracked(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"overloaded\": if at least MAX_PEER_TX_LOAD requests are in flight and requestable combined.\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or PF_NOBAN permission)\n+    // - \"reqtime\": immediately if none of the penalties below apply, otherwise current time plus:\n+    //   - INBOUND_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for announcements from txid peers while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from overloaded peers\n+    auto delay = std::chrono::microseconds{0};\n+    bool preferred = state->fPreferredDownload;\n+    bool overloaded = m_txrequest.CountLoad(nodeid) >= MAX_PEER_TX_LOAD;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495662860",
      "id" : 495662860,
      "in_reply_to_id" : 495641913,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY2Mjg2MA==",
      "original_commit_id" : "242146dce083d047b88b66b20d72fa92587bddbc",
      "original_line" : 751,
      "original_position" : 192,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 497156056,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495662860",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495663507"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495663507"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I did this at first, but I like the current approach a lot more. It leaves the actual policy decisions inside net_processing, without needing configuration flags etc. in the txrequest interface.\r\n\r\nNot a very strong opinion, but I like the fact that txrequest is mostly the data structure, and its responsibility is consistency and efficiency - not policy parameters. There are currently a lot of future improvements that can be made without changing txrequest - and that due to the nature of its current interface - are already covered by fuzz testing.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-28T02:47:43Z",
      "diff_hunk" : "@@ -793,73 +724,35 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest\n+    NodeId nodeid = node.GetId();\n+    if (m_txrequest.CountTracked(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"overloaded\": if at least MAX_PEER_TX_LOAD requests are in flight and requestable combined.\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or PF_NOBAN permission)\n+    // - \"reqtime\": immediately if none of the penalties below apply, otherwise current time plus:\n+    //   - INBOUND_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for announcements from txid peers while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from overloaded peers\n+    auto delay = std::chrono::microseconds{0};\n+    bool preferred = state->fPreferredDownload;\n+    bool overloaded = m_txrequest.CountLoad(nodeid) >= MAX_PEER_TX_LOAD;\n+    if (!preferred) delay += INBOUND_PEER_TX_DELAY;\n+    if (!state->m_wtxid_relay && g_wtxid_relay_peers > 0) delay += TXID_RELAY_DELAY;\n+    if (overloaded) delay += OVERLOADED_PEER_TX_DELAY;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495663507",
      "id" : 495663507,
      "in_reply_to_id" : 495646456,
      "line" : 777,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY2MzUwNw==",
      "original_commit_id" : "242146dce083d047b88b66b20d72fa92587bddbc",
      "original_line" : 777,
      "original_position" : 195,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 220,
      "pull_request_review_id" : 497156805,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495663507",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495692754"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495692754"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> Only minimally, but I think we are. There are plenty of spy peers that do weird things, and if they announce abundantly, they can interfere somewhat with ordering of dependent transactions (after the first request, they go out randomly, so parents and children may go to different peers, and the parent may arrive first).\r\n\r\n> Judging by actual numbers, having 100 candidates simultaneously for any non-obviously-broken-peer basically doesn't happen.\r\n\r\nHmm. With the new change you could kind-of make that happen:\r\n\r\n * find a victim who is an inbound connection\r\n * make up 100 transactions\r\n * INV them to your victim, but don't respond to their GETDATA\r\n * send the 100 transactions to everyone else\r\n * everyone else will announce to victim\r\n * all victims peers have 100+ CANDIDATE_* announcements,  making all victim's peers appear overloaded for the next real transaction that comes along\r\n\r\n(That said, I'm still not really seeing how being falsely marked as \"overloaded\" is a problem)\r\n\r\n> If you receive 100 INVs, then do a round of `SendMessages`, and request them, followed by 4900 of them, they get punished ... If you receive 100 INVs, then 4900 INVs, and then do a round of `SendMessages`, they don't get punished.\r\n\r\nYeah. I'm looking at that as: \"If you request 100 INVs, and then receive 4900 more INVs before receiving a response to your request, then the peer is overloaded\" and \"If all your requests have been responded too and you receive 4900 more INVs, then you don't have a reason to think the peer is overloaded\". ie, \"overloaded\" == \"am I getting responses, or am I just getting more and more announcements?\" I think that means the peer is able to prioritise \"respond to GETDATA\" above \"forward on more INVs\" and thus ensure they're never overloaded, even if they're announcing txs in massive bursts, no matter what anyone else is doing (except when they do two large INVs in less than the RTT maybe).",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-28T05:14:09Z",
      "diff_hunk" : "@@ -793,73 +724,35 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest\n+    NodeId nodeid = node.GetId();\n+    if (m_txrequest.CountTracked(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"overloaded\": if at least MAX_PEER_TX_LOAD requests are in flight and requestable combined.\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or PF_NOBAN permission)\n+    // - \"reqtime\": immediately if none of the penalties below apply, otherwise current time plus:\n+    //   - INBOUND_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for announcements from txid peers while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from overloaded peers\n+    auto delay = std::chrono::microseconds{0};\n+    bool preferred = state->fPreferredDownload;\n+    bool overloaded = m_txrequest.CountLoad(nodeid) >= MAX_PEER_TX_LOAD;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495692754",
      "id" : 495692754,
      "in_reply_to_id" : 495641913,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5Mjc1NA==",
      "original_commit_id" : "242146dce083d047b88b66b20d72fa92587bddbc",
      "original_line" : 751,
      "original_position" : 192,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 497190696,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495692754",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495781805"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495781805"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> There are currently a lot of future improvements that can be made without changing txrequest - and that due to the nature of its current interface are already covered by fuzz testing.\r\n\r\nKind-of? I would have said the fuzz testing only really tests the optimisations work; it doesn't really check that the basic implementation makes \"sense\"?\r\n\r\neg, we could check the \"don't request dependent transactions out of order\" goal by adding a constraint that all peers announce tx `i` prior to tx `j`, and then checking that tx `i` is requested before tx `j`, but I think that would currently fail in the fuzzer due to random delays (and also fail in net_processing in rare cases, eg where a tx is only announced by one node, `j` is announced less than 2 seconds after `i` and the node becomes non-overloaded in that same period, or where all the non-wtxid-relay peers disappear in between).\r\n\r\nI'm trying out some logging to see if the \"first\" marker actually does much good in practice. We're calling `GetRequestable`/`RequestedTx` ten times a second for every peer (provided various queues don't fill up anyway), so I think you'd have to be pretty unlucky for it to even matter.\r\n\r\n```diff\r\n--- a/src/txrequest.cpp\r\n+++ b/src/txrequest.cpp\r\n@@ -528,6 +528,29 @@ public:\r\n         // in between, which preserve the state of other GenTxids).\r\n         assert(it != m_index.get<ByPeer>().end());\r\n         assert(it->GetState() == State::CANDIDATE_BEST);\r\n+       {\r\n+            auto bytxhashit = m_index.project<ByTxHash>(it);\r\n+            auto bytxhashit_pre = bytxhashit;\r\n+           int delayed = 0;\r\n+           int candidates = 0;\r\n+           while (bytxhashit_pre != m_index.get<ByTxHash>().begin()) {\r\n+               --bytxhashit_pre;\r\n+               if (bytxhashit_pre->GetState() != State::CANDIDATE_DELAYED || bytxhashit->m_txhash != it->m_txhash) break;\r\n+               ++delayed;\r\n+           }\r\n+           ++bytxhashit;\r\n+           while (bytxhashit != m_index.get<ByTxHash>().end() && bytxhashit->GetState() != State::COMPLETED && bytxhashit->m_txhash == it->m_txhash) {\r\n+               ++candidates;\r\n+               ++bytxhashit;\r\n+           }\r\n+           int completed = 0;\r\n+           while (bytxhashit != m_index.get<ByTxHash>().end() && bytxhashit->GetState() == State::COMPLETED && bytxhashit->m_txhash == it->m_txhash) {\r\n+               ++completed;\r\n+               ++bytxhashit;\r\n+           }\r\n+           assert(bytxhashit == m_index.get<ByTxHash>().end() || bytxhashit->m_txhash != it->m_txhash);\r\n+           LogPrintf(\"ABCD requested txid=%s preferred=%d first=%d delayed=%d candidates=%d completed=%d peer=%d\\n\", it->m_txhash.ToString(), it->m_preferred, it->m_first, delayed, candidates, completed, it->m_peer);\r\n+       }\r\n         Modify<ByPeer>(it, [expiry](Entry& entry) {\r\n             entry.SetState(State::REQUESTED);\r\n             entry.m_time = expiry;\r\n```\r\n\r\nAfter running it for a few minutes with ~20 peers, only 0.17% of requests actually had other announcements in CANDIDATE_READY, so for 99.82% of txs the first marker didn't make any difference. About 1.6% of requests weren't for a \"first\" marked announcement (a tor outbound managed to overload itself I think). Will let it go 'til it fills up the disk with logs or whatever, and see what it looks like then.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-28T08:46:53Z",
      "diff_hunk" : "@@ -793,73 +724,35 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest\n+    NodeId nodeid = node.GetId();\n+    if (m_txrequest.CountTracked(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"overloaded\": if at least MAX_PEER_TX_LOAD requests are in flight and requestable combined.\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or PF_NOBAN permission)\n+    // - \"reqtime\": immediately if none of the penalties below apply, otherwise current time plus:\n+    //   - INBOUND_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for announcements from txid peers while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from overloaded peers\n+    auto delay = std::chrono::microseconds{0};\n+    bool preferred = state->fPreferredDownload;\n+    bool overloaded = m_txrequest.CountLoad(nodeid) >= MAX_PEER_TX_LOAD;\n+    if (!preferred) delay += INBOUND_PEER_TX_DELAY;\n+    if (!state->m_wtxid_relay && g_wtxid_relay_peers > 0) delay += TXID_RELAY_DELAY;\n+    if (overloaded) delay += OVERLOADED_PEER_TX_DELAY;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r495781805",
      "id" : 495781805,
      "in_reply_to_id" : 495646456,
      "line" : 777,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4MTgwNQ==",
      "original_commit_id" : "242146dce083d047b88b66b20d72fa92587bddbc",
      "original_line" : 777,
      "original_position" : 195,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 220,
      "pull_request_review_id" : 497305646,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/495781805",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "Started to give a look at this, hope I'm not late to the party.",
      "created_at" : "2020-09-28T15:06:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#issuecomment-700067143",
      "id" : 700067143,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19988",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwMDA2NzE0Mw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-28T15:06:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/700067143",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r496263583"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/496263583"
         }
      },
      "author_association" : "MEMBER",
      "body" : "That's a pretty convincing argument.\r\n\r\nIf we assume that getting the \"overloaded\" treatment is relevant at all, it seems worse that an attacker can cause it to occur in \"third party\" connections than possibly missing out on getting that effect himself.\r\n\r\nI also don't see how a large at-once dump can be at all exploited. It means an attacker needs an excessive amount of transactions to begin with. If those are bogus/invalid or self-generated ones, the `first` marker has no effect as only attacker nodes will have it. If they're valid under-attack transactions, it means there is something seriously wrong already that such a batch of transactions is being propagated (remember the max tx rate of INVs...), and the `first` marker isn't going to change much.\r\n\r\nI'm going to revert this change.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-28T22:08:16Z",
      "diff_hunk" : "@@ -793,73 +724,35 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest\n+    NodeId nodeid = node.GetId();\n+    if (m_txrequest.CountTracked(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"overloaded\": if at least MAX_PEER_TX_LOAD requests are in flight and requestable combined.\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or PF_NOBAN permission)\n+    // - \"reqtime\": immediately if none of the penalties below apply, otherwise current time plus:\n+    //   - INBOUND_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for announcements from txid peers while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from overloaded peers\n+    auto delay = std::chrono::microseconds{0};\n+    bool preferred = state->fPreferredDownload;\n+    bool overloaded = m_txrequest.CountLoad(nodeid) >= MAX_PEER_TX_LOAD;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r496263583",
      "id" : 496263583,
      "in_reply_to_id" : 495641913,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2MzU4Mw==",
      "original_commit_id" : "242146dce083d047b88b66b20d72fa92587bddbc",
      "original_line" : 751,
      "original_position" : 192,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 497933875,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/496263583",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r496315814"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/496315814"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-29T01:02:24Z",
      "diff_hunk" : "@@ -793,73 +724,35 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest\n+    NodeId nodeid = node.GetId();\n+    if (m_txrequest.CountTracked(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"overloaded\": if at least MAX_PEER_TX_LOAD requests are in flight and requestable combined.\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or PF_NOBAN permission)\n+    // - \"reqtime\": immediately if none of the penalties below apply, otherwise current time plus:\n+    //   - INBOUND_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for announcements from txid peers while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from overloaded peers\n+    auto delay = std::chrono::microseconds{0};\n+    bool preferred = state->fPreferredDownload;\n+    bool overloaded = m_txrequest.CountLoad(nodeid) >= MAX_PEER_TX_LOAD;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r496315814",
      "id" : 496315814,
      "in_reply_to_id" : 495641913,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMxNTgxNA==",
      "original_commit_id" : "242146dce083d047b88b66b20d72fa92587bddbc",
      "original_line" : 751,
      "original_position" : 192,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 497993548,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/496315814",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r496320026"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/496320026"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> Kind-of? I would have said the fuzz testing only really tests the optimisations work; it doesn't really check that the basic implementation makes \"sense\"?\r\n\r\nYeah, kind of.\r\n\r\nThe fuzz test only verifies consistency of the optimized data structure, and observational equivalence with the naive reimplementation. That naive reimplementation is hopefully close enough to the written specification in txrequest.h that we can say the test actually correctness according to the specification. It however does not test whether that specification actually results in desirable high-level behavior. That's what the scenario unit tests are for, but they're not nearly as detailed.\r\n\r\nStill, as far as the specification goes, by keeping the policy out of txrequest and it tests, there is evidence that the data structure correctly implements it, and this doesn't depend on coincidences like \"non-preferred requests always have a reqtime in the future\" that are currently true, but maybe won't always be true. The interface doesn't force such relations, so the fuzz tests should be covering both situations where they do and don't hold.\r\n\r\nFurthermore, I'm not sure there is much of a simplification in the interface that can be made by moving more into txrequest?\r\n* Right now: `ReceivedInv(peer, gtxid, preferred, overloaded, reqtime)`.\r\n* Potentially: `ReceivedInv(peer, gtxid, preferred, have_wtxid_peers, current_time)`.\r\n* With the addition of bypassing `overloaded` under PF_RELAY you'd need to pass an additional argument `pf_relay_peer` argument even.\r\n\r\nThe fact that this last change could be made by just changing the parameters to `ReceivedInv` and not changing the interface - or the fuzz tests - is argument in favor of it, IMO.\r\n\r\nSeveral potential changes like making delays dynamic in function of load/inflight, or adding randomness to it, are equally possible without impacting txrequest.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-29T01:18:17Z",
      "diff_hunk" : "@@ -793,73 +724,35 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest\n+    NodeId nodeid = node.GetId();\n+    if (m_txrequest.CountTracked(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"overloaded\": if at least MAX_PEER_TX_LOAD requests are in flight and requestable combined.\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or PF_NOBAN permission)\n+    // - \"reqtime\": immediately if none of the penalties below apply, otherwise current time plus:\n+    //   - INBOUND_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for announcements from txid peers while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from overloaded peers\n+    auto delay = std::chrono::microseconds{0};\n+    bool preferred = state->fPreferredDownload;\n+    bool overloaded = m_txrequest.CountLoad(nodeid) >= MAX_PEER_TX_LOAD;\n+    if (!preferred) delay += INBOUND_PEER_TX_DELAY;\n+    if (!state->m_wtxid_relay && g_wtxid_relay_peers > 0) delay += TXID_RELAY_DELAY;\n+    if (overloaded) delay += OVERLOADED_PEER_TX_DELAY;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r496320026",
      "id" : 496320026,
      "in_reply_to_id" : 495646456,
      "line" : 777,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMyMDAyNg==",
      "original_commit_id" : "242146dce083d047b88b66b20d72fa92587bddbc",
      "original_line" : 777,
      "original_position" : 195,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 220,
      "pull_request_review_id" : 497998218,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/496320026",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r496323073"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/496323073"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> Either way, it may make sense for noban or relay permission to override considering a peer to be overloaded?\r\n\r\nAlso done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-29T01:29:37Z",
      "diff_hunk" : "@@ -793,73 +724,35 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest\n+    NodeId nodeid = node.GetId();\n+    if (m_txrequest.CountTracked(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"overloaded\": if at least MAX_PEER_TX_LOAD requests are in flight and requestable combined.\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or PF_NOBAN permission)\n+    // - \"reqtime\": immediately if none of the penalties below apply, otherwise current time plus:\n+    //   - INBOUND_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for announcements from txid peers while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from overloaded peers\n+    auto delay = std::chrono::microseconds{0};\n+    bool preferred = state->fPreferredDownload;\n+    bool overloaded = m_txrequest.CountLoad(nodeid) >= MAX_PEER_TX_LOAD;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r496323073",
      "id" : 496323073,
      "in_reply_to_id" : 495641913,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMyMzA3Mw==",
      "original_commit_id" : "242146dce083d047b88b66b20d72fa92587bddbc",
      "original_line" : 751,
      "original_position" : 192,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 498001699,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/496323073",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r496360433"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/496360433"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yeah, agree with what you wrote. (Well, I was thinking you'd call `ReceivedInv(peer, gtxid, preferred, max_load, current_time)` and pass `max_load=max()` to bypass overloaded, fwiw)\r\n\r\nI'm more thinking of the API in terms of what the caller has to do to ensure the txrequest modules behaves \"sensibly\" -- avoids requesting txs out of order, avoiding double requesting a tx, etc. If there's a way to make txrequest behave \"sensibly\" no matter how you call the API, that might be better than just documenting the expectations, or the consequences of violating the expectations. But I don't fully understand what sensibly means or what restrictions that implies yet.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-29T03:44:42Z",
      "diff_hunk" : "@@ -793,73 +724,35 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest\n+    NodeId nodeid = node.GetId();\n+    if (m_txrequest.CountTracked(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"overloaded\": if at least MAX_PEER_TX_LOAD requests are in flight and requestable combined.\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or PF_NOBAN permission)\n+    // - \"reqtime\": immediately if none of the penalties below apply, otherwise current time plus:\n+    //   - INBOUND_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for announcements from txid peers while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from overloaded peers\n+    auto delay = std::chrono::microseconds{0};\n+    bool preferred = state->fPreferredDownload;\n+    bool overloaded = m_txrequest.CountLoad(nodeid) >= MAX_PEER_TX_LOAD;\n+    if (!preferred) delay += INBOUND_PEER_TX_DELAY;\n+    if (!state->m_wtxid_relay && g_wtxid_relay_peers > 0) delay += TXID_RELAY_DELAY;\n+    if (overloaded) delay += OVERLOADED_PEER_TX_DELAY;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r496360433",
      "id" : 496360433,
      "in_reply_to_id" : 495646456,
      "line" : 777,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM2MDQzMw==",
      "original_commit_id" : "242146dce083d047b88b66b20d72fa92587bddbc",
      "original_line" : 777,
      "original_position" : 195,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 220,
      "pull_request_review_id" : 498043237,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/496360433",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r496365716"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/496365716"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I see what you mean now.\n\nThere is no strict reason why we couldn't have both. There could a class around TxRequestTracker that adds the policy and sanity checking of inputs, which just forwards to the inner TxRequestTracker. That would let the inner part still be tested for consistency, while permitting testing of the higher level construct for higher level \"goal\" properties.\n\nAs the logic in that outer layer would just be (part of) what is now in TxRequest(), I don't think this is worth it - but maybe at some point it is.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-29T04:06:30Z",
      "diff_hunk" : "@@ -793,73 +724,35 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest\n+    NodeId nodeid = node.GetId();\n+    if (m_txrequest.CountTracked(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"overloaded\": if at least MAX_PEER_TX_LOAD requests are in flight and requestable combined.\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or PF_NOBAN permission)\n+    // - \"reqtime\": immediately if none of the penalties below apply, otherwise current time plus:\n+    //   - INBOUND_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for announcements from txid peers while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from overloaded peers\n+    auto delay = std::chrono::microseconds{0};\n+    bool preferred = state->fPreferredDownload;\n+    bool overloaded = m_txrequest.CountLoad(nodeid) >= MAX_PEER_TX_LOAD;\n+    if (!preferred) delay += INBOUND_PEER_TX_DELAY;\n+    if (!state->m_wtxid_relay && g_wtxid_relay_peers > 0) delay += TXID_RELAY_DELAY;\n+    if (overloaded) delay += OVERLOADED_PEER_TX_DELAY;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r496365716",
      "id" : 496365716,
      "in_reply_to_id" : 495646456,
      "line" : 777,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM2NTcxNg==",
      "original_commit_id" : "242146dce083d047b88b66b20d72fa92587bddbc",
      "original_line" : 777,
      "original_position" : 195,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 220,
      "pull_request_review_id" : 498076237,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/496365716",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r496379595"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/496379595"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Okay, so I've run some stats on this now. Results (for me) after just under 230k calls to `RequestedTx` are:\r\n\r\n * in 77.9% of cases, it's requesting the tx from a preferred peer, with no alternative (non-delayed) candidates\r\n * in 18.2% of cases, it's requesting the tx from a non-preferred peer, with no alternative (n-d) candidates\r\n * in 1.3% of cases, it's requesting the tx from a preferred peer, with the only (n-d) alternative candidates being non-preferred peers\r\n * in 1.1% of cases, it's requesting the tx from a preferred peer using the first marker, and other preferred candidates are available (!)\r\n * in 1.0% of cases, it's requesting the tx from a non-preferred peer using the first marker, with other non-preferred candidates available (and no preferred candidates available) (!)\r\n * in 0.2% of cases, it's requesting the tx from a non-preferred peer using random selection\r\n * in 0.02% of cases, it's requesting the tx from a non-preferred peer using random selection\r\n\r\n(The remaining ~0.3% I didn't sort through)\r\n\r\nThis implies that the first marker is only relevant in ~2.1% of cases -- the rest of the time it's determined by the first peer's reqtime being reached at a call to `GetRequestable()` prior to any other announcement for that tx. That occurs because (unless I've missed something) we're calling `GetRequestable()` for each peer about ten times per second (100ms delay in `CConnman::ThreadMessageHandler` between calls to `SendMessages(pnode)`), which means the \"first\" marker only matters for preferred nodes when the first two preferred nodes to announce a tx manage to both set their reqtimes in the same ~100ms period and thus get activated in the same call the `GetRequestable`.\r\n\r\nI think what the \"first\" marker is actually doing is slightly different to what I was kind-of expecting. ie, \"reqtime\" and \"preferredness\" is almost always what's used to actually choose which announcement to request first, and the \"first\" marker is a backup. It's only relevant when (a) txrequest is used less frequently than every 100ms via some other implementation, (b) the 100ms delay is extended, eg due to cs_main being held while adding a new block or something, or (c) there's a race and we want a consistent tie-breaker.\r\n\r\nI haven't instrumented it, but I'm not convinced this does much for dependent transactions. Assuming B spends an output of A, and peers P and Q both announce A prior to B, you could still see announcements as `{Q:A, P:A, P:B}` then call `GetRequestable(P)` and have A assigned to Q and B assigned to P, and requested immediately, with A requested from Q moments later. But if that's not a big problem, what's the advantage in locking  A to Q via the \"first\" marker?\r\n\r\nAs it stands, I want to argue that the \"first\" marker is an unnecessary complication, and maybe we should remove it. But I'm not really convinced -- for one, that claim relies on calling `GetRequestable` very frequently, and maybe we want the flexibility to not do that? But if we called it for a given peer once a second instead of 10x a second, that adds another 0.5s delay on average to requesting a tx, which is pretty significant compared to the existing delays, so maybe relying on calling `GetRequetable` frequently is perfectly reasonable?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-29T04:27:58Z",
      "diff_hunk" : "@@ -0,0 +1,216 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in). Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              Invblocking is the practice of announcing transactions but not answer requests for them, in order\n+ *              to delay (or prevent) a target learning the transaction. See\n+ *              https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more information.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the first (non-overloaded) peer to have announced the transaction,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r496379595",
      "id" : 496379595,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM3OTU5NQ==",
      "original_commit_id" : "9e23f6e106a6e79b1ddf8be09b60a4bc4f5b387e",
      "original_line" : 74,
      "original_position" : 74,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 498086810,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/496379595",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r496383496"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/496383496"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yeah. I don't think a wrapper would really be an improvement on documenting the expectations, and agree that sticking fixed params in txrequest is really too restrictive. Going to mark this thread as resolved, but still continue thinking about it.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-29T04:33:50Z",
      "diff_hunk" : "@@ -793,73 +724,35 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest\n+    NodeId nodeid = node.GetId();\n+    if (m_txrequest.CountTracked(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"overloaded\": if at least MAX_PEER_TX_LOAD requests are in flight and requestable combined.\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or PF_NOBAN permission)\n+    // - \"reqtime\": immediately if none of the penalties below apply, otherwise current time plus:\n+    //   - INBOUND_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for announcements from txid peers while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from overloaded peers\n+    auto delay = std::chrono::microseconds{0};\n+    bool preferred = state->fPreferredDownload;\n+    bool overloaded = m_txrequest.CountLoad(nodeid) >= MAX_PEER_TX_LOAD;\n+    if (!preferred) delay += INBOUND_PEER_TX_DELAY;\n+    if (!state->m_wtxid_relay && g_wtxid_relay_peers > 0) delay += TXID_RELAY_DELAY;\n+    if (overloaded) delay += OVERLOADED_PEER_TX_DELAY;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r496383496",
      "id" : 496383496,
      "in_reply_to_id" : 495646456,
      "line" : 777,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM4MzQ5Ng==",
      "original_commit_id" : "242146dce083d047b88b66b20d72fa92587bddbc",
      "original_line" : 777,
      "original_position" : 195,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 220,
      "pull_request_review_id" : 498088441,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/496383496",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r496410646"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/496410646"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Not 100% on topic for this PR I guess, but `if (!gtixd.m_is_wtxid && g_wtxid_relay_peers > 0)` perhaps? That was we delay requesting a parent by txid when handing orphans in case we might have already been requesting the parent by wtxid from some peer (even this one if they were announced/requested/replied out of order for some reason).",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-29T05:12:04Z",
      "diff_hunk" : "@@ -793,73 +727,35 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest\n+    NodeId nodeid = node.GetId();\n+    if (!node.HasPermission(PF_RELAY) && m_txrequest.Count(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"overloaded\": if at least MAX_PEER_TX_IN_FLIGHT requests are in flight (and no PF_RELAY).\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or PF_NOBAN permission)\n+    // - \"reqtime\": immediately if none of the penalties below apply, otherwise current time plus:\n+    //   - INBOUND_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for announcements from txid peers while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from overloaded peers\n+    auto delay = std::chrono::microseconds{0};\n+    bool preferred = state->fPreferredDownload;\n+    bool overloaded = !node.HasPermission(PF_RELAY) && m_txrequest.CountInFlight(nodeid) >= MAX_PEER_TX_IN_FLIGHT;\n+    if (!preferred) delay += INBOUND_PEER_TX_DELAY;\n+    if (!state->m_wtxid_relay && g_wtxid_relay_peers > 0) delay += TXID_RELAY_DELAY;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r496410646",
      "id" : 496410646,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQxMDY0Ng==",
      "original_commit_id" : "9e23f6e106a6e79b1ddf8be09b60a4bc4f5b387e",
      "original_line" : 753,
      "original_position" : 216,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 498100145,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/496410646",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r496453269"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/496453269"
         }
      },
      "author_association" : "MEMBER",
      "body" : "That's great data, and perhaps not very surprising: we'd hope to pick good peers as outbounds, so most announcements will come in from preferred peers (and even more within the first 2s after the first announcement from inbound connections). As we fetch immediately from preferred connections in general, the \"first\" marker shouldn't do much.\r\n\r\nGiven that information, perhaps I wouldn't have added this to the first iteration of this logic. Now that it's implemented, I could argue that it may improve robustness in some cases:\r\n* During the rollout of BIP339, we can expect to see many more transactions fetched from delayed (but possibly preferred) peers, as just one wtxid peer will cause a delay on all announcements from other peers. It's hard to predict/measure what the impact of this will be.\r\n* I can imagine we'd add (possibly random) delays even from fetches from preferred peers, for privacy reasons.\r\n* Very well connected nodes (with way more inbound than outbound nodes) may see a larger percentage fetched from non-preferred connections.\r\n",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-29T06:44:38Z",
      "diff_hunk" : "@@ -0,0 +1,216 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in). Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              Invblocking is the practice of announcing transactions but not answer requests for them, in order\n+ *              to delay (or prevent) a target learning the transaction. See\n+ *              https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more information.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the first (non-overloaded) peer to have announced the transaction,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r496453269",
      "id" : 496453269,
      "in_reply_to_id" : 496379595,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ1MzI2OQ==",
      "original_commit_id" : "9e23f6e106a6e79b1ddf8be09b60a4bc4f5b387e",
      "original_line" : 74,
      "original_position" : 74,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 498139168,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/496453269",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r496491011"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/496491011"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think all those cases would just change the distribution between the cases where the \"first\" marker doesn't matter -- ie they're entirely determined by reqtime and preferredness.\r\n\r\nI do think it might improve robustness *somewhere* though...\r\n\r\nAlso, if, in the future, we changed the code to either update current_time less, or to target specific reqtimes (\"anything between t=0.0 and t=0.499 will be requested at t=1.234\"), it might start mattering\r\n\r\n> During the rollout of BIP339, we can expect to see many more transactions fetched from delayed (but possibly preferred) peers, as just one wtxid peer will cause a delay on all announcements from other peers.\r\n\r\nThat's a good point! I've restarted my node since the above numbers, and don't have any logging as to whether any of them were wtxidrelay. However post-restart, I have two inbound wtxidrelay peers, so should already be suffering from BIP339 rollout. And I guess that means all my preferred nodes should be degraded to the same priority as the non-preferred wtxid nodes, which in turn probably explains why I got such a high percentage of non-preferred announcements as the very first request for a txid.\r\n\r\nYeah, collecting `RequestedTx` calls by peerid and whether they were preferred or not gives me:\r\n\r\n *  1049 preferred=0 peer=2717\r\n *  1500 preferred=0 peer=3993\r\n *  3255 preferred=0 peer=3815\r\n *  3270 preferred=1 peer=13\r\n * 14216 preferred=1 peer=15\r\n * 14651 preferred=1 peer=14\r\n * 16918 preferred=1 peer=11\r\n * 18635 preferred=1 peer=2\r\n * 30675 preferred=0 peer=1163\r\n * 37776 preferred=1 peer=1\r\n * 39962 preferred=1 peer=16\r\n * 52112 preferred=1 peer=0\r\n\r\n(ignoring peers with under 1k requests). Which looks to me like the top 9 peers include the 8 outbounds I connected to initially, and a random inbound wtxidrelay peer which connected about 3h after my peer was restarted. That single node accounts for about 2/3rds of the \"18.2% of cases\" by the looks.\r\n\r\nSo I might desable wtxidrelay, and restart my node again, I think, which ironically seems like the easiest way to simulate an all-wtxid-relay world...",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-29T07:54:15Z",
      "diff_hunk" : "@@ -0,0 +1,216 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in). Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              Invblocking is the practice of announcing transactions but not answer requests for them, in order\n+ *              to delay (or prevent) a target learning the transaction. See\n+ *              https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more information.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the first (non-overloaded) peer to have announced the transaction,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r496491011",
      "id" : 496491011,
      "in_reply_to_id" : 496379595,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ5MTAxMQ==",
      "original_commit_id" : "9e23f6e106a6e79b1ddf8be09b60a4bc4f5b387e",
      "original_line" : 74,
      "original_position" : 74,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 498198212,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/496491011",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\n This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2020-09-29T10:03:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#issuecomment-700602271",
      "id" : 700602271,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19988",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwMDYwMjI3MQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-29T10:03:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/700602271",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497000115"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497000115"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Good point; I think was overlooked in #19569.\r\n\r\nFixed in a separate commit.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-29T19:43:27Z",
      "diff_hunk" : "@@ -793,73 +727,35 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest\n+    NodeId nodeid = node.GetId();\n+    if (!node.HasPermission(PF_RELAY) && m_txrequest.Count(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"overloaded\": if at least MAX_PEER_TX_IN_FLIGHT requests are in flight (and no PF_RELAY).\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or PF_NOBAN permission)\n+    // - \"reqtime\": immediately if none of the penalties below apply, otherwise current time plus:\n+    //   - INBOUND_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for announcements from txid peers while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from overloaded peers\n+    auto delay = std::chrono::microseconds{0};\n+    bool preferred = state->fPreferredDownload;\n+    bool overloaded = !node.HasPermission(PF_RELAY) && m_txrequest.CountInFlight(nodeid) >= MAX_PEER_TX_IN_FLIGHT;\n+    if (!preferred) delay += INBOUND_PEER_TX_DELAY;\n+    if (!state->m_wtxid_relay && g_wtxid_relay_peers > 0) delay += TXID_RELAY_DELAY;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497000115",
      "id" : 497000115,
      "in_reply_to_id" : 496410646,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAwMDExNQ==",
      "original_commit_id" : "9e23f6e106a6e79b1ddf8be09b60a4bc4f5b387e",
      "original_line" : 753,
      "original_position" : 216,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 498822690,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497000115",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497128048"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497128048"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done. Also included some more comments from your branch linked above.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-29T23:15:03Z",
      "diff_hunk" : "@@ -555,6 +555,124 @@ class TxRequestTracker::Impl {\n \n     //! Count how many announcements are being tracked in total across all peers and transactions.\n     size_t Size() const { return m_index.size(); }\n+\n+    uint64_t ComputePriority(const uint256& txhash, uint64_t peer, bool preferred, bool first) const\n+    {\n+        return m_computer(txhash, peer, preferred, first);\n+    }\n+\n+    void SanityCheck() const\n+    {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497128048",
      "id" : 497128048,
      "in_reply_to_id" : 494799280,
      "line" : 680,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzEyODA0OA==",
      "original_commit_id" : "512e0f9076b5d22f44d2a6dbf4eaacc1bdeb789b",
      "original_line" : 680,
      "original_position" : 11,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 680,
      "pull_request_review_id" : 498988556,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497128048",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497155136"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497155136"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Ok, updated stats based on 257k `RequestedTx` calls with wtxidrelay disabled (added a `false &&` to the if's in net_processing)\r\n\r\nI'm seeing 98.04% of requests being trivial cases -- there's no alternatives that have hit reqtime, and this is the first request of a tx. Despite having lots of (up to ~50?) inbounds, it's still choosing outbounds for almost all txs.\r\n\r\nPreferredness only mattered in 0.67% of cases, and only in 0.59% of cases did it matter for the first request.\r\n\r\n\"First\" marker only mattered in 0.77% of cases, and only ever for choosing between two non-preferred peers; though it was at least (almost) always for the first actual request for the txid.\r\n\r\nFWIW, ignoring the first hour, I got 520 \"accepted orphan tx\" messages. I'm running this node with mempool expiry set to 24h so that might be a bit high.\r\n\r\n```\r\n86.59% 222556 ABCD  requested  preferred=1  first=1  candidates=[-,-]  completed=[-,-]\r\n11.45%  29429 ABCD  requested  preferred=0  first=1  candidates=[-,-]  completed=[-,-]\r\n 0.18%    455 ABCD  requested  preferred=1  first=0  candidates=[-,-]  completed=[Y,-]\r\n 0.09%    222 ABCD  requested  preferred=0  first=1  candidates=[-,-]  completed=[Y,-]\r\n 0.08%    201 ABCD  requested  preferred=0  first=0  candidates=[-,-]  completed=[-,-]\r\n 0.05%    127 ABCD  requested  preferred=0  first=0  candidates=[-,-]  completed=[Y,Y]\r\n 0.04%    111 ABCD  requested  preferred=1  first=0  candidates=[-,-]  completed=[Y,Y]\r\n 0.03%     79 ABCD  requested  preferred=0  first=0  candidates=[-,-]  completed=[Y,-]\r\n 0.01%     17 ABCD  requested  preferred=1  first=0  candidates=[-,-]  completed=[-,Y]\r\n 0.01%     15 ABCD  requested  preferred=0  first=0  candidates=[-,-]  completed=[-,Y]\r\n\r\n 0.59%   1524 ABCD  requested  preferred=1  first=1  candidates=[-,Y]  completed=[-,-]\r\n 0.02%     64 ABCD  requested  preferred=1  first=0  candidates=[Y,Y]  completed=[-,Y]\r\n 0.02%     51 ABCD  requested  preferred=1  first=0  candidates=[Y,Y]  completed=[Y,Y]\r\n 0.02%     50 ABCD  requested  preferred=1  first=0  candidates=[-,Y]  completed=[Y,-]\r\n 0.01%     38 ABCD  requested  preferred=1  first=0  candidates=[-,Y]  completed=[Y,Y]\r\n 0.01%     32 ABCD  requested  preferred=1  first=0  candidates=[Y,-]  completed=[Y,-]\r\n 0.01%     24 ABCD  requested  preferred=1  first=0  candidates=[Y,-]  completed=[Y,Y]\r\n 0.00%     10 ABCD  requested  preferred=1  first=0  candidates=[Y,Y]  completed=[Y,-]\r\n 0.00%      1 ABCD  requested  preferred=1  first=0  candidates=[Y,-]  completed=[-,Y]\r\n 0.00%      1 ABCD  requested  preferred=1  first=0  candidates=[-,Y]  completed=[-,Y]\r\n\r\n 0.77%   1978 ABCD  requested  preferred=0  first=1  candidates=[-,Y]  completed=[-,-]\r\n 0.01%     20 ABCD  requested  preferred=0  first=0  candidates=[-,Y]  completed=[Y,Y]\r\n 0.00%      8 ABCD  requested  preferred=0  first=1  candidates=[-,Y]  completed=[Y,-]\r\n 0.00%      2 ABCD  requested  preferred=0  first=0  candidates=[-,Y]  completed=[Y,-]\r\n 0.00%      1 ABCD  requested  preferred=0  first=0  candidates=[-,Y]  completed=[-,Y]\r\n```\r\n\r\nJust considering the first request for a tx (ie, `candidates=[-,-] completed=[-,-]` cases) the number of announcements for the tx in CANDIDATE_DELAYED was distributed something like:\r\n\r\n```\r\n  48839 ABCD requested preferred=1 delayed=0\r\n  37457 ABCD requested preferred=1 delayed=1\r\n  32913 ABCD requested preferred=1 delayed=2\r\n  27587 ABCD requested preferred=1 delayed=3\r\n  22798 ABCD requested preferred=1 delayed=4\r\n  17525 ABCD requested preferred=1 delayed=5\r\n  12564 ABCD requested preferred=1 delayed=6\r\n   8071 ABCD requested preferred=1 delayed=7\r\n   5148 ABCD requested preferred=1 delayed=8\r\n   2965 ABCD requested preferred=1 delayed=9\r\n   1822 ABCD requested preferred=1 delayed=10\r\n\r\n   4437 ABCD requested preferred=0 delayed=0\r\n   2025 ABCD requested preferred=0 delayed=5\r\n   1981 ABCD requested preferred=0 delayed=6\r\n   1780 ABCD requested preferred=0 delayed=4\r\n```\r\n\r\nwhich looks pretty reasonable, I think. (I didn't break the delayed count into preferred/non-preferred, so the delayed= figure should include both inbounds and any overloaded outbounds)\r\n\r\nI wasn't quite as lucky with my outbounds staying around the entire timeby the looks, but got a much more even looking distribution of requests between the different prefrences:\r\n\r\n```\r\n   1048 ABCD requested preferred=0 peer=2013\r\n   1294 ABCD requested preferred=0 peer=4076\r\n   1359 ABCD requested preferred=0 peer=4096\r\n   1725 ABCD requested preferred=0 peer=235\r\n   2193 ABCD requested preferred=0 peer=3370\r\n   2630 ABCD requested preferred=0 peer=1950\r\n   2694 ABCD requested preferred=0 peer=2304\r\n   2843 ABCD requested preferred=0 peer=2095\r\n   3618 ABCD requested preferred=0 peer=1853\r\n\r\n      9 ABCD requested preferred=1 peer=6529\r\n     21 ABCD requested preferred=1 peer=5853\r\n     25 ABCD requested preferred=1 peer=1737\r\n     39 ABCD requested preferred=1 peer=1624\r\n     44 ABCD requested preferred=1 peer=30\r\n     57 ABCD requested preferred=1 peer=644\r\n    853 ABCD requested preferred=1 peer=22\r\n   2312 ABCD requested preferred=1 peer=11\r\n   5470 ABCD requested preferred=1 peer=202\r\n  13974 ABCD requested preferred=1 peer=0\r\n  14062 ABCD requested preferred=1 peer=2238\r\n  14427 ABCD requested preferred=1 peer=14\r\n  16520 ABCD requested preferred=1 peer=16\r\n  23714 ABCD requested preferred=1 peer=3385\r\n  37178 ABCD requested preferred=1 peer=24\r\n  46702 ABCD requested preferred=1 peer=29\r\n  49527 ABCD requested preferred=1 peer=44\r\n```\r\n\r\n(ignoring non-preferred peers that didn't have >1000 requests)\r\n\r\nEDIT: I'm guessing the lack of \"used the first marker to tie-break between two preferred peers\" cases means that none of my preferred peers were overloaded for any length of time, and always had `reqtime=min()`, and thus the `ThreadMessageHandler` loop would see the INV and immediately request it in a single iteration with no chance to consider any other peer, no matter how simultaneous the announcements were. \r\n\r\nThe previous 1.1% figure was due to the wtxidrelay delay causing all my preferred peers to have a 2s delay, so that if the outbounds were within 100ms there'd be a tie-breaker, ie they'd get added to the index, then both their reqtimes would pass while the thread was sleeping, and both would progress to READY/BEST in a single GetRequestable call.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-29T23:53:08Z",
      "diff_hunk" : "@@ -0,0 +1,216 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in). Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              Invblocking is the practice of announcing transactions but not answer requests for them, in order\n+ *              to delay (or prevent) a target learning the transaction. See\n+ *              https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more information.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the first (non-overloaded) peer to have announced the transaction,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497155136",
      "id" : 497155136,
      "in_reply_to_id" : 496379595,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE1NTEzNg==",
      "original_commit_id" : "9e23f6e106a6e79b1ddf8be09b60a4bc4f5b387e",
      "original_line" : 74,
      "original_position" : 74,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 499001275,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497155136",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497222956"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497222956"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Am currently running a test to see if removing \"first\" markers has a noticable effect on orphans (or anything else), but my current feeling is that the benefits of \"first\" markers don't justify the complexity. I've had a quick go at pulling the feature out into its own commit at https://github.com/ajtowns/bitcoin/commits/202009-txoverhaul-sep-first to see how much complexity that is, fwiw.\r\n\r\nI think the robustness that it adds is preserving the \"first announcer\" when multiple candidate announcements become ready at the same time. At present it only does that when their reqtimes were very similar from the word go, relative to how often `GetRequestable` is called.\r\n\r\nOne thing that might be worth considering is extending that towards a firmer guarantee, eg if a later, equally-preferred peer's announcement ends up with an earlier reqtime (due to time going backwards or randomized delays maybe) automatically adjust the \"first\" peer's announcement's reqtime to the same figure. (That would make a difference even with the current net_processing code in this PR, I think. Namely in the case where a non-wtxid-relay announces txid X, then a wtxid-relay-node announces wtxid X, ie X has no witness -- it'd bump the reqtime of the original peer's announcement at that point, rather than making it wait for the full TXID_RELAY_DELAY)\r\n\r\nEven if that's a good idea though, I'm not really convinced it makes sense to do it now, rather than later, with code to actually randomize times and thus make it relevant, and we can see if it covers all the cases that actually make sense. eg, would probably want to bump the reqtime of the \"first\" preferred announcement upon receipt of a non-preferred announcement with earlier reqtime, but probably not the reverse...",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-30T03:31:22Z",
      "diff_hunk" : "@@ -0,0 +1,216 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in). Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              Invblocking is the practice of announcing transactions but not answer requests for them, in order\n+ *              to delay (or prevent) a target learning the transaction. See\n+ *              https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more information.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the first (non-overloaded) peer to have announced the transaction,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497222956",
      "id" : 497222956,
      "in_reply_to_id" : 496379595,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIyMjk1Ng==",
      "original_commit_id" : "9e23f6e106a6e79b1ddf8be09b60a4bc4f5b387e",
      "original_line" : 74,
      "original_position" : 74,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 499061046,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497222956",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497519563"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497519563"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Unmatched `)` parse error",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-30T13:42:59Z",
      "diff_hunk" : "@@ -0,0 +1,216 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in). Even when the",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497519563",
      "id" : 497519563,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUxOTU2Mw==",
      "original_commit_id" : "a5a80aab130ade3eded6bbe87560876f4130c251",
      "original_line" : 29,
      "original_position" : 29,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 499443888,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497519563",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497558883"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497558883"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Maybe personal preference, but I *really* don't like the invblock terminology (for this reason: https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493163586) and would prefer not to introduce it to the Bitcoin Core codebase.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-30T14:32:45Z",
      "diff_hunk" : "@@ -0,0 +1,216 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in). Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              Invblocking is the practice of announcing transactions but not answer requests for them, in order",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497558883",
      "id" : 497558883,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU1ODg4Mw==",
      "original_commit_id" : "a5a80aab130ade3eded6bbe87560876f4130c251",
      "original_line" : 50,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 499443888,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497558883",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497561110"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497561110"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think this depends on your definition of progress? If all of your peers are announcing but not relaying transactions, then it doesn't matter how many times you request the tx, you're never making progress.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-30T14:35:43Z",
      "diff_hunk" : "@@ -0,0 +1,216 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in). Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              Invblocking is the practice of announcing transactions but not answer requests for them, in order\n+ *              to delay (or prevent) a target learning the transaction. See\n+ *              https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more information.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497561110",
      "id" : 497561110,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU2MTExMA==",
      "original_commit_id" : "a5a80aab130ade3eded6bbe87560876f4130c251",
      "original_line" : 59,
      "original_position" : 59,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 499443888,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497561110",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497561680"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497561680"
         }
      },
      "author_association" : "MEMBER",
      "body" : "change 'net_processing' to 'caller'",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-30T14:36:28Z",
      "diff_hunk" : "@@ -0,0 +1,216 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in). Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              Invblocking is the practice of announcing transactions but not answer requests for them, in order\n+ *              to delay (or prevent) a target learning the transaction. See\n+ *              https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more information.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497561680",
      "id" : 497561680,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU2MTY4MA==",
      "original_commit_id" : "a5a80aab130ade3eded6bbe87560876f4130c251",
      "original_line" : 64,
      "original_position" : 64,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 499443888,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497561680",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497565261"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497565261"
         }
      },
      "author_association" : "MEMBER",
      "body" : "remove \"(outbound, whitelisted)\". The caller chooses which peers are preferred, so it's best to avoid what we expect the caller to do here.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-30T14:40:56Z",
      "diff_hunk" : "@@ -0,0 +1,216 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in). Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              Invblocking is the practice of announcing transactions but not answer requests for them, in order\n+ *              to delay (or prevent) a target learning the transaction. See\n+ *              https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more information.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497565261",
      "id" : 497565261,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU2NTI2MQ==",
      "original_commit_id" : "a5a80aab130ade3eded6bbe87560876f4130c251",
      "original_line" : 71,
      "original_position" : 71,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 499443888,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497565261",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497569242"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497569242"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Perhaps reword this to be singular i.e. \"..marker is given to an announcement at the time it is received ... The peer that announced it was not overloaded.\"\r\n\r\nCurrently your mixing plural (\"announcements\") with singular (\"its txhash\", \"the same txhash\")",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-30T14:45:49Z",
      "diff_hunk" : "@@ -0,0 +1,216 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in). Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              Invblocking is the practice of announcing transactions but not answer requests for them, in order\n+ *              to delay (or prevent) a target learning the transaction. See\n+ *              https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more information.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the first (non-overloaded) peer to have announced the transaction,\n+ *     if that one is still a candidate. This is done using a \"first\" marker that is added to announcements, which\n+ *     prioritizes an announcement over all others (within the class of preferred or non-preferred announcements).\n+ *     The \"first\" marker is given to announcements at the time they are received, provided:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497569242",
      "id" : 497569242,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU2OTI0Mg==",
      "original_commit_id" : "a5a80aab130ade3eded6bbe87560876f4130c251",
      "original_line" : 77,
      "original_position" : 77,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 499443888,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497569242",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497623013"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497623013"
         }
      },
      "author_association" : "MEMBER",
      "body" : "\"when backwards\" -> \"went backwards\"?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-30T15:57:23Z",
      "diff_hunk" : "@@ -0,0 +1,778 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 56;\n+    /** Whether the request is preferred (giving it priority higher than non-preferred ones). */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+    /** Whether this was: the very first announcement for this txhash, within the preferred or non-preferred ones,\n+     *  and no request had been made for this txhash from any peer at the time the announcement came in. */\n+    const bool m_first : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    // The two flags below are _per txhash_, and not per announcement. They're part of the Entry\n+    // data structure because having a separate per-txhash map would consume much more memory.\n+    // Only the flags of the last Entry for a given txhash (ByTxHash order) are relevant;\n+    // the other ones are ignored.\n+\n+    /** New preferred announcements with this txhash are not eligible to get the 'first' marker. */\n+    mutable bool m_no_more_first_pref : 1;\n+    /** New non-preferred announcements with this txhash are not eligible to get the 'first' marker. */\n+    mutable bool m_no_more_first_nonpref : 1;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence, bool first) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_first(first), m_state(uint8_t(State::CANDIDATE_DELAYED)),\n+        m_no_more_first_pref(false), m_no_more_first_nonpref(false) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred, entry.m_first);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_READY, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time when backwards).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497623013",
      "id" : 497623013,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYyMzAxMw==",
      "original_commit_id" : "a5a80aab130ade3eded6bbe87560876f4130c251",
      "original_line" : 194,
      "original_position" : 194,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 499443888,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497623013",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497649495"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497649495"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Perhaps comment that this is only used in sanity testing, or even better remove it entirely and move the logic into `TxRequestTracker::Impl::SanityCheck()` (since it's only called in one place).",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-30T16:36:48Z",
      "diff_hunk" : "@@ -0,0 +1,778 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 56;\n+    /** Whether the request is preferred (giving it priority higher than non-preferred ones). */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+    /** Whether this was: the very first announcement for this txhash, within the preferred or non-preferred ones,\n+     *  and no request had been made for this txhash from any peer at the time the announcement came in. */\n+    const bool m_first : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    // The two flags below are _per txhash_, and not per announcement. They're part of the Entry\n+    // data structure because having a separate per-txhash map would consume much more memory.\n+    // Only the flags of the last Entry for a given txhash (ByTxHash order) are relevant;\n+    // the other ones are ignored.\n+\n+    /** New preferred announcements with this txhash are not eligible to get the 'first' marker. */\n+    mutable bool m_no_more_first_pref : 1;\n+    /** New non-preferred announcements with this txhash are not eligible to get the 'first' marker. */\n+    mutable bool m_no_more_first_nonpref : 1;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence, bool first) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_first(first), m_state(uint8_t(State::CANDIDATE_DELAYED)),\n+        m_no_more_first_pref(false), m_no_more_first_nonpref(false) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred, entry.m_first);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_READY, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time when backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497649495",
      "id" : 497649495,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY0OTQ5NQ==",
      "original_commit_id" : "a5a80aab130ade3eded6bbe87560876f4130c251",
      "original_line" : 210,
      "original_position" : 226,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 499443888,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497649495",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497649827"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497649827"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Consider moving this logic into `SanityCheck()`, since it's only called in one place.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-30T16:37:23Z",
      "diff_hunk" : "@@ -0,0 +1,778 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 56;\n+    /** Whether the request is preferred (giving it priority higher than non-preferred ones). */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+    /** Whether this was: the very first announcement for this txhash, within the preferred or non-preferred ones,\n+     *  and no request had been made for this txhash from any peer at the time the announcement came in. */\n+    const bool m_first : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    // The two flags below are _per txhash_, and not per announcement. They're part of the Entry\n+    // data structure because having a separate per-txhash map would consume much more memory.\n+    // Only the flags of the last Entry for a given txhash (ByTxHash order) are relevant;\n+    // the other ones are ignored.\n+\n+    /** New preferred announcements with this txhash are not eligible to get the 'first' marker. */\n+    mutable bool m_no_more_first_pref : 1;\n+    /** New non-preferred announcements with this txhash are not eligible to get the 'first' marker. */\n+    mutable bool m_no_more_first_nonpref : 1;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence, bool first) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_first(first), m_state(uint8_t(State::CANDIDATE_DELAYED)),\n+        m_no_more_first_pref(false), m_no_more_first_nonpref(false) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred, entry.m_first);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_READY, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time when backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+    //! Whether any preferred first entry exists.\n+    bool m_any_first_pref = false;\n+    //! Whether any non-preferred first entry exists.\n+    bool m_any_first_nonpref = false;\n+    //! Whether any Entry with m_no_more_first_pref exists.\n+    bool m_any_no_more_first_pref = false;\n+    //! Whether any Entry with m_no_more_first_nonpref exists.\n+    bool m_any_no_more_first_nonpref = false;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497649827",
      "id" : 497649827,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY0OTgyNw==",
      "original_commit_id" : "a5a80aab130ade3eded6bbe87560876f4130c251",
      "original_line" : 237,
      "original_position" : 261,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 499443888,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497649827",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497662929"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497662929"
         }
      },
      "author_association" : "MEMBER",
      "body" : "What's the thinking behind having this logic in a separate function, rather than contained in `SanityCheck()`? It's only called in one place.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-30T16:58:03Z",
      "diff_hunk" : "@@ -0,0 +1,778 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 56;\n+    /** Whether the request is preferred (giving it priority higher than non-preferred ones). */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+    /** Whether this was: the very first announcement for this txhash, within the preferred or non-preferred ones,\n+     *  and no request had been made for this txhash from any peer at the time the announcement came in. */\n+    const bool m_first : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    // The two flags below are _per txhash_, and not per announcement. They're part of the Entry\n+    // data structure because having a separate per-txhash map would consume much more memory.\n+    // Only the flags of the last Entry for a given txhash (ByTxHash order) are relevant;\n+    // the other ones are ignored.\n+\n+    /** New preferred announcements with this txhash are not eligible to get the 'first' marker. */\n+    mutable bool m_no_more_first_pref : 1;\n+    /** New non-preferred announcements with this txhash are not eligible to get the 'first' marker. */\n+    mutable bool m_no_more_first_nonpref : 1;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence, bool first) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_first(first), m_state(uint8_t(State::CANDIDATE_DELAYED)),\n+        m_no_more_first_pref(false), m_no_more_first_nonpref(false) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred, entry.m_first);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_READY, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time when backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+    //! Whether any preferred first entry exists.\n+    bool m_any_first_pref = false;\n+    //! Whether any non-preferred first entry exists.\n+    bool m_any_first_nonpref = false;\n+    //! Whether any Entry with m_no_more_first_pref exists.\n+    bool m_any_no_more_first_pref = false;\n+    //! Whether any Entry with m_no_more_first_nonpref exists.\n+    bool m_any_no_more_first_nonpref = false;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497662929",
      "id" : 497662929,
      "line" : 276,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY2MjkyOQ==",
      "original_commit_id" : "a5a80aab130ade3eded6bbe87560876f4130c251",
      "original_line" : 276,
      "original_position" : 274,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 276,
      "pull_request_review_id" : 499443888,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497662929",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497699166"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497699166"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Actually, I think just a comment saying that his is just used for sanity checking is sufficient.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-30T17:57:50Z",
      "diff_hunk" : "@@ -0,0 +1,778 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 56;\n+    /** Whether the request is preferred (giving it priority higher than non-preferred ones). */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+    /** Whether this was: the very first announcement for this txhash, within the preferred or non-preferred ones,\n+     *  and no request had been made for this txhash from any peer at the time the announcement came in. */\n+    const bool m_first : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    // The two flags below are _per txhash_, and not per announcement. They're part of the Entry\n+    // data structure because having a separate per-txhash map would consume much more memory.\n+    // Only the flags of the last Entry for a given txhash (ByTxHash order) are relevant;\n+    // the other ones are ignored.\n+\n+    /** New preferred announcements with this txhash are not eligible to get the 'first' marker. */\n+    mutable bool m_no_more_first_pref : 1;\n+    /** New non-preferred announcements with this txhash are not eligible to get the 'first' marker. */\n+    mutable bool m_no_more_first_nonpref : 1;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence, bool first) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_first(first), m_state(uint8_t(State::CANDIDATE_DELAYED)),\n+        m_no_more_first_pref(false), m_no_more_first_nonpref(false) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred, entry.m_first);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_READY, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time when backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497699166",
      "id" : 497699166,
      "in_reply_to_id" : 497649495,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY5OTE2Ng==",
      "original_commit_id" : "a5a80aab130ade3eded6bbe87560876f4130c251",
      "original_line" : 210,
      "original_position" : 226,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 499680880,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497699166",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497699422"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497699422"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Marking as resolved. AJ asked you to separate this, and I don't have a strong opionion.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-30T17:58:16Z",
      "diff_hunk" : "@@ -0,0 +1,778 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 56;\n+    /** Whether the request is preferred (giving it priority higher than non-preferred ones). */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+    /** Whether this was: the very first announcement for this txhash, within the preferred or non-preferred ones,\n+     *  and no request had been made for this txhash from any peer at the time the announcement came in. */\n+    const bool m_first : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    // The two flags below are _per txhash_, and not per announcement. They're part of the Entry\n+    // data structure because having a separate per-txhash map would consume much more memory.\n+    // Only the flags of the last Entry for a given txhash (ByTxHash order) are relevant;\n+    // the other ones are ignored.\n+\n+    /** New preferred announcements with this txhash are not eligible to get the 'first' marker. */\n+    mutable bool m_no_more_first_pref : 1;\n+    /** New non-preferred announcements with this txhash are not eligible to get the 'first' marker. */\n+    mutable bool m_no_more_first_nonpref : 1;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence, bool first) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_first(first), m_state(uint8_t(State::CANDIDATE_DELAYED)),\n+        m_no_more_first_pref(false), m_no_more_first_nonpref(false) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred, entry.m_first);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_READY, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time when backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+    //! Whether any preferred first entry exists.\n+    bool m_any_first_pref = false;\n+    //! Whether any non-preferred first entry exists.\n+    bool m_any_first_nonpref = false;\n+    //! Whether any Entry with m_no_more_first_pref exists.\n+    bool m_any_no_more_first_pref = false;\n+    //! Whether any Entry with m_no_more_first_nonpref exists.\n+    bool m_any_no_more_first_nonpref = false;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497699422",
      "id" : 497699422,
      "in_reply_to_id" : 497649827,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY5OTQyMg==",
      "original_commit_id" : "a5a80aab130ade3eded6bbe87560876f4130c251",
      "original_line" : 237,
      "original_position" : 261,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 499681272,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497699422",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497699475"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497699475"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Marking as resolved. AJ asked you to separate this, and I don't have a strong opionion.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-30T17:58:22Z",
      "diff_hunk" : "@@ -0,0 +1,778 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 56;\n+    /** Whether the request is preferred (giving it priority higher than non-preferred ones). */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+    /** Whether this was: the very first announcement for this txhash, within the preferred or non-preferred ones,\n+     *  and no request had been made for this txhash from any peer at the time the announcement came in. */\n+    const bool m_first : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    // The two flags below are _per txhash_, and not per announcement. They're part of the Entry\n+    // data structure because having a separate per-txhash map would consume much more memory.\n+    // Only the flags of the last Entry for a given txhash (ByTxHash order) are relevant;\n+    // the other ones are ignored.\n+\n+    /** New preferred announcements with this txhash are not eligible to get the 'first' marker. */\n+    mutable bool m_no_more_first_pref : 1;\n+    /** New non-preferred announcements with this txhash are not eligible to get the 'first' marker. */\n+    mutable bool m_no_more_first_nonpref : 1;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence, bool first) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_first(first), m_state(uint8_t(State::CANDIDATE_DELAYED)),\n+        m_no_more_first_pref(false), m_no_more_first_nonpref(false) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred, entry.m_first);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_READY, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time when backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+    //! Whether any preferred first entry exists.\n+    bool m_any_first_pref = false;\n+    //! Whether any non-preferred first entry exists.\n+    bool m_any_first_nonpref = false;\n+    //! Whether any Entry with m_no_more_first_pref exists.\n+    bool m_any_no_more_first_pref = false;\n+    //! Whether any Entry with m_no_more_first_nonpref exists.\n+    bool m_any_no_more_first_nonpref = false;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497699475",
      "id" : 497699475,
      "in_reply_to_id" : 497662929,
      "line" : 276,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY5OTQ3NQ==",
      "original_commit_id" : "a5a80aab130ade3eded6bbe87560876f4130c251",
      "original_line" : 276,
      "original_position" : 274,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 276,
      "pull_request_review_id" : 499681352,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497699475",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497747371"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497747371"
         }
      },
      "author_association" : "MEMBER",
      "body" : "\"progress towards forgetting a transaction\" is unambiguous I think? Every minute one peer is crossed off the list of candidates, so eventually you will run out. Note that this section isn't about successfully receiving the transaction, but bounding memory usage.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-30T19:25:11Z",
      "diff_hunk" : "@@ -0,0 +1,216 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in). Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              Invblocking is the practice of announcing transactions but not answer requests for them, in order\n+ *              to delay (or prevent) a target learning the transaction. See\n+ *              https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more information.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497747371",
      "id" : 497747371,
      "in_reply_to_id" : 497561110,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc0NzM3MQ==",
      "original_commit_id" : "a5a80aab130ade3eded6bbe87560876f4130c251",
      "original_line" : 59,
      "original_position" : 59,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 499743135,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497747371",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497752786"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497752786"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Actually, thinking more about this, it isn't exactly true, because for non-preferred connections we should assume the attacker can disconnect and reconnect, giving them a new opportunity. I think this should be restated as: an attacker can force us to keep a transaction in memory (even in the queues of honest peers) for as long as they can prevent us from receiving the transaction. That's not necessarily bounded, but in cases where it isn't, we have bigger problems. Actual OOM is prevented using per-peer queue size limits.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-30T19:35:06Z",
      "diff_hunk" : "@@ -0,0 +1,216 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in). Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              Invblocking is the practice of announcing transactions but not answer requests for them, in order\n+ *              to delay (or prevent) a target learning the transaction. See\n+ *              https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more information.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497752786",
      "id" : 497752786,
      "in_reply_to_id" : 497561110,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc1Mjc4Ng==",
      "original_commit_id" : "a5a80aab130ade3eded6bbe87560876f4130c251",
      "original_line" : 59,
      "original_position" : 59,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 499749851,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497752786",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497782110"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497782110"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done, I've changed this PR to drop the \"first\" marker logic, based on your branch + adjusting fuzz tester and some extra comments. The commit to add it back is here: https://github.com/sipa/bitcoin/commits/202009_txrequest_rand_wtxid_first",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-30T20:31:06Z",
      "diff_hunk" : "@@ -0,0 +1,216 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in). Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              Invblocking is the practice of announcing transactions but not answer requests for them, in order\n+ *              to delay (or prevent) a target learning the transaction. See\n+ *              https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more information.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the first (non-overloaded) peer to have announced the transaction,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497782110",
      "id" : 497782110,
      "in_reply_to_id" : 496379595,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc4MjExMA==",
      "original_commit_id" : "9e23f6e106a6e79b1ddf8be09b60a4bc4f5b387e",
      "original_line" : 74,
      "original_position" : 74,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 499787973,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497782110",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497782343"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497782343"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-30T20:31:31Z",
      "diff_hunk" : "@@ -0,0 +1,216 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in). Even when the",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497782343",
      "id" : 497782343,
      "in_reply_to_id" : 497519563,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc4MjM0Mw==",
      "original_commit_id" : "a5a80aab130ade3eded6bbe87560876f4130c251",
      "original_line" : 29,
      "original_position" : 29,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 499788288,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497782343",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497782492"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497782492"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've replaced it with \"transaction censorship attacks\".",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-30T20:31:48Z",
      "diff_hunk" : "@@ -0,0 +1,216 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in). Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              Invblocking is the practice of announcing transactions but not answer requests for them, in order",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497782492",
      "id" : 497782492,
      "in_reply_to_id" : 497558883,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc4MjQ5Mg==",
      "original_commit_id" : "a5a80aab130ade3eded6bbe87560876f4130c251",
      "original_line" : 50,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 499788495,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497782492",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497782811"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497782811"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've adjusted the comments, merging this paragraph into the previous one (they were already kind of circularly referring to each other). Also changed the formula for delay to take this potential for reconnection behavior into account.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-30T20:32:22Z",
      "diff_hunk" : "@@ -0,0 +1,216 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in). Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              Invblocking is the practice of announcing transactions but not answer requests for them, in order\n+ *              to delay (or prevent) a target learning the transaction. See\n+ *              https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more information.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497782811",
      "id" : 497782811,
      "in_reply_to_id" : 497561110,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc4MjgxMQ==",
      "original_commit_id" : "a5a80aab130ade3eded6bbe87560876f4130c251",
      "original_line" : 59,
      "original_position" : 59,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 499788879,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497782811",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497783237"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497783237"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-30T20:33:09Z",
      "diff_hunk" : "@@ -0,0 +1,216 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in). Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              Invblocking is the practice of announcing transactions but not answer requests for them, in order\n+ *              to delay (or prevent) a target learning the transaction. See\n+ *              https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more information.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497783237",
      "id" : 497783237,
      "in_reply_to_id" : 497561680,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc4MzIzNw==",
      "original_commit_id" : "a5a80aab130ade3eded6bbe87560876f4130c251",
      "original_line" : 64,
      "original_position" : 64,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 499789430,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497783237",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497783298"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497783298"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-30T20:33:17Z",
      "diff_hunk" : "@@ -0,0 +1,216 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in). Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              Invblocking is the practice of announcing transactions but not answer requests for them, in order\n+ *              to delay (or prevent) a target learning the transaction. See\n+ *              https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more information.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497783298",
      "id" : 497783298,
      "in_reply_to_id" : 497565261,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc4MzI5OA==",
      "original_commit_id" : "a5a80aab130ade3eded6bbe87560876f4130c251",
      "original_line" : 71,
      "original_position" : 71,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 499789523,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497783298",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497783405"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497783405"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Gone (moved to https://github.com/sipa/bitcoin/commits/202009_txrequest_rand_wtxid_first).",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-30T20:33:29Z",
      "diff_hunk" : "@@ -0,0 +1,216 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in). Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              Invblocking is the practice of announcing transactions but not answer requests for them, in order\n+ *              to delay (or prevent) a target learning the transaction. See\n+ *              https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more information.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the first (non-overloaded) peer to have announced the transaction,\n+ *     if that one is still a candidate. This is done using a \"first\" marker that is added to announcements, which\n+ *     prioritizes an announcement over all others (within the class of preferred or non-preferred announcements).\n+ *     The \"first\" marker is given to announcements at the time they are received, provided:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497783405",
      "id" : 497783405,
      "in_reply_to_id" : 497569242,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc4MzQwNQ==",
      "original_commit_id" : "a5a80aab130ade3eded6bbe87560876f4130c251",
      "original_line" : 77,
      "original_position" : 77,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 499789670,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497783405",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497783457"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497783457"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-30T20:33:36Z",
      "diff_hunk" : "@@ -0,0 +1,778 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 56;\n+    /** Whether the request is preferred (giving it priority higher than non-preferred ones). */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+    /** Whether this was: the very first announcement for this txhash, within the preferred or non-preferred ones,\n+     *  and no request had been made for this txhash from any peer at the time the announcement came in. */\n+    const bool m_first : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    // The two flags below are _per txhash_, and not per announcement. They're part of the Entry\n+    // data structure because having a separate per-txhash map would consume much more memory.\n+    // Only the flags of the last Entry for a given txhash (ByTxHash order) are relevant;\n+    // the other ones are ignored.\n+\n+    /** New preferred announcements with this txhash are not eligible to get the 'first' marker. */\n+    mutable bool m_no_more_first_pref : 1;\n+    /** New non-preferred announcements with this txhash are not eligible to get the 'first' marker. */\n+    mutable bool m_no_more_first_nonpref : 1;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence, bool first) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_first(first), m_state(uint8_t(State::CANDIDATE_DELAYED)),\n+        m_no_more_first_pref(false), m_no_more_first_nonpref(false) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred, entry.m_first);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_READY, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time when backwards).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497783457",
      "id" : 497783457,
      "in_reply_to_id" : 497623013,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc4MzQ1Nw==",
      "original_commit_id" : "a5a80aab130ade3eded6bbe87560876f4130c251",
      "original_line" : 194,
      "original_position" : 194,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 499789747,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497783457",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497783508"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497783508"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-30T20:33:41Z",
      "diff_hunk" : "@@ -0,0 +1,778 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 56;\n+    /** Whether the request is preferred (giving it priority higher than non-preferred ones). */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+    /** Whether this was: the very first announcement for this txhash, within the preferred or non-preferred ones,\n+     *  and no request had been made for this txhash from any peer at the time the announcement came in. */\n+    const bool m_first : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    // The two flags below are _per txhash_, and not per announcement. They're part of the Entry\n+    // data structure because having a separate per-txhash map would consume much more memory.\n+    // Only the flags of the last Entry for a given txhash (ByTxHash order) are relevant;\n+    // the other ones are ignored.\n+\n+    /** New preferred announcements with this txhash are not eligible to get the 'first' marker. */\n+    mutable bool m_no_more_first_pref : 1;\n+    /** New non-preferred announcements with this txhash are not eligible to get the 'first' marker. */\n+    mutable bool m_no_more_first_nonpref : 1;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence, bool first) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_first(first), m_state(uint8_t(State::CANDIDATE_DELAYED)),\n+        m_no_more_first_pref(false), m_no_more_first_nonpref(false) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred, entry.m_first);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_READY, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time when backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497783508",
      "id" : 497783508,
      "in_reply_to_id" : 497649495,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc4MzUwOA==",
      "original_commit_id" : "a5a80aab130ade3eded6bbe87560876f4130c251",
      "original_line" : 210,
      "original_position" : 226,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 499789815,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497783508",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I've removed the \"first\" marker logic as @ajtowns found that it has little effect in practice (and is unlikely to have one absent other significant changes to the logic), see https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497222956 and preceding comments. A branch that re-enables it (in a final commit on top) is here: https://github.com/sipa/bitcoin/commits/202009_txrequest_rand_wtxid_first\r\n\r\nAlso made some changes to comments, after realizing that we can't assume that the attacker can't disconnect/reconnect non-preferred connections.",
      "created_at" : "2020-09-30T20:59:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#issuecomment-701642487",
      "id" : 701642487,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19988",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwMTY0MjQ4Nw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-30T20:59:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/701642487",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497859597"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497859597"
         }
      },
      "author_association" : "MEMBER",
      "body" : "You can add \"pushback mechanisms (OVERLOADED_PEER_TX_DELAY)\".\r\n\r\nA future improvement of pushback mechanism could be to scale it up by the number of times of MAX_PEER_TX_IN_FLIGHT is reached, like `m_txrequest.CountInFlightMagnitude(nodeid, MAX_PEER_TX_IN_FLIGHT)` ? Thus delaying further and further a likely-malicious peer.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-30T23:42:00Z",
      "diff_hunk" : "@@ -71,22 +71,22 @@ static constexpr std::chrono::minutes PING_INTERVAL{2};\n static const unsigned int MAX_LOCATOR_SZ = 101;\n /** The maximum number of entries in an 'inv' protocol message */\n static const unsigned int MAX_INV_SZ = 50000;\n-/** Maximum number of in-flight transactions from a peer */\n+/** Maximum number of in-flight transactions from a peer. It is not a hard limit, but the threshold\n+ *  at which point pushback mechanisms kick in. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497859597",
      "id" : 497859597,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg1OTU5Nw==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 75,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 499884175,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497859597",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497861187"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497861187"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think this delay applies to non-preferred peers which is strictly a different set than inbound ones as some of them might be PF_NOBAN==true. Variable name can be updated to reflect this.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-30T23:47:31Z",
      "diff_hunk" : "@@ -71,22 +71,22 @@ static constexpr std::chrono::minutes PING_INTERVAL{2};\n static const unsigned int MAX_LOCATOR_SZ = 101;\n /** The maximum number of entries in an 'inv' protocol message */\n static const unsigned int MAX_INV_SZ = 50000;\n-/** Maximum number of in-flight transactions from a peer */\n+/** Maximum number of in-flight transactions from a peer. It is not a hard limit, but the threshold\n+ *  at which point pushback mechanisms kick in. */\n static constexpr int32_t MAX_PEER_TX_IN_FLIGHT = 100;\n-/** Maximum number of announced transactions from a peer */\n-static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 2 * MAX_INV_SZ;\n+/** Maximum number of transactions to consider for requesting, per peer. It provides a reasonable DoS limit to\n+ *  per-peer memory usage spent on announcements, while covering peers continuously sending INVs at the maximum\n+ *  rate (by our own policy, see INVENTORY_BROADCAST_PER_SECOND) for several minutes, while not receiving\n+ *  the actual transaction (from any peer) in response to requests for them. */\n+static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 5000;\n /** How many microseconds to delay requesting transactions via txids, if we have wtxid-relaying peers */\n static constexpr std::chrono::microseconds TXID_RELAY_DELAY{std::chrono::seconds{2}};\n /** How many microseconds to delay requesting transactions from inbound peers */\n static constexpr std::chrono::microseconds INBOUND_PEER_TX_DELAY{std::chrono::seconds{2}};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497861187",
      "id" : 497861187,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg2MTE4Nw==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 85,
      "original_position" : 18,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 499884175,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497861187",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497863468"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497863468"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It's documented in TxRequestTracker specification but I think you could recall that a preferred, txid-relay peer will be always favored on a non-preferred, wtxid-relay one. So it doesn't matter that all delay penalties are actually 2 seconds. They order peers inside a class, not across ?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-09-30T23:55:42Z",
      "diff_hunk" : "@@ -806,73 +740,35 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest\n+    NodeId nodeid = node.GetId();\n+    if (!node.HasPermission(PF_RELAY) && m_txrequest.Count(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"overloaded\": if at least MAX_PEER_TX_IN_FLIGHT requests are in flight (and no PF_RELAY).\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or PF_NOBAN permission)\n+    // - \"reqtime\": immediately if none of the penalties below apply, otherwise current time plus:\n+    //   - INBOUND_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for announcements from txid peers while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from overloaded peers\n+    auto delay = std::chrono::microseconds{0};\n+    bool preferred = state->fPreferredDownload;\n+    bool overloaded = !node.HasPermission(PF_RELAY) && m_txrequest.CountInFlight(nodeid) >= MAX_PEER_TX_IN_FLIGHT;\n+    if (!preferred) delay += INBOUND_PEER_TX_DELAY;\n+    if (!gtxid.IsWtxid() && g_wtxid_relay_peers > 0) delay += TXID_RELAY_DELAY;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497863468",
      "id" : 497863468,
      "line" : 775,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg2MzQ2OA==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 775,
      "original_position" : 216,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 218,
      "pull_request_review_id" : 499884175,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497863468",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497879370"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497879370"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Why not pass `current_time` only for false-branch of ternary ? Entry should be promoted to {READY/BEST} in `SetTimePoint` anyway.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-01T00:32:11Z",
      "diff_hunk" : "@@ -806,73 +740,35 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest\n+    NodeId nodeid = node.GetId();\n+    if (!node.HasPermission(PF_RELAY) && m_txrequest.Count(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"overloaded\": if at least MAX_PEER_TX_IN_FLIGHT requests are in flight (and no PF_RELAY).\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or PF_NOBAN permission)\n+    // - \"reqtime\": immediately if none of the penalties below apply, otherwise current time plus:\n+    //   - INBOUND_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for announcements from txid peers while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from overloaded peers\n+    auto delay = std::chrono::microseconds{0};\n+    bool preferred = state->fPreferredDownload;\n+    bool overloaded = !node.HasPermission(PF_RELAY) && m_txrequest.CountInFlight(nodeid) >= MAX_PEER_TX_IN_FLIGHT;\n+    if (!preferred) delay += INBOUND_PEER_TX_DELAY;\n+    if (!gtxid.IsWtxid() && g_wtxid_relay_peers > 0) delay += TXID_RELAY_DELAY;\n+    if (overloaded) delay += OVERLOADED_PEER_TX_DELAY;\n+    auto reqtime = delay.count() ? current_time + delay : std::chrono::microseconds::min();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497879370",
      "id" : 497879370,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg3OTM3MA==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 768,
      "original_position" : 218,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 499884175,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497879370",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497882360"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497882360"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Have you considered moving `m_txrequest` under it's own lock as it's a well-contained, new data structure ? a) useless as we already take `cs_main` independently in all code paths reaching `m_txrequest` or b) too much work and this PR is already complex enough?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-01T00:36:58Z",
      "diff_hunk" : "@@ -806,73 +740,35 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497882360",
      "id" : 497882360,
      "line" : 757,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg4MjM2MA==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 757,
      "original_position" : 190,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 193,
      "pull_request_review_id" : 499884175,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497882360",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497885320"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497885320"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think this comment isn't clear with other comments spread elsewhere like \"Lower priorities are selected first\". ",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-01T00:41:22Z",
      "diff_hunk" : "@@ -0,0 +1,690 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred (giving it priority higher than non-preferred ones). */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497885320",
      "id" : 497885320,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg4NTMyMA==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 65,
      "original_position" : 65,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 499884175,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497885320",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497887645"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497887645"
         }
      },
      "author_association" : "MEMBER",
      "body" : "to convert to CANDIDATE_BEST?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-01T00:45:04Z",
      "diff_hunk" : "@@ -0,0 +1,690 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred (giving it priority higher than non-preferred ones). */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    // The two flags below are _per txhash_, and not per announcement. They're part of the Entry\n+    // data structure because having a separate per-txhash map would consume much more memory.\n+    // Only the flags of the last Entry for a given txhash (ByTxHash order) are relevant;\n+    // the other ones are ignored.\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_READY, when no other CANDIDATE_READY or REQUESTED",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497887645",
      "id" : 497887645,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg4NzY0NQ==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 158,
      "original_position" : 158,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 499884175,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497887645",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497889661"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497889661"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Is there a caveat here if the same transaction is announced concurrently by txid and wtxid ? You may have a download collision due to transaction identifier ambiguity.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-01T00:48:20Z",
      "diff_hunk" : "@@ -0,0 +1,195 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497889661",
      "id" : 497889661,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg4OTY2MQ==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 39,
      "original_position" : 39,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 499884175,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497889661",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497891117"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497891117"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I find this confusing. Is \"Announcements\" denoting all Entry under the same txhash or a given (peer/txhash) Entry. In the former, a peer going offline shouldn't carry deletion of other different-peer/same-txhash Entries.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-01T00:50:34Z",
      "diff_hunk" : "@@ -0,0 +1,195 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten when the peer that sent them went offline, when the",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497891117",
      "id" : 497891117,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg5MTExNw==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 42,
      "original_position" : 42,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 499884175,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497891117",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497892403"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497892403"
         }
      },
      "author_association" : "MEMBER",
      "body" : "At least one _what_ ? An attacker controlled-peer, a non-buggy honest preferred connection?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-01T00:52:36Z",
      "diff_hunk" : "@@ -0,0 +1,195 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten when the peer that sent them went offline, when the\n+ *   transaction has been successfully received or is otherwise no longer needed, or when all candidate peers have\n+ *   been tried already.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening transaction censoring attacks. The flip side is that as long as an attacker manages\n+ *              to prevent us from receiving a transaction, failed announcements (including those from honest peers)\n+ *              will linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a\n+ *              cap on the number of tracked announcements per peer. As failed requests in response to announcements\n+ *              from honest peers should be rare, this almost solely hinders attackers.\n+ *              Transaction censoring attacks can be done by announcing transactions quickly while not answering\n+ *              requests for them. See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more\n+ *              information.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable the calling code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers are more trusted by us, so are less likely to be under attacker control.\n+ *\n+ *   - Pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: random assignments are hard to influence for attackers.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and minimizing\n+ * susceptibility to censorship attacks. An attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497892403",
      "id" : 497892403,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg5MjQwMw==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 73,
      "original_position" : 73,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 499884175,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497892403",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497898269"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497898269"
         }
      },
      "author_association" : "MEMBER",
      "body" : "How does entry uniqueness is enforced w.r.t to wtxid/txid ? For segwit txn, the ByPeer can't dissociate between a txid and wtxid announcement, it's different hash ?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-01T01:01:37Z",
      "diff_hunk" : "@@ -0,0 +1,195 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten when the peer that sent them went offline, when the\n+ *   transaction has been successfully received or is otherwise no longer needed, or when all candidate peers have\n+ *   been tried already.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening transaction censoring attacks. The flip side is that as long as an attacker manages\n+ *              to prevent us from receiving a transaction, failed announcements (including those from honest peers)\n+ *              will linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a\n+ *              cap on the number of tracked announcements per peer. As failed requests in response to announcements\n+ *              from honest peers should be rare, this almost solely hinders attackers.\n+ *              Transaction censoring attacks can be done by announcing transactions quickly while not answering\n+ *              requests for them. See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more\n+ *              information.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable the calling code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers are more trusted by us, so are less likely to be under attacker control.\n+ *\n+ *   - Pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: random assignments are hard to influence for attackers.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and minimizing\n+ * susceptibility to censorship attacks. An attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution). The \"1 +\" is due to the fact that the\n+ *   attacker can be the first to announce through a preferred connection in this scenario, which very likely means\n+ *   they get the first request.\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh>=1\n+ *   are honest, where we assume that the attacker can disconnect and reconnect those connections, the distribution\n+ *   becomes k ~ P + NB(p=1-NP/NPh,r=1) (where NB stands for Negative Binomial distribution), which has mean\n+ *   P-1+NP/NPh.\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, and a NOTFOUND or a\n+    //   transaction was received in response (valid or not), or they timed out. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DisconnectedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash (both txid and wtxid ones).\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it.\n+     */\n+    void ForgetTxHash(const uint256& txhash);\n+\n+    /** Adds a new CANDIDATE entry.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that this means a second INV with the same txhash from the same peer will be ignored, even\n+     * if one is a txid and the other is wtxid (but that shouldn't happen, as BIP339 requires that all announced\n+     * inventory is exclusively using MSG_WTX). The new entry is given the specified preferred and reqtime values,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497898269",
      "id" : 497898269,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg5ODI2OQ==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 134,
      "original_position" : 134,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 499884175,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497898269",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497939185"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497939185"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> You can add \"pushback mechanisms (OVERLOADED_PEER_TX_DELAY)\".\r\n\r\nDone.\r\n\r\n> A future improvement of pushback mechanism could be to scale it up by the number of times of MAX_PEER_TX_IN_FLIGHT is reached, like m_txrequest.CountInFlightMagnitude(nodeid, MAX_PEER_TX_IN_FLIGHT) ? Thus delaying further and further a likely-malicious peer.\r\n\r\nYes, there are a number of possibilities there.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-01T02:06:31Z",
      "diff_hunk" : "@@ -71,22 +71,22 @@ static constexpr std::chrono::minutes PING_INTERVAL{2};\n static const unsigned int MAX_LOCATOR_SZ = 101;\n /** The maximum number of entries in an 'inv' protocol message */\n static const unsigned int MAX_INV_SZ = 50000;\n-/** Maximum number of in-flight transactions from a peer */\n+/** Maximum number of in-flight transactions from a peer. It is not a hard limit, but the threshold\n+ *  at which point pushback mechanisms kick in. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497939185",
      "id" : 497939185,
      "in_reply_to_id" : 497859597,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkzOTE4NQ==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 75,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 499965154,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497939185",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497942461"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497942461"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> It's documented in TxRequestTracker specification but I think you could recall that a preferred, txid-relay peer will be always favored on a non-preferred, wtxid-relay one.\r\n\r\nI'd rather not duplicate the explanations; it'll just risk things becoming inconsistent and confusing.\r\n\r\n> So it doesn't matter that all delay penalties are actually 2 seconds. They order peers inside a class, not across ?\r\n\r\nreqtimes don't really order, they set the earliest request time. Actual requests are picked randomly from all announcements past their reqtime (preferred first, then non-preferred).",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-01T02:11:33Z",
      "diff_hunk" : "@@ -806,73 +740,35 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest\n+    NodeId nodeid = node.GetId();\n+    if (!node.HasPermission(PF_RELAY) && m_txrequest.Count(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"overloaded\": if at least MAX_PEER_TX_IN_FLIGHT requests are in flight (and no PF_RELAY).\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or PF_NOBAN permission)\n+    // - \"reqtime\": immediately if none of the penalties below apply, otherwise current time plus:\n+    //   - INBOUND_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for announcements from txid peers while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from overloaded peers\n+    auto delay = std::chrono::microseconds{0};\n+    bool preferred = state->fPreferredDownload;\n+    bool overloaded = !node.HasPermission(PF_RELAY) && m_txrequest.CountInFlight(nodeid) >= MAX_PEER_TX_IN_FLIGHT;\n+    if (!preferred) delay += INBOUND_PEER_TX_DELAY;\n+    if (!gtxid.IsWtxid() && g_wtxid_relay_peers > 0) delay += TXID_RELAY_DELAY;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497942461",
      "id" : 497942461,
      "in_reply_to_id" : 497863468,
      "line" : 775,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk0MjQ2MQ==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 775,
      "original_position" : 216,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 218,
      "pull_request_review_id" : 499966455,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497942461",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497942638"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497942638"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Agree, the current code is just unnecessarily complicated. Fixed.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-01T02:11:52Z",
      "diff_hunk" : "@@ -806,73 +740,35 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest\n+    NodeId nodeid = node.GetId();\n+    if (!node.HasPermission(PF_RELAY) && m_txrequest.Count(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"overloaded\": if at least MAX_PEER_TX_IN_FLIGHT requests are in flight (and no PF_RELAY).\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or PF_NOBAN permission)\n+    // - \"reqtime\": immediately if none of the penalties below apply, otherwise current time plus:\n+    //   - INBOUND_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for announcements from txid peers while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from overloaded peers\n+    auto delay = std::chrono::microseconds{0};\n+    bool preferred = state->fPreferredDownload;\n+    bool overloaded = !node.HasPermission(PF_RELAY) && m_txrequest.CountInFlight(nodeid) >= MAX_PEER_TX_IN_FLIGHT;\n+    if (!preferred) delay += INBOUND_PEER_TX_DELAY;\n+    if (!gtxid.IsWtxid() && g_wtxid_relay_peers > 0) delay += TXID_RELAY_DELAY;\n+    if (overloaded) delay += OVERLOADED_PEER_TX_DELAY;\n+    auto reqtime = delay.count() ? current_time + delay : std::chrono::microseconds::min();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497942638",
      "id" : 497942638,
      "in_reply_to_id" : 497879370,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk0MjYzOA==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 768,
      "original_position" : 218,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 499966537,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497942638",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497943426"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497943426"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't think there is a benefit to giving it a separate lock. There may be one at some point, but probably together with the majority of net_processing moving from cs_main to its own lock(s). At this point, cs_main is already held anyway.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-01T02:13:10Z",
      "diff_hunk" : "@@ -806,73 +740,35 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497943426",
      "id" : 497943426,
      "in_reply_to_id" : 497882360,
      "line" : 757,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk0MzQyNg==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 757,
      "original_position" : 190,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 193,
      "pull_request_review_id" : 499966852,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497943426",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497943680"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497943680"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've removed it, preferredness is explained much better in the .h file now then when this comment was added.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-01T02:13:36Z",
      "diff_hunk" : "@@ -0,0 +1,690 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred (giving it priority higher than non-preferred ones). */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497943680",
      "id" : 497943680,
      "in_reply_to_id" : 497885320,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk0MzY4MA==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 65,
      "original_position" : 65,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 499966953,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497943680",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497943760"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497943760"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-01T02:13:43Z",
      "diff_hunk" : "@@ -0,0 +1,690 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred (giving it priority higher than non-preferred ones). */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    // The two flags below are _per txhash_, and not per announcement. They're part of the Entry\n+    // data structure because having a separate per-txhash map would consume much more memory.\n+    // Only the flags of the last Entry for a given txhash (ByTxHash order) are relevant;\n+    // the other ones are ignored.\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_READY, when no other CANDIDATE_READY or REQUESTED",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497943760",
      "id" : 497943760,
      "in_reply_to_id" : 497887645,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk0Mzc2MA==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 158,
      "original_position" : 158,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 499966987,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497943760",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497946020"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497946020"
         }
      },
      "author_association" : "MEMBER",
      "body" : "As far as txrequest is converned, transactions are identified by its txhash. If there is both a txid and wtxid announcement for the same transaction (and the wtxid differs from the txid), it'll be treated as two transactions, and they could be fetched both. That is exactly the reason why an extra delay for txid announcements was introduced (prior to this PR), to avoid downloading the same thing twice.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-01T02:17:16Z",
      "diff_hunk" : "@@ -0,0 +1,195 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497946020",
      "id" : 497946020,
      "in_reply_to_id" : 497889661,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk0NjAyMA==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 39,
      "original_position" : 39,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 499967975,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497946020",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497947120"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497947120"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This is the specification, there is no concept of Entry here.\r\n\r\nEarlier in the file it says that a txhash/peer combination is called an announcement, so I don't think this is ambiguous.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-01T02:19:04Z",
      "diff_hunk" : "@@ -0,0 +1,195 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten when the peer that sent them went offline, when the",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497947120",
      "id" : 497947120,
      "in_reply_to_id" : 497891117,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk0NzEyMA==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 42,
      "original_position" : 42,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 499968470,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497947120",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497947359"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497947359"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've clarified this, I think.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-01T02:19:24Z",
      "diff_hunk" : "@@ -0,0 +1,195 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten when the peer that sent them went offline, when the\n+ *   transaction has been successfully received or is otherwise no longer needed, or when all candidate peers have\n+ *   been tried already.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening transaction censoring attacks. The flip side is that as long as an attacker manages\n+ *              to prevent us from receiving a transaction, failed announcements (including those from honest peers)\n+ *              will linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a\n+ *              cap on the number of tracked announcements per peer. As failed requests in response to announcements\n+ *              from honest peers should be rare, this almost solely hinders attackers.\n+ *              Transaction censoring attacks can be done by announcing transactions quickly while not answering\n+ *              requests for them. See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more\n+ *              information.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable the calling code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers are more trusted by us, so are less likely to be under attacker control.\n+ *\n+ *   - Pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: random assignments are hard to influence for attackers.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and minimizing\n+ * susceptibility to censorship attacks. An attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497947359",
      "id" : 497947359,
      "in_reply_to_id" : 497892403,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk0NzM1OQ==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 73,
      "original_position" : 73,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 499968562,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497947359",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497948043"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497948043"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think that's explained exactly in this paragraph? \"if one already exists for that (txhash, peer) combination\". Uniqueness is on that combination.\r\n\r\nIf the txhash is the same, it's the same. If they're not, they're not.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-01T02:20:27Z",
      "diff_hunk" : "@@ -0,0 +1,195 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten when the peer that sent them went offline, when the\n+ *   transaction has been successfully received or is otherwise no longer needed, or when all candidate peers have\n+ *   been tried already.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening transaction censoring attacks. The flip side is that as long as an attacker manages\n+ *              to prevent us from receiving a transaction, failed announcements (including those from honest peers)\n+ *              will linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a\n+ *              cap on the number of tracked announcements per peer. As failed requests in response to announcements\n+ *              from honest peers should be rare, this almost solely hinders attackers.\n+ *              Transaction censoring attacks can be done by announcing transactions quickly while not answering\n+ *              requests for them. See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more\n+ *              information.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable the calling code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers are more trusted by us, so are less likely to be under attacker control.\n+ *\n+ *   - Pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: random assignments are hard to influence for attackers.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and minimizing\n+ * susceptibility to censorship attacks. An attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution). The \"1 +\" is due to the fact that the\n+ *   attacker can be the first to announce through a preferred connection in this scenario, which very likely means\n+ *   they get the first request.\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh>=1\n+ *   are honest, where we assume that the attacker can disconnect and reconnect those connections, the distribution\n+ *   becomes k ~ P + NB(p=1-NP/NPh,r=1) (where NB stands for Negative Binomial distribution), which has mean\n+ *   P-1+NP/NPh.\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, and a NOTFOUND or a\n+    //   transaction was received in response (valid or not), or they timed out. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DisconnectedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash (both txid and wtxid ones).\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it.\n+     */\n+    void ForgetTxHash(const uint256& txhash);\n+\n+    /** Adds a new CANDIDATE entry.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that this means a second INV with the same txhash from the same peer will be ignored, even\n+     * if one is a txid and the other is wtxid (but that shouldn't happen, as BIP339 requires that all announced\n+     * inventory is exclusively using MSG_WTX). The new entry is given the specified preferred and reqtime values,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497948043",
      "id" : 497948043,
      "in_reply_to_id" : 497898269,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk0ODA0Mw==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 134,
      "original_position" : 134,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 499968832,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497948043",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497976995"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497976995"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "(replying to resolved thread without marking it unresolved)\r\n\r\nWith \"first\" marker disabled (essentially treating every peer as oveloaded), I got:\r\n\r\n```\r\n 324484 ABCD  requested  preferred=1  first=0  candidates=[-,-]  completed=[-,-] -- 81.7%\r\n  61457 ABCD  requested  preferred=0  first=0  candidates=[-,-]  completed=[-,-] -- 15.5%\r\n    599 ABCD  requested  preferred=0  first=0  candidates=[-,-]  completed=[Y,Y]\r\n    122 ABCD  requested  preferred=0  first=0  candidates=[-,-]  completed=[-,Y]\r\n    110 ABCD  requested  preferred=0  first=0  candidates=[-,-]  completed=[Y,-]\r\n     87 ABCD  requested  preferred=1  first=0  candidates=[-,-]  completed=[Y,Y]\r\n     60 ABCD  requested  preferred=1  first=0  candidates=[-,-]  completed=[Y,-]\r\n     13 ABCD  requested  preferred=1  first=0  candidates=[-,-]  completed=[-,Y]\r\n\r\n   2949 ABCD  requested  preferred=1  first=0  candidates=[-,Y]  completed=[-,-] -- 0.7%\r\n    543 ABCD  requested  preferred=1  first=0  candidates=[-,Y]  completed=[Y,Y]\r\n    214 ABCD  requested  preferred=1  first=0  candidates=[Y,Y]  completed=[Y,Y]\r\n     51 ABCD  requested  preferred=1  first=0  candidates=[Y,Y]  completed=[-,Y]\r\n     24 ABCD  requested  preferred=1  first=0  candidates=[-,Y]  completed=[-,Y]\r\n      5 ABCD  requested  preferred=1  first=0  candidates=[Y,Y]  completed=[Y,-]\r\n      5 ABCD  requested  preferred=1  first=0  candidates=[-,Y]  completed=[Y,-]\r\n      4 ABCD  requested  preferred=1  first=0  candidates=[Y,-]  completed=[Y,Y]\r\n      3 ABCD  requested  preferred=1  first=0  candidates=[Y,-]  completed=[Y,-]\r\n      1 ABCD  requested  preferred=1  first=0  candidates=[Y,-]  completed=[-,Y]\r\n\r\n   3285 ABCD  requested  preferred=0  first=0  candidates=[-,Y]  completed=[-,-] -- 0.8%\r\n   2910 ABCD  requested  preferred=0  first=0  candidates=[-,Y]  completed=[Y,Y] -- 0.7%\r\n    107 ABCD  requested  preferred=0  first=0  candidates=[-,Y]  completed=[-,Y]\r\n      8 ABCD  requested  preferred=0  first=0  candidates=[-,Y]  completed=[Y,-]\r\n```\r\n\r\nI got 561 \"accepted orphan tx\" entries (ignoring the first first hour), compared to 520 last time, which is an 8% increase in orphans compared to running for about 90% longer or doing 54% more requests; so seems like any differences in behaviour are lost in the noise.\r\n\r\nLooking at the per-peer behaviour, one non-preferred peer got a lot of requests:\r\n\r\n```\r\n   1088 ABCD requested preferred=0 peer=8236\r\n   1245 ABCD requested preferred=0 peer=7422\r\n   1470 ABCD requested preferred=0 peer=7219\r\n   1486 ABCD requested preferred=0 peer=7712\r\n   1540 ABCD requested preferred=0 peer=7342\r\n  13124 ABCD requested preferred=0 peer=53\r\n  22367 ABCD requested preferred=0 peer=12516\r\n\r\n    159 ABCD requested preferred=1 peer=20\r\n    166 ABCD requested preferred=1 peer=7\r\n    746 ABCD requested preferred=1 peer=6\r\n  16624 ABCD requested preferred=1 peer=31\r\n  22917 ABCD requested preferred=1 peer=122\r\n  25830 ABCD requested preferred=1 peer=24\r\n  54666 ABCD requested preferred=1 peer=30\r\n  55279 ABCD requested preferred=1 peer=27\r\n  72306 ABCD requested preferred=1 peer=29\r\n  79637 ABCD requested preferred=1 peer=23\r\n```\r\n\r\n(ignores preferred peers that got less than 100 requests, and non-preferred peers that got less than 1000).\r\n\r\nFor peer=12516, almost every request (21625) was when it was the only candidate and no other peer had already been tried for the tx. It looks like it just happened to be fastest most of the time, with plenty of other inbounds (presumably) having already announced when we actually make the request:\r\n\r\n```\r\n      1 delayed=114\r\n...\r\n      7 delayed=60\r\n     12 delayed=59\r\n     12 delayed=58\r\n...\r\n    744 delayed=12\r\n    904 delayed=11\r\n   1025 delayed=10\r\n   1146 delayed=9\r\n   1252 delayed=8\r\n   1389 delayed=7\r\n   1448 delayed=6\r\n   1335 delayed=5\r\n   1354 delayed=4\r\n   1096 delayed=3\r\n    706 delayed=2\r\n    420 delayed=1\r\n    193 delayed=0\r\n```\r\n\r\nResults for peer=53 look pretty similar to me, though it had a higher proportion of announcements where delayed=0 or delayed=1.\r\n\r\nSo I think that just means it's showing a heavy bias towards fast peers/first announcers? The bias part is fine and desirable, but maybe it would be good to reduce the heaviness in future by mildly varying peers' delays, either randomly or based on load in some way? Something to worry about in a followup.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-01T04:28:17Z",
      "diff_hunk" : "@@ -0,0 +1,216 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in). Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              Invblocking is the practice of announcing transactions but not answer requests for them, in order\n+ *              to delay (or prevent) a target learning the transaction. See\n+ *              https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more information.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the first (non-overloaded) peer to have announced the transaction,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497976995",
      "id" : 497976995,
      "in_reply_to_id" : 496379595,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk3Njk5NQ==",
      "original_commit_id" : "9e23f6e106a6e79b1ddf8be09b60a4bc4f5b387e",
      "original_line" : 74,
      "original_position" : 74,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 500000609,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497976995",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497984375"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497984375"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "With this change, if time goes slightly backwards due to a non-monotonic clock, a later announcement may get requested first, even when no delay is intended:\r\n\r\n * t=1.000  peer=1 preferred=1 txid=X --> ReceivedInv --> reqtime=1.000 state=CANDIDATE_DELAYED\r\n * t=0.997  GetRequestable(peer=1) --> (no change)\r\n * t=0.998  peer=2 preferred=1 txid=X --> ReceivedInv --> reqtime=0.999 state=CANDIDATE_DELAYED\r\n * t=0.999  GetRequestable(peer=2) --> peer=2 txid=X state --> CANDIDATE_BEST\r\n\r\nThe previous code would have ensured that when no delay is desired, the announcement will always go to READY or BEST the next time GetRequestable is called.\r\n\r\n(No opinion on whether that edge case is worth the conditional. If it is, might be nice to just pass in (current_time, delay) and have the addition/min done in ReceivedInv though)",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-01T05:00:14Z",
      "diff_hunk" : "@@ -806,73 +740,35 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest\n+    NodeId nodeid = node.GetId();\n+    if (!node.HasPermission(PF_RELAY) && m_txrequest.Count(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"overloaded\": if at least MAX_PEER_TX_IN_FLIGHT requests are in flight (and no PF_RELAY).\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or PF_NOBAN permission)\n+    // - \"reqtime\": immediately if none of the penalties below apply, otherwise current time plus:\n+    //   - INBOUND_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for announcements from txid peers while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from overloaded peers\n+    auto delay = std::chrono::microseconds{0};\n+    bool preferred = state->fPreferredDownload;\n+    bool overloaded = !node.HasPermission(PF_RELAY) && m_txrequest.CountInFlight(nodeid) >= MAX_PEER_TX_IN_FLIGHT;\n+    if (!preferred) delay += INBOUND_PEER_TX_DELAY;\n+    if (!gtxid.IsWtxid() && g_wtxid_relay_peers > 0) delay += TXID_RELAY_DELAY;\n+    if (overloaded) delay += OVERLOADED_PEER_TX_DELAY;\n+    auto reqtime = delay.count() ? current_time + delay : std::chrono::microseconds::min();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r497984375",
      "id" : 497984375,
      "in_reply_to_id" : 497879370,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk4NDM3NQ==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 768,
      "original_position" : 218,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 500009293,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/497984375",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498173969"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498173969"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Question: why wasn't `entry.IsSelectable()` used instead?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-01T11:30:56Z",
      "diff_hunk" : "@@ -0,0 +1,547 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498173969",
      "id" : 498173969,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE3Mzk2OQ==",
      "original_commit_id" : "5411f1fe307bc67f6cfd0787ade933922b133cea",
      "original_line" : 167,
      "original_position" : 167,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 500252767,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498173969",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498342921"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498342921"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I interpret this comment to mean that `ForgetTxHash` i.e. the `TxRequestTracker` is responsible for deleting the transaction by txid and wtxid, but I don't think this is the case... that's `PeerManager`'s job right?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-01T15:41:32Z",
      "diff_hunk" : "@@ -0,0 +1,183 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten when the peer that sent them went offline, when the\n+ *   transaction has been successfully received or is otherwise no longer needed, or when all candidate peers have\n+ *   been tried already.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening transaction censoring attacks. The flip side is that as long as an attacker manages\n+ *              to prevent us from receiving a transaction, failed announcements (including those from honest peers)\n+ *              will linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a\n+ *              cap on the number of tracked announcements per peer. As failed requests in response to announcements\n+ *              from honest peers should be rare, this almost solely hinders attackers.\n+ *              Transaction censoring attacks can be done by announcing transactions quickly while not answering\n+ *              requests for them. See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more\n+ *              information.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable the calling code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers are more trusted by us, so are less likely to be under attacker control.\n+ *\n+ *   - Pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: random assignments are hard to influence for attackers.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and minimizing\n+ * susceptibility to censorship attacks. An attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one preferred connection).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution). The \"1 +\" is due to the fact that the\n+ *   attacker can be the first to announce through a preferred connection in this scenario, which very likely means\n+ *   they get the first request.\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh>=1\n+ *   are honest, where we assume that the attacker can disconnect and reconnect those connections, the distribution\n+ *   becomes k ~ P + NB(p=1-NP/NPh,r=1) (where NB stands for Negative Binomial distribution), which has mean\n+ *   P-1+NP/NPh.\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, and a NOTFOUND or a\n+    //   transaction was received in response (valid or not), or they timed out. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DisconnectedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash (both txid and wtxid ones).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498342921",
      "id" : 498342921,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM0MjkyMQ==",
      "original_commit_id" : "5411f1fe307bc67f6cfd0787ade933922b133cea",
      "original_line" : 127,
      "original_position" : 122,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 500252767,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498342921",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498381797"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498381797"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-01T16:44:13Z",
      "diff_hunk" : "@@ -71,22 +71,22 @@ static constexpr std::chrono::minutes PING_INTERVAL{2};\n static const unsigned int MAX_LOCATOR_SZ = 101;\n /** The maximum number of entries in an 'inv' protocol message */\n static const unsigned int MAX_INV_SZ = 50000;\n-/** Maximum number of in-flight transactions from a peer */\n+/** Maximum number of in-flight transactions from a peer. It is not a hard limit, but the threshold\n+ *  at which point pushback mechanisms kick in. */\n static constexpr int32_t MAX_PEER_TX_IN_FLIGHT = 100;\n-/** Maximum number of announced transactions from a peer */\n-static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 2 * MAX_INV_SZ;\n+/** Maximum number of transactions to consider for requesting, per peer. It provides a reasonable DoS limit to\n+ *  per-peer memory usage spent on announcements, while covering peers continuously sending INVs at the maximum\n+ *  rate (by our own policy, see INVENTORY_BROADCAST_PER_SECOND) for several minutes, while not receiving\n+ *  the actual transaction (from any peer) in response to requests for them. */\n+static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 5000;\n /** How many microseconds to delay requesting transactions via txids, if we have wtxid-relaying peers */\n static constexpr std::chrono::microseconds TXID_RELAY_DELAY{std::chrono::seconds{2}};\n /** How many microseconds to delay requesting transactions from inbound peers */\n static constexpr std::chrono::microseconds INBOUND_PEER_TX_DELAY{std::chrono::seconds{2}};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498381797",
      "id" : 498381797,
      "in_reply_to_id" : 497861187,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM4MTc5Nw==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 85,
      "original_position" : 18,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 500534401,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498381797",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498400043"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498400043"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yes, that was the original reasoning, but I'm not sure clocks going backward is worth extra complexity (it should do something sane, and be tested, but it should be sufficiently rare that the actual behavior doesn't matter too much).",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-01T17:17:43Z",
      "diff_hunk" : "@@ -806,73 +740,35 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest\n+    NodeId nodeid = node.GetId();\n+    if (!node.HasPermission(PF_RELAY) && m_txrequest.Count(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"overloaded\": if at least MAX_PEER_TX_IN_FLIGHT requests are in flight (and no PF_RELAY).\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or PF_NOBAN permission)\n+    // - \"reqtime\": immediately if none of the penalties below apply, otherwise current time plus:\n+    //   - INBOUND_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for announcements from txid peers while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from overloaded peers\n+    auto delay = std::chrono::microseconds{0};\n+    bool preferred = state->fPreferredDownload;\n+    bool overloaded = !node.HasPermission(PF_RELAY) && m_txrequest.CountInFlight(nodeid) >= MAX_PEER_TX_IN_FLIGHT;\n+    if (!preferred) delay += INBOUND_PEER_TX_DELAY;\n+    if (!gtxid.IsWtxid() && g_wtxid_relay_peers > 0) delay += TXID_RELAY_DELAY;\n+    if (overloaded) delay += OVERLOADED_PEER_TX_DELAY;\n+    auto reqtime = delay.count() ? current_time + delay : std::chrono::microseconds::min();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498400043",
      "id" : 498400043,
      "in_reply_to_id" : 497879370,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwMDA0Mw==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 768,
      "original_position" : 218,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 500559999,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498400043",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498407749"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498407749"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In https://github.com/bitcoin/bitcoin/pull/19988/commits/987b27176e41f38b997f7b732f087a518fa678ca\r\n\r\nPlease forgive me but I just want to make sure I'm understanding this commit correctly... we want to add a delay for transactions by txid just in case we're able to get it by wtxid from another peer. But when we get an orphan, we only have the txid of the missing parent.\r\n-Using the logic of peer's `m_wtxid_relay` doesn't apply to requests for missing parents because we can only request by txid, even if the peer is wtxid relay?\r\n-But using transaction's `IsWtxid` means we're interested in potentially receiving the missing parent (from anyone) as a wtxid relay before we ask this peer for the missing parent?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-01T17:31:38Z",
      "diff_hunk" : "@@ -763,7 +763,7 @@ void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono\n     bool preferred = state->fPreferredDownload;\n     bool overloaded = !node.HasPermission(PF_RELAY) && m_txrequest.CountInFlight(nodeid) >= MAX_PEER_TX_IN_FLIGHT;\n     if (!preferred) delay += NONPREF_PEER_TX_DELAY;\n-    if (!state->m_wtxid_relay && g_wtxid_relay_peers > 0) delay += TXID_RELAY_DELAY;\n+    if (!gtxid.IsWtxid() && g_wtxid_relay_peers > 0) delay += TXID_RELAY_DELAY;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498407749",
      "id" : 498407749,
      "line" : 775,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwNzc0OQ==",
      "original_commit_id" : "987b27176e41f38b997f7b732f087a518fa678ca",
      "original_line" : 775,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 218,
      "pull_request_review_id" : 500252767,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498407749",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498422091"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498422091"
         }
      },
      "author_association" : "MEMBER",
      "body" : "That would also compute the priority for entries in the CANDIDATE_BEST state. That would be harmless as it wouldn't change behavior, but the computation of priority isn't exactly free either, so better avoid it when not needed.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-01T17:57:53Z",
      "diff_hunk" : "@@ -0,0 +1,547 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498422091",
      "id" : 498422091,
      "in_reply_to_id" : 498173969,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyMjA5MQ==",
      "original_commit_id" : "5411f1fe307bc67f6cfd0787ade933922b133cea",
      "original_line" : 167,
      "original_position" : 167,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 500590154,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498422091",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498427113"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498427113"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`TxRequestTracker` is a data structure that manages the set of announced txids/wtxids for all peers, exposes ways to alter that set, and answers queries about it. Its responsibility is maintaining the consistency of that data structure, and doing as it's told; it isn't responsible for deciding what mutations to make and when; that's net_processing's job.\r\n\r\nThis function is the mutator that removes all entries with a given txid or wtxid. It does just that. Net_processing calls it whenever it is no longer interested in a particular txid/wtxid.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-01T18:07:32Z",
      "diff_hunk" : "@@ -0,0 +1,183 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten when the peer that sent them went offline, when the\n+ *   transaction has been successfully received or is otherwise no longer needed, or when all candidate peers have\n+ *   been tried already.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening transaction censoring attacks. The flip side is that as long as an attacker manages\n+ *              to prevent us from receiving a transaction, failed announcements (including those from honest peers)\n+ *              will linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a\n+ *              cap on the number of tracked announcements per peer. As failed requests in response to announcements\n+ *              from honest peers should be rare, this almost solely hinders attackers.\n+ *              Transaction censoring attacks can be done by announcing transactions quickly while not answering\n+ *              requests for them. See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more\n+ *              information.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable the calling code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers are more trusted by us, so are less likely to be under attacker control.\n+ *\n+ *   - Pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: random assignments are hard to influence for attackers.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and minimizing\n+ * susceptibility to censorship attacks. An attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one preferred connection).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution). The \"1 +\" is due to the fact that the\n+ *   attacker can be the first to announce through a preferred connection in this scenario, which very likely means\n+ *   they get the first request.\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh>=1\n+ *   are honest, where we assume that the attacker can disconnect and reconnect those connections, the distribution\n+ *   becomes k ~ P + NB(p=1-NP/NPh,r=1) (where NB stands for Negative Binomial distribution), which has mean\n+ *   P-1+NP/NPh.\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, and a NOTFOUND or a\n+    //   transaction was received in response (valid or not), or they timed out. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DisconnectedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash (both txid and wtxid ones).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498427113",
      "id" : 498427113,
      "in_reply_to_id" : 498342921,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyNzExMw==",
      "original_commit_id" : "5411f1fe307bc67f6cfd0787ade933922b133cea",
      "original_line" : 127,
      "original_position" : 122,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 500597252,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498427113",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498435998"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498435998"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Imagine we have multiple announcements for the same witness transaction, and all peers have different witnesses for it. So the transaction will be known by one txid, but multiple distinct wtxids. We don't know that these are all for the same transaction, as all the (non-txid) requests have different hashes.\r\n\r\nNo matter who we ask, or what we receive, we'll always be able to delete all txid-based announcements for it (we'll compute the txid of the received transaction, which will be the same for all). However, we can't delete all wtxid announcements, only the one for the wtxid announcement for the witness we actually received. Thus we want to prioritize fetching by wtxid, as a successful response to that will allow us to delete at least one wtxid-based announcements + plus all txid-based announcements (while a txid based request only guarantees deleting all txid-based announcements).\r\n\r\nNow imagine that instead all our peers are BIP339 (wtxid) peers, and there are transactions A and B, where B spends one of A's outputs. For most peers, we receive A first and then B. But from one peer, we only receive B (e.g. because we just connected and weren't connected when A was sent), and B is fetched first. That makes it an orphan, and its \"prevout\" entry in its input for A is treated as a txid announcement (we don't have its wtxid), despite being from a wtxid peer. Thus we end up with a txid announcement for A, and a bunch of wtxid announcements for it (from the other peers). The same reasoning applies here: we want to fetch by one of the wtxid ones first, because it is guaranteed to allow us to forget the txid announcement PLUS at least one wtxid one.\r\n",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-01T18:24:30Z",
      "diff_hunk" : "@@ -763,7 +763,7 @@ void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono\n     bool preferred = state->fPreferredDownload;\n     bool overloaded = !node.HasPermission(PF_RELAY) && m_txrequest.CountInFlight(nodeid) >= MAX_PEER_TX_IN_FLIGHT;\n     if (!preferred) delay += NONPREF_PEER_TX_DELAY;\n-    if (!state->m_wtxid_relay && g_wtxid_relay_peers > 0) delay += TXID_RELAY_DELAY;\n+    if (!gtxid.IsWtxid() && g_wtxid_relay_peers > 0) delay += TXID_RELAY_DELAY;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498435998",
      "id" : 498435998,
      "in_reply_to_id" : 498407749,
      "line" : 775,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQzNTk5OA==",
      "original_commit_id" : "987b27176e41f38b997f7b732f087a518fa678ca",
      "original_line" : 775,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 218,
      "pull_request_review_id" : 500609234,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498435998",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498569001"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498569001"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Okay so the only download duplication we may have is if any preferred, wtxid-relay peers is really slow, requiring from a txid-relay peer and receiving both. Really a edge case once the network is sufficiently upgraded I guess.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T00:09:03Z",
      "diff_hunk" : "@@ -0,0 +1,195 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498569001",
      "id" : 498569001,
      "in_reply_to_id" : 497889661,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU2OTAwMQ==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 39,
      "original_position" : 39,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 500794251,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498569001",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498569749"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498569749"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think I hurted on \"Note that this means a second INV with the same txhash from the same peer will be ignored, even if one is a txid and the other is wtxid\". I interpreted it \"As if first is txid, does nothing even if a second announcement is wtxid\". That's my English here, nevermind.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T00:12:37Z",
      "diff_hunk" : "@@ -0,0 +1,195 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten when the peer that sent them went offline, when the\n+ *   transaction has been successfully received or is otherwise no longer needed, or when all candidate peers have\n+ *   been tried already.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening transaction censoring attacks. The flip side is that as long as an attacker manages\n+ *              to prevent us from receiving a transaction, failed announcements (including those from honest peers)\n+ *              will linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a\n+ *              cap on the number of tracked announcements per peer. As failed requests in response to announcements\n+ *              from honest peers should be rare, this almost solely hinders attackers.\n+ *              Transaction censoring attacks can be done by announcing transactions quickly while not answering\n+ *              requests for them. See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more\n+ *              information.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable the calling code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers are more trusted by us, so are less likely to be under attacker control.\n+ *\n+ *   - Pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: random assignments are hard to influence for attackers.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and minimizing\n+ * susceptibility to censorship attacks. An attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution). The \"1 +\" is due to the fact that the\n+ *   attacker can be the first to announce through a preferred connection in this scenario, which very likely means\n+ *   they get the first request.\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh>=1\n+ *   are honest, where we assume that the attacker can disconnect and reconnect those connections, the distribution\n+ *   becomes k ~ P + NB(p=1-NP/NPh,r=1) (where NB stands for Negative Binomial distribution), which has mean\n+ *   P-1+NP/NPh.\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, and a NOTFOUND or a\n+    //   transaction was received in response (valid or not), or they timed out. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DisconnectedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash (both txid and wtxid ones).\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it.\n+     */\n+    void ForgetTxHash(const uint256& txhash);\n+\n+    /** Adds a new CANDIDATE entry.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that this means a second INV with the same txhash from the same peer will be ignored, even\n+     * if one is a txid and the other is wtxid (but that shouldn't happen, as BIP339 requires that all announced\n+     * inventory is exclusively using MSG_WTX). The new entry is given the specified preferred and reqtime values,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498569749",
      "id" : 498569749,
      "in_reply_to_id" : 497898269,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU2OTc0OQ==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 134,
      "original_position" : 134,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 500795233,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498569749",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498570981"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498570981"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Just so we're on the same page. The scenario is:\r\n* Peer P announces txid H\r\n* Peer P announces wtxid H\r\n\r\nIn this case, the second announcement is ignored, because one already exists for peer/txhash combination (P, H). This is harmless for two reasons:\r\n* The txid and wtxid being identical implies it's a non-segwit transaction, so it doesn't matter how we fetch.\r\n* BIP339 prescribes that all announcements have to be wtxid when enabled (though I now realize that orphan fetching could actually mean this can actually still occur; I'll improve the comment).",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T00:18:25Z",
      "diff_hunk" : "@@ -0,0 +1,195 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten when the peer that sent them went offline, when the\n+ *   transaction has been successfully received or is otherwise no longer needed, or when all candidate peers have\n+ *   been tried already.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening transaction censoring attacks. The flip side is that as long as an attacker manages\n+ *              to prevent us from receiving a transaction, failed announcements (including those from honest peers)\n+ *              will linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a\n+ *              cap on the number of tracked announcements per peer. As failed requests in response to announcements\n+ *              from honest peers should be rare, this almost solely hinders attackers.\n+ *              Transaction censoring attacks can be done by announcing transactions quickly while not answering\n+ *              requests for them. See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more\n+ *              information.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable the calling code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers are more trusted by us, so are less likely to be under attacker control.\n+ *\n+ *   - Pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: random assignments are hard to influence for attackers.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and minimizing\n+ * susceptibility to censorship attacks. An attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution). The \"1 +\" is due to the fact that the\n+ *   attacker can be the first to announce through a preferred connection in this scenario, which very likely means\n+ *   they get the first request.\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh>=1\n+ *   are honest, where we assume that the attacker can disconnect and reconnect those connections, the distribution\n+ *   becomes k ~ P + NB(p=1-NP/NPh,r=1) (where NB stands for Negative Binomial distribution), which has mean\n+ *   P-1+NP/NPh.\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, and a NOTFOUND or a\n+    //   transaction was received in response (valid or not), or they timed out. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DisconnectedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash (both txid and wtxid ones).\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it.\n+     */\n+    void ForgetTxHash(const uint256& txhash);\n+\n+    /** Adds a new CANDIDATE entry.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that this means a second INV with the same txhash from the same peer will be ignored, even\n+     * if one is a txid and the other is wtxid (but that shouldn't happen, as BIP339 requires that all announced\n+     * inventory is exclusively using MSG_WTX). The new entry is given the specified preferred and reqtime values,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498570981",
      "id" : 498570981,
      "in_reply_to_id" : 497898269,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU3MDk4MQ==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 134,
      "original_position" : 134,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 500796853,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498570981",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498572854"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498572854"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't expect it to be super rare, but the risk of double fetching during rollout is inherent to BIP339 (and exists in the same form in current master, so I don't think it's significantly affected by this PR).",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T00:27:38Z",
      "diff_hunk" : "@@ -0,0 +1,195 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498572854",
      "id" : 498572854,
      "in_reply_to_id" : 497889661,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU3Mjg1NA==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 39,
      "original_position" : 39,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 500799302,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498572854",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498575252"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498575252"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've elaborated this a bit. Is it clearer now?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T00:39:39Z",
      "diff_hunk" : "@@ -0,0 +1,195 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten when the peer that sent them went offline, when the",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498575252",
      "id" : 498575252,
      "in_reply_to_id" : 497891117,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU3NTI1Mg==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 42,
      "original_position" : 42,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 500802396,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498575252",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498575310"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498575310"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Added a note about this.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T00:39:53Z",
      "diff_hunk" : "@@ -0,0 +1,195 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498575310",
      "id" : 498575310,
      "in_reply_to_id" : 497889661,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU3NTMxMA==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 39,
      "original_position" : 39,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 500802467,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498575310",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498575373"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498575373"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've rewritten the comment.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T00:40:17Z",
      "diff_hunk" : "@@ -0,0 +1,195 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten when the peer that sent them went offline, when the\n+ *   transaction has been successfully received or is otherwise no longer needed, or when all candidate peers have\n+ *   been tried already.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening transaction censoring attacks. The flip side is that as long as an attacker manages\n+ *              to prevent us from receiving a transaction, failed announcements (including those from honest peers)\n+ *              will linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a\n+ *              cap on the number of tracked announcements per peer. As failed requests in response to announcements\n+ *              from honest peers should be rare, this almost solely hinders attackers.\n+ *              Transaction censoring attacks can be done by announcing transactions quickly while not answering\n+ *              requests for them. See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more\n+ *              information.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable the calling code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers are more trusted by us, so are less likely to be under attacker control.\n+ *\n+ *   - Pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: random assignments are hard to influence for attackers.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and minimizing\n+ * susceptibility to censorship attacks. An attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution). The \"1 +\" is due to the fact that the\n+ *   attacker can be the first to announce through a preferred connection in this scenario, which very likely means\n+ *   they get the first request.\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh>=1\n+ *   are honest, where we assume that the attacker can disconnect and reconnect those connections, the distribution\n+ *   becomes k ~ P + NB(p=1-NP/NPh,r=1) (where NB stands for Negative Binomial distribution), which has mean\n+ *   P-1+NP/NPh.\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, and a NOTFOUND or a\n+    //   transaction was received in response (valid or not), or they timed out. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DisconnectedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash (both txid and wtxid ones).\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it.\n+     */\n+    void ForgetTxHash(const uint256& txhash);\n+\n+    /** Adds a new CANDIDATE entry.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that this means a second INV with the same txhash from the same peer will be ignored, even\n+     * if one is a txid and the other is wtxid (but that shouldn't happen, as BIP339 requires that all announced\n+     * inventory is exclusively using MSG_WTX). The new entry is given the specified preferred and reqtime values,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498575373",
      "id" : 498575373,
      "in_reply_to_id" : 497898269,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU3NTM3Mw==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 134,
      "original_position" : 134,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 500802554,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498575373",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498644419"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498644419"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\nstatic constexpr std::chrono::seconds NONPREF_PEER_TX_DELAY{2};\r\n```\r\n\r\nThis can be written shorter, as the compiler will do the chrono conversion for you\r\n\r\n(Same below)",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T06:55:31Z",
      "diff_hunk" : "@@ -71,22 +71,22 @@ static constexpr std::chrono::minutes PING_INTERVAL{2};\n static const unsigned int MAX_LOCATOR_SZ = 101;\n /** The maximum number of entries in an 'inv' protocol message */\n static const unsigned int MAX_INV_SZ = 50000;\n-/** Maximum number of in-flight transactions from a peer */\n+/** Maximum number of in-flight transactions from a peer. It is not a hard limit, but the threshold\n+ *  at which point the OVERLOADED_PEER_TX_DELAY kicks in. */\n static constexpr int32_t MAX_PEER_TX_IN_FLIGHT = 100;\n-/** Maximum number of announced transactions from a peer */\n-static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 2 * MAX_INV_SZ;\n+/** Maximum number of transactions to consider for requesting, per peer. It provides a reasonable DoS limit to\n+ *  per-peer memory usage spent on announcements, while covering peers continuously sending INVs at the maximum\n+ *  rate (by our own policy, see INVENTORY_BROADCAST_PER_SECOND) for several minutes, while not receiving\n+ *  the actual transaction (from any peer) in response to requests for them. */\n+static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 5000;\n /** How many microseconds to delay requesting transactions via txids, if we have wtxid-relaying peers */\n static constexpr std::chrono::microseconds TXID_RELAY_DELAY{std::chrono::seconds{2}};\n-/** How many microseconds to delay requesting transactions from inbound peers */\n-static constexpr std::chrono::microseconds INBOUND_PEER_TX_DELAY{std::chrono::seconds{2}};\n+/** How many microseconds to delay requesting transactions from non-preferred peers */\n+static constexpr std::chrono::microseconds NONPREF_PEER_TX_DELAY{std::chrono::seconds{2}};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498644419",
      "id" : 498644419,
      "line" : 85,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY0NDQxOQ==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 85,
      "original_position" : 20,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 21,
      "pull_request_review_id" : 500895273,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T14:11:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498644419",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498699913"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498699913"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`==()` doesn't need to be a friend, since it's not accessing any private/protected members:\r\n\r\n```diff\r\ndiff --git a/src/txrequest.cpp b/src/txrequest.cpp\r\nindex bef3460dd6..b7347d8d34 100644\r\n--- a/src/txrequest.cpp\r\n+++ b/src/txrequest.cpp\r\n@@ -206,14 +206,15 @@ struct PeerInfo {\r\n     size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\r\n     size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\r\n \r\n-    /** Compare two PeerInfo objects. Only used for sanity checking. */\r\n-    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\r\n-    {\r\n-        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\r\n-               std::tie(b.m_total, b.m_completed, b.m_requested);\r\n-    }\r\n };\r\n \r\n+/** Compare two PeerInfo objects. Only used for sanity checking. */\r\n+bool operator==(const PeerInfo& a, const PeerInfo& b)\r\n+{\r\n+    return std::tie(a.m_total, a.m_completed, a.m_requested) ==\r\n+           std::tie(b.m_total, b.m_completed, b.m_requested);\r\n+}\r\n+\r\n```\r\n\r\nFeels slightly clearer to me, but obviously doesn't make much difference.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T08:58:53Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498699913",
      "id" : 498699913,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY5OTkxMw==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 210,
      "original_position" : 210,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 500968997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498699913",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498708036"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498708036"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This is really just a stylistic thing, but is there a reason to make any members of an impl class private? By definition it doesn't have an exposed interface, so theoretically everything could just be public. The first two examples at https://en.cppreference.com/w/cpp/language/pimpl are actually declared as `struct`s (although the third example does have a private data member)",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T09:15:18Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+public:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498708036",
      "id" : 498708036,
      "line" : 318,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcwODAzNg==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 318,
      "original_position" : 293,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 318,
      "pull_request_review_id" : 500968997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498708036",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498714760"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498714760"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Is there a reason not to use `NodeId` throughout instead of `uint64_t`? It seems to me that `NodeId` would be more consistent with net/net_processing, and more readable in function signatures/returns types/typedefs.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T09:29:12Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498714760",
      "id" : 498714760,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcxNDc2MA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 62,
      "original_position" : 62,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 500968997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498714760",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498718932"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498718932"
         }
      },
      "author_association" : "MEMBER",
      "body" : "s/takes it/takes its/",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T09:38:19Z",
      "diff_hunk" : "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction. Note that this only works\n+ *              per txhash, so if the same transaction is announced both through txid and wtxid, we have no means\n+ *              to prevent fetching both (the caller can however mitigate this by delaying one, see further).\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten only:\n+ *   - If a peer goes offline, all its announcements are forgotten.\n+ *   - If a transaction has been successfully received, or is otherwise no longer needed, the caller can call\n+ *     ForgetTxHash, which removes all announcements across all peers with the specified txhash.\n+ *   - If for a given txhash only already-requested announcements remain, they are all forgotten.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening transaction censoring attacks. The flip side is that as long as an attacker manages\n+ *              to prevent us from receiving a transaction, failed announcements (including those from honest peers)\n+ *              will linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a\n+ *              cap on the number of tracked announcements per peer. As failed requests in response to announcements\n+ *              from honest peers should be rare, this almost solely hinders attackers.\n+ *              Transaction censoring attacks can be done by announcing transactions quickly while not answering\n+ *              requests for them. See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more\n+ *              information.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable the calling code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers are more trusted by us, so are less likely to be under attacker control.\n+ *\n+ *   - Pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: random assignments are hard to influence for attackers.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and minimizing\n+ * susceptibility to censorship attacks. An attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one preferred connection).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution). The \"1 +\" is due to the fact that the\n+ *   attacker can be the first to announce through a preferred connection in this scenario, which very likely means\n+ *   they get the first request.\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh>=1\n+ *   are honest, where we assume that the attacker can disconnect and reconnect those connections, the distribution\n+ *   becomes k ~ P + NB(p=1-NP/NPh,r=1) (where NB stands for Negative Binomial distribution), which has mean\n+ *   P-1+NP/NPh.\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, and a NOTFOUND or a\n+    //   transaction was received in response (valid or not), or they timed out. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DisconnectedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash (both txid and wtxid ones).\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it.\n+     */\n+    void ForgetTxHash(const uint256& txhash);\n+\n+    /** Adds a new CANDIDATE announcement.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that the txid/wtxid property is ignored for determining uniqueness, so if an announcement\n+     * is added for a wtxid H, while one for txid H from the same peer already exists, it will be ignored. This is\n+     * harmless as the txhashes being equal implies it is a non-segwit transaction, so it doesn't matter how it is\n+     * fetched. The new announcement is given the specified preferred and reqtime values, and takes it is_wtxid from",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498718932",
      "id" : 498718932,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcxODkzMg==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 139,
      "original_position" : 139,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 500968997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498718932",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498723043"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498723043"
         }
      },
      "author_association" : "MEMBER",
      "body" : "s/AlreadyHave/ForgetTxHash/",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T09:47:07Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo entries exist with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+\n+            // Looking up the last ByTxHash entry with the given txhash must return an Entry with that txhash or the\n+            // multi_index is very bad.\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{item.first, State::TOO_LARGE, 0}));\n+            assert(it_last != m_index.get<ByTxHash>().end() && it_last->m_txhash == item.first);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+\n+private:\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txhash that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txhash already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = m_computer(*std::prev(it));\n+            uint64_t priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in\n+            // the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Entry for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED entries.\n+\n+        // If this Entry's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Entry's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txhash, they are\n+     *  deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+     *  CANDIDATE_BEST. Returns whether the Entry still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED entry for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the entry COMPLETED, and select the next best entry (the first CANDIDATE_READY) if needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to EntryTxHashExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(EntryPeerExtractor(), std::less<EntryPeer>()),\n+            boost::make_tuple(EntryTxHashExtractor(m_computer), std::less<EntryTxHash>()),\n+            boost::make_tuple(EntryTimeExtractor(), std::less<EntryTime>())\n+        )) {}\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxHashExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+            // CANDIDATE_BEST, or delete all of a txhash's entries if no non-COMPLETED ones are left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(EntryTxHash{txhash, State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST entry for this (txhash, peer) combination. The case where\n+        // there is a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+        // automatically.\n+        if (m_index.get<ByPeer>().count(EntryPeer{peer, true, gtxid.GetHash()})) return;\n+\n+        // Find last entry for this txhash, and extract per-txhash information from it.\n+        Iter<ByTxHash> it_last = m_index.get<ByTxHash>().end();\n+        // First find the first entry past this txhash.\n+        it_last = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0});\n+        if (it_last != m_index.get<ByTxHash>().begin() && std::prev(it_last)->m_txhash == gtxid.GetHash()) {\n+            it_last--;\n+        } else {\n+            // No entry for this txhash exists yet.\n+            it_last = m_index.get<ByTxHash>().end();\n+        }\n+\n+        // Try creating the entry with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST entry already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_sequence);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+    }\n+\n+    //! Find the GenTxids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now)\n+    {\n+        // Move time.\n+        SetTimePoint(now);\n+\n+        // Find all CANDIDATE_BEST entries for this peer.\n+        std::vector<std::pair<uint64_t, const Entry*>> selected;\n+        auto it_peer = m_index.get<ByPeer>().lower_bound(EntryPeer{peer, true, UINT256_ZERO});\n+        while (it_peer != m_index.get<ByPeer>().end() && it_peer->m_peer == peer &&\n+            it_peer->GetState() == State::CANDIDATE_BEST) {\n+            selected.emplace_back(it_peer->m_sequence, &*it_peer);\n+            ++it_peer;\n+        }\n+\n+        // Return them, sorted by sequence number.\n+        std::sort(selected.begin(), selected.end());\n+        std::vector<GenTxid> ret;\n+        for (const auto& item : selected) {\n+            ret.emplace_back(item.second->m_is_wtxid, item.second->m_txhash);\n+        }\n+        return ret;\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds expiry)\n+    {\n+        auto it = m_index.get<ByPeer>().find(EntryPeer{peer, true, gtxid.GetHash()});\n+        // RequestedTx can only be called on CANDIDATE_BEST entries (this is implied by its condition that it can\n+        // only be called on GenTxids returned by GetRequestable (and only AlreadyHave and RequestedTx can be called",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498723043",
      "id" : 498723043,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcyMzA0Mw==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 587,
      "original_position" : 587,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 500968997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498723043",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498725131"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498725131"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Delete all this. It's no longer needed now that there's no 'first' marker.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T09:51:30Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo entries exist with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+\n+            // Looking up the last ByTxHash entry with the given txhash must return an Entry with that txhash or the\n+            // multi_index is very bad.\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{item.first, State::TOO_LARGE, 0}));\n+            assert(it_last != m_index.get<ByTxHash>().end() && it_last->m_txhash == item.first);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+\n+private:\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txhash that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txhash already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = m_computer(*std::prev(it));\n+            uint64_t priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in\n+            // the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Entry for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED entries.\n+\n+        // If this Entry's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Entry's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txhash, they are\n+     *  deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+     *  CANDIDATE_BEST. Returns whether the Entry still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED entry for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the entry COMPLETED, and select the next best entry (the first CANDIDATE_READY) if needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to EntryTxHashExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(EntryPeerExtractor(), std::less<EntryPeer>()),\n+            boost::make_tuple(EntryTxHashExtractor(m_computer), std::less<EntryTxHash>()),\n+            boost::make_tuple(EntryTimeExtractor(), std::less<EntryTime>())\n+        )) {}\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxHashExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+            // CANDIDATE_BEST, or delete all of a txhash's entries if no non-COMPLETED ones are left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(EntryTxHash{txhash, State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST entry for this (txhash, peer) combination. The case where\n+        // there is a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+        // automatically.\n+        if (m_index.get<ByPeer>().count(EntryPeer{peer, true, gtxid.GetHash()})) return;\n+\n+        // Find last entry for this txhash, and extract per-txhash information from it.\n+        Iter<ByTxHash> it_last = m_index.get<ByTxHash>().end();\n+        // First find the first entry past this txhash.\n+        it_last = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0});\n+        if (it_last != m_index.get<ByTxHash>().begin() && std::prev(it_last)->m_txhash == gtxid.GetHash()) {\n+            it_last--;\n+        } else {\n+            // No entry for this txhash exists yet.\n+            it_last = m_index.get<ByTxHash>().end();\n+        }\n+\n+        // Try creating the entry with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST entry already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_sequence);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+    }\n+\n+    //! Find the GenTxids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now)\n+    {\n+        // Move time.\n+        SetTimePoint(now);\n+\n+        // Find all CANDIDATE_BEST entries for this peer.\n+        std::vector<std::pair<uint64_t, const Entry*>> selected;\n+        auto it_peer = m_index.get<ByPeer>().lower_bound(EntryPeer{peer, true, UINT256_ZERO});\n+        while (it_peer != m_index.get<ByPeer>().end() && it_peer->m_peer == peer &&\n+            it_peer->GetState() == State::CANDIDATE_BEST) {\n+            selected.emplace_back(it_peer->m_sequence, &*it_peer);\n+            ++it_peer;\n+        }\n+\n+        // Return them, sorted by sequence number.\n+        std::sort(selected.begin(), selected.end());\n+        std::vector<GenTxid> ret;\n+        for (const auto& item : selected) {\n+            ret.emplace_back(item.second->m_is_wtxid, item.second->m_txhash);\n+        }\n+        return ret;\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds expiry)\n+    {\n+        auto it = m_index.get<ByPeer>().find(EntryPeer{peer, true, gtxid.GetHash()});\n+        // RequestedTx can only be called on CANDIDATE_BEST entries (this is implied by its condition that it can\n+        // only be called on GenTxids returned by GetRequestable (and only AlreadyHave and RequestedTx can be called\n+        // in between, which preserve the state of other GenTxids).\n+        assert(it != m_index.get<ByPeer>().end());\n+        assert(it->GetState() == State::CANDIDATE_BEST);\n+        Modify<ByPeer>(it, [expiry](Entry& entry) {\n+            entry.SetState(State::REQUESTED);\n+            entry.m_time = expiry;\n+        });\n+\n+        // Update the per-txhash data (of the last Entry for this txhash) to reflect that new ones are no longer\n+        // eligible for the \"first\" marker.\n+        auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0}));\n+        assert(it_last->m_txhash == gtxid.GetHash());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498725131",
      "id" : 498725131,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcyNTEzMQ==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 599,
      "original_position" : 599,
      "original_start_line" : 595,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 500968997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498725131",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498727923"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498727923"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Delete",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T09:57:24Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498727923",
      "id" : 498727923,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcyNzkyMw==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 278,
      "original_position" : 269,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 500968997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498727923",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498732054"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498732054"
         }
      },
      "author_association" : "MEMBER",
      "body" : "s/ForgetTx/ForgetTxHash/",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T10:06:56Z",
      "diff_hunk" : "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction. Note that this only works\n+ *              per txhash, so if the same transaction is announced both through txid and wtxid, we have no means\n+ *              to prevent fetching both (the caller can however mitigate this by delaying one, see further).\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten only:\n+ *   - If a peer goes offline, all its announcements are forgotten.\n+ *   - If a transaction has been successfully received, or is otherwise no longer needed, the caller can call\n+ *     ForgetTxHash, which removes all announcements across all peers with the specified txhash.\n+ *   - If for a given txhash only already-requested announcements remain, they are all forgotten.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening transaction censoring attacks. The flip side is that as long as an attacker manages\n+ *              to prevent us from receiving a transaction, failed announcements (including those from honest peers)\n+ *              will linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a\n+ *              cap on the number of tracked announcements per peer. As failed requests in response to announcements\n+ *              from honest peers should be rare, this almost solely hinders attackers.\n+ *              Transaction censoring attacks can be done by announcing transactions quickly while not answering\n+ *              requests for them. See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more\n+ *              information.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable the calling code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers are more trusted by us, so are less likely to be under attacker control.\n+ *\n+ *   - Pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: random assignments are hard to influence for attackers.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and minimizing\n+ * susceptibility to censorship attacks. An attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one preferred connection).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution). The \"1 +\" is due to the fact that the\n+ *   attacker can be the first to announce through a preferred connection in this scenario, which very likely means\n+ *   they get the first request.\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh>=1\n+ *   are honest, where we assume that the attacker can disconnect and reconnect those connections, the distribution\n+ *   becomes k ~ P + NB(p=1-NP/NPh,r=1) (where NB stands for Negative Binomial distribution), which has mean\n+ *   P-1+NP/NPh.\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, and a NOTFOUND or a\n+    //   transaction was received in response (valid or not), or they timed out. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DisconnectedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash (both txid and wtxid ones).\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it.\n+     */\n+    void ForgetTxHash(const uint256& txhash);\n+\n+    /** Adds a new CANDIDATE announcement.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that the txid/wtxid property is ignored for determining uniqueness, so if an announcement\n+     * is added for a wtxid H, while one for txid H from the same peer already exists, it will be ignored. This is\n+     * harmless as the txhashes being equal implies it is a non-segwit transaction, so it doesn't matter how it is\n+     * fetched. The new announcement is given the specified preferred and reqtime values, and takes it is_wtxid from\n+     * the specified gtxid.\n+     */\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime);\n+\n+    /** Converts the CANDIDATE announcement for the provided peer and gtxid into a REQUESTED one.\n+     *\n+     * Expiry is set to the specified value. This can ONLY be called immediately after GetRequestable was called\n+     * (for the same peer), with only ForgetTx and other RequestedTx calls (both for other txhashes) in",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498732054",
      "id" : 498732054,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODczMjA1NA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 148,
      "original_position" : 148,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 500968997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498732054",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498734530"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498734530"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Possible changes to this interface:\r\n\r\n1. Change the `GenTxid` argument to `uint256`. The function doesn't make any distinction between txids and wtxids, so why make it part of the interface?\r\n2. Pass a `const std::vector<uint256>&`, with all txs that have been requested, rather than repeatedly calling the same function with different tx hashes.\r\n3. Also pass in a `const std::vector<uint256>& hashes_to_forget`, with all txs to forget.\r\n\r\nDoing all of those would change the condition \"This can ONLY be called immediately after GetRequestable was called (for the same peer), with only ForgetTxHash and other RequestedTx calls (both for other txhashes) in between.\" to the much stronger condition \"This can ONLY be called immediately after a GetRequestable call with no other calls in between\".",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T10:12:29Z",
      "diff_hunk" : "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction. Note that this only works\n+ *              per txhash, so if the same transaction is announced both through txid and wtxid, we have no means\n+ *              to prevent fetching both (the caller can however mitigate this by delaying one, see further).\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten only:\n+ *   - If a peer goes offline, all its announcements are forgotten.\n+ *   - If a transaction has been successfully received, or is otherwise no longer needed, the caller can call\n+ *     ForgetTxHash, which removes all announcements across all peers with the specified txhash.\n+ *   - If for a given txhash only already-requested announcements remain, they are all forgotten.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening transaction censoring attacks. The flip side is that as long as an attacker manages\n+ *              to prevent us from receiving a transaction, failed announcements (including those from honest peers)\n+ *              will linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a\n+ *              cap on the number of tracked announcements per peer. As failed requests in response to announcements\n+ *              from honest peers should be rare, this almost solely hinders attackers.\n+ *              Transaction censoring attacks can be done by announcing transactions quickly while not answering\n+ *              requests for them. See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more\n+ *              information.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable the calling code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers are more trusted by us, so are less likely to be under attacker control.\n+ *\n+ *   - Pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: random assignments are hard to influence for attackers.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and minimizing\n+ * susceptibility to censorship attacks. An attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one preferred connection).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution). The \"1 +\" is due to the fact that the\n+ *   attacker can be the first to announce through a preferred connection in this scenario, which very likely means\n+ *   they get the first request.\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh>=1\n+ *   are honest, where we assume that the attacker can disconnect and reconnect those connections, the distribution\n+ *   becomes k ~ P + NB(p=1-NP/NPh,r=1) (where NB stands for Negative Binomial distribution), which has mean\n+ *   P-1+NP/NPh.\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, and a NOTFOUND or a\n+    //   transaction was received in response (valid or not), or they timed out. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DisconnectedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash (both txid and wtxid ones).\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it.\n+     */\n+    void ForgetTxHash(const uint256& txhash);\n+\n+    /** Adds a new CANDIDATE announcement.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that the txid/wtxid property is ignored for determining uniqueness, so if an announcement\n+     * is added for a wtxid H, while one for txid H from the same peer already exists, it will be ignored. This is\n+     * harmless as the txhashes being equal implies it is a non-segwit transaction, so it doesn't matter how it is\n+     * fetched. The new announcement is given the specified preferred and reqtime values, and takes it is_wtxid from\n+     * the specified gtxid.\n+     */\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime);\n+\n+    /** Converts the CANDIDATE announcement for the provided peer and gtxid into a REQUESTED one.\n+     *\n+     * Expiry is set to the specified value. This can ONLY be called immediately after GetRequestable was called\n+     * (for the same peer), with only ForgetTx and other RequestedTx calls (both for other txhashes) in\n+     * between. Any other non-const operation removes the ability to call RequestedTx.\n+     */\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds expiry);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498734530",
      "id" : 498734530,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODczNDUzMA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 151,
      "original_position" : 151,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 500968997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498734530",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498737921"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498737921"
         }
      },
      "author_association" : "MEMBER",
      "body" : "_overloaded_ isn't a TxRequestTracker parameter, so I think it's fine just to have the `OVERLOADED_PEER_TX_DELAY` comment in the sub-bullet below",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T10:20:00Z",
      "diff_hunk" : "@@ -806,73 +740,34 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest\n+    NodeId nodeid = node.GetId();\n+    if (!node.HasPermission(PF_RELAY) && m_txrequest.Count(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"overloaded\": if at least MAX_PEER_TX_IN_FLIGHT requests are in flight (and no PF_RELAY).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498737921",
      "id" : 498737921,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODczNzkyMQ==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 756,
      "original_position" : 208,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 500968997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498737921",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498738238"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498738238"
         }
      },
      "author_association" : "MEMBER",
      "body" : "s/announcements from txid peers/txid announcements/ (since requesting an orphan tx from a wtxid peer counts as a txid announcement)",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T10:20:40Z",
      "diff_hunk" : "@@ -806,73 +740,34 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest\n+    NodeId nodeid = node.GetId();\n+    if (!node.HasPermission(PF_RELAY) && m_txrequest.Count(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"overloaded\": if at least MAX_PEER_TX_IN_FLIGHT requests are in flight (and no PF_RELAY).\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or PF_NOBAN permission)\n+    // - \"reqtime\": current time plus delays for:\n+    //   - NONPREF_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for announcements from txid peers while wtxid peers are available",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498738238",
      "id" : 498738238,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODczODIzOA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 760,
      "original_position" : 212,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 500968997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498738238",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498742352"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498742352"
         }
      },
      "author_association" : "MEMBER",
      "body" : "s/How many microseconds/How long/ (commenting that a `std::chrono::microseconds` constant is microseconds is redundant)",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T10:30:01Z",
      "diff_hunk" : "@@ -71,22 +71,22 @@ static constexpr std::chrono::minutes PING_INTERVAL{2};\n static const unsigned int MAX_LOCATOR_SZ = 101;\n /** The maximum number of entries in an 'inv' protocol message */\n static const unsigned int MAX_INV_SZ = 50000;\n-/** Maximum number of in-flight transactions from a peer */\n+/** Maximum number of in-flight transactions from a peer. It is not a hard limit, but the threshold\n+ *  at which point the OVERLOADED_PEER_TX_DELAY kicks in. */\n static constexpr int32_t MAX_PEER_TX_IN_FLIGHT = 100;\n-/** Maximum number of announced transactions from a peer */\n-static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 2 * MAX_INV_SZ;\n+/** Maximum number of transactions to consider for requesting, per peer. It provides a reasonable DoS limit to\n+ *  per-peer memory usage spent on announcements, while covering peers continuously sending INVs at the maximum\n+ *  rate (by our own policy, see INVENTORY_BROADCAST_PER_SECOND) for several minutes, while not receiving\n+ *  the actual transaction (from any peer) in response to requests for them. */\n+static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 5000;\n /** How many microseconds to delay requesting transactions via txids, if we have wtxid-relaying peers */\n static constexpr std::chrono::microseconds TXID_RELAY_DELAY{std::chrono::seconds{2}};\n-/** How many microseconds to delay requesting transactions from inbound peers */\n-static constexpr std::chrono::microseconds INBOUND_PEER_TX_DELAY{std::chrono::seconds{2}};\n+/** How many microseconds to delay requesting transactions from non-preferred peers */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498742352",
      "id" : 498742352,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc0MjM1Mg==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 84,
      "original_position" : 19,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 500968997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498742352",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498746033"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498746033"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Delete all this. No longer needed since you removed the 'first' marker.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T10:38:46Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo entries exist with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+\n+            // Looking up the last ByTxHash entry with the given txhash must return an Entry with that txhash or the\n+            // multi_index is very bad.\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{item.first, State::TOO_LARGE, 0}));\n+            assert(it_last != m_index.get<ByTxHash>().end() && it_last->m_txhash == item.first);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+\n+private:\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txhash that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txhash already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = m_computer(*std::prev(it));\n+            uint64_t priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in\n+            // the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Entry for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED entries.\n+\n+        // If this Entry's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Entry's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txhash, they are\n+     *  deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+     *  CANDIDATE_BEST. Returns whether the Entry still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED entry for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the entry COMPLETED, and select the next best entry (the first CANDIDATE_READY) if needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to EntryTxHashExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(EntryPeerExtractor(), std::less<EntryPeer>()),\n+            boost::make_tuple(EntryTxHashExtractor(m_computer), std::less<EntryTxHash>()),\n+            boost::make_tuple(EntryTimeExtractor(), std::less<EntryTime>())\n+        )) {}\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxHashExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+            // CANDIDATE_BEST, or delete all of a txhash's entries if no non-COMPLETED ones are left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(EntryTxHash{txhash, State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST entry for this (txhash, peer) combination. The case where\n+        // there is a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+        // automatically.\n+        if (m_index.get<ByPeer>().count(EntryPeer{peer, true, gtxid.GetHash()})) return;\n+\n+        // Find last entry for this txhash, and extract per-txhash information from it.\n+        Iter<ByTxHash> it_last = m_index.get<ByTxHash>().end();\n+        // First find the first entry past this txhash.\n+        it_last = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0});\n+        if (it_last != m_index.get<ByTxHash>().begin() && std::prev(it_last)->m_txhash == gtxid.GetHash()) {\n+            it_last--;\n+        } else {\n+            // No entry for this txhash exists yet.\n+            it_last = m_index.get<ByTxHash>().end();\n+        }\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498746033",
      "id" : 498746033,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc0NjAzMw==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 565,
      "original_position" : 547,
      "original_start_line" : 537,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 500968997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498746033",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498746475"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498746475"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't understand this comment about catching a non-CANDIDATE_BEST entry automatically. `m_index.get<ByPeer>().count()` will return 0 in that case.\r\n\r\nEdit: Ah! I've just seen the comment below. Perhaps update this comment to say \"will be caught by the uniqueness property when we try to emplace the new Entry object\".",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T10:39:49Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo entries exist with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+\n+            // Looking up the last ByTxHash entry with the given txhash must return an Entry with that txhash or the\n+            // multi_index is very bad.\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{item.first, State::TOO_LARGE, 0}));\n+            assert(it_last != m_index.get<ByTxHash>().end() && it_last->m_txhash == item.first);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+\n+private:\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txhash that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txhash already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = m_computer(*std::prev(it));\n+            uint64_t priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in\n+            // the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Entry for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED entries.\n+\n+        // If this Entry's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Entry's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txhash, they are\n+     *  deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+     *  CANDIDATE_BEST. Returns whether the Entry still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED entry for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the entry COMPLETED, and select the next best entry (the first CANDIDATE_READY) if needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to EntryTxHashExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(EntryPeerExtractor(), std::less<EntryPeer>()),\n+            boost::make_tuple(EntryTxHashExtractor(m_computer), std::less<EntryTxHash>()),\n+            boost::make_tuple(EntryTimeExtractor(), std::less<EntryTime>())\n+        )) {}\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxHashExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+            // CANDIDATE_BEST, or delete all of a txhash's entries if no non-COMPLETED ones are left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(EntryTxHash{txhash, State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST entry for this (txhash, peer) combination. The case where\n+        // there is a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498746475",
      "id" : 498746475,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc0NjQ3NQ==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 533,
      "original_position" : 533,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 500968997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498746475",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498749661"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498749661"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Why not just index by (peer, txhash), and then in `GetRequestable()` just add an `if (it_peer->GetState() == State::CANDIDATE_BEST)` before adding the hash to `selected`? It seems like in all other places (`DisconnectedPeer()`, `ReceivedInv()` and `ReceivedResponse()`), we're actually interested in all the outstanding Entry objects for a given peer.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T10:47:35Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498749661",
      "id" : 498749661,
      "line" : 137,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc0OTY2MQ==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 137,
      "original_position" : 133,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 137,
      "pull_request_review_id" : 500968997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498749661",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498758268"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498758268"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Maybe assert that `it` is not `end()` at the top of this function?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T11:09:50Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo entries exist with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+\n+            // Looking up the last ByTxHash entry with the given txhash must return an Entry with that txhash or the\n+            // multi_index is very bad.\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{item.first, State::TOO_LARGE, 0}));\n+            assert(it_last != m_index.get<ByTxHash>().end() && it_last->m_txhash == item.first);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+\n+private:\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txhash that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txhash already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = m_computer(*std::prev(it));\n+            uint64_t priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        if (it->IsSelected()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498758268",
      "id" : 498758268,
      "line" : 428,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc1ODI2OA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 428,
      "original_position" : 404,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 428,
      "pull_request_review_id" : 500968997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498758268",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498765059"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498765059"
         }
      },
      "author_association" : "NONE",
      "body" : "There is no longer a \"first\" maker for the entires, is there?",
      "commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "created_at" : "2020-10-02T11:28:04Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo entries exist with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+\n+            // Looking up the last ByTxHash entry with the given txhash must return an Entry with that txhash or the\n+            // multi_index is very bad.\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{item.first, State::TOO_LARGE, 0}));\n+            assert(it_last != m_index.get<ByTxHash>().end() && it_last->m_txhash == item.first);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+\n+private:\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txhash that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txhash already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = m_computer(*std::prev(it));\n+            uint64_t priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in\n+            // the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Entry for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED entries.\n+\n+        // If this Entry's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Entry's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txhash, they are\n+     *  deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+     *  CANDIDATE_BEST. Returns whether the Entry still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED entry for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the entry COMPLETED, and select the next best entry (the first CANDIDATE_READY) if needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to EntryTxHashExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(EntryPeerExtractor(), std::less<EntryPeer>()),\n+            boost::make_tuple(EntryTxHashExtractor(m_computer), std::less<EntryTxHash>()),\n+            boost::make_tuple(EntryTimeExtractor(), std::less<EntryTime>())\n+        )) {}\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxHashExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+            // CANDIDATE_BEST, or delete all of a txhash's entries if no non-COMPLETED ones are left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(EntryTxHash{txhash, State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST entry for this (txhash, peer) combination. The case where\n+        // there is a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+        // automatically.\n+        if (m_index.get<ByPeer>().count(EntryPeer{peer, true, gtxid.GetHash()})) return;\n+\n+        // Find last entry for this txhash, and extract per-txhash information from it.\n+        Iter<ByTxHash> it_last = m_index.get<ByTxHash>().end();\n+        // First find the first entry past this txhash.\n+        it_last = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0});\n+        if (it_last != m_index.get<ByTxHash>().begin() && std::prev(it_last)->m_txhash == gtxid.GetHash()) {\n+            it_last--;\n+        } else {\n+            // No entry for this txhash exists yet.\n+            it_last = m_index.get<ByTxHash>().end();\n+        }\n+\n+        // Try creating the entry with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST entry already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_sequence);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+    }\n+\n+    //! Find the GenTxids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now)\n+    {\n+        // Move time.\n+        SetTimePoint(now);\n+\n+        // Find all CANDIDATE_BEST entries for this peer.\n+        std::vector<std::pair<uint64_t, const Entry*>> selected;\n+        auto it_peer = m_index.get<ByPeer>().lower_bound(EntryPeer{peer, true, UINT256_ZERO});\n+        while (it_peer != m_index.get<ByPeer>().end() && it_peer->m_peer == peer &&\n+            it_peer->GetState() == State::CANDIDATE_BEST) {\n+            selected.emplace_back(it_peer->m_sequence, &*it_peer);\n+            ++it_peer;\n+        }\n+\n+        // Return them, sorted by sequence number.\n+        std::sort(selected.begin(), selected.end());\n+        std::vector<GenTxid> ret;\n+        for (const auto& item : selected) {\n+            ret.emplace_back(item.second->m_is_wtxid, item.second->m_txhash);\n+        }\n+        return ret;\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds expiry)\n+    {\n+        auto it = m_index.get<ByPeer>().find(EntryPeer{peer, true, gtxid.GetHash()});\n+        // RequestedTx can only be called on CANDIDATE_BEST entries (this is implied by its condition that it can\n+        // only be called on GenTxids returned by GetRequestable (and only AlreadyHave and RequestedTx can be called\n+        // in between, which preserve the state of other GenTxids).\n+        assert(it != m_index.get<ByPeer>().end());\n+        assert(it->GetState() == State::CANDIDATE_BEST);\n+        Modify<ByPeer>(it, [expiry](Entry& entry) {\n+            entry.SetState(State::REQUESTED);\n+            entry.m_time = expiry;\n+        });\n+\n+        // Update the per-txhash data (of the last Entry for this txhash) to reflect that new ones are no longer\n+        // eligible for the \"first\" marker.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498765059",
      "id" : 498765059,
      "line" : 597,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc2NTA1OQ==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 597,
      "original_position" : 597,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 597,
      "pull_request_review_id" : 501056270,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-02T11:28:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498765059",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498772237"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498772237"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This can be changed to take a hash instead of a GenTxid. The function doesn't do anything with whether it's a txid or wtxid, so it shouldn't be part of the interface.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T11:46:40Z",
      "diff_hunk" : "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction. Note that this only works\n+ *              per txhash, so if the same transaction is announced both through txid and wtxid, we have no means\n+ *              to prevent fetching both (the caller can however mitigate this by delaying one, see further).\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten only:\n+ *   - If a peer goes offline, all its announcements are forgotten.\n+ *   - If a transaction has been successfully received, or is otherwise no longer needed, the caller can call\n+ *     ForgetTxHash, which removes all announcements across all peers with the specified txhash.\n+ *   - If for a given txhash only already-requested announcements remain, they are all forgotten.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening transaction censoring attacks. The flip side is that as long as an attacker manages\n+ *              to prevent us from receiving a transaction, failed announcements (including those from honest peers)\n+ *              will linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a\n+ *              cap on the number of tracked announcements per peer. As failed requests in response to announcements\n+ *              from honest peers should be rare, this almost solely hinders attackers.\n+ *              Transaction censoring attacks can be done by announcing transactions quickly while not answering\n+ *              requests for them. See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more\n+ *              information.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable the calling code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers are more trusted by us, so are less likely to be under attacker control.\n+ *\n+ *   - Pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: random assignments are hard to influence for attackers.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and minimizing\n+ * susceptibility to censorship attacks. An attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one preferred connection).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution). The \"1 +\" is due to the fact that the\n+ *   attacker can be the first to announce through a preferred connection in this scenario, which very likely means\n+ *   they get the first request.\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh>=1\n+ *   are honest, where we assume that the attacker can disconnect and reconnect those connections, the distribution\n+ *   becomes k ~ P + NB(p=1-NP/NPh,r=1) (where NB stands for Negative Binomial distribution), which has mean\n+ *   P-1+NP/NPh.\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, and a NOTFOUND or a\n+    //   transaction was received in response (valid or not), or they timed out. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DisconnectedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash (both txid and wtxid ones).\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it.\n+     */\n+    void ForgetTxHash(const uint256& txhash);\n+\n+    /** Adds a new CANDIDATE announcement.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that the txid/wtxid property is ignored for determining uniqueness, so if an announcement\n+     * is added for a wtxid H, while one for txid H from the same peer already exists, it will be ignored. This is\n+     * harmless as the txhashes being equal implies it is a non-segwit transaction, so it doesn't matter how it is\n+     * fetched. The new announcement is given the specified preferred and reqtime values, and takes it is_wtxid from\n+     * the specified gtxid.\n+     */\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime);\n+\n+    /** Converts the CANDIDATE announcement for the provided peer and gtxid into a REQUESTED one.\n+     *\n+     * Expiry is set to the specified value. This can ONLY be called immediately after GetRequestable was called\n+     * (for the same peer), with only ForgetTx and other RequestedTx calls (both for other txhashes) in\n+     * between. Any other non-const operation removes the ability to call RequestedTx.\n+     */\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds expiry);\n+\n+    /** Converts any CANDIDATE or REQUESTED announcement to a COMPLETED one, if one exists.\n+     *\n+     * It should be called whenever a transaction or NOTFOUND was received from a peer. When a good transaction is\n+     * received, ForgetTx should be called instead of (or in addition to) this operation.\n+     */\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498772237",
      "id" : 498772237,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc3MjIzNw==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 158,
      "original_position" : 158,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 500968997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498772237",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498773268"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498773268"
         }
      },
      "author_association" : "MEMBER",
      "body" : "No point in calling this twice. `ReceivedResponse()` only cares about the hash.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T11:49:18Z",
      "diff_hunk" : "@@ -2994,9 +2898,7 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n         TxValidationState state;\n \n         for (const GenTxid& gtxid : {GenTxid(false, txid), GenTxid(true, wtxid)}) {\n-            nodestate->m_tx_download.m_tx_announced.erase(gtxid.GetHash());\n-            nodestate->m_tx_download.m_tx_in_flight.erase(gtxid.GetHash());\n-            EraseTxRequest(gtxid);\n+            m_txrequest.ReceivedResponse(pfrom.GetId(), gtxid);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498773268",
      "id" : 498773268,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc3MzI2OA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 2901,
      "original_position" : 276,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 500968997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498773268",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498775868"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498775868"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Testing my understanding here: do we ever expect to hit this? I think that every action that causes a tx to become AlreadyHave will also cause us to ForgetTxHash, and we won't add an AlreadyHave tx back into TxRequestTracker. If I'm right, perhaps just add a comment here saying that we don't expect to hit this and it's here for belt-and-suspenders.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T11:55:35Z",
      "diff_hunk" : "@@ -4544,67 +4446,19 @@ bool PeerManager::SendMessages(CNode* pto)\n         //\n         // Message: getdata (non-blocks)\n         //\n-\n-        // For robustness, expire old requests after a long timeout, so that\n-        // we can resume downloading transactions from a peer even if they\n-        // were unresponsive in the past.\n-        // Eventually we should consider disconnecting peers, but this is\n-        // conservative.\n-        if (state.m_tx_download.m_check_expiry_timer <= current_time) {\n-            for (auto it=state.m_tx_download.m_tx_in_flight.begin(); it != state.m_tx_download.m_tx_in_flight.end();) {\n-                if (it->second <= current_time - TX_EXPIRY_INTERVAL) {\n-                    LogPrint(BCLog::NET, \"timeout of inflight tx %s from peer=%d\\n\", it->first.ToString(), pto->GetId());\n-                    state.m_tx_download.m_tx_announced.erase(it->first);\n-                    state.m_tx_download.m_tx_in_flight.erase(it++);\n-                } else {\n-                    ++it;\n-                }\n-            }\n-            // On average, we do this check every TX_EXPIRY_INTERVAL. Randomize\n-            // so that we're not doing this for all peers at the same time.\n-            state.m_tx_download.m_check_expiry_timer = current_time + TX_EXPIRY_INTERVAL / 2 + GetRandMicros(TX_EXPIRY_INTERVAL);\n-        }\n-\n-        auto& tx_process_time = state.m_tx_download.m_tx_process_time;\n-        while (!tx_process_time.empty() && tx_process_time.begin()->first <= current_time && state.m_tx_download.m_tx_in_flight.size() < MAX_PEER_TX_IN_FLIGHT) {\n-            const GenTxid gtxid = tx_process_time.begin()->second;\n-            // Erase this entry from tx_process_time (it may be added back for\n-            // processing at a later time, see below)\n-            tx_process_time.erase(tx_process_time.begin());\n+        for (const GenTxid& gtxid : m_txrequest.GetRequestable(pto->GetId(), current_time)) {\n             CInv inv(gtxid.IsWtxid() ? MSG_WTX : (MSG_TX | GetFetchFlags(*pto)), gtxid.GetHash());\n-            if (!AlreadyHaveTx(ToGenTxid(inv), m_mempool)) {\n-                // If this transaction was last requested more than 1 minute ago,\n-                // then request.\n-                const auto last_request_time = GetTxRequestTime(gtxid);\n-                if (last_request_time <= current_time - GETDATA_TX_INTERVAL) {\n-                    LogPrint(BCLog::NET, \"Requesting %s peer=%d\\n\", inv.ToString(), pto->GetId());\n-                    vGetData.push_back(inv);\n-                    if (vGetData.size() >= MAX_GETDATA_SZ) {\n-                        m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n-                        vGetData.clear();\n-                    }\n-                    UpdateTxRequestTime(gtxid, current_time);\n-                    state.m_tx_download.m_tx_in_flight.emplace(gtxid.GetHash(), current_time);\n-                } else {\n-                    // This transaction is in flight from someone else; queue\n-                    // up processing to happen after the download times out\n-                    // (with a slight delay for inbound peers, to prefer\n-                    // requests to outbound peers).\n-                    // Don't apply the txid-delay to re-requests of a\n-                    // transaction; the heuristic of delaying requests to\n-                    // txid-relay peers is to save bandwidth on initial\n-                    // announcement of a transaction, and doesn't make sense\n-                    // for a followup request if our first peer times out (and\n-                    // would open us up to an attacker using inbound\n-                    // wtxid-relay to prevent us from requesting transactions\n-                    // from outbound txid-relay peers).\n-                    const auto next_process_time = CalculateTxGetDataTime(gtxid, current_time, !state.fPreferredDownload, false);\n-                    tx_process_time.emplace(next_process_time, gtxid);\n+            if (!AlreadyHaveTx(gtxid, m_mempool)) {\n+                LogPrint(BCLog::NET, \"Requesting %s peer=%d\\n\", inv.ToString(), pto->GetId());\n+                vGetData.push_back(inv);\n+                if (vGetData.size() >= MAX_GETDATA_SZ) {\n+                    m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n+                    vGetData.clear();\n                 }\n+                m_txrequest.RequestedTx(pto->GetId(), gtxid, current_time + GETDATA_TX_INTERVAL);\n             } else {\n                 // We have already seen this transaction, no need to download.\n-                state.m_tx_download.m_tx_announced.erase(gtxid.GetHash());\n-                state.m_tx_download.m_tx_in_flight.erase(gtxid.GetHash());\n+                m_txrequest.ForgetTxHash(gtxid.GetHash());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498775868",
      "id" : 498775868,
      "line" : 4471,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc3NTg2OA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 4471,
      "original_position" : 528,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 548,
      "pull_request_review_id" : 500968997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498775868",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498779231"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498779231"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This `CInv` only needs to be constructed inside the `!AlreadyHaveTx` block. It could even be emplaced directly into `vGetData`.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T12:03:50Z",
      "diff_hunk" : "@@ -4544,67 +4446,19 @@ bool PeerManager::SendMessages(CNode* pto)\n         //\n         // Message: getdata (non-blocks)\n         //\n-\n-        // For robustness, expire old requests after a long timeout, so that\n-        // we can resume downloading transactions from a peer even if they\n-        // were unresponsive in the past.\n-        // Eventually we should consider disconnecting peers, but this is\n-        // conservative.\n-        if (state.m_tx_download.m_check_expiry_timer <= current_time) {\n-            for (auto it=state.m_tx_download.m_tx_in_flight.begin(); it != state.m_tx_download.m_tx_in_flight.end();) {\n-                if (it->second <= current_time - TX_EXPIRY_INTERVAL) {\n-                    LogPrint(BCLog::NET, \"timeout of inflight tx %s from peer=%d\\n\", it->first.ToString(), pto->GetId());\n-                    state.m_tx_download.m_tx_announced.erase(it->first);\n-                    state.m_tx_download.m_tx_in_flight.erase(it++);\n-                } else {\n-                    ++it;\n-                }\n-            }\n-            // On average, we do this check every TX_EXPIRY_INTERVAL. Randomize\n-            // so that we're not doing this for all peers at the same time.\n-            state.m_tx_download.m_check_expiry_timer = current_time + TX_EXPIRY_INTERVAL / 2 + GetRandMicros(TX_EXPIRY_INTERVAL);\n-        }\n-\n-        auto& tx_process_time = state.m_tx_download.m_tx_process_time;\n-        while (!tx_process_time.empty() && tx_process_time.begin()->first <= current_time && state.m_tx_download.m_tx_in_flight.size() < MAX_PEER_TX_IN_FLIGHT) {\n-            const GenTxid gtxid = tx_process_time.begin()->second;\n-            // Erase this entry from tx_process_time (it may be added back for\n-            // processing at a later time, see below)\n-            tx_process_time.erase(tx_process_time.begin());\n+        for (const GenTxid& gtxid : m_txrequest.GetRequestable(pto->GetId(), current_time)) {\n             CInv inv(gtxid.IsWtxid() ? MSG_WTX : (MSG_TX | GetFetchFlags(*pto)), gtxid.GetHash());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498779231",
      "id" : 498779231,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc3OTIzMQ==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 4450,
      "original_position" : 487,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 500968997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498779231",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498781706"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498781706"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This function is now on the hot path and is called for every peer on every SendMessages() loop. Have you done any profiling to see how much time we'll spend in here on a normally loaded system? I think all of the lookups in here are O(1) in the size of the index, but is the constant factor important?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T12:09:43Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo entries exist with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+\n+            // Looking up the last ByTxHash entry with the given txhash must return an Entry with that txhash or the\n+            // multi_index is very bad.\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{item.first, State::TOO_LARGE, 0}));\n+            assert(it_last != m_index.get<ByTxHash>().end() && it_last->m_txhash == item.first);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+\n+private:\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txhash that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txhash already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = m_computer(*std::prev(it));\n+            uint64_t priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in\n+            // the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Entry for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED entries.\n+\n+        // If this Entry's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Entry's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txhash, they are\n+     *  deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+     *  CANDIDATE_BEST. Returns whether the Entry still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED entry for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the entry COMPLETED, and select the next best entry (the first CANDIDATE_READY) if needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to EntryTxHashExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(EntryPeerExtractor(), std::less<EntryPeer>()),\n+            boost::make_tuple(EntryTxHashExtractor(m_computer), std::less<EntryTxHash>()),\n+            boost::make_tuple(EntryTimeExtractor(), std::less<EntryTime>())\n+        )) {}\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxHashExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+            // CANDIDATE_BEST, or delete all of a txhash's entries if no non-COMPLETED ones are left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(EntryTxHash{txhash, State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST entry for this (txhash, peer) combination. The case where\n+        // there is a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+        // automatically.\n+        if (m_index.get<ByPeer>().count(EntryPeer{peer, true, gtxid.GetHash()})) return;\n+\n+        // Find last entry for this txhash, and extract per-txhash information from it.\n+        Iter<ByTxHash> it_last = m_index.get<ByTxHash>().end();\n+        // First find the first entry past this txhash.\n+        it_last = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0});\n+        if (it_last != m_index.get<ByTxHash>().begin() && std::prev(it_last)->m_txhash == gtxid.GetHash()) {\n+            it_last--;\n+        } else {\n+            // No entry for this txhash exists yet.\n+            it_last = m_index.get<ByTxHash>().end();\n+        }\n+\n+        // Try creating the entry with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST entry already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_sequence);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+    }\n+\n+    //! Find the GenTxids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now)\n+    {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498781706",
      "id" : 498781706,
      "line" : 579,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc4MTcwNg==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 579,
      "original_position" : 561,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 579,
      "pull_request_review_id" : 500968997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498781706",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498783476"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498783476"
         }
      },
      "author_association" : "MEMBER",
      "body" : "If you don't change the `m_peer` to be `NodeId`, consider making a typedef `SeqNo` for the sequence number, so that it's obvious which types are using sequence numbers and which are using peer ids.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T12:13:56Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498783476",
      "id" : 498783476,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc4MzQ3Ng==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 64,
      "original_position" : 64,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 500968997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498783476",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498784855"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498784855"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Is there a reason not to just construct the `GenTxid`s directly into `selected`?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T12:17:02Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo entries exist with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+\n+            // Looking up the last ByTxHash entry with the given txhash must return an Entry with that txhash or the\n+            // multi_index is very bad.\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{item.first, State::TOO_LARGE, 0}));\n+            assert(it_last != m_index.get<ByTxHash>().end() && it_last->m_txhash == item.first);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+\n+private:\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txhash that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txhash already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = m_computer(*std::prev(it));\n+            uint64_t priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in\n+            // the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Entry for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED entries.\n+\n+        // If this Entry's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Entry's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txhash, they are\n+     *  deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+     *  CANDIDATE_BEST. Returns whether the Entry still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED entry for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the entry COMPLETED, and select the next best entry (the first CANDIDATE_READY) if needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to EntryTxHashExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(EntryPeerExtractor(), std::less<EntryPeer>()),\n+            boost::make_tuple(EntryTxHashExtractor(m_computer), std::less<EntryTxHash>()),\n+            boost::make_tuple(EntryTimeExtractor(), std::less<EntryTime>())\n+        )) {}\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxHashExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+            // CANDIDATE_BEST, or delete all of a txhash's entries if no non-COMPLETED ones are left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(EntryTxHash{txhash, State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST entry for this (txhash, peer) combination. The case where\n+        // there is a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+        // automatically.\n+        if (m_index.get<ByPeer>().count(EntryPeer{peer, true, gtxid.GetHash()})) return;\n+\n+        // Find last entry for this txhash, and extract per-txhash information from it.\n+        Iter<ByTxHash> it_last = m_index.get<ByTxHash>().end();\n+        // First find the first entry past this txhash.\n+        it_last = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0});\n+        if (it_last != m_index.get<ByTxHash>().begin() && std::prev(it_last)->m_txhash == gtxid.GetHash()) {\n+            it_last--;\n+        } else {\n+            // No entry for this txhash exists yet.\n+            it_last = m_index.get<ByTxHash>().end();\n+        }\n+\n+        // Try creating the entry with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST entry already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_sequence);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+    }\n+\n+    //! Find the GenTxids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now)\n+    {\n+        // Move time.\n+        SetTimePoint(now);\n+\n+        // Find all CANDIDATE_BEST entries for this peer.\n+        std::vector<std::pair<uint64_t, const Entry*>> selected;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498784855",
      "id" : 498784855,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc4NDg1NQ==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 566,
      "original_position" : 566,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 500968997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498784855",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498788277"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498788277"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Are \"entry\" and \"announcement\" synonymous? If so, would it make sense to rename `Entry` to `Announcement` and drop the \"entry\" terminology?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T12:24:49Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498788277",
      "id" : 498788277,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc4ODI3Nw==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 56,
      "original_position" : 56,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 500968997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498788277",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498825108"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498825108"
         }
      },
      "author_association" : "NONE",
      "body" : "Is there any specific flag for this? I guess it is implicitly store in `m_state`, but also alongside any other state the transaction can be at. ",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T13:35:26Z",
      "diff_hunk" : "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498825108",
      "id" : 498825108,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgyNTEwOA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 33,
      "original_position" : 32,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 501140022,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498825108",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498825307"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498825307"
         }
      },
      "author_association" : "NONE",
      "body" : "There is no longer a \"first\" maker for the entires, is there?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T13:35:46Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo entries exist with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+\n+            // Looking up the last ByTxHash entry with the given txhash must return an Entry with that txhash or the\n+            // multi_index is very bad.\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{item.first, State::TOO_LARGE, 0}));\n+            assert(it_last != m_index.get<ByTxHash>().end() && it_last->m_txhash == item.first);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+\n+private:\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txhash that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txhash already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = m_computer(*std::prev(it));\n+            uint64_t priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in\n+            // the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Entry for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED entries.\n+\n+        // If this Entry's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Entry's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txhash, they are\n+     *  deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+     *  CANDIDATE_BEST. Returns whether the Entry still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED entry for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the entry COMPLETED, and select the next best entry (the first CANDIDATE_READY) if needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to EntryTxHashExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(EntryPeerExtractor(), std::less<EntryPeer>()),\n+            boost::make_tuple(EntryTxHashExtractor(m_computer), std::less<EntryTxHash>()),\n+            boost::make_tuple(EntryTimeExtractor(), std::less<EntryTime>())\n+        )) {}\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxHashExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+            // CANDIDATE_BEST, or delete all of a txhash's entries if no non-COMPLETED ones are left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(EntryTxHash{txhash, State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST entry for this (txhash, peer) combination. The case where\n+        // there is a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+        // automatically.\n+        if (m_index.get<ByPeer>().count(EntryPeer{peer, true, gtxid.GetHash()})) return;\n+\n+        // Find last entry for this txhash, and extract per-txhash information from it.\n+        Iter<ByTxHash> it_last = m_index.get<ByTxHash>().end();\n+        // First find the first entry past this txhash.\n+        it_last = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0});\n+        if (it_last != m_index.get<ByTxHash>().begin() && std::prev(it_last)->m_txhash == gtxid.GetHash()) {\n+            it_last--;\n+        } else {\n+            // No entry for this txhash exists yet.\n+            it_last = m_index.get<ByTxHash>().end();\n+        }\n+\n+        // Try creating the entry with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST entry already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_sequence);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+    }\n+\n+    //! Find the GenTxids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now)\n+    {\n+        // Move time.\n+        SetTimePoint(now);\n+\n+        // Find all CANDIDATE_BEST entries for this peer.\n+        std::vector<std::pair<uint64_t, const Entry*>> selected;\n+        auto it_peer = m_index.get<ByPeer>().lower_bound(EntryPeer{peer, true, UINT256_ZERO});\n+        while (it_peer != m_index.get<ByPeer>().end() && it_peer->m_peer == peer &&\n+            it_peer->GetState() == State::CANDIDATE_BEST) {\n+            selected.emplace_back(it_peer->m_sequence, &*it_peer);\n+            ++it_peer;\n+        }\n+\n+        // Return them, sorted by sequence number.\n+        std::sort(selected.begin(), selected.end());\n+        std::vector<GenTxid> ret;\n+        for (const auto& item : selected) {\n+            ret.emplace_back(item.second->m_is_wtxid, item.second->m_txhash);\n+        }\n+        return ret;\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds expiry)\n+    {\n+        auto it = m_index.get<ByPeer>().find(EntryPeer{peer, true, gtxid.GetHash()});\n+        // RequestedTx can only be called on CANDIDATE_BEST entries (this is implied by its condition that it can\n+        // only be called on GenTxids returned by GetRequestable (and only AlreadyHave and RequestedTx can be called\n+        // in between, which preserve the state of other GenTxids).\n+        assert(it != m_index.get<ByPeer>().end());\n+        assert(it->GetState() == State::CANDIDATE_BEST);\n+        Modify<ByPeer>(it, [expiry](Entry& entry) {\n+            entry.SetState(State::REQUESTED);\n+            entry.m_time = expiry;\n+        });\n+\n+        // Update the per-txhash data (of the last Entry for this txhash) to reflect that new ones are no longer\n+        // eligible for the \"first\" marker.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498825307",
      "id" : 498825307,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgyNTMwNw==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 597,
      "original_position" : 597,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 501140022,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498825307",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/6665628?v=4",
         "events_url" : "https://api.github.com/users/sr-gi/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sr-gi/followers",
         "following_url" : "https://api.github.com/users/sr-gi/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sr-gi/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sr-gi",
         "id" : 6665628,
         "login" : "sr-gi",
         "node_id" : "MDQ6VXNlcjY2NjU2Mjg=",
         "organizations_url" : "https://api.github.com/users/sr-gi/orgs",
         "received_events_url" : "https://api.github.com/users/sr-gi/received_events",
         "repos_url" : "https://api.github.com/users/sr-gi/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sr-gi/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sr-gi/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sr-gi"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498844918"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498844918"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Constructing vectors instead of repeatedly calling the function seems worse to me, fwiw, but agree that it would be nice to have a simpler description of the constraint.\r\n\r\nMaybe tying it to the return value of `GetRequestable` might be better: \"each value returned by `GetRequestable` may used with either `ForgetTxHash` or `RequestedTx` for the given peer, but not both, and at most only once. Any other calls to non-const methods on `TxRequestTracker` invalidate all the results from `GetRequestable`\" ?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T14:08:35Z",
      "diff_hunk" : "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction. Note that this only works\n+ *              per txhash, so if the same transaction is announced both through txid and wtxid, we have no means\n+ *              to prevent fetching both (the caller can however mitigate this by delaying one, see further).\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten only:\n+ *   - If a peer goes offline, all its announcements are forgotten.\n+ *   - If a transaction has been successfully received, or is otherwise no longer needed, the caller can call\n+ *     ForgetTxHash, which removes all announcements across all peers with the specified txhash.\n+ *   - If for a given txhash only already-requested announcements remain, they are all forgotten.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening transaction censoring attacks. The flip side is that as long as an attacker manages\n+ *              to prevent us from receiving a transaction, failed announcements (including those from honest peers)\n+ *              will linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a\n+ *              cap on the number of tracked announcements per peer. As failed requests in response to announcements\n+ *              from honest peers should be rare, this almost solely hinders attackers.\n+ *              Transaction censoring attacks can be done by announcing transactions quickly while not answering\n+ *              requests for them. See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more\n+ *              information.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable the calling code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers are more trusted by us, so are less likely to be under attacker control.\n+ *\n+ *   - Pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: random assignments are hard to influence for attackers.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and minimizing\n+ * susceptibility to censorship attacks. An attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one preferred connection).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution). The \"1 +\" is due to the fact that the\n+ *   attacker can be the first to announce through a preferred connection in this scenario, which very likely means\n+ *   they get the first request.\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh>=1\n+ *   are honest, where we assume that the attacker can disconnect and reconnect those connections, the distribution\n+ *   becomes k ~ P + NB(p=1-NP/NPh,r=1) (where NB stands for Negative Binomial distribution), which has mean\n+ *   P-1+NP/NPh.\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, and a NOTFOUND or a\n+    //   transaction was received in response (valid or not), or they timed out. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DisconnectedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash (both txid and wtxid ones).\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it.\n+     */\n+    void ForgetTxHash(const uint256& txhash);\n+\n+    /** Adds a new CANDIDATE announcement.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that the txid/wtxid property is ignored for determining uniqueness, so if an announcement\n+     * is added for a wtxid H, while one for txid H from the same peer already exists, it will be ignored. This is\n+     * harmless as the txhashes being equal implies it is a non-segwit transaction, so it doesn't matter how it is\n+     * fetched. The new announcement is given the specified preferred and reqtime values, and takes it is_wtxid from\n+     * the specified gtxid.\n+     */\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime);\n+\n+    /** Converts the CANDIDATE announcement for the provided peer and gtxid into a REQUESTED one.\n+     *\n+     * Expiry is set to the specified value. This can ONLY be called immediately after GetRequestable was called\n+     * (for the same peer), with only ForgetTx and other RequestedTx calls (both for other txhashes) in\n+     * between. Any other non-const operation removes the ability to call RequestedTx.\n+     */\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds expiry);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498844918",
      "id" : 498844918,
      "in_reply_to_id" : 498734530,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg0NDkxOA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 151,
      "original_position" : 151,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 501168268,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498844918",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498846846"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498846846"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "That would make `GetRequestable` be `O(nr_announcements)` instead of `O(nr_best)` which I think makes the complexity blow out in worst case scenarios.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T14:11:46Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498846846",
      "id" : 498846846,
      "in_reply_to_id" : 498749661,
      "line" : 137,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg0Njg0Ng==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 137,
      "original_position" : 133,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 137,
      "pull_request_review_id" : 501170934,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498846846",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498846972"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498846972"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yes, better!",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T14:11:59Z",
      "diff_hunk" : "@@ -0,0 +1,195 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten when the peer that sent them went offline, when the",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498846972",
      "id" : 498846972,
      "in_reply_to_id" : 497891117,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg0Njk3Mg==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 42,
      "original_position" : 42,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 501171100,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498846972",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498848066"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498848066"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yes clearer.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T14:13:57Z",
      "diff_hunk" : "@@ -0,0 +1,195 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten when the peer that sent them went offline, when the\n+ *   transaction has been successfully received or is otherwise no longer needed, or when all candidate peers have\n+ *   been tried already.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening transaction censoring attacks. The flip side is that as long as an attacker manages\n+ *              to prevent us from receiving a transaction, failed announcements (including those from honest peers)\n+ *              will linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a\n+ *              cap on the number of tracked announcements per peer. As failed requests in response to announcements\n+ *              from honest peers should be rare, this almost solely hinders attackers.\n+ *              Transaction censoring attacks can be done by announcing transactions quickly while not answering\n+ *              requests for them. See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more\n+ *              information.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable the calling code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers are more trusted by us, so are less likely to be under attacker control.\n+ *\n+ *   - Pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: random assignments are hard to influence for attackers.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and minimizing\n+ * susceptibility to censorship attacks. An attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution). The \"1 +\" is due to the fact that the\n+ *   attacker can be the first to announce through a preferred connection in this scenario, which very likely means\n+ *   they get the first request.\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh>=1\n+ *   are honest, where we assume that the attacker can disconnect and reconnect those connections, the distribution\n+ *   becomes k ~ P + NB(p=1-NP/NPh,r=1) (where NB stands for Negative Binomial distribution), which has mean\n+ *   P-1+NP/NPh.\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, and a NOTFOUND or a\n+    //   transaction was received in response (valid or not), or they timed out. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DisconnectedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash (both txid and wtxid ones).\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it.\n+     */\n+    void ForgetTxHash(const uint256& txhash);\n+\n+    /** Adds a new CANDIDATE entry.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that this means a second INV with the same txhash from the same peer will be ignored, even\n+     * if one is a txid and the other is wtxid (but that shouldn't happen, as BIP339 requires that all announced\n+     * inventory is exclusively using MSG_WTX). The new entry is given the specified preferred and reqtime values,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498848066",
      "id" : 498848066,
      "in_reply_to_id" : 497898269,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg0ODA2Ng==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 134,
      "original_position" : 134,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 501172694,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498848066",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498860862"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498860862"
         }
      },
      "author_association" : "MEMBER",
      "body" : "+1 was wondering the same ",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T14:35:01Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498860862",
      "id" : 498860862,
      "in_reply_to_id" : 498788277,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg2MDg2Mg==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 56,
      "original_position" : 56,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 501190284,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498860862",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498864365"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498864365"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`m_index.get<ByX>.begin()` should be `O(log_2(n))`, `++it` should be `O(1)`, `.emplace()` should be `O(log_2(n))` with about 3x constant factor overhead, `.modify()` should the same except maybe 6x constant factor overhead. `n` is limited to about 600k, so `log_2(n)` is below about 20. With max peers and max announcements, the entire index could be something like 100MB I think, more if you're removing the bounds for some peers via the relay permission.\r\n\r\nI think worst case complexity is that in SetTimePoint you end up adjusting the state of every announcement , then you find the first BEST for the given peer, which turns out to be every tx for that peer, then iterate through the remaining BEST for that peer adding them to a vector, then sort the vector, and construct the result. I think that's about:\r\n\r\n    600000 * (20 + 2*20) + 20 + 5000 + 5000*12 + 5000 ~= 36M ops\r\n\r\nbut assuming time doesn't go backwards, then amortized across multiple calls to `GetRequstable`, each announcement only causes 7 transitions over its lifetime (delayed, ready, best(+demotion of other), requested, completed(+promotion of other), and only 4 of those occur via `GetRequestable` so amortized cost per tx is something like `4*60+20+1+1*12+1 = 274` ops, so max average cost of calling `GetRequestable` should be about 1.4M ops.\r\n\r\nOn a normally loaded system, you should be getting no more than 35-70 txs from each call to GetRequestable, and I think SetTimePoint should likewise be dealing with (far) fewer than 7000 txs in each call, so load should be about 100 to 1000 times less, I think.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T14:41:06Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo entries exist with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+\n+            // Looking up the last ByTxHash entry with the given txhash must return an Entry with that txhash or the\n+            // multi_index is very bad.\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{item.first, State::TOO_LARGE, 0}));\n+            assert(it_last != m_index.get<ByTxHash>().end() && it_last->m_txhash == item.first);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+\n+private:\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txhash that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txhash already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = m_computer(*std::prev(it));\n+            uint64_t priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in\n+            // the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Entry for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED entries.\n+\n+        // If this Entry's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Entry's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txhash, they are\n+     *  deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+     *  CANDIDATE_BEST. Returns whether the Entry still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED entry for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the entry COMPLETED, and select the next best entry (the first CANDIDATE_READY) if needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to EntryTxHashExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(EntryPeerExtractor(), std::less<EntryPeer>()),\n+            boost::make_tuple(EntryTxHashExtractor(m_computer), std::less<EntryTxHash>()),\n+            boost::make_tuple(EntryTimeExtractor(), std::less<EntryTime>())\n+        )) {}\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxHashExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+            // CANDIDATE_BEST, or delete all of a txhash's entries if no non-COMPLETED ones are left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(EntryTxHash{txhash, State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST entry for this (txhash, peer) combination. The case where\n+        // there is a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+        // automatically.\n+        if (m_index.get<ByPeer>().count(EntryPeer{peer, true, gtxid.GetHash()})) return;\n+\n+        // Find last entry for this txhash, and extract per-txhash information from it.\n+        Iter<ByTxHash> it_last = m_index.get<ByTxHash>().end();\n+        // First find the first entry past this txhash.\n+        it_last = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0});\n+        if (it_last != m_index.get<ByTxHash>().begin() && std::prev(it_last)->m_txhash == gtxid.GetHash()) {\n+            it_last--;\n+        } else {\n+            // No entry for this txhash exists yet.\n+            it_last = m_index.get<ByTxHash>().end();\n+        }\n+\n+        // Try creating the entry with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST entry already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_sequence);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+    }\n+\n+    //! Find the GenTxids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now)\n+    {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498864365",
      "id" : 498864365,
      "in_reply_to_id" : 498781706,
      "line" : 579,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg2NDM2NQ==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 579,
      "original_position" : 561,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 579,
      "pull_request_review_id" : 501195225,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498864365",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498867957"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498867957"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "It needs to be sorted by sequence before being returned to ensure txs are requested in order of announcement, and the sequence isn't needed in the return value, so having a temporary vector's sensible, I think. And sorting a vector of 16-byte seq/pointer pairs should be more cache efficient than for 48-byte seq/is_wtxid/uint256 tuples (or 40 bytes if you combined is_wtxid into seq).",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T14:46:46Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo entries exist with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+\n+            // Looking up the last ByTxHash entry with the given txhash must return an Entry with that txhash or the\n+            // multi_index is very bad.\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{item.first, State::TOO_LARGE, 0}));\n+            assert(it_last != m_index.get<ByTxHash>().end() && it_last->m_txhash == item.first);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+\n+private:\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txhash that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txhash already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = m_computer(*std::prev(it));\n+            uint64_t priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in\n+            // the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Entry for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED entries.\n+\n+        // If this Entry's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Entry's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txhash, they are\n+     *  deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+     *  CANDIDATE_BEST. Returns whether the Entry still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED entry for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the entry COMPLETED, and select the next best entry (the first CANDIDATE_READY) if needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to EntryTxHashExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(EntryPeerExtractor(), std::less<EntryPeer>()),\n+            boost::make_tuple(EntryTxHashExtractor(m_computer), std::less<EntryTxHash>()),\n+            boost::make_tuple(EntryTimeExtractor(), std::less<EntryTime>())\n+        )) {}\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxHashExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+            // CANDIDATE_BEST, or delete all of a txhash's entries if no non-COMPLETED ones are left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(EntryTxHash{txhash, State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST entry for this (txhash, peer) combination. The case where\n+        // there is a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+        // automatically.\n+        if (m_index.get<ByPeer>().count(EntryPeer{peer, true, gtxid.GetHash()})) return;\n+\n+        // Find last entry for this txhash, and extract per-txhash information from it.\n+        Iter<ByTxHash> it_last = m_index.get<ByTxHash>().end();\n+        // First find the first entry past this txhash.\n+        it_last = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0});\n+        if (it_last != m_index.get<ByTxHash>().begin() && std::prev(it_last)->m_txhash == gtxid.GetHash()) {\n+            it_last--;\n+        } else {\n+            // No entry for this txhash exists yet.\n+            it_last = m_index.get<ByTxHash>().end();\n+        }\n+\n+        // Try creating the entry with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST entry already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_sequence);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+    }\n+\n+    //! Find the GenTxids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now)\n+    {\n+        // Move time.\n+        SetTimePoint(now);\n+\n+        // Find all CANDIDATE_BEST entries for this peer.\n+        std::vector<std::pair<uint64_t, const Entry*>> selected;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498867957",
      "id" : 498867957,
      "in_reply_to_id" : 498784855,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg2Nzk1Nw==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 566,
      "original_position" : 566,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 501200186,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498867957",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498869138"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498869138"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yes, makes sense. Thanks!",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T14:48:38Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498869138",
      "id" : 498869138,
      "in_reply_to_id" : 498749661,
      "line" : 137,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg2OTEzOA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 137,
      "original_position" : 133,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 137,
      "pull_request_review_id" : 501201793,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498869138",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498893703"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498893703"
         }
      },
      "author_association" : "MEMBER",
      "body" : "If you assume the return 23-bit integers are statically uniform across samples (`RandomTime()`) I don't understand why adding them increase randomness ?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T15:29:26Z",
      "diff_hunk" : "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds MIN_TIME = std::chrono::microseconds::min();\n+constexpr std::chrono::microseconds MAX_TIME = std::chrono::microseconds::max();\n+constexpr std::chrono::microseconds MICROSECOND = std::chrono::microseconds{1};\n+constexpr std::chrono::microseconds NO_TIME = std::chrono::microseconds{0};\n+\n+/** An Action is a function to call at a particular (simulated) timestamp. */\n+using Action = std::pair<std::chrono::microseconds, std::function<void()>>;\n+\n+/** Object that stores actions from multiple interleaved scenarios, and data shared across them.\n+ *\n+ * The Scenario below is used to fill this.\n+ */\n+struct Runner\n+{\n+    /** The TxRequestTracker being tested. */\n+    TxRequestTracker txrequest;\n+\n+    /** List of actions to be executed (in order of increasing timestamp). */\n+    std::vector<Action> actions;\n+\n+    /** Which node ids have been assigned already (to prevent reuse). */\n+    std::set<uint64_t> peerset;\n+\n+    /** Which txhashes have been assigned already (to prevent reuse). */\n+    std::set<uint256> txhashset;\n+};\n+\n+std::chrono::microseconds RandomTime(int bits=23) { return std::chrono::microseconds{1 + InsecureRandBits(bits)}; }\n+\n+/** A proxy for a Runner that helps build a sequence of consecutive test actions on a TxRequestTracker.\n+ *\n+ * Multiple Scenarios are used with a single Runner, resulting in interleaved actions.\n+ */\n+class Scenario\n+{\n+    Runner& m_runner;\n+    std::chrono::microseconds m_now;\n+    std::string m_testname;\n+\n+public:\n+    Scenario(Runner& runner, std::chrono::microseconds starttime) : m_runner(runner)\n+    {\n+        m_now = starttime + RandomTime() + RandomTime() + RandomTime();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498893703",
      "id" : 498893703,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg5MzcwMw==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 63,
      "original_position" : 63,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 501236154,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498893703",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498899567"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498899567"
         }
      },
      "author_association" : "MEMBER",
      "body" : "You may draw a new `starttime` for every new scenario such increasing the space of starting time covered at each `TestInterleavedScenarios` ?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T15:39:50Z",
      "diff_hunk" : "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds MIN_TIME = std::chrono::microseconds::min();\n+constexpr std::chrono::microseconds MAX_TIME = std::chrono::microseconds::max();\n+constexpr std::chrono::microseconds MICROSECOND = std::chrono::microseconds{1};\n+constexpr std::chrono::microseconds NO_TIME = std::chrono::microseconds{0};\n+\n+/** An Action is a function to call at a particular (simulated) timestamp. */\n+using Action = std::pair<std::chrono::microseconds, std::function<void()>>;\n+\n+/** Object that stores actions from multiple interleaved scenarios, and data shared across them.\n+ *\n+ * The Scenario below is used to fill this.\n+ */\n+struct Runner\n+{\n+    /** The TxRequestTracker being tested. */\n+    TxRequestTracker txrequest;\n+\n+    /** List of actions to be executed (in order of increasing timestamp). */\n+    std::vector<Action> actions;\n+\n+    /** Which node ids have been assigned already (to prevent reuse). */\n+    std::set<uint64_t> peerset;\n+\n+    /** Which txhashes have been assigned already (to prevent reuse). */\n+    std::set<uint256> txhashset;\n+};\n+\n+std::chrono::microseconds RandomTime(int bits=23) { return std::chrono::microseconds{1 + InsecureRandBits(bits)}; }\n+\n+/** A proxy for a Runner that helps build a sequence of consecutive test actions on a TxRequestTracker.\n+ *\n+ * Multiple Scenarios are used with a single Runner, resulting in interleaved actions.\n+ */\n+class Scenario\n+{\n+    Runner& m_runner;\n+    std::chrono::microseconds m_now;\n+    std::string m_testname;\n+\n+public:\n+    Scenario(Runner& runner, std::chrono::microseconds starttime) : m_runner(runner)\n+    {\n+        m_now = starttime + RandomTime() + RandomTime() + RandomTime();\n+    }\n+\n+    void SetTestName(std::string testname)\n+    {\n+        m_testname = std::move(testname);\n+    }\n+\n+    void AdvanceTime(std::chrono::microseconds amount)\n+    {\n+        assert(amount.count() >= 0);\n+        m_now += amount;\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ForgetTxHash(txhash);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool pref, std::chrono::microseconds reqtime = MIN_TIME)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedInv(peer, gtxid, pref, reqtime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.DisconnectedPeer(peer);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds exptime)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.RequestedTx(peer, gtxid, exptime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedResponse(peer, gtxid);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void Check(uint64_t peer, const std::vector<GenTxid>& expected, size_t candidates, size_t inflight,\n+        size_t completed, const std::string& checkname = \"\")\n+    {\n+        const auto comment = m_testname + \" \" + checkname;\n+        auto& runner = m_runner;\n+        const auto now = m_now;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            auto ret = runner.txrequest.GetRequestable(peer, now);\n+            runner.txrequest.SanityCheck();\n+            runner.txrequest.PostGetRequestableSanityCheck(now);\n+            size_t total = candidates + inflight + completed;\n+            size_t real_total = runner.txrequest.Count(peer);\n+            size_t real_candidates = runner.txrequest.CountCandidates(peer);\n+            size_t real_inflight = runner.txrequest.CountInFlight(peer);\n+            BOOST_CHECK_MESSAGE(real_total == total, strprintf(\"[\" + comment + \"] total %i (%i expected)\", real_total, total));\n+            BOOST_CHECK_MESSAGE(real_inflight == inflight, strprintf(\"[\" + comment + \"] inflight %i (%i expected)\", real_inflight, inflight));\n+            BOOST_CHECK_MESSAGE(real_candidates == candidates, strprintf(\"[\" + comment + \"] candidates %i (%i expected)\", real_candidates, candidates));\n+            BOOST_CHECK_MESSAGE(ret == expected, \"[\" + comment + \"] mismatching requestables\");\n+        });\n+    }\n+\n+    uint256 NewTxHash(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        uint256 ret;\n+        bool ok;\n+        do {\n+            ret = InsecureRand256();\n+            ok = true;\n+            for (const auto& order : orders) {\n+                for (size_t pos = 1; pos < order.size(); ++pos) {\n+                    uint64_t prio_prev = m_runner.txrequest.ComputePriority(ret, order[pos - 1], true);\n+                    uint64_t prio_cur = m_runner.txrequest.ComputePriority(ret, order[pos], true);\n+                    if (prio_prev >= prio_cur) {\n+                        ok = false;\n+                        break;\n+                    }\n+                }\n+                if (!ok) break;\n+            }\n+            if (ok) {\n+                ok = m_runner.txhashset.insert(ret).second;\n+            }\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    GenTxid NewGTxid(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        return {InsecureRandBool(), NewTxHash(orders)};\n+    }\n+\n+    uint64_t NewPeer()\n+    {\n+        bool ok;\n+        uint64_t ret;\n+        do {\n+            ret = InsecureRandBits(63);\n+            ok = m_runner.peerset.insert(ret).second;\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    std::chrono::microseconds Now() const { return m_now; }\n+};\n+\n+/** Add to scenario a test with a single tx announced by a single peer.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildSingleTest(Scenario& scenario, int config)\n+{\n+    auto peer = scenario.NewPeer();\n+    auto gtxid = scenario.NewGTxid();\n+    bool immediate = config & 1;\n+    bool preferred = config & 2;\n+    auto delay = immediate ? NO_TIME : RandomTime();\n+\n+    scenario.SetTestName(strprintf(\"Single(config=%i)\", config));\n+\n+    // Receive an announcement, either immediately requestable or delayed.\n+    scenario.ReceivedInv(peer, gtxid, preferred, immediate ? MIN_TIME : scenario.Now() + delay);\n+    if (immediate) {\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s1\");\n+    } else {\n+        scenario.Check(peer, {}, 1, 0, 0, \"s2\");\n+        scenario.AdvanceTime(delay - MICROSECOND);\n+        scenario.Check(peer, {}, 1, 0, 0, \"s3\");\n+        scenario.AdvanceTime(MICROSECOND);\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s4\");\n+    }\n+\n+    if (config >> 3) { // We'll request the transaction\n+        scenario.AdvanceTime(RandomTime());\n+        auto expiry = RandomTime();\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s5\");\n+        scenario.RequestedTx(peer, gtxid, scenario.Now() + expiry);\n+        scenario.Check(peer, {}, 0, 1, 0, \"s6\");\n+\n+        if ((config >> 3) == 1) { // The request will time out\n+            scenario.AdvanceTime(expiry - MICROSECOND);\n+            scenario.Check(peer, {}, 0, 1, 0, \"s7\");\n+            scenario.AdvanceTime(MICROSECOND);\n+            scenario.Check(peer, {}, 0, 0, 0, \"s8\");\n+            return;\n+        } else {\n+            scenario.AdvanceTime(std::chrono::microseconds{InsecureRandRange(expiry.count())});\n+            scenario.Check(peer, {}, 0, 1, 0, \"s9\");\n+            if ((config >> 3) == 3) { // A reponse will arrive for the transaction\n+                scenario.ReceivedResponse(peer, gtxid);\n+                scenario.Check(peer, {}, 0, 0, 0, \"s10\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    scenario.AdvanceTime(RandomTime());\n+    if (config & 4) { // The peer will go offline\n+        scenario.DisconnectedPeer(peer);\n+    } else { // The transaction is no longer needed\n+        scenario.ForgetTxHash(gtxid.GetHash());\n+    }\n+    scenario.Check(peer, {}, 0, 0, 0, \"s11\");\n+}\n+\n+/** Add to scenario a test with a single tx announced by two peers, to verify the\n+ *  right peer is selected for requests.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildPriorityTest(Scenario& scenario, int config)\n+{\n+    scenario.SetTestName(strprintf(\"Priority(config=%i)\", config));\n+\n+    // Three peers. They will announce in order.\n+    auto peer1 = scenario.NewPeer(), peer2 = scenario.NewPeer();\n+    // Construct a transaction that under random rules would be preferred by peer2 or peer1,\n+    // depending on configuration.\n+    bool prio1 = config & 1;\n+    auto gtxid = prio1 ? scenario.NewGTxid({{peer1, peer2}}) : scenario.NewGTxid({{peer2, peer1}});\n+    bool pref1 = config & 2, pref2 = config & 4;\n+\n+    scenario.ReceivedInv(peer1, gtxid, pref1, MIN_TIME);\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p1\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p2\");\n+\n+    scenario.ReceivedInv(peer2, gtxid, pref2, MIN_TIME);\n+    bool stage2_prio =\n+        // At this point, peer2 will be given priority if:\n+        // - It is preferred and peer1 is not\n+        (pref2 && !pref1) ||\n+        // - They're in the same preference class,\n+        //   and the randomized priority favors peer2 over peer1.\n+        (pref1 == pref2 && !prio1);\n+    uint64_t priopeer = stage2_prio ? peer2 : peer1, otherpeer = stage2_prio ? peer1 : peer2;\n+    scenario.Check(otherpeer, {}, 1, 0, 0, \"p3\");\n+    scenario.Check(priopeer, {gtxid}, 1, 0, 0, \"p4\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(otherpeer, {}, 1, 0, 0, \"p5\");\n+    scenario.Check(priopeer, {gtxid}, 1, 0, 0, \"p6\");\n+\n+    // We possibly request from the selected peer.\n+    if (config & 8) {\n+        scenario.RequestedTx(priopeer, gtxid, MAX_TIME);\n+        scenario.Check(priopeer, {}, 0, 1, 0, \"p7\");\n+        scenario.Check(otherpeer, {}, 1, 0, 0, \"p8\");\n+        if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    }\n+\n+    // The peer which was selected (or requested from) now goes offline, or a NOTFOUND is received from them.\n+    if (config & 16) {\n+        scenario.DisconnectedPeer(priopeer);\n+    } else {\n+        scenario.ReceivedResponse(priopeer, gtxid);\n+    }\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(priopeer, {}, 0, 0, !(config & 16), \"p8\");\n+    scenario.Check(otherpeer, {gtxid}, 1, 0, 0, \"p9\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+\n+    // Now the other peer goes offline.\n+    scenario.DisconnectedPeer(otherpeer);\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(peer1, {}, 0, 0, 0, \"p10\");\n+    scenario.Check(peer2, {}, 0, 0, 0, \"p11\");\n+}\n+\n+/** Add to scenario a randomized test in which N peers announce the same transaction, to verify\n+ *  the order in which they are requested.\n+ */\n+void BuildBigPriorityTest(Scenario& scenario, int peers)\n+{\n+    scenario.SetTestName(strprintf(\"BigPriority(peers=%i)\", peers));\n+\n+    // We will have N peers announce the same transaction.\n+    std::map<uint64_t, bool> preferred;\n+    std::vector<uint64_t> pref_order, npref_order;\n+    std::vector<uint64_t> pref_peers, npref_peers;\n+    int num_pref = InsecureRandRange(peers + 1) ; // Some preferred, ...\n+    int num_npref = peers - num_pref; // some not preferred.\n+    for (int i = 0; i < num_pref; ++i) {\n+        pref_peers.push_back(scenario.NewPeer());\n+        preferred[pref_peers.back()] = true;\n+    }\n+    for (int i = 0; i < num_npref; ++i) {\n+        npref_peers.push_back(scenario.NewPeer());\n+        preferred[npref_peers.back()] = false;\n+    }\n+    // Make a list of all peers, in order of intended request order (concatenation of pref_peers and\n+    // npref_peers).\n+    std::vector<uint64_t> request_order;\n+    for (int i = 0; i < num_pref; ++i) request_order.push_back(pref_peers[i]);\n+    for (int i = 0; i < num_npref; ++i) request_order.push_back(npref_peers[i]);\n+\n+    // Setup pref_order\n+    for (int i = 0; i < num_pref; ++i) {\n+        pref_order.push_back(pref_peers[i]);\n+    }\n+\n+    // Setup npref_order\n+    for (int i = 0; i < num_npref; ++i) {\n+        npref_order.push_back(npref_peers[i]);\n+    }\n+\n+    // Determine the announcement order randomly.\n+    std::vector<uint64_t> announce_order = request_order;\n+    Shuffle(announce_order.begin(), announce_order.end(), g_insecure_rand_ctx);\n+\n+    // Find a gtxid that has a prioritization consistent with the required pref_order and npref_order.\n+    auto gtxid = scenario.NewGTxid({pref_order, npref_order});\n+\n+    // Decide reqtimes in opposite order of the eventual request order. So every time time jumps\n+    // past the next reqtime, the to-be-requested-from peer will change.\n+    std::map<uint64_t, std::chrono::microseconds> reqtimes;\n+    auto reqtime = scenario.Now();\n+    for (int i = peers - 1; i >= 0; --i) {\n+        reqtime += RandomTime();\n+        reqtimes[request_order[i]] = reqtime;\n+    }\n+\n+    // Actually announce from all peers simultaneously (but in announce_order).\n+    for (const auto peer : announce_order) {\n+        scenario.ReceivedInv(peer, gtxid, preferred[peer], reqtimes[peer]);\n+    }\n+    for (const auto peer : announce_order) {\n+        scenario.Check(peer, {}, 1, 0, 0, \"b1\");\n+    }\n+\n+    // Let time pass and observe the to-be-requested-from peer change.\n+    for (int i = peers - 1; i >= 0; --i) {\n+        scenario.AdvanceTime(reqtimes[request_order[i]] - scenario.Now() - MICROSECOND);\n+        scenario.Check(request_order[i], {}, 1, 0, 0, \"b2\");\n+        scenario.AdvanceTime(MICROSECOND);\n+        scenario.Check(request_order[i], {gtxid}, 1, 0, 0, \"b3\");\n+    }\n+\n+    // Peers now in random order go offline, or send NOTFOUNDs. Observe the to-be-requested-peer\n+    // change whenever the previous best one disappears.\n+    for (int i = 0; i < peers; ++i) {\n+        if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+        const int pos = InsecureRandRange(request_order.size());\n+        const auto peer = request_order[pos];\n+        request_order.erase(request_order.begin() + pos);\n+        if (InsecureRandBool()) {\n+            scenario.DisconnectedPeer(peer);\n+            scenario.Check(peer, {}, 0, 0, 0, \"b4\");\n+        } else {\n+            scenario.ReceivedResponse(peer, gtxid);\n+            scenario.Check(peer, {}, 0, 0, request_order.size() > 0, \"b5\");\n+        }\n+        if (request_order.size()) {\n+            scenario.Check(request_order[0], {gtxid}, 1, 0, 0, \"b6\");\n+        }\n+    }\n+\n+    // Everything is gone in the end.\n+    for (const auto peer : announce_order) {\n+        scenario.Check(peer, {}, 0, 0, 0, \"b7\");\n+    }\n+}\n+\n+/** Add to scenario a test with one peer announcing two transactions, to verify they are\n+ *  fetched in announcement order. */\n+void BuildRequestOrderTest(Scenario& scenario, int config)\n+{\n+    scenario.SetTestName(strprintf(\"RequestOrder(config=%i)\", config));\n+\n+    auto peer = scenario.NewPeer();\n+    auto gtxid1 = scenario.NewGTxid();\n+    auto gtxid2 = scenario.NewGTxid();\n+\n+    auto reqtime2 = scenario.Now() + RandomTime();\n+    auto reqtime1 = reqtime2 + RandomTime();\n+\n+    scenario.ReceivedInv(peer, gtxid1, config & 1, reqtime1);\n+    // Simulate time going backwards by giving the second announcement an earlier reqtime.\n+    scenario.ReceivedInv(peer, gtxid2, config & 2, reqtime2);\n+\n+    scenario.AdvanceTime(reqtime2 - MICROSECOND - scenario.Now());\n+    scenario.Check(peer, {}, 2, 0, 0, \"o1\");\n+    scenario.AdvanceTime(MICROSECOND);\n+    scenario.Check(peer, {gtxid2}, 2, 0, 0, \"o2\");\n+    scenario.AdvanceTime(reqtime1 - MICROSECOND - scenario.Now());\n+    scenario.Check(peer, {gtxid2}, 2, 0, 0, \"o3\");\n+    scenario.AdvanceTime(MICROSECOND);\n+    // Even with time going backwards in between announcements, the return value of GetRequestable is in\n+    // announcement order.\n+    scenario.Check(peer, {gtxid1, gtxid2}, 2, 0, 0, \"o4\");\n+\n+    scenario.DisconnectedPeer(peer);\n+    scenario.Check(peer, {}, 0, 0, 0, \"o5\");\n+}\n+\n+/** Add to scenario a test thats verifies behavior related to both txid and wtxid with the same\n+    hash being announced.\n+*/\n+void BuildWtxidTest(Scenario& scenario, int config)\n+{\n+    scenario.SetTestName(strprintf(\"Wtxid(config=%i)\", config));\n+\n+    auto peerT = scenario.NewPeer();\n+    auto peerW = scenario.NewPeer();\n+    auto txhash = scenario.NewTxHash();\n+    GenTxid txid{false, txhash};\n+    GenTxid wtxid{true, txhash};\n+\n+    auto reqtimeT = InsecureRandBool() ? MIN_TIME : scenario.Now() + RandomTime();\n+    auto reqtimeW = InsecureRandBool() ? MIN_TIME : scenario.Now() + RandomTime();\n+\n+    // Announce txid first or wtxid first.\n+    if (config & 1) {\n+        scenario.ReceivedInv(peerT, txid, config & 2, reqtimeT);\n+        if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+        scenario.ReceivedInv(peerW, wtxid, !(config & 2), reqtimeW);\n+    } else {\n+        scenario.ReceivedInv(peerW, wtxid, !(config & 2), reqtimeW);\n+        if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+        scenario.ReceivedInv(peerT, txid, config & 2, reqtimeT);\n+    }\n+\n+    // Let time pass if needed, and check that the preferred announcement (txid or wtxid)\n+    // is correctly to-be-requested (and with the correct wtxidness).\n+    auto max_reqtime = std::max(reqtimeT, reqtimeW);\n+    if (max_reqtime > scenario.Now()) scenario.AdvanceTime(max_reqtime - scenario.Now());\n+    if (config & 2) {\n+        scenario.Check(peerT, {txid}, 1, 0, 0, \"w1\");\n+        scenario.Check(peerW, {}, 1, 0, 0, \"w2\");\n+    } else {\n+        scenario.Check(peerT, {}, 1, 0, 0, \"w3\");\n+        scenario.Check(peerW, {wtxid}, 1, 0, 0, \"w4\");\n+    }\n+\n+    // If a good transaction with either that hash as wtxid or txid arrives, both\n+    // announcements are gone.\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.ForgetTxHash(txhash);\n+    scenario.Check(peerT, {}, 0, 0, 0, \"w5\");\n+    scenario.Check(peerW, {}, 0, 0, 0, \"w6\");\n+}\n+\n+void TestInterleavedScenarios()\n+{\n+    // Create a list of functions which add tests to scenarios.\n+    std::vector<std::function<void(Scenario&)>> builders;\n+    // Add instances of every test, for every configuration.\n+    for (int config = 0; config < 4; ++config) {\n+        builders.emplace_back([config](Scenario& scenario){ BuildWtxidTest(scenario, config); });\n+    }\n+    for (int config = 0; config < 4; ++config) {\n+        builders.emplace_back([config](Scenario& scenario){ BuildRequestOrderTest(scenario, config); });\n+    }\n+    for (int config = 0; config < 32; ++config) {\n+        builders.emplace_back([config](Scenario& scenario){ BuildSingleTest(scenario, config); });\n+    }\n+    for (int config = 0; config < 32; ++config) {\n+        builders.emplace_back([config](Scenario& scenario){ BuildPriorityTest(scenario, config); });\n+    }\n+    for (int peers = 1; peers <= 8; ++peers) {\n+        for (int i = 0; i < 10; ++i) {\n+            builders.emplace_back([peers](Scenario& scenario){ BuildBigPriorityTest(scenario, peers); });\n+        }\n+    }\n+    // Randomly shuffle all those functions.\n+    Shuffle(builders.begin(), builders.end(), g_insecure_rand_ctx);\n+\n+    Runner runner;\n+    auto starttime = RandomTime(44);\n+    // Construct many scenarios, and run (up to) 10 randomly-chosen tests consecutively in each.\n+    while (builders.size()) {\n+        Scenario scenario(runner, starttime);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498899567",
      "id" : 498899567,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg5OTU2Nw==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 511,
      "original_position" : 511,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 501236154,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498899567",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498916810"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498916810"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yes, that's exactly the reason.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T16:12:03Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498916810",
      "id" : 498916810,
      "in_reply_to_id" : 498749661,
      "line" : 137,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxNjgxMA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 137,
      "original_position" : 133,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 137,
      "pull_request_review_id" : 501268225,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498916810",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498925098"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498925098"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The only reason not to is avoiding a dependency on net.h.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T16:28:19Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498925098",
      "id" : 498925098,
      "in_reply_to_id" : 498714760,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyNTA5OA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 62,
      "original_position" : 62,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 501279461,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498925098",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498926860"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498926860"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Does this test check that the non-preferred announcement is requested after expiration of the first one to verify that wtxidness doesn't interfere with promotion of CANDIDATEs left to _BEST ?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T16:31:43Z",
      "diff_hunk" : "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds MIN_TIME = std::chrono::microseconds::min();\n+constexpr std::chrono::microseconds MAX_TIME = std::chrono::microseconds::max();\n+constexpr std::chrono::microseconds MICROSECOND = std::chrono::microseconds{1};\n+constexpr std::chrono::microseconds NO_TIME = std::chrono::microseconds{0};\n+\n+/** An Action is a function to call at a particular (simulated) timestamp. */\n+using Action = std::pair<std::chrono::microseconds, std::function<void()>>;\n+\n+/** Object that stores actions from multiple interleaved scenarios, and data shared across them.\n+ *\n+ * The Scenario below is used to fill this.\n+ */\n+struct Runner\n+{\n+    /** The TxRequestTracker being tested. */\n+    TxRequestTracker txrequest;\n+\n+    /** List of actions to be executed (in order of increasing timestamp). */\n+    std::vector<Action> actions;\n+\n+    /** Which node ids have been assigned already (to prevent reuse). */\n+    std::set<uint64_t> peerset;\n+\n+    /** Which txhashes have been assigned already (to prevent reuse). */\n+    std::set<uint256> txhashset;\n+};\n+\n+std::chrono::microseconds RandomTime(int bits=23) { return std::chrono::microseconds{1 + InsecureRandBits(bits)}; }\n+\n+/** A proxy for a Runner that helps build a sequence of consecutive test actions on a TxRequestTracker.\n+ *\n+ * Multiple Scenarios are used with a single Runner, resulting in interleaved actions.\n+ */\n+class Scenario\n+{\n+    Runner& m_runner;\n+    std::chrono::microseconds m_now;\n+    std::string m_testname;\n+\n+public:\n+    Scenario(Runner& runner, std::chrono::microseconds starttime) : m_runner(runner)\n+    {\n+        m_now = starttime + RandomTime() + RandomTime() + RandomTime();\n+    }\n+\n+    void SetTestName(std::string testname)\n+    {\n+        m_testname = std::move(testname);\n+    }\n+\n+    void AdvanceTime(std::chrono::microseconds amount)\n+    {\n+        assert(amount.count() >= 0);\n+        m_now += amount;\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ForgetTxHash(txhash);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool pref, std::chrono::microseconds reqtime = MIN_TIME)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedInv(peer, gtxid, pref, reqtime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.DisconnectedPeer(peer);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds exptime)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.RequestedTx(peer, gtxid, exptime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedResponse(peer, gtxid);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void Check(uint64_t peer, const std::vector<GenTxid>& expected, size_t candidates, size_t inflight,\n+        size_t completed, const std::string& checkname = \"\")\n+    {\n+        const auto comment = m_testname + \" \" + checkname;\n+        auto& runner = m_runner;\n+        const auto now = m_now;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            auto ret = runner.txrequest.GetRequestable(peer, now);\n+            runner.txrequest.SanityCheck();\n+            runner.txrequest.PostGetRequestableSanityCheck(now);\n+            size_t total = candidates + inflight + completed;\n+            size_t real_total = runner.txrequest.Count(peer);\n+            size_t real_candidates = runner.txrequest.CountCandidates(peer);\n+            size_t real_inflight = runner.txrequest.CountInFlight(peer);\n+            BOOST_CHECK_MESSAGE(real_total == total, strprintf(\"[\" + comment + \"] total %i (%i expected)\", real_total, total));\n+            BOOST_CHECK_MESSAGE(real_inflight == inflight, strprintf(\"[\" + comment + \"] inflight %i (%i expected)\", real_inflight, inflight));\n+            BOOST_CHECK_MESSAGE(real_candidates == candidates, strprintf(\"[\" + comment + \"] candidates %i (%i expected)\", real_candidates, candidates));\n+            BOOST_CHECK_MESSAGE(ret == expected, \"[\" + comment + \"] mismatching requestables\");\n+        });\n+    }\n+\n+    uint256 NewTxHash(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        uint256 ret;\n+        bool ok;\n+        do {\n+            ret = InsecureRand256();\n+            ok = true;\n+            for (const auto& order : orders) {\n+                for (size_t pos = 1; pos < order.size(); ++pos) {\n+                    uint64_t prio_prev = m_runner.txrequest.ComputePriority(ret, order[pos - 1], true);\n+                    uint64_t prio_cur = m_runner.txrequest.ComputePriority(ret, order[pos], true);\n+                    if (prio_prev >= prio_cur) {\n+                        ok = false;\n+                        break;\n+                    }\n+                }\n+                if (!ok) break;\n+            }\n+            if (ok) {\n+                ok = m_runner.txhashset.insert(ret).second;\n+            }\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    GenTxid NewGTxid(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        return {InsecureRandBool(), NewTxHash(orders)};\n+    }\n+\n+    uint64_t NewPeer()\n+    {\n+        bool ok;\n+        uint64_t ret;\n+        do {\n+            ret = InsecureRandBits(63);\n+            ok = m_runner.peerset.insert(ret).second;\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    std::chrono::microseconds Now() const { return m_now; }\n+};\n+\n+/** Add to scenario a test with a single tx announced by a single peer.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildSingleTest(Scenario& scenario, int config)\n+{\n+    auto peer = scenario.NewPeer();\n+    auto gtxid = scenario.NewGTxid();\n+    bool immediate = config & 1;\n+    bool preferred = config & 2;\n+    auto delay = immediate ? NO_TIME : RandomTime();\n+\n+    scenario.SetTestName(strprintf(\"Single(config=%i)\", config));\n+\n+    // Receive an announcement, either immediately requestable or delayed.\n+    scenario.ReceivedInv(peer, gtxid, preferred, immediate ? MIN_TIME : scenario.Now() + delay);\n+    if (immediate) {\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s1\");\n+    } else {\n+        scenario.Check(peer, {}, 1, 0, 0, \"s2\");\n+        scenario.AdvanceTime(delay - MICROSECOND);\n+        scenario.Check(peer, {}, 1, 0, 0, \"s3\");\n+        scenario.AdvanceTime(MICROSECOND);\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s4\");\n+    }\n+\n+    if (config >> 3) { // We'll request the transaction\n+        scenario.AdvanceTime(RandomTime());\n+        auto expiry = RandomTime();\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s5\");\n+        scenario.RequestedTx(peer, gtxid, scenario.Now() + expiry);\n+        scenario.Check(peer, {}, 0, 1, 0, \"s6\");\n+\n+        if ((config >> 3) == 1) { // The request will time out\n+            scenario.AdvanceTime(expiry - MICROSECOND);\n+            scenario.Check(peer, {}, 0, 1, 0, \"s7\");\n+            scenario.AdvanceTime(MICROSECOND);\n+            scenario.Check(peer, {}, 0, 0, 0, \"s8\");\n+            return;\n+        } else {\n+            scenario.AdvanceTime(std::chrono::microseconds{InsecureRandRange(expiry.count())});\n+            scenario.Check(peer, {}, 0, 1, 0, \"s9\");\n+            if ((config >> 3) == 3) { // A reponse will arrive for the transaction\n+                scenario.ReceivedResponse(peer, gtxid);\n+                scenario.Check(peer, {}, 0, 0, 0, \"s10\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    scenario.AdvanceTime(RandomTime());\n+    if (config & 4) { // The peer will go offline\n+        scenario.DisconnectedPeer(peer);\n+    } else { // The transaction is no longer needed\n+        scenario.ForgetTxHash(gtxid.GetHash());\n+    }\n+    scenario.Check(peer, {}, 0, 0, 0, \"s11\");\n+}\n+\n+/** Add to scenario a test with a single tx announced by two peers, to verify the\n+ *  right peer is selected for requests.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildPriorityTest(Scenario& scenario, int config)\n+{\n+    scenario.SetTestName(strprintf(\"Priority(config=%i)\", config));\n+\n+    // Three peers. They will announce in order.\n+    auto peer1 = scenario.NewPeer(), peer2 = scenario.NewPeer();\n+    // Construct a transaction that under random rules would be preferred by peer2 or peer1,\n+    // depending on configuration.\n+    bool prio1 = config & 1;\n+    auto gtxid = prio1 ? scenario.NewGTxid({{peer1, peer2}}) : scenario.NewGTxid({{peer2, peer1}});\n+    bool pref1 = config & 2, pref2 = config & 4;\n+\n+    scenario.ReceivedInv(peer1, gtxid, pref1, MIN_TIME);\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p1\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p2\");\n+\n+    scenario.ReceivedInv(peer2, gtxid, pref2, MIN_TIME);\n+    bool stage2_prio =\n+        // At this point, peer2 will be given priority if:\n+        // - It is preferred and peer1 is not\n+        (pref2 && !pref1) ||\n+        // - They're in the same preference class,\n+        //   and the randomized priority favors peer2 over peer1.\n+        (pref1 == pref2 && !prio1);\n+    uint64_t priopeer = stage2_prio ? peer2 : peer1, otherpeer = stage2_prio ? peer1 : peer2;\n+    scenario.Check(otherpeer, {}, 1, 0, 0, \"p3\");\n+    scenario.Check(priopeer, {gtxid}, 1, 0, 0, \"p4\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(otherpeer, {}, 1, 0, 0, \"p5\");\n+    scenario.Check(priopeer, {gtxid}, 1, 0, 0, \"p6\");\n+\n+    // We possibly request from the selected peer.\n+    if (config & 8) {\n+        scenario.RequestedTx(priopeer, gtxid, MAX_TIME);\n+        scenario.Check(priopeer, {}, 0, 1, 0, \"p7\");\n+        scenario.Check(otherpeer, {}, 1, 0, 0, \"p8\");\n+        if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    }\n+\n+    // The peer which was selected (or requested from) now goes offline, or a NOTFOUND is received from them.\n+    if (config & 16) {\n+        scenario.DisconnectedPeer(priopeer);\n+    } else {\n+        scenario.ReceivedResponse(priopeer, gtxid);\n+    }\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(priopeer, {}, 0, 0, !(config & 16), \"p8\");\n+    scenario.Check(otherpeer, {gtxid}, 1, 0, 0, \"p9\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+\n+    // Now the other peer goes offline.\n+    scenario.DisconnectedPeer(otherpeer);\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(peer1, {}, 0, 0, 0, \"p10\");\n+    scenario.Check(peer2, {}, 0, 0, 0, \"p11\");\n+}\n+\n+/** Add to scenario a randomized test in which N peers announce the same transaction, to verify\n+ *  the order in which they are requested.\n+ */\n+void BuildBigPriorityTest(Scenario& scenario, int peers)\n+{\n+    scenario.SetTestName(strprintf(\"BigPriority(peers=%i)\", peers));\n+\n+    // We will have N peers announce the same transaction.\n+    std::map<uint64_t, bool> preferred;\n+    std::vector<uint64_t> pref_order, npref_order;\n+    std::vector<uint64_t> pref_peers, npref_peers;\n+    int num_pref = InsecureRandRange(peers + 1) ; // Some preferred, ...\n+    int num_npref = peers - num_pref; // some not preferred.\n+    for (int i = 0; i < num_pref; ++i) {\n+        pref_peers.push_back(scenario.NewPeer());\n+        preferred[pref_peers.back()] = true;\n+    }\n+    for (int i = 0; i < num_npref; ++i) {\n+        npref_peers.push_back(scenario.NewPeer());\n+        preferred[npref_peers.back()] = false;\n+    }\n+    // Make a list of all peers, in order of intended request order (concatenation of pref_peers and\n+    // npref_peers).\n+    std::vector<uint64_t> request_order;\n+    for (int i = 0; i < num_pref; ++i) request_order.push_back(pref_peers[i]);\n+    for (int i = 0; i < num_npref; ++i) request_order.push_back(npref_peers[i]);\n+\n+    // Setup pref_order\n+    for (int i = 0; i < num_pref; ++i) {\n+        pref_order.push_back(pref_peers[i]);\n+    }\n+\n+    // Setup npref_order\n+    for (int i = 0; i < num_npref; ++i) {\n+        npref_order.push_back(npref_peers[i]);\n+    }\n+\n+    // Determine the announcement order randomly.\n+    std::vector<uint64_t> announce_order = request_order;\n+    Shuffle(announce_order.begin(), announce_order.end(), g_insecure_rand_ctx);\n+\n+    // Find a gtxid that has a prioritization consistent with the required pref_order and npref_order.\n+    auto gtxid = scenario.NewGTxid({pref_order, npref_order});\n+\n+    // Decide reqtimes in opposite order of the eventual request order. So every time time jumps\n+    // past the next reqtime, the to-be-requested-from peer will change.\n+    std::map<uint64_t, std::chrono::microseconds> reqtimes;\n+    auto reqtime = scenario.Now();\n+    for (int i = peers - 1; i >= 0; --i) {\n+        reqtime += RandomTime();\n+        reqtimes[request_order[i]] = reqtime;\n+    }\n+\n+    // Actually announce from all peers simultaneously (but in announce_order).\n+    for (const auto peer : announce_order) {\n+        scenario.ReceivedInv(peer, gtxid, preferred[peer], reqtimes[peer]);\n+    }\n+    for (const auto peer : announce_order) {\n+        scenario.Check(peer, {}, 1, 0, 0, \"b1\");\n+    }\n+\n+    // Let time pass and observe the to-be-requested-from peer change.\n+    for (int i = peers - 1; i >= 0; --i) {\n+        scenario.AdvanceTime(reqtimes[request_order[i]] - scenario.Now() - MICROSECOND);\n+        scenario.Check(request_order[i], {}, 1, 0, 0, \"b2\");\n+        scenario.AdvanceTime(MICROSECOND);\n+        scenario.Check(request_order[i], {gtxid}, 1, 0, 0, \"b3\");\n+    }\n+\n+    // Peers now in random order go offline, or send NOTFOUNDs. Observe the to-be-requested-peer\n+    // change whenever the previous best one disappears.\n+    for (int i = 0; i < peers; ++i) {\n+        if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+        const int pos = InsecureRandRange(request_order.size());\n+        const auto peer = request_order[pos];\n+        request_order.erase(request_order.begin() + pos);\n+        if (InsecureRandBool()) {\n+            scenario.DisconnectedPeer(peer);\n+            scenario.Check(peer, {}, 0, 0, 0, \"b4\");\n+        } else {\n+            scenario.ReceivedResponse(peer, gtxid);\n+            scenario.Check(peer, {}, 0, 0, request_order.size() > 0, \"b5\");\n+        }\n+        if (request_order.size()) {\n+            scenario.Check(request_order[0], {gtxid}, 1, 0, 0, \"b6\");\n+        }\n+    }\n+\n+    // Everything is gone in the end.\n+    for (const auto peer : announce_order) {\n+        scenario.Check(peer, {}, 0, 0, 0, \"b7\");\n+    }\n+}\n+\n+/** Add to scenario a test with one peer announcing two transactions, to verify they are\n+ *  fetched in announcement order. */\n+void BuildRequestOrderTest(Scenario& scenario, int config)\n+{\n+    scenario.SetTestName(strprintf(\"RequestOrder(config=%i)\", config));\n+\n+    auto peer = scenario.NewPeer();\n+    auto gtxid1 = scenario.NewGTxid();\n+    auto gtxid2 = scenario.NewGTxid();\n+\n+    auto reqtime2 = scenario.Now() + RandomTime();\n+    auto reqtime1 = reqtime2 + RandomTime();\n+\n+    scenario.ReceivedInv(peer, gtxid1, config & 1, reqtime1);\n+    // Simulate time going backwards by giving the second announcement an earlier reqtime.\n+    scenario.ReceivedInv(peer, gtxid2, config & 2, reqtime2);\n+\n+    scenario.AdvanceTime(reqtime2 - MICROSECOND - scenario.Now());\n+    scenario.Check(peer, {}, 2, 0, 0, \"o1\");\n+    scenario.AdvanceTime(MICROSECOND);\n+    scenario.Check(peer, {gtxid2}, 2, 0, 0, \"o2\");\n+    scenario.AdvanceTime(reqtime1 - MICROSECOND - scenario.Now());\n+    scenario.Check(peer, {gtxid2}, 2, 0, 0, \"o3\");\n+    scenario.AdvanceTime(MICROSECOND);\n+    // Even with time going backwards in between announcements, the return value of GetRequestable is in\n+    // announcement order.\n+    scenario.Check(peer, {gtxid1, gtxid2}, 2, 0, 0, \"o4\");\n+\n+    scenario.DisconnectedPeer(peer);\n+    scenario.Check(peer, {}, 0, 0, 0, \"o5\");\n+}\n+\n+/** Add to scenario a test thats verifies behavior related to both txid and wtxid with the same\n+    hash being announced.\n+*/\n+void BuildWtxidTest(Scenario& scenario, int config)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498926860",
      "id" : 498926860,
      "line" : 460,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyNjg2MA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 460,
      "original_position" : 438,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : 460,
      "pull_request_review_id" : 501236154,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498926860",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498935631"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498935631"
         }
      },
      "author_association" : "MEMBER",
      "body" : "You mean in the header file? Could you make the public functions take `int64_t` and use `NodeId` internally in the cpp file (which already includes net.h)?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T16:49:40Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498935631",
      "id" : 498935631,
      "in_reply_to_id" : 498714760,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzNTYzMQ==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 62,
      "original_position" : 62,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 501293510,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498935631",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498936239"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498936239"
         }
      },
      "author_association" : "MEMBER",
      "body" : "What about `m_cur_sequence` to dissociate clearly from the per-Entry `m_sequence` ? Also comment could be clearer that the the request are ordered per-peer, not globally. I had a doubt while reviewing `BuildRequestOrderTest`",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T16:50:55Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498936239",
      "id" : 498936239,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzNjIzOQ==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 282,
      "original_position" : 282,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 501236154,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498936239",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498936404"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498936404"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It may be matter of personal taste.\r\n\r\nIn general I think it still makes sense to have non-exposed classes with private/public fields/members. It's not there to prevent external code from messing with the internals, obviously, but it does still kind of define a layer between what is part of the class's representation and what is its (even just internally) exposed interface.\r\n\r\nIn this case with the pimpl pattern... maybe that's silly, as the glue layer to forward calls on `TxRequestTracker` to `TxRequestTracker::Impl` is super thin, and it's already obvious what the exposed part is.\r\n\r\nHappy to change it if there are strong opinions.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T16:51:18Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+public:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498936404",
      "id" : 498936404,
      "in_reply_to_id" : 498708036,
      "line" : 318,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzNjQwNA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 318,
      "original_position" : 293,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 318,
      "pull_request_review_id" : 501294597,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498936404",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498937736"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498937736"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Maybe add a config where they're _all_ preferred/non-preferred ? `InsecureRandRange` is really unlikely to return min and max values when you have 7 peers ?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T16:54:00Z",
      "diff_hunk" : "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds MIN_TIME = std::chrono::microseconds::min();\n+constexpr std::chrono::microseconds MAX_TIME = std::chrono::microseconds::max();\n+constexpr std::chrono::microseconds MICROSECOND = std::chrono::microseconds{1};\n+constexpr std::chrono::microseconds NO_TIME = std::chrono::microseconds{0};\n+\n+/** An Action is a function to call at a particular (simulated) timestamp. */\n+using Action = std::pair<std::chrono::microseconds, std::function<void()>>;\n+\n+/** Object that stores actions from multiple interleaved scenarios, and data shared across them.\n+ *\n+ * The Scenario below is used to fill this.\n+ */\n+struct Runner\n+{\n+    /** The TxRequestTracker being tested. */\n+    TxRequestTracker txrequest;\n+\n+    /** List of actions to be executed (in order of increasing timestamp). */\n+    std::vector<Action> actions;\n+\n+    /** Which node ids have been assigned already (to prevent reuse). */\n+    std::set<uint64_t> peerset;\n+\n+    /** Which txhashes have been assigned already (to prevent reuse). */\n+    std::set<uint256> txhashset;\n+};\n+\n+std::chrono::microseconds RandomTime(int bits=23) { return std::chrono::microseconds{1 + InsecureRandBits(bits)}; }\n+\n+/** A proxy for a Runner that helps build a sequence of consecutive test actions on a TxRequestTracker.\n+ *\n+ * Multiple Scenarios are used with a single Runner, resulting in interleaved actions.\n+ */\n+class Scenario\n+{\n+    Runner& m_runner;\n+    std::chrono::microseconds m_now;\n+    std::string m_testname;\n+\n+public:\n+    Scenario(Runner& runner, std::chrono::microseconds starttime) : m_runner(runner)\n+    {\n+        m_now = starttime + RandomTime() + RandomTime() + RandomTime();\n+    }\n+\n+    void SetTestName(std::string testname)\n+    {\n+        m_testname = std::move(testname);\n+    }\n+\n+    void AdvanceTime(std::chrono::microseconds amount)\n+    {\n+        assert(amount.count() >= 0);\n+        m_now += amount;\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ForgetTxHash(txhash);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool pref, std::chrono::microseconds reqtime = MIN_TIME)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedInv(peer, gtxid, pref, reqtime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.DisconnectedPeer(peer);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds exptime)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.RequestedTx(peer, gtxid, exptime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedResponse(peer, gtxid);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void Check(uint64_t peer, const std::vector<GenTxid>& expected, size_t candidates, size_t inflight,\n+        size_t completed, const std::string& checkname = \"\")\n+    {\n+        const auto comment = m_testname + \" \" + checkname;\n+        auto& runner = m_runner;\n+        const auto now = m_now;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            auto ret = runner.txrequest.GetRequestable(peer, now);\n+            runner.txrequest.SanityCheck();\n+            runner.txrequest.PostGetRequestableSanityCheck(now);\n+            size_t total = candidates + inflight + completed;\n+            size_t real_total = runner.txrequest.Count(peer);\n+            size_t real_candidates = runner.txrequest.CountCandidates(peer);\n+            size_t real_inflight = runner.txrequest.CountInFlight(peer);\n+            BOOST_CHECK_MESSAGE(real_total == total, strprintf(\"[\" + comment + \"] total %i (%i expected)\", real_total, total));\n+            BOOST_CHECK_MESSAGE(real_inflight == inflight, strprintf(\"[\" + comment + \"] inflight %i (%i expected)\", real_inflight, inflight));\n+            BOOST_CHECK_MESSAGE(real_candidates == candidates, strprintf(\"[\" + comment + \"] candidates %i (%i expected)\", real_candidates, candidates));\n+            BOOST_CHECK_MESSAGE(ret == expected, \"[\" + comment + \"] mismatching requestables\");\n+        });\n+    }\n+\n+    uint256 NewTxHash(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        uint256 ret;\n+        bool ok;\n+        do {\n+            ret = InsecureRand256();\n+            ok = true;\n+            for (const auto& order : orders) {\n+                for (size_t pos = 1; pos < order.size(); ++pos) {\n+                    uint64_t prio_prev = m_runner.txrequest.ComputePriority(ret, order[pos - 1], true);\n+                    uint64_t prio_cur = m_runner.txrequest.ComputePriority(ret, order[pos], true);\n+                    if (prio_prev >= prio_cur) {\n+                        ok = false;\n+                        break;\n+                    }\n+                }\n+                if (!ok) break;\n+            }\n+            if (ok) {\n+                ok = m_runner.txhashset.insert(ret).second;\n+            }\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    GenTxid NewGTxid(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        return {InsecureRandBool(), NewTxHash(orders)};\n+    }\n+\n+    uint64_t NewPeer()\n+    {\n+        bool ok;\n+        uint64_t ret;\n+        do {\n+            ret = InsecureRandBits(63);\n+            ok = m_runner.peerset.insert(ret).second;\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    std::chrono::microseconds Now() const { return m_now; }\n+};\n+\n+/** Add to scenario a test with a single tx announced by a single peer.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildSingleTest(Scenario& scenario, int config)\n+{\n+    auto peer = scenario.NewPeer();\n+    auto gtxid = scenario.NewGTxid();\n+    bool immediate = config & 1;\n+    bool preferred = config & 2;\n+    auto delay = immediate ? NO_TIME : RandomTime();\n+\n+    scenario.SetTestName(strprintf(\"Single(config=%i)\", config));\n+\n+    // Receive an announcement, either immediately requestable or delayed.\n+    scenario.ReceivedInv(peer, gtxid, preferred, immediate ? MIN_TIME : scenario.Now() + delay);\n+    if (immediate) {\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s1\");\n+    } else {\n+        scenario.Check(peer, {}, 1, 0, 0, \"s2\");\n+        scenario.AdvanceTime(delay - MICROSECOND);\n+        scenario.Check(peer, {}, 1, 0, 0, \"s3\");\n+        scenario.AdvanceTime(MICROSECOND);\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s4\");\n+    }\n+\n+    if (config >> 3) { // We'll request the transaction\n+        scenario.AdvanceTime(RandomTime());\n+        auto expiry = RandomTime();\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s5\");\n+        scenario.RequestedTx(peer, gtxid, scenario.Now() + expiry);\n+        scenario.Check(peer, {}, 0, 1, 0, \"s6\");\n+\n+        if ((config >> 3) == 1) { // The request will time out\n+            scenario.AdvanceTime(expiry - MICROSECOND);\n+            scenario.Check(peer, {}, 0, 1, 0, \"s7\");\n+            scenario.AdvanceTime(MICROSECOND);\n+            scenario.Check(peer, {}, 0, 0, 0, \"s8\");\n+            return;\n+        } else {\n+            scenario.AdvanceTime(std::chrono::microseconds{InsecureRandRange(expiry.count())});\n+            scenario.Check(peer, {}, 0, 1, 0, \"s9\");\n+            if ((config >> 3) == 3) { // A reponse will arrive for the transaction\n+                scenario.ReceivedResponse(peer, gtxid);\n+                scenario.Check(peer, {}, 0, 0, 0, \"s10\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    scenario.AdvanceTime(RandomTime());\n+    if (config & 4) { // The peer will go offline\n+        scenario.DisconnectedPeer(peer);\n+    } else { // The transaction is no longer needed\n+        scenario.ForgetTxHash(gtxid.GetHash());\n+    }\n+    scenario.Check(peer, {}, 0, 0, 0, \"s11\");\n+}\n+\n+/** Add to scenario a test with a single tx announced by two peers, to verify the\n+ *  right peer is selected for requests.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildPriorityTest(Scenario& scenario, int config)\n+{\n+    scenario.SetTestName(strprintf(\"Priority(config=%i)\", config));\n+\n+    // Three peers. They will announce in order.\n+    auto peer1 = scenario.NewPeer(), peer2 = scenario.NewPeer();\n+    // Construct a transaction that under random rules would be preferred by peer2 or peer1,\n+    // depending on configuration.\n+    bool prio1 = config & 1;\n+    auto gtxid = prio1 ? scenario.NewGTxid({{peer1, peer2}}) : scenario.NewGTxid({{peer2, peer1}});\n+    bool pref1 = config & 2, pref2 = config & 4;\n+\n+    scenario.ReceivedInv(peer1, gtxid, pref1, MIN_TIME);\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p1\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p2\");\n+\n+    scenario.ReceivedInv(peer2, gtxid, pref2, MIN_TIME);\n+    bool stage2_prio =\n+        // At this point, peer2 will be given priority if:\n+        // - It is preferred and peer1 is not\n+        (pref2 && !pref1) ||\n+        // - They're in the same preference class,\n+        //   and the randomized priority favors peer2 over peer1.\n+        (pref1 == pref2 && !prio1);\n+    uint64_t priopeer = stage2_prio ? peer2 : peer1, otherpeer = stage2_prio ? peer1 : peer2;\n+    scenario.Check(otherpeer, {}, 1, 0, 0, \"p3\");\n+    scenario.Check(priopeer, {gtxid}, 1, 0, 0, \"p4\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(otherpeer, {}, 1, 0, 0, \"p5\");\n+    scenario.Check(priopeer, {gtxid}, 1, 0, 0, \"p6\");\n+\n+    // We possibly request from the selected peer.\n+    if (config & 8) {\n+        scenario.RequestedTx(priopeer, gtxid, MAX_TIME);\n+        scenario.Check(priopeer, {}, 0, 1, 0, \"p7\");\n+        scenario.Check(otherpeer, {}, 1, 0, 0, \"p8\");\n+        if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    }\n+\n+    // The peer which was selected (or requested from) now goes offline, or a NOTFOUND is received from them.\n+    if (config & 16) {\n+        scenario.DisconnectedPeer(priopeer);\n+    } else {\n+        scenario.ReceivedResponse(priopeer, gtxid);\n+    }\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(priopeer, {}, 0, 0, !(config & 16), \"p8\");\n+    scenario.Check(otherpeer, {gtxid}, 1, 0, 0, \"p9\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+\n+    // Now the other peer goes offline.\n+    scenario.DisconnectedPeer(otherpeer);\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(peer1, {}, 0, 0, 0, \"p10\");\n+    scenario.Check(peer2, {}, 0, 0, 0, \"p11\");\n+}\n+\n+/** Add to scenario a randomized test in which N peers announce the same transaction, to verify\n+ *  the order in which they are requested.\n+ */\n+void BuildBigPriorityTest(Scenario& scenario, int peers)\n+{\n+    scenario.SetTestName(strprintf(\"BigPriority(peers=%i)\", peers));\n+\n+    // We will have N peers announce the same transaction.\n+    std::map<uint64_t, bool> preferred;\n+    std::vector<uint64_t> pref_order, npref_order;\n+    std::vector<uint64_t> pref_peers, npref_peers;\n+    int num_pref = InsecureRandRange(peers + 1) ; // Some preferred, ...\n+    int num_npref = peers - num_pref; // some not preferred.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498937736",
      "id" : 498937736,
      "line" : 352,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzNzczNg==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 352,
      "original_position" : 321,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : 352,
      "pull_request_review_id" : 501236154,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498937736",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498938083"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498938083"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think the observable \"c++ file dependencies\" are only an approximation for what actually matters in terms of code organization: \"conceptual dependencies between modules\". What you're suggesting is just as much a dependency of txrequest on net in my view - just slightly more hidden.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T16:54:44Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498938083",
      "id" : 498938083,
      "in_reply_to_id" : 498714760,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzODA4Mw==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 62,
      "original_position" : 62,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 501296896,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498938083",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498941128"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498941128"
         }
      },
      "author_association" : "MEMBER",
      "body" : "All of this to say: I'd like to avoid a dependency on net, and am therefore using uint64_t as opaque peer identifier rather than NodeId.\r\n\r\nBut if we feel that's not worth the cost, it should be changed to use NodeId everywhere (in both the .h and the .cpp).",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T17:00:54Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498941128",
      "id" : 498941128,
      "in_reply_to_id" : 498714760,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk0MTEyOA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 62,
      "original_position" : 62,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 501301051,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498941128",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498944375"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498944375"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It wouldn't be too hard to just drop the constraint, and instead specify it as:\r\n* If no announcement with the specified (peer, txhash) exists, or it isn't in CANDIDATE state, the call has no effect.\r\n* The specified announcement is changed from CANDIDATE to REQUESTED.\r\n* If another announcement for the same txhash was already in REQUESTED state, it is marked COMPLETED.\r\n\r\nIt'd be a bit more code, but would make the function fully specified. I've avoided it, as there is really no point for that functionality in practice, but it does make things a bit nicer. WDYT?\r\n\r\nIf we don't do that, I like @ajtowns's way of describing the functionality.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T17:07:39Z",
      "diff_hunk" : "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction. Note that this only works\n+ *              per txhash, so if the same transaction is announced both through txid and wtxid, we have no means\n+ *              to prevent fetching both (the caller can however mitigate this by delaying one, see further).\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten only:\n+ *   - If a peer goes offline, all its announcements are forgotten.\n+ *   - If a transaction has been successfully received, or is otherwise no longer needed, the caller can call\n+ *     ForgetTxHash, which removes all announcements across all peers with the specified txhash.\n+ *   - If for a given txhash only already-requested announcements remain, they are all forgotten.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening transaction censoring attacks. The flip side is that as long as an attacker manages\n+ *              to prevent us from receiving a transaction, failed announcements (including those from honest peers)\n+ *              will linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a\n+ *              cap on the number of tracked announcements per peer. As failed requests in response to announcements\n+ *              from honest peers should be rare, this almost solely hinders attackers.\n+ *              Transaction censoring attacks can be done by announcing transactions quickly while not answering\n+ *              requests for them. See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more\n+ *              information.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable the calling code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers are more trusted by us, so are less likely to be under attacker control.\n+ *\n+ *   - Pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: random assignments are hard to influence for attackers.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and minimizing\n+ * susceptibility to censorship attacks. An attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one preferred connection).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution). The \"1 +\" is due to the fact that the\n+ *   attacker can be the first to announce through a preferred connection in this scenario, which very likely means\n+ *   they get the first request.\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh>=1\n+ *   are honest, where we assume that the attacker can disconnect and reconnect those connections, the distribution\n+ *   becomes k ~ P + NB(p=1-NP/NPh,r=1) (where NB stands for Negative Binomial distribution), which has mean\n+ *   P-1+NP/NPh.\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, and a NOTFOUND or a\n+    //   transaction was received in response (valid or not), or they timed out. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DisconnectedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash (both txid and wtxid ones).\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it.\n+     */\n+    void ForgetTxHash(const uint256& txhash);\n+\n+    /** Adds a new CANDIDATE announcement.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that the txid/wtxid property is ignored for determining uniqueness, so if an announcement\n+     * is added for a wtxid H, while one for txid H from the same peer already exists, it will be ignored. This is\n+     * harmless as the txhashes being equal implies it is a non-segwit transaction, so it doesn't matter how it is\n+     * fetched. The new announcement is given the specified preferred and reqtime values, and takes it is_wtxid from\n+     * the specified gtxid.\n+     */\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime);\n+\n+    /** Converts the CANDIDATE announcement for the provided peer and gtxid into a REQUESTED one.\n+     *\n+     * Expiry is set to the specified value. This can ONLY be called immediately after GetRequestable was called\n+     * (for the same peer), with only ForgetTx and other RequestedTx calls (both for other txhashes) in\n+     * between. Any other non-const operation removes the ability to call RequestedTx.\n+     */\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds expiry);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498944375",
      "id" : 498944375,
      "in_reply_to_id" : 498734530,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk0NDM3NQ==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 151,
      "original_position" : 151,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 501305482,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498944375",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498947675"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498947675"
         }
      },
      "author_association" : "MEMBER",
      "body" : "No strong opinion. Feel free to mark this resolved.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T17:14:22Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+public:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498947675",
      "id" : 498947675,
      "in_reply_to_id" : 498708036,
      "line" : 318,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk0NzY3NQ==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 318,
      "original_position" : 293,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 318,
      "pull_request_review_id" : 501309949,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498947675",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498949058"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498949058"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I do feel like we should use the same type to represent node ids in all components. Perhaps the purest way to do it would be to move the `typedef NodeId int64_t` somewhere outside net.h, but that seems a bit overkill.\r\n\r\nEven if you don't use `NodeId`, is there a reason that you're using `uint64_t` rather than `int64_t` like everywhere else?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T17:17:14Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498949058",
      "id" : 498949058,
      "in_reply_to_id" : 498714760,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk0OTA1OA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 62,
      "original_position" : 62,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 501311801,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498949058",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498949341"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498949341"
         }
      },
      "author_association" : "MEMBER",
      "body" : "If I understand `NewTxHash` correctly it will return a `uint256` which is guaranteed to respect the priority order of peers for both preferred and non-preferred classes ? And those `NewTxHash` checks are needed as peer identifier is part of siphash message. It's more find a `txhash` rather than a `gtxid` as wtxidness shouldn't interfere with priority. ",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T17:17:54Z",
      "diff_hunk" : "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds MIN_TIME = std::chrono::microseconds::min();\n+constexpr std::chrono::microseconds MAX_TIME = std::chrono::microseconds::max();\n+constexpr std::chrono::microseconds MICROSECOND = std::chrono::microseconds{1};\n+constexpr std::chrono::microseconds NO_TIME = std::chrono::microseconds{0};\n+\n+/** An Action is a function to call at a particular (simulated) timestamp. */\n+using Action = std::pair<std::chrono::microseconds, std::function<void()>>;\n+\n+/** Object that stores actions from multiple interleaved scenarios, and data shared across them.\n+ *\n+ * The Scenario below is used to fill this.\n+ */\n+struct Runner\n+{\n+    /** The TxRequestTracker being tested. */\n+    TxRequestTracker txrequest;\n+\n+    /** List of actions to be executed (in order of increasing timestamp). */\n+    std::vector<Action> actions;\n+\n+    /** Which node ids have been assigned already (to prevent reuse). */\n+    std::set<uint64_t> peerset;\n+\n+    /** Which txhashes have been assigned already (to prevent reuse). */\n+    std::set<uint256> txhashset;\n+};\n+\n+std::chrono::microseconds RandomTime(int bits=23) { return std::chrono::microseconds{1 + InsecureRandBits(bits)}; }\n+\n+/** A proxy for a Runner that helps build a sequence of consecutive test actions on a TxRequestTracker.\n+ *\n+ * Multiple Scenarios are used with a single Runner, resulting in interleaved actions.\n+ */\n+class Scenario\n+{\n+    Runner& m_runner;\n+    std::chrono::microseconds m_now;\n+    std::string m_testname;\n+\n+public:\n+    Scenario(Runner& runner, std::chrono::microseconds starttime) : m_runner(runner)\n+    {\n+        m_now = starttime + RandomTime() + RandomTime() + RandomTime();\n+    }\n+\n+    void SetTestName(std::string testname)\n+    {\n+        m_testname = std::move(testname);\n+    }\n+\n+    void AdvanceTime(std::chrono::microseconds amount)\n+    {\n+        assert(amount.count() >= 0);\n+        m_now += amount;\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ForgetTxHash(txhash);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool pref, std::chrono::microseconds reqtime = MIN_TIME)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedInv(peer, gtxid, pref, reqtime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.DisconnectedPeer(peer);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds exptime)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.RequestedTx(peer, gtxid, exptime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedResponse(peer, gtxid);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void Check(uint64_t peer, const std::vector<GenTxid>& expected, size_t candidates, size_t inflight,\n+        size_t completed, const std::string& checkname = \"\")\n+    {\n+        const auto comment = m_testname + \" \" + checkname;\n+        auto& runner = m_runner;\n+        const auto now = m_now;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            auto ret = runner.txrequest.GetRequestable(peer, now);\n+            runner.txrequest.SanityCheck();\n+            runner.txrequest.PostGetRequestableSanityCheck(now);\n+            size_t total = candidates + inflight + completed;\n+            size_t real_total = runner.txrequest.Count(peer);\n+            size_t real_candidates = runner.txrequest.CountCandidates(peer);\n+            size_t real_inflight = runner.txrequest.CountInFlight(peer);\n+            BOOST_CHECK_MESSAGE(real_total == total, strprintf(\"[\" + comment + \"] total %i (%i expected)\", real_total, total));\n+            BOOST_CHECK_MESSAGE(real_inflight == inflight, strprintf(\"[\" + comment + \"] inflight %i (%i expected)\", real_inflight, inflight));\n+            BOOST_CHECK_MESSAGE(real_candidates == candidates, strprintf(\"[\" + comment + \"] candidates %i (%i expected)\", real_candidates, candidates));\n+            BOOST_CHECK_MESSAGE(ret == expected, \"[\" + comment + \"] mismatching requestables\");\n+        });\n+    }\n+\n+    uint256 NewTxHash(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        uint256 ret;\n+        bool ok;\n+        do {\n+            ret = InsecureRand256();\n+            ok = true;\n+            for (const auto& order : orders) {\n+                for (size_t pos = 1; pos < order.size(); ++pos) {\n+                    uint64_t prio_prev = m_runner.txrequest.ComputePriority(ret, order[pos - 1], true);\n+                    uint64_t prio_cur = m_runner.txrequest.ComputePriority(ret, order[pos], true);\n+                    if (prio_prev >= prio_cur) {\n+                        ok = false;\n+                        break;\n+                    }\n+                }\n+                if (!ok) break;\n+            }\n+            if (ok) {\n+                ok = m_runner.txhashset.insert(ret).second;\n+            }\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    GenTxid NewGTxid(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        return {InsecureRandBool(), NewTxHash(orders)};\n+    }\n+\n+    uint64_t NewPeer()\n+    {\n+        bool ok;\n+        uint64_t ret;\n+        do {\n+            ret = InsecureRandBits(63);\n+            ok = m_runner.peerset.insert(ret).second;\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    std::chrono::microseconds Now() const { return m_now; }\n+};\n+\n+/** Add to scenario a test with a single tx announced by a single peer.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildSingleTest(Scenario& scenario, int config)\n+{\n+    auto peer = scenario.NewPeer();\n+    auto gtxid = scenario.NewGTxid();\n+    bool immediate = config & 1;\n+    bool preferred = config & 2;\n+    auto delay = immediate ? NO_TIME : RandomTime();\n+\n+    scenario.SetTestName(strprintf(\"Single(config=%i)\", config));\n+\n+    // Receive an announcement, either immediately requestable or delayed.\n+    scenario.ReceivedInv(peer, gtxid, preferred, immediate ? MIN_TIME : scenario.Now() + delay);\n+    if (immediate) {\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s1\");\n+    } else {\n+        scenario.Check(peer, {}, 1, 0, 0, \"s2\");\n+        scenario.AdvanceTime(delay - MICROSECOND);\n+        scenario.Check(peer, {}, 1, 0, 0, \"s3\");\n+        scenario.AdvanceTime(MICROSECOND);\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s4\");\n+    }\n+\n+    if (config >> 3) { // We'll request the transaction\n+        scenario.AdvanceTime(RandomTime());\n+        auto expiry = RandomTime();\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s5\");\n+        scenario.RequestedTx(peer, gtxid, scenario.Now() + expiry);\n+        scenario.Check(peer, {}, 0, 1, 0, \"s6\");\n+\n+        if ((config >> 3) == 1) { // The request will time out\n+            scenario.AdvanceTime(expiry - MICROSECOND);\n+            scenario.Check(peer, {}, 0, 1, 0, \"s7\");\n+            scenario.AdvanceTime(MICROSECOND);\n+            scenario.Check(peer, {}, 0, 0, 0, \"s8\");\n+            return;\n+        } else {\n+            scenario.AdvanceTime(std::chrono::microseconds{InsecureRandRange(expiry.count())});\n+            scenario.Check(peer, {}, 0, 1, 0, \"s9\");\n+            if ((config >> 3) == 3) { // A reponse will arrive for the transaction\n+                scenario.ReceivedResponse(peer, gtxid);\n+                scenario.Check(peer, {}, 0, 0, 0, \"s10\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    scenario.AdvanceTime(RandomTime());\n+    if (config & 4) { // The peer will go offline\n+        scenario.DisconnectedPeer(peer);\n+    } else { // The transaction is no longer needed\n+        scenario.ForgetTxHash(gtxid.GetHash());\n+    }\n+    scenario.Check(peer, {}, 0, 0, 0, \"s11\");\n+}\n+\n+/** Add to scenario a test with a single tx announced by two peers, to verify the\n+ *  right peer is selected for requests.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildPriorityTest(Scenario& scenario, int config)\n+{\n+    scenario.SetTestName(strprintf(\"Priority(config=%i)\", config));\n+\n+    // Three peers. They will announce in order.\n+    auto peer1 = scenario.NewPeer(), peer2 = scenario.NewPeer();\n+    // Construct a transaction that under random rules would be preferred by peer2 or peer1,\n+    // depending on configuration.\n+    bool prio1 = config & 1;\n+    auto gtxid = prio1 ? scenario.NewGTxid({{peer1, peer2}}) : scenario.NewGTxid({{peer2, peer1}});\n+    bool pref1 = config & 2, pref2 = config & 4;\n+\n+    scenario.ReceivedInv(peer1, gtxid, pref1, MIN_TIME);\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p1\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p2\");\n+\n+    scenario.ReceivedInv(peer2, gtxid, pref2, MIN_TIME);\n+    bool stage2_prio =\n+        // At this point, peer2 will be given priority if:\n+        // - It is preferred and peer1 is not\n+        (pref2 && !pref1) ||\n+        // - They're in the same preference class,\n+        //   and the randomized priority favors peer2 over peer1.\n+        (pref1 == pref2 && !prio1);\n+    uint64_t priopeer = stage2_prio ? peer2 : peer1, otherpeer = stage2_prio ? peer1 : peer2;\n+    scenario.Check(otherpeer, {}, 1, 0, 0, \"p3\");\n+    scenario.Check(priopeer, {gtxid}, 1, 0, 0, \"p4\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(otherpeer, {}, 1, 0, 0, \"p5\");\n+    scenario.Check(priopeer, {gtxid}, 1, 0, 0, \"p6\");\n+\n+    // We possibly request from the selected peer.\n+    if (config & 8) {\n+        scenario.RequestedTx(priopeer, gtxid, MAX_TIME);\n+        scenario.Check(priopeer, {}, 0, 1, 0, \"p7\");\n+        scenario.Check(otherpeer, {}, 1, 0, 0, \"p8\");\n+        if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    }\n+\n+    // The peer which was selected (or requested from) now goes offline, or a NOTFOUND is received from them.\n+    if (config & 16) {\n+        scenario.DisconnectedPeer(priopeer);\n+    } else {\n+        scenario.ReceivedResponse(priopeer, gtxid);\n+    }\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(priopeer, {}, 0, 0, !(config & 16), \"p8\");\n+    scenario.Check(otherpeer, {gtxid}, 1, 0, 0, \"p9\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+\n+    // Now the other peer goes offline.\n+    scenario.DisconnectedPeer(otherpeer);\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(peer1, {}, 0, 0, 0, \"p10\");\n+    scenario.Check(peer2, {}, 0, 0, 0, \"p11\");\n+}\n+\n+/** Add to scenario a randomized test in which N peers announce the same transaction, to verify\n+ *  the order in which they are requested.\n+ */\n+void BuildBigPriorityTest(Scenario& scenario, int peers)\n+{\n+    scenario.SetTestName(strprintf(\"BigPriority(peers=%i)\", peers));\n+\n+    // We will have N peers announce the same transaction.\n+    std::map<uint64_t, bool> preferred;\n+    std::vector<uint64_t> pref_order, npref_order;\n+    std::vector<uint64_t> pref_peers, npref_peers;\n+    int num_pref = InsecureRandRange(peers + 1) ; // Some preferred, ...\n+    int num_npref = peers - num_pref; // some not preferred.\n+    for (int i = 0; i < num_pref; ++i) {\n+        pref_peers.push_back(scenario.NewPeer());\n+        preferred[pref_peers.back()] = true;\n+    }\n+    for (int i = 0; i < num_npref; ++i) {\n+        npref_peers.push_back(scenario.NewPeer());\n+        preferred[npref_peers.back()] = false;\n+    }\n+    // Make a list of all peers, in order of intended request order (concatenation of pref_peers and\n+    // npref_peers).\n+    std::vector<uint64_t> request_order;\n+    for (int i = 0; i < num_pref; ++i) request_order.push_back(pref_peers[i]);\n+    for (int i = 0; i < num_npref; ++i) request_order.push_back(npref_peers[i]);\n+\n+    // Setup pref_order\n+    for (int i = 0; i < num_pref; ++i) {\n+        pref_order.push_back(pref_peers[i]);\n+    }\n+\n+    // Setup npref_order\n+    for (int i = 0; i < num_npref; ++i) {\n+        npref_order.push_back(npref_peers[i]);\n+    }\n+\n+    // Determine the announcement order randomly.\n+    std::vector<uint64_t> announce_order = request_order;\n+    Shuffle(announce_order.begin(), announce_order.end(), g_insecure_rand_ctx);\n+\n+    // Find a gtxid that has a prioritization consistent with the required pref_order and npref_order.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498949341",
      "id" : 498949341,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk0OTM0MQ==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 350,
      "original_position" : 350,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 501236154,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498949341",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498950864"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498950864"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Either is fine. I also like @ajtowns's description.\r\n\r\nWhichever way we go, I still think the function should be changed to take a txhash - I should have left that as a separate comment.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T17:21:07Z",
      "diff_hunk" : "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction. Note that this only works\n+ *              per txhash, so if the same transaction is announced both through txid and wtxid, we have no means\n+ *              to prevent fetching both (the caller can however mitigate this by delaying one, see further).\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten only:\n+ *   - If a peer goes offline, all its announcements are forgotten.\n+ *   - If a transaction has been successfully received, or is otherwise no longer needed, the caller can call\n+ *     ForgetTxHash, which removes all announcements across all peers with the specified txhash.\n+ *   - If for a given txhash only already-requested announcements remain, they are all forgotten.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening transaction censoring attacks. The flip side is that as long as an attacker manages\n+ *              to prevent us from receiving a transaction, failed announcements (including those from honest peers)\n+ *              will linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a\n+ *              cap on the number of tracked announcements per peer. As failed requests in response to announcements\n+ *              from honest peers should be rare, this almost solely hinders attackers.\n+ *              Transaction censoring attacks can be done by announcing transactions quickly while not answering\n+ *              requests for them. See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more\n+ *              information.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable the calling code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers are more trusted by us, so are less likely to be under attacker control.\n+ *\n+ *   - Pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: random assignments are hard to influence for attackers.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and minimizing\n+ * susceptibility to censorship attacks. An attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one preferred connection).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution). The \"1 +\" is due to the fact that the\n+ *   attacker can be the first to announce through a preferred connection in this scenario, which very likely means\n+ *   they get the first request.\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh>=1\n+ *   are honest, where we assume that the attacker can disconnect and reconnect those connections, the distribution\n+ *   becomes k ~ P + NB(p=1-NP/NPh,r=1) (where NB stands for Negative Binomial distribution), which has mean\n+ *   P-1+NP/NPh.\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, and a NOTFOUND or a\n+    //   transaction was received in response (valid or not), or they timed out. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DisconnectedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash (both txid and wtxid ones).\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it.\n+     */\n+    void ForgetTxHash(const uint256& txhash);\n+\n+    /** Adds a new CANDIDATE announcement.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that the txid/wtxid property is ignored for determining uniqueness, so if an announcement\n+     * is added for a wtxid H, while one for txid H from the same peer already exists, it will be ignored. This is\n+     * harmless as the txhashes being equal implies it is a non-segwit transaction, so it doesn't matter how it is\n+     * fetched. The new announcement is given the specified preferred and reqtime values, and takes it is_wtxid from\n+     * the specified gtxid.\n+     */\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime);\n+\n+    /** Converts the CANDIDATE announcement for the provided peer and gtxid into a REQUESTED one.\n+     *\n+     * Expiry is set to the specified value. This can ONLY be called immediately after GetRequestable was called\n+     * (for the same peer), with only ForgetTx and other RequestedTx calls (both for other txhashes) in\n+     * between. Any other non-const operation removes the ability to call RequestedTx.\n+     */\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds expiry);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498950864",
      "id" : 498950864,
      "in_reply_to_id" : 498734530,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1MDg2NA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 151,
      "original_position" : 151,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 501314200,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498950864",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498956144"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498956144"
         }
      },
      "author_association" : "MEMBER",
      "body" : "\"Decide reqtimes in opposite order of the _expected_ request order which is function of the announcement order and peer preferredness\". Clearer to underscore there are two orders, and you're deliberately tweaking the second one.\r\n\r\nMaybe, \"The lowest priority peer will get the soonest reqtime. It will be the to-be-requested-from peer until the time (Scenario.m_now) is jumped above reqtime of next priority peer.\"",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T17:32:04Z",
      "diff_hunk" : "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds MIN_TIME = std::chrono::microseconds::min();\n+constexpr std::chrono::microseconds MAX_TIME = std::chrono::microseconds::max();\n+constexpr std::chrono::microseconds MICROSECOND = std::chrono::microseconds{1};\n+constexpr std::chrono::microseconds NO_TIME = std::chrono::microseconds{0};\n+\n+/** An Action is a function to call at a particular (simulated) timestamp. */\n+using Action = std::pair<std::chrono::microseconds, std::function<void()>>;\n+\n+/** Object that stores actions from multiple interleaved scenarios, and data shared across them.\n+ *\n+ * The Scenario below is used to fill this.\n+ */\n+struct Runner\n+{\n+    /** The TxRequestTracker being tested. */\n+    TxRequestTracker txrequest;\n+\n+    /** List of actions to be executed (in order of increasing timestamp). */\n+    std::vector<Action> actions;\n+\n+    /** Which node ids have been assigned already (to prevent reuse). */\n+    std::set<uint64_t> peerset;\n+\n+    /** Which txhashes have been assigned already (to prevent reuse). */\n+    std::set<uint256> txhashset;\n+};\n+\n+std::chrono::microseconds RandomTime(int bits=23) { return std::chrono::microseconds{1 + InsecureRandBits(bits)}; }\n+\n+/** A proxy for a Runner that helps build a sequence of consecutive test actions on a TxRequestTracker.\n+ *\n+ * Multiple Scenarios are used with a single Runner, resulting in interleaved actions.\n+ */\n+class Scenario\n+{\n+    Runner& m_runner;\n+    std::chrono::microseconds m_now;\n+    std::string m_testname;\n+\n+public:\n+    Scenario(Runner& runner, std::chrono::microseconds starttime) : m_runner(runner)\n+    {\n+        m_now = starttime + RandomTime() + RandomTime() + RandomTime();\n+    }\n+\n+    void SetTestName(std::string testname)\n+    {\n+        m_testname = std::move(testname);\n+    }\n+\n+    void AdvanceTime(std::chrono::microseconds amount)\n+    {\n+        assert(amount.count() >= 0);\n+        m_now += amount;\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ForgetTxHash(txhash);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool pref, std::chrono::microseconds reqtime = MIN_TIME)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedInv(peer, gtxid, pref, reqtime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.DisconnectedPeer(peer);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds exptime)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.RequestedTx(peer, gtxid, exptime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedResponse(peer, gtxid);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void Check(uint64_t peer, const std::vector<GenTxid>& expected, size_t candidates, size_t inflight,\n+        size_t completed, const std::string& checkname = \"\")\n+    {\n+        const auto comment = m_testname + \" \" + checkname;\n+        auto& runner = m_runner;\n+        const auto now = m_now;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            auto ret = runner.txrequest.GetRequestable(peer, now);\n+            runner.txrequest.SanityCheck();\n+            runner.txrequest.PostGetRequestableSanityCheck(now);\n+            size_t total = candidates + inflight + completed;\n+            size_t real_total = runner.txrequest.Count(peer);\n+            size_t real_candidates = runner.txrequest.CountCandidates(peer);\n+            size_t real_inflight = runner.txrequest.CountInFlight(peer);\n+            BOOST_CHECK_MESSAGE(real_total == total, strprintf(\"[\" + comment + \"] total %i (%i expected)\", real_total, total));\n+            BOOST_CHECK_MESSAGE(real_inflight == inflight, strprintf(\"[\" + comment + \"] inflight %i (%i expected)\", real_inflight, inflight));\n+            BOOST_CHECK_MESSAGE(real_candidates == candidates, strprintf(\"[\" + comment + \"] candidates %i (%i expected)\", real_candidates, candidates));\n+            BOOST_CHECK_MESSAGE(ret == expected, \"[\" + comment + \"] mismatching requestables\");\n+        });\n+    }\n+\n+    uint256 NewTxHash(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        uint256 ret;\n+        bool ok;\n+        do {\n+            ret = InsecureRand256();\n+            ok = true;\n+            for (const auto& order : orders) {\n+                for (size_t pos = 1; pos < order.size(); ++pos) {\n+                    uint64_t prio_prev = m_runner.txrequest.ComputePriority(ret, order[pos - 1], true);\n+                    uint64_t prio_cur = m_runner.txrequest.ComputePriority(ret, order[pos], true);\n+                    if (prio_prev >= prio_cur) {\n+                        ok = false;\n+                        break;\n+                    }\n+                }\n+                if (!ok) break;\n+            }\n+            if (ok) {\n+                ok = m_runner.txhashset.insert(ret).second;\n+            }\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    GenTxid NewGTxid(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        return {InsecureRandBool(), NewTxHash(orders)};\n+    }\n+\n+    uint64_t NewPeer()\n+    {\n+        bool ok;\n+        uint64_t ret;\n+        do {\n+            ret = InsecureRandBits(63);\n+            ok = m_runner.peerset.insert(ret).second;\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    std::chrono::microseconds Now() const { return m_now; }\n+};\n+\n+/** Add to scenario a test with a single tx announced by a single peer.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildSingleTest(Scenario& scenario, int config)\n+{\n+    auto peer = scenario.NewPeer();\n+    auto gtxid = scenario.NewGTxid();\n+    bool immediate = config & 1;\n+    bool preferred = config & 2;\n+    auto delay = immediate ? NO_TIME : RandomTime();\n+\n+    scenario.SetTestName(strprintf(\"Single(config=%i)\", config));\n+\n+    // Receive an announcement, either immediately requestable or delayed.\n+    scenario.ReceivedInv(peer, gtxid, preferred, immediate ? MIN_TIME : scenario.Now() + delay);\n+    if (immediate) {\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s1\");\n+    } else {\n+        scenario.Check(peer, {}, 1, 0, 0, \"s2\");\n+        scenario.AdvanceTime(delay - MICROSECOND);\n+        scenario.Check(peer, {}, 1, 0, 0, \"s3\");\n+        scenario.AdvanceTime(MICROSECOND);\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s4\");\n+    }\n+\n+    if (config >> 3) { // We'll request the transaction\n+        scenario.AdvanceTime(RandomTime());\n+        auto expiry = RandomTime();\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s5\");\n+        scenario.RequestedTx(peer, gtxid, scenario.Now() + expiry);\n+        scenario.Check(peer, {}, 0, 1, 0, \"s6\");\n+\n+        if ((config >> 3) == 1) { // The request will time out\n+            scenario.AdvanceTime(expiry - MICROSECOND);\n+            scenario.Check(peer, {}, 0, 1, 0, \"s7\");\n+            scenario.AdvanceTime(MICROSECOND);\n+            scenario.Check(peer, {}, 0, 0, 0, \"s8\");\n+            return;\n+        } else {\n+            scenario.AdvanceTime(std::chrono::microseconds{InsecureRandRange(expiry.count())});\n+            scenario.Check(peer, {}, 0, 1, 0, \"s9\");\n+            if ((config >> 3) == 3) { // A reponse will arrive for the transaction\n+                scenario.ReceivedResponse(peer, gtxid);\n+                scenario.Check(peer, {}, 0, 0, 0, \"s10\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    scenario.AdvanceTime(RandomTime());\n+    if (config & 4) { // The peer will go offline\n+        scenario.DisconnectedPeer(peer);\n+    } else { // The transaction is no longer needed\n+        scenario.ForgetTxHash(gtxid.GetHash());\n+    }\n+    scenario.Check(peer, {}, 0, 0, 0, \"s11\");\n+}\n+\n+/** Add to scenario a test with a single tx announced by two peers, to verify the\n+ *  right peer is selected for requests.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildPriorityTest(Scenario& scenario, int config)\n+{\n+    scenario.SetTestName(strprintf(\"Priority(config=%i)\", config));\n+\n+    // Three peers. They will announce in order.\n+    auto peer1 = scenario.NewPeer(), peer2 = scenario.NewPeer();\n+    // Construct a transaction that under random rules would be preferred by peer2 or peer1,\n+    // depending on configuration.\n+    bool prio1 = config & 1;\n+    auto gtxid = prio1 ? scenario.NewGTxid({{peer1, peer2}}) : scenario.NewGTxid({{peer2, peer1}});\n+    bool pref1 = config & 2, pref2 = config & 4;\n+\n+    scenario.ReceivedInv(peer1, gtxid, pref1, MIN_TIME);\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p1\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p2\");\n+\n+    scenario.ReceivedInv(peer2, gtxid, pref2, MIN_TIME);\n+    bool stage2_prio =\n+        // At this point, peer2 will be given priority if:\n+        // - It is preferred and peer1 is not\n+        (pref2 && !pref1) ||\n+        // - They're in the same preference class,\n+        //   and the randomized priority favors peer2 over peer1.\n+        (pref1 == pref2 && !prio1);\n+    uint64_t priopeer = stage2_prio ? peer2 : peer1, otherpeer = stage2_prio ? peer1 : peer2;\n+    scenario.Check(otherpeer, {}, 1, 0, 0, \"p3\");\n+    scenario.Check(priopeer, {gtxid}, 1, 0, 0, \"p4\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(otherpeer, {}, 1, 0, 0, \"p5\");\n+    scenario.Check(priopeer, {gtxid}, 1, 0, 0, \"p6\");\n+\n+    // We possibly request from the selected peer.\n+    if (config & 8) {\n+        scenario.RequestedTx(priopeer, gtxid, MAX_TIME);\n+        scenario.Check(priopeer, {}, 0, 1, 0, \"p7\");\n+        scenario.Check(otherpeer, {}, 1, 0, 0, \"p8\");\n+        if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    }\n+\n+    // The peer which was selected (or requested from) now goes offline, or a NOTFOUND is received from them.\n+    if (config & 16) {\n+        scenario.DisconnectedPeer(priopeer);\n+    } else {\n+        scenario.ReceivedResponse(priopeer, gtxid);\n+    }\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(priopeer, {}, 0, 0, !(config & 16), \"p8\");\n+    scenario.Check(otherpeer, {gtxid}, 1, 0, 0, \"p9\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+\n+    // Now the other peer goes offline.\n+    scenario.DisconnectedPeer(otherpeer);\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(peer1, {}, 0, 0, 0, \"p10\");\n+    scenario.Check(peer2, {}, 0, 0, 0, \"p11\");\n+}\n+\n+/** Add to scenario a randomized test in which N peers announce the same transaction, to verify\n+ *  the order in which they are requested.\n+ */\n+void BuildBigPriorityTest(Scenario& scenario, int peers)\n+{\n+    scenario.SetTestName(strprintf(\"BigPriority(peers=%i)\", peers));\n+\n+    // We will have N peers announce the same transaction.\n+    std::map<uint64_t, bool> preferred;\n+    std::vector<uint64_t> pref_order, npref_order;\n+    std::vector<uint64_t> pref_peers, npref_peers;\n+    int num_pref = InsecureRandRange(peers + 1) ; // Some preferred, ...\n+    int num_npref = peers - num_pref; // some not preferred.\n+    for (int i = 0; i < num_pref; ++i) {\n+        pref_peers.push_back(scenario.NewPeer());\n+        preferred[pref_peers.back()] = true;\n+    }\n+    for (int i = 0; i < num_npref; ++i) {\n+        npref_peers.push_back(scenario.NewPeer());\n+        preferred[npref_peers.back()] = false;\n+    }\n+    // Make a list of all peers, in order of intended request order (concatenation of pref_peers and\n+    // npref_peers).\n+    std::vector<uint64_t> request_order;\n+    for (int i = 0; i < num_pref; ++i) request_order.push_back(pref_peers[i]);\n+    for (int i = 0; i < num_npref; ++i) request_order.push_back(npref_peers[i]);\n+\n+    // Setup pref_order\n+    for (int i = 0; i < num_pref; ++i) {\n+        pref_order.push_back(pref_peers[i]);\n+    }\n+\n+    // Setup npref_order\n+    for (int i = 0; i < num_npref; ++i) {\n+        npref_order.push_back(npref_peers[i]);\n+    }\n+\n+    // Determine the announcement order randomly.\n+    std::vector<uint64_t> announce_order = request_order;\n+    Shuffle(announce_order.begin(), announce_order.end(), g_insecure_rand_ctx);\n+\n+    // Find a gtxid that has a prioritization consistent with the required pref_order and npref_order.\n+    auto gtxid = scenario.NewGTxid({pref_order, npref_order});\n+\n+    // Decide reqtimes in opposite order of the eventual request order. So every time time jumps",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498956144",
      "id" : 498956144,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1NjE0NA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 353,
      "original_position" : 353,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 501236154,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498956144",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498961964"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498961964"
         }
      },
      "author_association" : "MEMBER",
      "body" : "\"We pin back current time under checked peer reqtime. We observe it's not the current to-be-requested-from peer.\r\nWe advance forward current time beyond checked peer reqtime. We observe it's henceforth the new to-be-requested-from peer\"",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T17:44:32Z",
      "diff_hunk" : "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds MIN_TIME = std::chrono::microseconds::min();\n+constexpr std::chrono::microseconds MAX_TIME = std::chrono::microseconds::max();\n+constexpr std::chrono::microseconds MICROSECOND = std::chrono::microseconds{1};\n+constexpr std::chrono::microseconds NO_TIME = std::chrono::microseconds{0};\n+\n+/** An Action is a function to call at a particular (simulated) timestamp. */\n+using Action = std::pair<std::chrono::microseconds, std::function<void()>>;\n+\n+/** Object that stores actions from multiple interleaved scenarios, and data shared across them.\n+ *\n+ * The Scenario below is used to fill this.\n+ */\n+struct Runner\n+{\n+    /** The TxRequestTracker being tested. */\n+    TxRequestTracker txrequest;\n+\n+    /** List of actions to be executed (in order of increasing timestamp). */\n+    std::vector<Action> actions;\n+\n+    /** Which node ids have been assigned already (to prevent reuse). */\n+    std::set<uint64_t> peerset;\n+\n+    /** Which txhashes have been assigned already (to prevent reuse). */\n+    std::set<uint256> txhashset;\n+};\n+\n+std::chrono::microseconds RandomTime(int bits=23) { return std::chrono::microseconds{1 + InsecureRandBits(bits)}; }\n+\n+/** A proxy for a Runner that helps build a sequence of consecutive test actions on a TxRequestTracker.\n+ *\n+ * Multiple Scenarios are used with a single Runner, resulting in interleaved actions.\n+ */\n+class Scenario\n+{\n+    Runner& m_runner;\n+    std::chrono::microseconds m_now;\n+    std::string m_testname;\n+\n+public:\n+    Scenario(Runner& runner, std::chrono::microseconds starttime) : m_runner(runner)\n+    {\n+        m_now = starttime + RandomTime() + RandomTime() + RandomTime();\n+    }\n+\n+    void SetTestName(std::string testname)\n+    {\n+        m_testname = std::move(testname);\n+    }\n+\n+    void AdvanceTime(std::chrono::microseconds amount)\n+    {\n+        assert(amount.count() >= 0);\n+        m_now += amount;\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ForgetTxHash(txhash);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool pref, std::chrono::microseconds reqtime = MIN_TIME)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedInv(peer, gtxid, pref, reqtime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.DisconnectedPeer(peer);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds exptime)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.RequestedTx(peer, gtxid, exptime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedResponse(peer, gtxid);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void Check(uint64_t peer, const std::vector<GenTxid>& expected, size_t candidates, size_t inflight,\n+        size_t completed, const std::string& checkname = \"\")\n+    {\n+        const auto comment = m_testname + \" \" + checkname;\n+        auto& runner = m_runner;\n+        const auto now = m_now;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            auto ret = runner.txrequest.GetRequestable(peer, now);\n+            runner.txrequest.SanityCheck();\n+            runner.txrequest.PostGetRequestableSanityCheck(now);\n+            size_t total = candidates + inflight + completed;\n+            size_t real_total = runner.txrequest.Count(peer);\n+            size_t real_candidates = runner.txrequest.CountCandidates(peer);\n+            size_t real_inflight = runner.txrequest.CountInFlight(peer);\n+            BOOST_CHECK_MESSAGE(real_total == total, strprintf(\"[\" + comment + \"] total %i (%i expected)\", real_total, total));\n+            BOOST_CHECK_MESSAGE(real_inflight == inflight, strprintf(\"[\" + comment + \"] inflight %i (%i expected)\", real_inflight, inflight));\n+            BOOST_CHECK_MESSAGE(real_candidates == candidates, strprintf(\"[\" + comment + \"] candidates %i (%i expected)\", real_candidates, candidates));\n+            BOOST_CHECK_MESSAGE(ret == expected, \"[\" + comment + \"] mismatching requestables\");\n+        });\n+    }\n+\n+    uint256 NewTxHash(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        uint256 ret;\n+        bool ok;\n+        do {\n+            ret = InsecureRand256();\n+            ok = true;\n+            for (const auto& order : orders) {\n+                for (size_t pos = 1; pos < order.size(); ++pos) {\n+                    uint64_t prio_prev = m_runner.txrequest.ComputePriority(ret, order[pos - 1], true);\n+                    uint64_t prio_cur = m_runner.txrequest.ComputePriority(ret, order[pos], true);\n+                    if (prio_prev >= prio_cur) {\n+                        ok = false;\n+                        break;\n+                    }\n+                }\n+                if (!ok) break;\n+            }\n+            if (ok) {\n+                ok = m_runner.txhashset.insert(ret).second;\n+            }\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    GenTxid NewGTxid(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        return {InsecureRandBool(), NewTxHash(orders)};\n+    }\n+\n+    uint64_t NewPeer()\n+    {\n+        bool ok;\n+        uint64_t ret;\n+        do {\n+            ret = InsecureRandBits(63);\n+            ok = m_runner.peerset.insert(ret).second;\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    std::chrono::microseconds Now() const { return m_now; }\n+};\n+\n+/** Add to scenario a test with a single tx announced by a single peer.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildSingleTest(Scenario& scenario, int config)\n+{\n+    auto peer = scenario.NewPeer();\n+    auto gtxid = scenario.NewGTxid();\n+    bool immediate = config & 1;\n+    bool preferred = config & 2;\n+    auto delay = immediate ? NO_TIME : RandomTime();\n+\n+    scenario.SetTestName(strprintf(\"Single(config=%i)\", config));\n+\n+    // Receive an announcement, either immediately requestable or delayed.\n+    scenario.ReceivedInv(peer, gtxid, preferred, immediate ? MIN_TIME : scenario.Now() + delay);\n+    if (immediate) {\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s1\");\n+    } else {\n+        scenario.Check(peer, {}, 1, 0, 0, \"s2\");\n+        scenario.AdvanceTime(delay - MICROSECOND);\n+        scenario.Check(peer, {}, 1, 0, 0, \"s3\");\n+        scenario.AdvanceTime(MICROSECOND);\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s4\");\n+    }\n+\n+    if (config >> 3) { // We'll request the transaction\n+        scenario.AdvanceTime(RandomTime());\n+        auto expiry = RandomTime();\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s5\");\n+        scenario.RequestedTx(peer, gtxid, scenario.Now() + expiry);\n+        scenario.Check(peer, {}, 0, 1, 0, \"s6\");\n+\n+        if ((config >> 3) == 1) { // The request will time out\n+            scenario.AdvanceTime(expiry - MICROSECOND);\n+            scenario.Check(peer, {}, 0, 1, 0, \"s7\");\n+            scenario.AdvanceTime(MICROSECOND);\n+            scenario.Check(peer, {}, 0, 0, 0, \"s8\");\n+            return;\n+        } else {\n+            scenario.AdvanceTime(std::chrono::microseconds{InsecureRandRange(expiry.count())});\n+            scenario.Check(peer, {}, 0, 1, 0, \"s9\");\n+            if ((config >> 3) == 3) { // A reponse will arrive for the transaction\n+                scenario.ReceivedResponse(peer, gtxid);\n+                scenario.Check(peer, {}, 0, 0, 0, \"s10\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    scenario.AdvanceTime(RandomTime());\n+    if (config & 4) { // The peer will go offline\n+        scenario.DisconnectedPeer(peer);\n+    } else { // The transaction is no longer needed\n+        scenario.ForgetTxHash(gtxid.GetHash());\n+    }\n+    scenario.Check(peer, {}, 0, 0, 0, \"s11\");\n+}\n+\n+/** Add to scenario a test with a single tx announced by two peers, to verify the\n+ *  right peer is selected for requests.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildPriorityTest(Scenario& scenario, int config)\n+{\n+    scenario.SetTestName(strprintf(\"Priority(config=%i)\", config));\n+\n+    // Three peers. They will announce in order.\n+    auto peer1 = scenario.NewPeer(), peer2 = scenario.NewPeer();\n+    // Construct a transaction that under random rules would be preferred by peer2 or peer1,\n+    // depending on configuration.\n+    bool prio1 = config & 1;\n+    auto gtxid = prio1 ? scenario.NewGTxid({{peer1, peer2}}) : scenario.NewGTxid({{peer2, peer1}});\n+    bool pref1 = config & 2, pref2 = config & 4;\n+\n+    scenario.ReceivedInv(peer1, gtxid, pref1, MIN_TIME);\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p1\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p2\");\n+\n+    scenario.ReceivedInv(peer2, gtxid, pref2, MIN_TIME);\n+    bool stage2_prio =\n+        // At this point, peer2 will be given priority if:\n+        // - It is preferred and peer1 is not\n+        (pref2 && !pref1) ||\n+        // - They're in the same preference class,\n+        //   and the randomized priority favors peer2 over peer1.\n+        (pref1 == pref2 && !prio1);\n+    uint64_t priopeer = stage2_prio ? peer2 : peer1, otherpeer = stage2_prio ? peer1 : peer2;\n+    scenario.Check(otherpeer, {}, 1, 0, 0, \"p3\");\n+    scenario.Check(priopeer, {gtxid}, 1, 0, 0, \"p4\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(otherpeer, {}, 1, 0, 0, \"p5\");\n+    scenario.Check(priopeer, {gtxid}, 1, 0, 0, \"p6\");\n+\n+    // We possibly request from the selected peer.\n+    if (config & 8) {\n+        scenario.RequestedTx(priopeer, gtxid, MAX_TIME);\n+        scenario.Check(priopeer, {}, 0, 1, 0, \"p7\");\n+        scenario.Check(otherpeer, {}, 1, 0, 0, \"p8\");\n+        if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    }\n+\n+    // The peer which was selected (or requested from) now goes offline, or a NOTFOUND is received from them.\n+    if (config & 16) {\n+        scenario.DisconnectedPeer(priopeer);\n+    } else {\n+        scenario.ReceivedResponse(priopeer, gtxid);\n+    }\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(priopeer, {}, 0, 0, !(config & 16), \"p8\");\n+    scenario.Check(otherpeer, {gtxid}, 1, 0, 0, \"p9\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+\n+    // Now the other peer goes offline.\n+    scenario.DisconnectedPeer(otherpeer);\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(peer1, {}, 0, 0, 0, \"p10\");\n+    scenario.Check(peer2, {}, 0, 0, 0, \"p11\");\n+}\n+\n+/** Add to scenario a randomized test in which N peers announce the same transaction, to verify\n+ *  the order in which they are requested.\n+ */\n+void BuildBigPriorityTest(Scenario& scenario, int peers)\n+{\n+    scenario.SetTestName(strprintf(\"BigPriority(peers=%i)\", peers));\n+\n+    // We will have N peers announce the same transaction.\n+    std::map<uint64_t, bool> preferred;\n+    std::vector<uint64_t> pref_order, npref_order;\n+    std::vector<uint64_t> pref_peers, npref_peers;\n+    int num_pref = InsecureRandRange(peers + 1) ; // Some preferred, ...\n+    int num_npref = peers - num_pref; // some not preferred.\n+    for (int i = 0; i < num_pref; ++i) {\n+        pref_peers.push_back(scenario.NewPeer());\n+        preferred[pref_peers.back()] = true;\n+    }\n+    for (int i = 0; i < num_npref; ++i) {\n+        npref_peers.push_back(scenario.NewPeer());\n+        preferred[npref_peers.back()] = false;\n+    }\n+    // Make a list of all peers, in order of intended request order (concatenation of pref_peers and\n+    // npref_peers).\n+    std::vector<uint64_t> request_order;\n+    for (int i = 0; i < num_pref; ++i) request_order.push_back(pref_peers[i]);\n+    for (int i = 0; i < num_npref; ++i) request_order.push_back(npref_peers[i]);\n+\n+    // Setup pref_order\n+    for (int i = 0; i < num_pref; ++i) {\n+        pref_order.push_back(pref_peers[i]);\n+    }\n+\n+    // Setup npref_order\n+    for (int i = 0; i < num_npref; ++i) {\n+        npref_order.push_back(npref_peers[i]);\n+    }\n+\n+    // Determine the announcement order randomly.\n+    std::vector<uint64_t> announce_order = request_order;\n+    Shuffle(announce_order.begin(), announce_order.end(), g_insecure_rand_ctx);\n+\n+    // Find a gtxid that has a prioritization consistent with the required pref_order and npref_order.\n+    auto gtxid = scenario.NewGTxid({pref_order, npref_order});\n+\n+    // Decide reqtimes in opposite order of the eventual request order. So every time time jumps\n+    // past the next reqtime, the to-be-requested-from peer will change.\n+    std::map<uint64_t, std::chrono::microseconds> reqtimes;\n+    auto reqtime = scenario.Now();\n+    for (int i = peers - 1; i >= 0; --i) {\n+        reqtime += RandomTime();\n+        reqtimes[request_order[i]] = reqtime;\n+    }\n+\n+    // Actually announce from all peers simultaneously (but in announce_order).\n+    for (const auto peer : announce_order) {\n+        scenario.ReceivedInv(peer, gtxid, preferred[peer], reqtimes[peer]);\n+    }\n+    for (const auto peer : announce_order) {\n+        scenario.Check(peer, {}, 1, 0, 0, \"b1\");\n+    }\n+\n+    // Let time pass and observe the to-be-requested-from peer change.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498961964",
      "id" : 498961964,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2MTk2NA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 370,
      "original_position" : 370,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 501236154,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498961964",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498962583"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498962583"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The hash is different in both calls.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T17:45:53Z",
      "diff_hunk" : "@@ -2994,9 +2898,7 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n         TxValidationState state;\n \n         for (const GenTxid& gtxid : {GenTxid(false, txid), GenTxid(true, wtxid)}) {\n-            nodestate->m_tx_download.m_tx_announced.erase(gtxid.GetHash());\n-            nodestate->m_tx_download.m_tx_in_flight.erase(gtxid.GetHash());\n-            EraseTxRequest(gtxid);\n+            m_txrequest.ReceivedResponse(pfrom.GetId(), gtxid);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498962583",
      "id" : 498962583,
      "in_reply_to_id" : 498773268,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2MjU4Mw==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 2901,
      "original_position" : 276,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 501329919,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498962583",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498963087"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498963087"
         }
      },
      "author_association" : "MEMBER",
      "body" : "\"Observe the to-be-requested peer change for the remaining peer with the highest priority\"",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T17:46:54Z",
      "diff_hunk" : "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds MIN_TIME = std::chrono::microseconds::min();\n+constexpr std::chrono::microseconds MAX_TIME = std::chrono::microseconds::max();\n+constexpr std::chrono::microseconds MICROSECOND = std::chrono::microseconds{1};\n+constexpr std::chrono::microseconds NO_TIME = std::chrono::microseconds{0};\n+\n+/** An Action is a function to call at a particular (simulated) timestamp. */\n+using Action = std::pair<std::chrono::microseconds, std::function<void()>>;\n+\n+/** Object that stores actions from multiple interleaved scenarios, and data shared across them.\n+ *\n+ * The Scenario below is used to fill this.\n+ */\n+struct Runner\n+{\n+    /** The TxRequestTracker being tested. */\n+    TxRequestTracker txrequest;\n+\n+    /** List of actions to be executed (in order of increasing timestamp). */\n+    std::vector<Action> actions;\n+\n+    /** Which node ids have been assigned already (to prevent reuse). */\n+    std::set<uint64_t> peerset;\n+\n+    /** Which txhashes have been assigned already (to prevent reuse). */\n+    std::set<uint256> txhashset;\n+};\n+\n+std::chrono::microseconds RandomTime(int bits=23) { return std::chrono::microseconds{1 + InsecureRandBits(bits)}; }\n+\n+/** A proxy for a Runner that helps build a sequence of consecutive test actions on a TxRequestTracker.\n+ *\n+ * Multiple Scenarios are used with a single Runner, resulting in interleaved actions.\n+ */\n+class Scenario\n+{\n+    Runner& m_runner;\n+    std::chrono::microseconds m_now;\n+    std::string m_testname;\n+\n+public:\n+    Scenario(Runner& runner, std::chrono::microseconds starttime) : m_runner(runner)\n+    {\n+        m_now = starttime + RandomTime() + RandomTime() + RandomTime();\n+    }\n+\n+    void SetTestName(std::string testname)\n+    {\n+        m_testname = std::move(testname);\n+    }\n+\n+    void AdvanceTime(std::chrono::microseconds amount)\n+    {\n+        assert(amount.count() >= 0);\n+        m_now += amount;\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ForgetTxHash(txhash);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool pref, std::chrono::microseconds reqtime = MIN_TIME)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedInv(peer, gtxid, pref, reqtime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.DisconnectedPeer(peer);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds exptime)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.RequestedTx(peer, gtxid, exptime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedResponse(peer, gtxid);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void Check(uint64_t peer, const std::vector<GenTxid>& expected, size_t candidates, size_t inflight,\n+        size_t completed, const std::string& checkname = \"\")\n+    {\n+        const auto comment = m_testname + \" \" + checkname;\n+        auto& runner = m_runner;\n+        const auto now = m_now;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            auto ret = runner.txrequest.GetRequestable(peer, now);\n+            runner.txrequest.SanityCheck();\n+            runner.txrequest.PostGetRequestableSanityCheck(now);\n+            size_t total = candidates + inflight + completed;\n+            size_t real_total = runner.txrequest.Count(peer);\n+            size_t real_candidates = runner.txrequest.CountCandidates(peer);\n+            size_t real_inflight = runner.txrequest.CountInFlight(peer);\n+            BOOST_CHECK_MESSAGE(real_total == total, strprintf(\"[\" + comment + \"] total %i (%i expected)\", real_total, total));\n+            BOOST_CHECK_MESSAGE(real_inflight == inflight, strprintf(\"[\" + comment + \"] inflight %i (%i expected)\", real_inflight, inflight));\n+            BOOST_CHECK_MESSAGE(real_candidates == candidates, strprintf(\"[\" + comment + \"] candidates %i (%i expected)\", real_candidates, candidates));\n+            BOOST_CHECK_MESSAGE(ret == expected, \"[\" + comment + \"] mismatching requestables\");\n+        });\n+    }\n+\n+    uint256 NewTxHash(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        uint256 ret;\n+        bool ok;\n+        do {\n+            ret = InsecureRand256();\n+            ok = true;\n+            for (const auto& order : orders) {\n+                for (size_t pos = 1; pos < order.size(); ++pos) {\n+                    uint64_t prio_prev = m_runner.txrequest.ComputePriority(ret, order[pos - 1], true);\n+                    uint64_t prio_cur = m_runner.txrequest.ComputePriority(ret, order[pos], true);\n+                    if (prio_prev >= prio_cur) {\n+                        ok = false;\n+                        break;\n+                    }\n+                }\n+                if (!ok) break;\n+            }\n+            if (ok) {\n+                ok = m_runner.txhashset.insert(ret).second;\n+            }\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    GenTxid NewGTxid(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        return {InsecureRandBool(), NewTxHash(orders)};\n+    }\n+\n+    uint64_t NewPeer()\n+    {\n+        bool ok;\n+        uint64_t ret;\n+        do {\n+            ret = InsecureRandBits(63);\n+            ok = m_runner.peerset.insert(ret).second;\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    std::chrono::microseconds Now() const { return m_now; }\n+};\n+\n+/** Add to scenario a test with a single tx announced by a single peer.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildSingleTest(Scenario& scenario, int config)\n+{\n+    auto peer = scenario.NewPeer();\n+    auto gtxid = scenario.NewGTxid();\n+    bool immediate = config & 1;\n+    bool preferred = config & 2;\n+    auto delay = immediate ? NO_TIME : RandomTime();\n+\n+    scenario.SetTestName(strprintf(\"Single(config=%i)\", config));\n+\n+    // Receive an announcement, either immediately requestable or delayed.\n+    scenario.ReceivedInv(peer, gtxid, preferred, immediate ? MIN_TIME : scenario.Now() + delay);\n+    if (immediate) {\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s1\");\n+    } else {\n+        scenario.Check(peer, {}, 1, 0, 0, \"s2\");\n+        scenario.AdvanceTime(delay - MICROSECOND);\n+        scenario.Check(peer, {}, 1, 0, 0, \"s3\");\n+        scenario.AdvanceTime(MICROSECOND);\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s4\");\n+    }\n+\n+    if (config >> 3) { // We'll request the transaction\n+        scenario.AdvanceTime(RandomTime());\n+        auto expiry = RandomTime();\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s5\");\n+        scenario.RequestedTx(peer, gtxid, scenario.Now() + expiry);\n+        scenario.Check(peer, {}, 0, 1, 0, \"s6\");\n+\n+        if ((config >> 3) == 1) { // The request will time out\n+            scenario.AdvanceTime(expiry - MICROSECOND);\n+            scenario.Check(peer, {}, 0, 1, 0, \"s7\");\n+            scenario.AdvanceTime(MICROSECOND);\n+            scenario.Check(peer, {}, 0, 0, 0, \"s8\");\n+            return;\n+        } else {\n+            scenario.AdvanceTime(std::chrono::microseconds{InsecureRandRange(expiry.count())});\n+            scenario.Check(peer, {}, 0, 1, 0, \"s9\");\n+            if ((config >> 3) == 3) { // A reponse will arrive for the transaction\n+                scenario.ReceivedResponse(peer, gtxid);\n+                scenario.Check(peer, {}, 0, 0, 0, \"s10\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    scenario.AdvanceTime(RandomTime());\n+    if (config & 4) { // The peer will go offline\n+        scenario.DisconnectedPeer(peer);\n+    } else { // The transaction is no longer needed\n+        scenario.ForgetTxHash(gtxid.GetHash());\n+    }\n+    scenario.Check(peer, {}, 0, 0, 0, \"s11\");\n+}\n+\n+/** Add to scenario a test with a single tx announced by two peers, to verify the\n+ *  right peer is selected for requests.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildPriorityTest(Scenario& scenario, int config)\n+{\n+    scenario.SetTestName(strprintf(\"Priority(config=%i)\", config));\n+\n+    // Three peers. They will announce in order.\n+    auto peer1 = scenario.NewPeer(), peer2 = scenario.NewPeer();\n+    // Construct a transaction that under random rules would be preferred by peer2 or peer1,\n+    // depending on configuration.\n+    bool prio1 = config & 1;\n+    auto gtxid = prio1 ? scenario.NewGTxid({{peer1, peer2}}) : scenario.NewGTxid({{peer2, peer1}});\n+    bool pref1 = config & 2, pref2 = config & 4;\n+\n+    scenario.ReceivedInv(peer1, gtxid, pref1, MIN_TIME);\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p1\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p2\");\n+\n+    scenario.ReceivedInv(peer2, gtxid, pref2, MIN_TIME);\n+    bool stage2_prio =\n+        // At this point, peer2 will be given priority if:\n+        // - It is preferred and peer1 is not\n+        (pref2 && !pref1) ||\n+        // - They're in the same preference class,\n+        //   and the randomized priority favors peer2 over peer1.\n+        (pref1 == pref2 && !prio1);\n+    uint64_t priopeer = stage2_prio ? peer2 : peer1, otherpeer = stage2_prio ? peer1 : peer2;\n+    scenario.Check(otherpeer, {}, 1, 0, 0, \"p3\");\n+    scenario.Check(priopeer, {gtxid}, 1, 0, 0, \"p4\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(otherpeer, {}, 1, 0, 0, \"p5\");\n+    scenario.Check(priopeer, {gtxid}, 1, 0, 0, \"p6\");\n+\n+    // We possibly request from the selected peer.\n+    if (config & 8) {\n+        scenario.RequestedTx(priopeer, gtxid, MAX_TIME);\n+        scenario.Check(priopeer, {}, 0, 1, 0, \"p7\");\n+        scenario.Check(otherpeer, {}, 1, 0, 0, \"p8\");\n+        if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    }\n+\n+    // The peer which was selected (or requested from) now goes offline, or a NOTFOUND is received from them.\n+    if (config & 16) {\n+        scenario.DisconnectedPeer(priopeer);\n+    } else {\n+        scenario.ReceivedResponse(priopeer, gtxid);\n+    }\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(priopeer, {}, 0, 0, !(config & 16), \"p8\");\n+    scenario.Check(otherpeer, {gtxid}, 1, 0, 0, \"p9\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+\n+    // Now the other peer goes offline.\n+    scenario.DisconnectedPeer(otherpeer);\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(peer1, {}, 0, 0, 0, \"p10\");\n+    scenario.Check(peer2, {}, 0, 0, 0, \"p11\");\n+}\n+\n+/** Add to scenario a randomized test in which N peers announce the same transaction, to verify\n+ *  the order in which they are requested.\n+ */\n+void BuildBigPriorityTest(Scenario& scenario, int peers)\n+{\n+    scenario.SetTestName(strprintf(\"BigPriority(peers=%i)\", peers));\n+\n+    // We will have N peers announce the same transaction.\n+    std::map<uint64_t, bool> preferred;\n+    std::vector<uint64_t> pref_order, npref_order;\n+    std::vector<uint64_t> pref_peers, npref_peers;\n+    int num_pref = InsecureRandRange(peers + 1) ; // Some preferred, ...\n+    int num_npref = peers - num_pref; // some not preferred.\n+    for (int i = 0; i < num_pref; ++i) {\n+        pref_peers.push_back(scenario.NewPeer());\n+        preferred[pref_peers.back()] = true;\n+    }\n+    for (int i = 0; i < num_npref; ++i) {\n+        npref_peers.push_back(scenario.NewPeer());\n+        preferred[npref_peers.back()] = false;\n+    }\n+    // Make a list of all peers, in order of intended request order (concatenation of pref_peers and\n+    // npref_peers).\n+    std::vector<uint64_t> request_order;\n+    for (int i = 0; i < num_pref; ++i) request_order.push_back(pref_peers[i]);\n+    for (int i = 0; i < num_npref; ++i) request_order.push_back(npref_peers[i]);\n+\n+    // Setup pref_order\n+    for (int i = 0; i < num_pref; ++i) {\n+        pref_order.push_back(pref_peers[i]);\n+    }\n+\n+    // Setup npref_order\n+    for (int i = 0; i < num_npref; ++i) {\n+        npref_order.push_back(npref_peers[i]);\n+    }\n+\n+    // Determine the announcement order randomly.\n+    std::vector<uint64_t> announce_order = request_order;\n+    Shuffle(announce_order.begin(), announce_order.end(), g_insecure_rand_ctx);\n+\n+    // Find a gtxid that has a prioritization consistent with the required pref_order and npref_order.\n+    auto gtxid = scenario.NewGTxid({pref_order, npref_order});\n+\n+    // Decide reqtimes in opposite order of the eventual request order. So every time time jumps\n+    // past the next reqtime, the to-be-requested-from peer will change.\n+    std::map<uint64_t, std::chrono::microseconds> reqtimes;\n+    auto reqtime = scenario.Now();\n+    for (int i = peers - 1; i >= 0; --i) {\n+        reqtime += RandomTime();\n+        reqtimes[request_order[i]] = reqtime;\n+    }\n+\n+    // Actually announce from all peers simultaneously (but in announce_order).\n+    for (const auto peer : announce_order) {\n+        scenario.ReceivedInv(peer, gtxid, preferred[peer], reqtimes[peer]);\n+    }\n+    for (const auto peer : announce_order) {\n+        scenario.Check(peer, {}, 1, 0, 0, \"b1\");\n+    }\n+\n+    // Let time pass and observe the to-be-requested-from peer change.\n+    for (int i = peers - 1; i >= 0; --i) {\n+        scenario.AdvanceTime(reqtimes[request_order[i]] - scenario.Now() - MICROSECOND);\n+        scenario.Check(request_order[i], {}, 1, 0, 0, \"b2\");\n+        scenario.AdvanceTime(MICROSECOND);\n+        scenario.Check(request_order[i], {gtxid}, 1, 0, 0, \"b3\");\n+    }\n+\n+    // Peers now in random order go offline, or send NOTFOUNDs. Observe the to-be-requested-peer\n+    // change whenever the previous best one disappears.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498963087",
      "id" : 498963087,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2MzA4Nw==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 379,
      "original_position" : 379,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 501236154,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498963087",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498967076"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498967076"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This is just to test that advancing time doesn't change the \"requestability\" of the transaction without a call to `RequestedTx` ?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T17:55:32Z",
      "diff_hunk" : "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds MIN_TIME = std::chrono::microseconds::min();\n+constexpr std::chrono::microseconds MAX_TIME = std::chrono::microseconds::max();\n+constexpr std::chrono::microseconds MICROSECOND = std::chrono::microseconds{1};\n+constexpr std::chrono::microseconds NO_TIME = std::chrono::microseconds{0};\n+\n+/** An Action is a function to call at a particular (simulated) timestamp. */\n+using Action = std::pair<std::chrono::microseconds, std::function<void()>>;\n+\n+/** Object that stores actions from multiple interleaved scenarios, and data shared across them.\n+ *\n+ * The Scenario below is used to fill this.\n+ */\n+struct Runner\n+{\n+    /** The TxRequestTracker being tested. */\n+    TxRequestTracker txrequest;\n+\n+    /** List of actions to be executed (in order of increasing timestamp). */\n+    std::vector<Action> actions;\n+\n+    /** Which node ids have been assigned already (to prevent reuse). */\n+    std::set<uint64_t> peerset;\n+\n+    /** Which txhashes have been assigned already (to prevent reuse). */\n+    std::set<uint256> txhashset;\n+};\n+\n+std::chrono::microseconds RandomTime(int bits=23) { return std::chrono::microseconds{1 + InsecureRandBits(bits)}; }\n+\n+/** A proxy for a Runner that helps build a sequence of consecutive test actions on a TxRequestTracker.\n+ *\n+ * Multiple Scenarios are used with a single Runner, resulting in interleaved actions.\n+ */\n+class Scenario\n+{\n+    Runner& m_runner;\n+    std::chrono::microseconds m_now;\n+    std::string m_testname;\n+\n+public:\n+    Scenario(Runner& runner, std::chrono::microseconds starttime) : m_runner(runner)\n+    {\n+        m_now = starttime + RandomTime() + RandomTime() + RandomTime();\n+    }\n+\n+    void SetTestName(std::string testname)\n+    {\n+        m_testname = std::move(testname);\n+    }\n+\n+    void AdvanceTime(std::chrono::microseconds amount)\n+    {\n+        assert(amount.count() >= 0);\n+        m_now += amount;\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ForgetTxHash(txhash);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool pref, std::chrono::microseconds reqtime = MIN_TIME)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedInv(peer, gtxid, pref, reqtime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.DisconnectedPeer(peer);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds exptime)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.RequestedTx(peer, gtxid, exptime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedResponse(peer, gtxid);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void Check(uint64_t peer, const std::vector<GenTxid>& expected, size_t candidates, size_t inflight,\n+        size_t completed, const std::string& checkname = \"\")\n+    {\n+        const auto comment = m_testname + \" \" + checkname;\n+        auto& runner = m_runner;\n+        const auto now = m_now;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            auto ret = runner.txrequest.GetRequestable(peer, now);\n+            runner.txrequest.SanityCheck();\n+            runner.txrequest.PostGetRequestableSanityCheck(now);\n+            size_t total = candidates + inflight + completed;\n+            size_t real_total = runner.txrequest.Count(peer);\n+            size_t real_candidates = runner.txrequest.CountCandidates(peer);\n+            size_t real_inflight = runner.txrequest.CountInFlight(peer);\n+            BOOST_CHECK_MESSAGE(real_total == total, strprintf(\"[\" + comment + \"] total %i (%i expected)\", real_total, total));\n+            BOOST_CHECK_MESSAGE(real_inflight == inflight, strprintf(\"[\" + comment + \"] inflight %i (%i expected)\", real_inflight, inflight));\n+            BOOST_CHECK_MESSAGE(real_candidates == candidates, strprintf(\"[\" + comment + \"] candidates %i (%i expected)\", real_candidates, candidates));\n+            BOOST_CHECK_MESSAGE(ret == expected, \"[\" + comment + \"] mismatching requestables\");\n+        });\n+    }\n+\n+    uint256 NewTxHash(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        uint256 ret;\n+        bool ok;\n+        do {\n+            ret = InsecureRand256();\n+            ok = true;\n+            for (const auto& order : orders) {\n+                for (size_t pos = 1; pos < order.size(); ++pos) {\n+                    uint64_t prio_prev = m_runner.txrequest.ComputePriority(ret, order[pos - 1], true);\n+                    uint64_t prio_cur = m_runner.txrequest.ComputePriority(ret, order[pos], true);\n+                    if (prio_prev >= prio_cur) {\n+                        ok = false;\n+                        break;\n+                    }\n+                }\n+                if (!ok) break;\n+            }\n+            if (ok) {\n+                ok = m_runner.txhashset.insert(ret).second;\n+            }\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    GenTxid NewGTxid(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        return {InsecureRandBool(), NewTxHash(orders)};\n+    }\n+\n+    uint64_t NewPeer()\n+    {\n+        bool ok;\n+        uint64_t ret;\n+        do {\n+            ret = InsecureRandBits(63);\n+            ok = m_runner.peerset.insert(ret).second;\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    std::chrono::microseconds Now() const { return m_now; }\n+};\n+\n+/** Add to scenario a test with a single tx announced by a single peer.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildSingleTest(Scenario& scenario, int config)\n+{\n+    auto peer = scenario.NewPeer();\n+    auto gtxid = scenario.NewGTxid();\n+    bool immediate = config & 1;\n+    bool preferred = config & 2;\n+    auto delay = immediate ? NO_TIME : RandomTime();\n+\n+    scenario.SetTestName(strprintf(\"Single(config=%i)\", config));\n+\n+    // Receive an announcement, either immediately requestable or delayed.\n+    scenario.ReceivedInv(peer, gtxid, preferred, immediate ? MIN_TIME : scenario.Now() + delay);\n+    if (immediate) {\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s1\");\n+    } else {\n+        scenario.Check(peer, {}, 1, 0, 0, \"s2\");\n+        scenario.AdvanceTime(delay - MICROSECOND);\n+        scenario.Check(peer, {}, 1, 0, 0, \"s3\");\n+        scenario.AdvanceTime(MICROSECOND);\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s4\");\n+    }\n+\n+    if (config >> 3) { // We'll request the transaction\n+        scenario.AdvanceTime(RandomTime());\n+        auto expiry = RandomTime();\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s5\");\n+        scenario.RequestedTx(peer, gtxid, scenario.Now() + expiry);\n+        scenario.Check(peer, {}, 0, 1, 0, \"s6\");\n+\n+        if ((config >> 3) == 1) { // The request will time out\n+            scenario.AdvanceTime(expiry - MICROSECOND);\n+            scenario.Check(peer, {}, 0, 1, 0, \"s7\");\n+            scenario.AdvanceTime(MICROSECOND);\n+            scenario.Check(peer, {}, 0, 0, 0, \"s8\");\n+            return;\n+        } else {\n+            scenario.AdvanceTime(std::chrono::microseconds{InsecureRandRange(expiry.count())});\n+            scenario.Check(peer, {}, 0, 1, 0, \"s9\");\n+            if ((config >> 3) == 3) { // A reponse will arrive for the transaction\n+                scenario.ReceivedResponse(peer, gtxid);\n+                scenario.Check(peer, {}, 0, 0, 0, \"s10\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    scenario.AdvanceTime(RandomTime());\n+    if (config & 4) { // The peer will go offline\n+        scenario.DisconnectedPeer(peer);\n+    } else { // The transaction is no longer needed\n+        scenario.ForgetTxHash(gtxid.GetHash());\n+    }\n+    scenario.Check(peer, {}, 0, 0, 0, \"s11\");\n+}\n+\n+/** Add to scenario a test with a single tx announced by two peers, to verify the\n+ *  right peer is selected for requests.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildPriorityTest(Scenario& scenario, int config)\n+{\n+    scenario.SetTestName(strprintf(\"Priority(config=%i)\", config));\n+\n+    // Three peers. They will announce in order.\n+    auto peer1 = scenario.NewPeer(), peer2 = scenario.NewPeer();\n+    // Construct a transaction that under random rules would be preferred by peer2 or peer1,\n+    // depending on configuration.\n+    bool prio1 = config & 1;\n+    auto gtxid = prio1 ? scenario.NewGTxid({{peer1, peer2}}) : scenario.NewGTxid({{peer2, peer1}});\n+    bool pref1 = config & 2, pref2 = config & 4;\n+\n+    scenario.ReceivedInv(peer1, gtxid, pref1, MIN_TIME);\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p1\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498967076",
      "id" : 498967076,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2NzA3Ng==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 265,
      "original_position" : 265,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 501236154,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498967076",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498971329"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498971329"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think advancing time should be a config alternative of its own, otherwise can you dissociate the state transition REQUESTED -> COMPLETED triggered by a `ReceivedResponse/DisconnectPeer` from a `GetRequestable` one ?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T18:04:30Z",
      "diff_hunk" : "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds MIN_TIME = std::chrono::microseconds::min();\n+constexpr std::chrono::microseconds MAX_TIME = std::chrono::microseconds::max();\n+constexpr std::chrono::microseconds MICROSECOND = std::chrono::microseconds{1};\n+constexpr std::chrono::microseconds NO_TIME = std::chrono::microseconds{0};\n+\n+/** An Action is a function to call at a particular (simulated) timestamp. */\n+using Action = std::pair<std::chrono::microseconds, std::function<void()>>;\n+\n+/** Object that stores actions from multiple interleaved scenarios, and data shared across them.\n+ *\n+ * The Scenario below is used to fill this.\n+ */\n+struct Runner\n+{\n+    /** The TxRequestTracker being tested. */\n+    TxRequestTracker txrequest;\n+\n+    /** List of actions to be executed (in order of increasing timestamp). */\n+    std::vector<Action> actions;\n+\n+    /** Which node ids have been assigned already (to prevent reuse). */\n+    std::set<uint64_t> peerset;\n+\n+    /** Which txhashes have been assigned already (to prevent reuse). */\n+    std::set<uint256> txhashset;\n+};\n+\n+std::chrono::microseconds RandomTime(int bits=23) { return std::chrono::microseconds{1 + InsecureRandBits(bits)}; }\n+\n+/** A proxy for a Runner that helps build a sequence of consecutive test actions on a TxRequestTracker.\n+ *\n+ * Multiple Scenarios are used with a single Runner, resulting in interleaved actions.\n+ */\n+class Scenario\n+{\n+    Runner& m_runner;\n+    std::chrono::microseconds m_now;\n+    std::string m_testname;\n+\n+public:\n+    Scenario(Runner& runner, std::chrono::microseconds starttime) : m_runner(runner)\n+    {\n+        m_now = starttime + RandomTime() + RandomTime() + RandomTime();\n+    }\n+\n+    void SetTestName(std::string testname)\n+    {\n+        m_testname = std::move(testname);\n+    }\n+\n+    void AdvanceTime(std::chrono::microseconds amount)\n+    {\n+        assert(amount.count() >= 0);\n+        m_now += amount;\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ForgetTxHash(txhash);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool pref, std::chrono::microseconds reqtime = MIN_TIME)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedInv(peer, gtxid, pref, reqtime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.DisconnectedPeer(peer);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds exptime)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.RequestedTx(peer, gtxid, exptime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedResponse(peer, gtxid);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void Check(uint64_t peer, const std::vector<GenTxid>& expected, size_t candidates, size_t inflight,\n+        size_t completed, const std::string& checkname = \"\")\n+    {\n+        const auto comment = m_testname + \" \" + checkname;\n+        auto& runner = m_runner;\n+        const auto now = m_now;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            auto ret = runner.txrequest.GetRequestable(peer, now);\n+            runner.txrequest.SanityCheck();\n+            runner.txrequest.PostGetRequestableSanityCheck(now);\n+            size_t total = candidates + inflight + completed;\n+            size_t real_total = runner.txrequest.Count(peer);\n+            size_t real_candidates = runner.txrequest.CountCandidates(peer);\n+            size_t real_inflight = runner.txrequest.CountInFlight(peer);\n+            BOOST_CHECK_MESSAGE(real_total == total, strprintf(\"[\" + comment + \"] total %i (%i expected)\", real_total, total));\n+            BOOST_CHECK_MESSAGE(real_inflight == inflight, strprintf(\"[\" + comment + \"] inflight %i (%i expected)\", real_inflight, inflight));\n+            BOOST_CHECK_MESSAGE(real_candidates == candidates, strprintf(\"[\" + comment + \"] candidates %i (%i expected)\", real_candidates, candidates));\n+            BOOST_CHECK_MESSAGE(ret == expected, \"[\" + comment + \"] mismatching requestables\");\n+        });\n+    }\n+\n+    uint256 NewTxHash(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        uint256 ret;\n+        bool ok;\n+        do {\n+            ret = InsecureRand256();\n+            ok = true;\n+            for (const auto& order : orders) {\n+                for (size_t pos = 1; pos < order.size(); ++pos) {\n+                    uint64_t prio_prev = m_runner.txrequest.ComputePriority(ret, order[pos - 1], true);\n+                    uint64_t prio_cur = m_runner.txrequest.ComputePriority(ret, order[pos], true);\n+                    if (prio_prev >= prio_cur) {\n+                        ok = false;\n+                        break;\n+                    }\n+                }\n+                if (!ok) break;\n+            }\n+            if (ok) {\n+                ok = m_runner.txhashset.insert(ret).second;\n+            }\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    GenTxid NewGTxid(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        return {InsecureRandBool(), NewTxHash(orders)};\n+    }\n+\n+    uint64_t NewPeer()\n+    {\n+        bool ok;\n+        uint64_t ret;\n+        do {\n+            ret = InsecureRandBits(63);\n+            ok = m_runner.peerset.insert(ret).second;\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    std::chrono::microseconds Now() const { return m_now; }\n+};\n+\n+/** Add to scenario a test with a single tx announced by a single peer.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildSingleTest(Scenario& scenario, int config)\n+{\n+    auto peer = scenario.NewPeer();\n+    auto gtxid = scenario.NewGTxid();\n+    bool immediate = config & 1;\n+    bool preferred = config & 2;\n+    auto delay = immediate ? NO_TIME : RandomTime();\n+\n+    scenario.SetTestName(strprintf(\"Single(config=%i)\", config));\n+\n+    // Receive an announcement, either immediately requestable or delayed.\n+    scenario.ReceivedInv(peer, gtxid, preferred, immediate ? MIN_TIME : scenario.Now() + delay);\n+    if (immediate) {\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s1\");\n+    } else {\n+        scenario.Check(peer, {}, 1, 0, 0, \"s2\");\n+        scenario.AdvanceTime(delay - MICROSECOND);\n+        scenario.Check(peer, {}, 1, 0, 0, \"s3\");\n+        scenario.AdvanceTime(MICROSECOND);\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s4\");\n+    }\n+\n+    if (config >> 3) { // We'll request the transaction\n+        scenario.AdvanceTime(RandomTime());\n+        auto expiry = RandomTime();\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s5\");\n+        scenario.RequestedTx(peer, gtxid, scenario.Now() + expiry);\n+        scenario.Check(peer, {}, 0, 1, 0, \"s6\");\n+\n+        if ((config >> 3) == 1) { // The request will time out\n+            scenario.AdvanceTime(expiry - MICROSECOND);\n+            scenario.Check(peer, {}, 0, 1, 0, \"s7\");\n+            scenario.AdvanceTime(MICROSECOND);\n+            scenario.Check(peer, {}, 0, 0, 0, \"s8\");\n+            return;\n+        } else {\n+            scenario.AdvanceTime(std::chrono::microseconds{InsecureRandRange(expiry.count())});\n+            scenario.Check(peer, {}, 0, 1, 0, \"s9\");\n+            if ((config >> 3) == 3) { // A reponse will arrive for the transaction\n+                scenario.ReceivedResponse(peer, gtxid);\n+                scenario.Check(peer, {}, 0, 0, 0, \"s10\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    scenario.AdvanceTime(RandomTime());\n+    if (config & 4) { // The peer will go offline\n+        scenario.DisconnectedPeer(peer);\n+    } else { // The transaction is no longer needed\n+        scenario.ForgetTxHash(gtxid.GetHash());\n+    }\n+    scenario.Check(peer, {}, 0, 0, 0, \"s11\");\n+}\n+\n+/** Add to scenario a test with a single tx announced by two peers, to verify the\n+ *  right peer is selected for requests.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildPriorityTest(Scenario& scenario, int config)\n+{\n+    scenario.SetTestName(strprintf(\"Priority(config=%i)\", config));\n+\n+    // Three peers. They will announce in order.\n+    auto peer1 = scenario.NewPeer(), peer2 = scenario.NewPeer();\n+    // Construct a transaction that under random rules would be preferred by peer2 or peer1,\n+    // depending on configuration.\n+    bool prio1 = config & 1;\n+    auto gtxid = prio1 ? scenario.NewGTxid({{peer1, peer2}}) : scenario.NewGTxid({{peer2, peer1}});\n+    bool pref1 = config & 2, pref2 = config & 4;\n+\n+    scenario.ReceivedInv(peer1, gtxid, pref1, MIN_TIME);\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p1\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p2\");\n+\n+    scenario.ReceivedInv(peer2, gtxid, pref2, MIN_TIME);\n+    bool stage2_prio =\n+        // At this point, peer2 will be given priority if:\n+        // - It is preferred and peer1 is not\n+        (pref2 && !pref1) ||\n+        // - They're in the same preference class,\n+        //   and the randomized priority favors peer2 over peer1.\n+        (pref1 == pref2 && !prio1);\n+    uint64_t priopeer = stage2_prio ? peer2 : peer1, otherpeer = stage2_prio ? peer1 : peer2;\n+    scenario.Check(otherpeer, {}, 1, 0, 0, \"p3\");\n+    scenario.Check(priopeer, {gtxid}, 1, 0, 0, \"p4\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(otherpeer, {}, 1, 0, 0, \"p5\");\n+    scenario.Check(priopeer, {gtxid}, 1, 0, 0, \"p6\");\n+\n+    // We possibly request from the selected peer.\n+    if (config & 8) {\n+        scenario.RequestedTx(priopeer, gtxid, MAX_TIME);\n+        scenario.Check(priopeer, {}, 0, 1, 0, \"p7\");\n+        scenario.Check(otherpeer, {}, 1, 0, 0, \"p8\");\n+        if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    }\n+\n+    // The peer which was selected (or requested from) now goes offline, or a NOTFOUND is received from them.\n+    if (config & 16) {\n+        scenario.DisconnectedPeer(priopeer);\n+    } else {\n+        scenario.ReceivedResponse(priopeer, gtxid);\n+    }\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498971329",
      "id" : 498971329,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk3MTMyOQ==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 297,
      "original_position" : 297,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 501236154,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498971329",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498972630"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498972630"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think using a AND here will get you higher coverage of this case ?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T18:07:18Z",
      "diff_hunk" : "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds MIN_TIME = std::chrono::microseconds::min();\n+constexpr std::chrono::microseconds MAX_TIME = std::chrono::microseconds::max();\n+constexpr std::chrono::microseconds MICROSECOND = std::chrono::microseconds{1};\n+constexpr std::chrono::microseconds NO_TIME = std::chrono::microseconds{0};\n+\n+/** An Action is a function to call at a particular (simulated) timestamp. */\n+using Action = std::pair<std::chrono::microseconds, std::function<void()>>;\n+\n+/** Object that stores actions from multiple interleaved scenarios, and data shared across them.\n+ *\n+ * The Scenario below is used to fill this.\n+ */\n+struct Runner\n+{\n+    /** The TxRequestTracker being tested. */\n+    TxRequestTracker txrequest;\n+\n+    /** List of actions to be executed (in order of increasing timestamp). */\n+    std::vector<Action> actions;\n+\n+    /** Which node ids have been assigned already (to prevent reuse). */\n+    std::set<uint64_t> peerset;\n+\n+    /** Which txhashes have been assigned already (to prevent reuse). */\n+    std::set<uint256> txhashset;\n+};\n+\n+std::chrono::microseconds RandomTime(int bits=23) { return std::chrono::microseconds{1 + InsecureRandBits(bits)}; }\n+\n+/** A proxy for a Runner that helps build a sequence of consecutive test actions on a TxRequestTracker.\n+ *\n+ * Multiple Scenarios are used with a single Runner, resulting in interleaved actions.\n+ */\n+class Scenario\n+{\n+    Runner& m_runner;\n+    std::chrono::microseconds m_now;\n+    std::string m_testname;\n+\n+public:\n+    Scenario(Runner& runner, std::chrono::microseconds starttime) : m_runner(runner)\n+    {\n+        m_now = starttime + RandomTime() + RandomTime() + RandomTime();\n+    }\n+\n+    void SetTestName(std::string testname)\n+    {\n+        m_testname = std::move(testname);\n+    }\n+\n+    void AdvanceTime(std::chrono::microseconds amount)\n+    {\n+        assert(amount.count() >= 0);\n+        m_now += amount;\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ForgetTxHash(txhash);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool pref, std::chrono::microseconds reqtime = MIN_TIME)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedInv(peer, gtxid, pref, reqtime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.DisconnectedPeer(peer);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds exptime)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.RequestedTx(peer, gtxid, exptime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedResponse(peer, gtxid);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void Check(uint64_t peer, const std::vector<GenTxid>& expected, size_t candidates, size_t inflight,\n+        size_t completed, const std::string& checkname = \"\")\n+    {\n+        const auto comment = m_testname + \" \" + checkname;\n+        auto& runner = m_runner;\n+        const auto now = m_now;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            auto ret = runner.txrequest.GetRequestable(peer, now);\n+            runner.txrequest.SanityCheck();\n+            runner.txrequest.PostGetRequestableSanityCheck(now);\n+            size_t total = candidates + inflight + completed;\n+            size_t real_total = runner.txrequest.Count(peer);\n+            size_t real_candidates = runner.txrequest.CountCandidates(peer);\n+            size_t real_inflight = runner.txrequest.CountInFlight(peer);\n+            BOOST_CHECK_MESSAGE(real_total == total, strprintf(\"[\" + comment + \"] total %i (%i expected)\", real_total, total));\n+            BOOST_CHECK_MESSAGE(real_inflight == inflight, strprintf(\"[\" + comment + \"] inflight %i (%i expected)\", real_inflight, inflight));\n+            BOOST_CHECK_MESSAGE(real_candidates == candidates, strprintf(\"[\" + comment + \"] candidates %i (%i expected)\", real_candidates, candidates));\n+            BOOST_CHECK_MESSAGE(ret == expected, \"[\" + comment + \"] mismatching requestables\");\n+        });\n+    }\n+\n+    uint256 NewTxHash(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        uint256 ret;\n+        bool ok;\n+        do {\n+            ret = InsecureRand256();\n+            ok = true;\n+            for (const auto& order : orders) {\n+                for (size_t pos = 1; pos < order.size(); ++pos) {\n+                    uint64_t prio_prev = m_runner.txrequest.ComputePriority(ret, order[pos - 1], true);\n+                    uint64_t prio_cur = m_runner.txrequest.ComputePriority(ret, order[pos], true);\n+                    if (prio_prev >= prio_cur) {\n+                        ok = false;\n+                        break;\n+                    }\n+                }\n+                if (!ok) break;\n+            }\n+            if (ok) {\n+                ok = m_runner.txhashset.insert(ret).second;\n+            }\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    GenTxid NewGTxid(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        return {InsecureRandBool(), NewTxHash(orders)};\n+    }\n+\n+    uint64_t NewPeer()\n+    {\n+        bool ok;\n+        uint64_t ret;\n+        do {\n+            ret = InsecureRandBits(63);\n+            ok = m_runner.peerset.insert(ret).second;\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    std::chrono::microseconds Now() const { return m_now; }\n+};\n+\n+/** Add to scenario a test with a single tx announced by a single peer.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildSingleTest(Scenario& scenario, int config)\n+{\n+    auto peer = scenario.NewPeer();\n+    auto gtxid = scenario.NewGTxid();\n+    bool immediate = config & 1;\n+    bool preferred = config & 2;\n+    auto delay = immediate ? NO_TIME : RandomTime();\n+\n+    scenario.SetTestName(strprintf(\"Single(config=%i)\", config));\n+\n+    // Receive an announcement, either immediately requestable or delayed.\n+    scenario.ReceivedInv(peer, gtxid, preferred, immediate ? MIN_TIME : scenario.Now() + delay);\n+    if (immediate) {\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s1\");\n+    } else {\n+        scenario.Check(peer, {}, 1, 0, 0, \"s2\");\n+        scenario.AdvanceTime(delay - MICROSECOND);\n+        scenario.Check(peer, {}, 1, 0, 0, \"s3\");\n+        scenario.AdvanceTime(MICROSECOND);\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s4\");\n+    }\n+\n+    if (config >> 3) { // We'll request the transaction\n+        scenario.AdvanceTime(RandomTime());\n+        auto expiry = RandomTime();\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s5\");\n+        scenario.RequestedTx(peer, gtxid, scenario.Now() + expiry);\n+        scenario.Check(peer, {}, 0, 1, 0, \"s6\");\n+\n+        if ((config >> 3) == 1) { // The request will time out",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498972630",
      "id" : 498972630,
      "line" : 250,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk3MjYzMA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 250,
      "original_position" : 220,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : 250,
      "pull_request_review_id" : 501236154,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498972630",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498973098"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498973098"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Isn't advancing the time blurring the further observance that the transaction state has been moved ? Compared to only relying on `DisconnectPeer`/`ForgetTxHash` ?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T18:08:28Z",
      "diff_hunk" : "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds MIN_TIME = std::chrono::microseconds::min();\n+constexpr std::chrono::microseconds MAX_TIME = std::chrono::microseconds::max();\n+constexpr std::chrono::microseconds MICROSECOND = std::chrono::microseconds{1};\n+constexpr std::chrono::microseconds NO_TIME = std::chrono::microseconds{0};\n+\n+/** An Action is a function to call at a particular (simulated) timestamp. */\n+using Action = std::pair<std::chrono::microseconds, std::function<void()>>;\n+\n+/** Object that stores actions from multiple interleaved scenarios, and data shared across them.\n+ *\n+ * The Scenario below is used to fill this.\n+ */\n+struct Runner\n+{\n+    /** The TxRequestTracker being tested. */\n+    TxRequestTracker txrequest;\n+\n+    /** List of actions to be executed (in order of increasing timestamp). */\n+    std::vector<Action> actions;\n+\n+    /** Which node ids have been assigned already (to prevent reuse). */\n+    std::set<uint64_t> peerset;\n+\n+    /** Which txhashes have been assigned already (to prevent reuse). */\n+    std::set<uint256> txhashset;\n+};\n+\n+std::chrono::microseconds RandomTime(int bits=23) { return std::chrono::microseconds{1 + InsecureRandBits(bits)}; }\n+\n+/** A proxy for a Runner that helps build a sequence of consecutive test actions on a TxRequestTracker.\n+ *\n+ * Multiple Scenarios are used with a single Runner, resulting in interleaved actions.\n+ */\n+class Scenario\n+{\n+    Runner& m_runner;\n+    std::chrono::microseconds m_now;\n+    std::string m_testname;\n+\n+public:\n+    Scenario(Runner& runner, std::chrono::microseconds starttime) : m_runner(runner)\n+    {\n+        m_now = starttime + RandomTime() + RandomTime() + RandomTime();\n+    }\n+\n+    void SetTestName(std::string testname)\n+    {\n+        m_testname = std::move(testname);\n+    }\n+\n+    void AdvanceTime(std::chrono::microseconds amount)\n+    {\n+        assert(amount.count() >= 0);\n+        m_now += amount;\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ForgetTxHash(txhash);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool pref, std::chrono::microseconds reqtime = MIN_TIME)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedInv(peer, gtxid, pref, reqtime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.DisconnectedPeer(peer);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds exptime)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.RequestedTx(peer, gtxid, exptime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedResponse(peer, gtxid);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void Check(uint64_t peer, const std::vector<GenTxid>& expected, size_t candidates, size_t inflight,\n+        size_t completed, const std::string& checkname = \"\")\n+    {\n+        const auto comment = m_testname + \" \" + checkname;\n+        auto& runner = m_runner;\n+        const auto now = m_now;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            auto ret = runner.txrequest.GetRequestable(peer, now);\n+            runner.txrequest.SanityCheck();\n+            runner.txrequest.PostGetRequestableSanityCheck(now);\n+            size_t total = candidates + inflight + completed;\n+            size_t real_total = runner.txrequest.Count(peer);\n+            size_t real_candidates = runner.txrequest.CountCandidates(peer);\n+            size_t real_inflight = runner.txrequest.CountInFlight(peer);\n+            BOOST_CHECK_MESSAGE(real_total == total, strprintf(\"[\" + comment + \"] total %i (%i expected)\", real_total, total));\n+            BOOST_CHECK_MESSAGE(real_inflight == inflight, strprintf(\"[\" + comment + \"] inflight %i (%i expected)\", real_inflight, inflight));\n+            BOOST_CHECK_MESSAGE(real_candidates == candidates, strprintf(\"[\" + comment + \"] candidates %i (%i expected)\", real_candidates, candidates));\n+            BOOST_CHECK_MESSAGE(ret == expected, \"[\" + comment + \"] mismatching requestables\");\n+        });\n+    }\n+\n+    uint256 NewTxHash(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        uint256 ret;\n+        bool ok;\n+        do {\n+            ret = InsecureRand256();\n+            ok = true;\n+            for (const auto& order : orders) {\n+                for (size_t pos = 1; pos < order.size(); ++pos) {\n+                    uint64_t prio_prev = m_runner.txrequest.ComputePriority(ret, order[pos - 1], true);\n+                    uint64_t prio_cur = m_runner.txrequest.ComputePriority(ret, order[pos], true);\n+                    if (prio_prev >= prio_cur) {\n+                        ok = false;\n+                        break;\n+                    }\n+                }\n+                if (!ok) break;\n+            }\n+            if (ok) {\n+                ok = m_runner.txhashset.insert(ret).second;\n+            }\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    GenTxid NewGTxid(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        return {InsecureRandBool(), NewTxHash(orders)};\n+    }\n+\n+    uint64_t NewPeer()\n+    {\n+        bool ok;\n+        uint64_t ret;\n+        do {\n+            ret = InsecureRandBits(63);\n+            ok = m_runner.peerset.insert(ret).second;\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    std::chrono::microseconds Now() const { return m_now; }\n+};\n+\n+/** Add to scenario a test with a single tx announced by a single peer.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildSingleTest(Scenario& scenario, int config)\n+{\n+    auto peer = scenario.NewPeer();\n+    auto gtxid = scenario.NewGTxid();\n+    bool immediate = config & 1;\n+    bool preferred = config & 2;\n+    auto delay = immediate ? NO_TIME : RandomTime();\n+\n+    scenario.SetTestName(strprintf(\"Single(config=%i)\", config));\n+\n+    // Receive an announcement, either immediately requestable or delayed.\n+    scenario.ReceivedInv(peer, gtxid, preferred, immediate ? MIN_TIME : scenario.Now() + delay);\n+    if (immediate) {\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s1\");\n+    } else {\n+        scenario.Check(peer, {}, 1, 0, 0, \"s2\");\n+        scenario.AdvanceTime(delay - MICROSECOND);\n+        scenario.Check(peer, {}, 1, 0, 0, \"s3\");\n+        scenario.AdvanceTime(MICROSECOND);\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s4\");\n+    }\n+\n+    if (config >> 3) { // We'll request the transaction\n+        scenario.AdvanceTime(RandomTime());\n+        auto expiry = RandomTime();\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s5\");\n+        scenario.RequestedTx(peer, gtxid, scenario.Now() + expiry);\n+        scenario.Check(peer, {}, 0, 1, 0, \"s6\");\n+\n+        if ((config >> 3) == 1) { // The request will time out\n+            scenario.AdvanceTime(expiry - MICROSECOND);\n+            scenario.Check(peer, {}, 0, 1, 0, \"s7\");\n+            scenario.AdvanceTime(MICROSECOND);\n+            scenario.Check(peer, {}, 0, 0, 0, \"s8\");\n+            return;\n+        } else {\n+            scenario.AdvanceTime(std::chrono::microseconds{InsecureRandRange(expiry.count())});\n+            scenario.Check(peer, {}, 0, 1, 0, \"s9\");\n+            if ((config >> 3) == 3) { // A reponse will arrive for the transaction\n+                scenario.ReceivedResponse(peer, gtxid);\n+                scenario.Check(peer, {}, 0, 0, 0, \"s10\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    scenario.AdvanceTime(RandomTime());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498973098",
      "id" : 498973098,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk3MzA5OA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 261,
      "original_position" : 237,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 501236154,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498973098",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498984068"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498984068"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T18:27:49Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498984068",
      "id" : 498984068,
      "in_reply_to_id" : 498699913,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NDA2OA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 210,
      "original_position" : 210,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 501357724,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498984068",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498984686"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498984686"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've bitten the bullet and converted everything to `NodeId`.\r\n\r\nI believe it being a uint64_t dates back to a time when I was trying to squeeze out bits by using less than 64 bits for the peer (and signed bitfields are implementation defined, IIRC). This was a bad idea.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T18:29:04Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498984686",
      "id" : 498984686,
      "in_reply_to_id" : 498714760,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NDY4Ng==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 62,
      "original_position" : 62,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 501358614,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498984686",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498984798"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498984798"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T18:29:16Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo entries exist with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+\n+            // Looking up the last ByTxHash entry with the given txhash must return an Entry with that txhash or the\n+            // multi_index is very bad.\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{item.first, State::TOO_LARGE, 0}));\n+            assert(it_last != m_index.get<ByTxHash>().end() && it_last->m_txhash == item.first);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+\n+private:\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txhash that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txhash already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = m_computer(*std::prev(it));\n+            uint64_t priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in\n+            // the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Entry for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED entries.\n+\n+        // If this Entry's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Entry's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txhash, they are\n+     *  deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+     *  CANDIDATE_BEST. Returns whether the Entry still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED entry for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the entry COMPLETED, and select the next best entry (the first CANDIDATE_READY) if needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to EntryTxHashExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(EntryPeerExtractor(), std::less<EntryPeer>()),\n+            boost::make_tuple(EntryTxHashExtractor(m_computer), std::less<EntryTxHash>()),\n+            boost::make_tuple(EntryTimeExtractor(), std::less<EntryTime>())\n+        )) {}\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxHashExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+            // CANDIDATE_BEST, or delete all of a txhash's entries if no non-COMPLETED ones are left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(EntryTxHash{txhash, State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST entry for this (txhash, peer) combination. The case where\n+        // there is a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+        // automatically.\n+        if (m_index.get<ByPeer>().count(EntryPeer{peer, true, gtxid.GetHash()})) return;\n+\n+        // Find last entry for this txhash, and extract per-txhash information from it.\n+        Iter<ByTxHash> it_last = m_index.get<ByTxHash>().end();\n+        // First find the first entry past this txhash.\n+        it_last = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0});\n+        if (it_last != m_index.get<ByTxHash>().begin() && std::prev(it_last)->m_txhash == gtxid.GetHash()) {\n+            it_last--;\n+        } else {\n+            // No entry for this txhash exists yet.\n+            it_last = m_index.get<ByTxHash>().end();\n+        }\n+\n+        // Try creating the entry with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST entry already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_sequence);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+    }\n+\n+    //! Find the GenTxids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now)\n+    {\n+        // Move time.\n+        SetTimePoint(now);\n+\n+        // Find all CANDIDATE_BEST entries for this peer.\n+        std::vector<std::pair<uint64_t, const Entry*>> selected;\n+        auto it_peer = m_index.get<ByPeer>().lower_bound(EntryPeer{peer, true, UINT256_ZERO});\n+        while (it_peer != m_index.get<ByPeer>().end() && it_peer->m_peer == peer &&\n+            it_peer->GetState() == State::CANDIDATE_BEST) {\n+            selected.emplace_back(it_peer->m_sequence, &*it_peer);\n+            ++it_peer;\n+        }\n+\n+        // Return them, sorted by sequence number.\n+        std::sort(selected.begin(), selected.end());\n+        std::vector<GenTxid> ret;\n+        for (const auto& item : selected) {\n+            ret.emplace_back(item.second->m_is_wtxid, item.second->m_txhash);\n+        }\n+        return ret;\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds expiry)\n+    {\n+        auto it = m_index.get<ByPeer>().find(EntryPeer{peer, true, gtxid.GetHash()});\n+        // RequestedTx can only be called on CANDIDATE_BEST entries (this is implied by its condition that it can\n+        // only be called on GenTxids returned by GetRequestable (and only AlreadyHave and RequestedTx can be called",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498984798",
      "id" : 498984798,
      "in_reply_to_id" : 498723043,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NDc5OA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 587,
      "original_position" : 587,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 501358742,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498984798",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498984897"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498984897"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T18:29:25Z",
      "diff_hunk" : "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction. Note that this only works\n+ *              per txhash, so if the same transaction is announced both through txid and wtxid, we have no means\n+ *              to prevent fetching both (the caller can however mitigate this by delaying one, see further).\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten only:\n+ *   - If a peer goes offline, all its announcements are forgotten.\n+ *   - If a transaction has been successfully received, or is otherwise no longer needed, the caller can call\n+ *     ForgetTxHash, which removes all announcements across all peers with the specified txhash.\n+ *   - If for a given txhash only already-requested announcements remain, they are all forgotten.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening transaction censoring attacks. The flip side is that as long as an attacker manages\n+ *              to prevent us from receiving a transaction, failed announcements (including those from honest peers)\n+ *              will linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a\n+ *              cap on the number of tracked announcements per peer. As failed requests in response to announcements\n+ *              from honest peers should be rare, this almost solely hinders attackers.\n+ *              Transaction censoring attacks can be done by announcing transactions quickly while not answering\n+ *              requests for them. See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more\n+ *              information.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable the calling code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers are more trusted by us, so are less likely to be under attacker control.\n+ *\n+ *   - Pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: random assignments are hard to influence for attackers.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and minimizing\n+ * susceptibility to censorship attacks. An attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one preferred connection).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution). The \"1 +\" is due to the fact that the\n+ *   attacker can be the first to announce through a preferred connection in this scenario, which very likely means\n+ *   they get the first request.\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh>=1\n+ *   are honest, where we assume that the attacker can disconnect and reconnect those connections, the distribution\n+ *   becomes k ~ P + NB(p=1-NP/NPh,r=1) (where NB stands for Negative Binomial distribution), which has mean\n+ *   P-1+NP/NPh.\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, and a NOTFOUND or a\n+    //   transaction was received in response (valid or not), or they timed out. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DisconnectedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash (both txid and wtxid ones).\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it.\n+     */\n+    void ForgetTxHash(const uint256& txhash);\n+\n+    /** Adds a new CANDIDATE announcement.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that the txid/wtxid property is ignored for determining uniqueness, so if an announcement\n+     * is added for a wtxid H, while one for txid H from the same peer already exists, it will be ignored. This is\n+     * harmless as the txhashes being equal implies it is a non-segwit transaction, so it doesn't matter how it is\n+     * fetched. The new announcement is given the specified preferred and reqtime values, and takes it is_wtxid from",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498984897",
      "id" : 498984897,
      "in_reply_to_id" : 498718932,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NDg5Nw==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 139,
      "original_position" : 139,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 501358863,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498984897",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498984960"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498984960"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T18:29:32Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo entries exist with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+\n+            // Looking up the last ByTxHash entry with the given txhash must return an Entry with that txhash or the\n+            // multi_index is very bad.\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{item.first, State::TOO_LARGE, 0}));\n+            assert(it_last != m_index.get<ByTxHash>().end() && it_last->m_txhash == item.first);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+\n+private:\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txhash that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txhash already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = m_computer(*std::prev(it));\n+            uint64_t priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in\n+            // the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Entry for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED entries.\n+\n+        // If this Entry's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Entry's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txhash, they are\n+     *  deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+     *  CANDIDATE_BEST. Returns whether the Entry still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED entry for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the entry COMPLETED, and select the next best entry (the first CANDIDATE_READY) if needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to EntryTxHashExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(EntryPeerExtractor(), std::less<EntryPeer>()),\n+            boost::make_tuple(EntryTxHashExtractor(m_computer), std::less<EntryTxHash>()),\n+            boost::make_tuple(EntryTimeExtractor(), std::less<EntryTime>())\n+        )) {}\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxHashExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+            // CANDIDATE_BEST, or delete all of a txhash's entries if no non-COMPLETED ones are left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(EntryTxHash{txhash, State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST entry for this (txhash, peer) combination. The case where\n+        // there is a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+        // automatically.\n+        if (m_index.get<ByPeer>().count(EntryPeer{peer, true, gtxid.GetHash()})) return;\n+\n+        // Find last entry for this txhash, and extract per-txhash information from it.\n+        Iter<ByTxHash> it_last = m_index.get<ByTxHash>().end();\n+        // First find the first entry past this txhash.\n+        it_last = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0});\n+        if (it_last != m_index.get<ByTxHash>().begin() && std::prev(it_last)->m_txhash == gtxid.GetHash()) {\n+            it_last--;\n+        } else {\n+            // No entry for this txhash exists yet.\n+            it_last = m_index.get<ByTxHash>().end();\n+        }\n+\n+        // Try creating the entry with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST entry already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_sequence);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+    }\n+\n+    //! Find the GenTxids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now)\n+    {\n+        // Move time.\n+        SetTimePoint(now);\n+\n+        // Find all CANDIDATE_BEST entries for this peer.\n+        std::vector<std::pair<uint64_t, const Entry*>> selected;\n+        auto it_peer = m_index.get<ByPeer>().lower_bound(EntryPeer{peer, true, UINT256_ZERO});\n+        while (it_peer != m_index.get<ByPeer>().end() && it_peer->m_peer == peer &&\n+            it_peer->GetState() == State::CANDIDATE_BEST) {\n+            selected.emplace_back(it_peer->m_sequence, &*it_peer);\n+            ++it_peer;\n+        }\n+\n+        // Return them, sorted by sequence number.\n+        std::sort(selected.begin(), selected.end());\n+        std::vector<GenTxid> ret;\n+        for (const auto& item : selected) {\n+            ret.emplace_back(item.second->m_is_wtxid, item.second->m_txhash);\n+        }\n+        return ret;\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds expiry)\n+    {\n+        auto it = m_index.get<ByPeer>().find(EntryPeer{peer, true, gtxid.GetHash()});\n+        // RequestedTx can only be called on CANDIDATE_BEST entries (this is implied by its condition that it can\n+        // only be called on GenTxids returned by GetRequestable (and only AlreadyHave and RequestedTx can be called\n+        // in between, which preserve the state of other GenTxids).\n+        assert(it != m_index.get<ByPeer>().end());\n+        assert(it->GetState() == State::CANDIDATE_BEST);\n+        Modify<ByPeer>(it, [expiry](Entry& entry) {\n+            entry.SetState(State::REQUESTED);\n+            entry.m_time = expiry;\n+        });\n+\n+        // Update the per-txhash data (of the last Entry for this txhash) to reflect that new ones are no longer\n+        // eligible for the \"first\" marker.\n+        auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0}));\n+        assert(it_last->m_txhash == gtxid.GetHash());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498984960",
      "id" : 498984960,
      "in_reply_to_id" : 498725131,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NDk2MA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 599,
      "original_position" : 599,
      "original_start_line" : 595,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 501358943,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498984960",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498985023"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498985023"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T18:29:39Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498985023",
      "id" : 498985023,
      "in_reply_to_id" : 498727923,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NTAyMw==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 278,
      "original_position" : 269,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 501359020,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498985023",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498985082"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498985082"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T18:29:45Z",
      "diff_hunk" : "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction. Note that this only works\n+ *              per txhash, so if the same transaction is announced both through txid and wtxid, we have no means\n+ *              to prevent fetching both (the caller can however mitigate this by delaying one, see further).\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten only:\n+ *   - If a peer goes offline, all its announcements are forgotten.\n+ *   - If a transaction has been successfully received, or is otherwise no longer needed, the caller can call\n+ *     ForgetTxHash, which removes all announcements across all peers with the specified txhash.\n+ *   - If for a given txhash only already-requested announcements remain, they are all forgotten.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening transaction censoring attacks. The flip side is that as long as an attacker manages\n+ *              to prevent us from receiving a transaction, failed announcements (including those from honest peers)\n+ *              will linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a\n+ *              cap on the number of tracked announcements per peer. As failed requests in response to announcements\n+ *              from honest peers should be rare, this almost solely hinders attackers.\n+ *              Transaction censoring attacks can be done by announcing transactions quickly while not answering\n+ *              requests for them. See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more\n+ *              information.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable the calling code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers are more trusted by us, so are less likely to be under attacker control.\n+ *\n+ *   - Pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: random assignments are hard to influence for attackers.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and minimizing\n+ * susceptibility to censorship attacks. An attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one preferred connection).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution). The \"1 +\" is due to the fact that the\n+ *   attacker can be the first to announce through a preferred connection in this scenario, which very likely means\n+ *   they get the first request.\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh>=1\n+ *   are honest, where we assume that the attacker can disconnect and reconnect those connections, the distribution\n+ *   becomes k ~ P + NB(p=1-NP/NPh,r=1) (where NB stands for Negative Binomial distribution), which has mean\n+ *   P-1+NP/NPh.\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, and a NOTFOUND or a\n+    //   transaction was received in response (valid or not), or they timed out. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DisconnectedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash (both txid and wtxid ones).\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it.\n+     */\n+    void ForgetTxHash(const uint256& txhash);\n+\n+    /** Adds a new CANDIDATE announcement.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that the txid/wtxid property is ignored for determining uniqueness, so if an announcement\n+     * is added for a wtxid H, while one for txid H from the same peer already exists, it will be ignored. This is\n+     * harmless as the txhashes being equal implies it is a non-segwit transaction, so it doesn't matter how it is\n+     * fetched. The new announcement is given the specified preferred and reqtime values, and takes it is_wtxid from\n+     * the specified gtxid.\n+     */\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime);\n+\n+    /** Converts the CANDIDATE announcement for the provided peer and gtxid into a REQUESTED one.\n+     *\n+     * Expiry is set to the specified value. This can ONLY be called immediately after GetRequestable was called\n+     * (for the same peer), with only ForgetTx and other RequestedTx calls (both for other txhashes) in",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498985082",
      "id" : 498985082,
      "in_reply_to_id" : 498732054,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NTA4Mg==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 148,
      "original_position" : 148,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 501359101,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498985082",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498985227"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498985227"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Changed to AJ's description.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T18:29:59Z",
      "diff_hunk" : "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction. Note that this only works\n+ *              per txhash, so if the same transaction is announced both through txid and wtxid, we have no means\n+ *              to prevent fetching both (the caller can however mitigate this by delaying one, see further).\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten only:\n+ *   - If a peer goes offline, all its announcements are forgotten.\n+ *   - If a transaction has been successfully received, or is otherwise no longer needed, the caller can call\n+ *     ForgetTxHash, which removes all announcements across all peers with the specified txhash.\n+ *   - If for a given txhash only already-requested announcements remain, they are all forgotten.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening transaction censoring attacks. The flip side is that as long as an attacker manages\n+ *              to prevent us from receiving a transaction, failed announcements (including those from honest peers)\n+ *              will linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a\n+ *              cap on the number of tracked announcements per peer. As failed requests in response to announcements\n+ *              from honest peers should be rare, this almost solely hinders attackers.\n+ *              Transaction censoring attacks can be done by announcing transactions quickly while not answering\n+ *              requests for them. See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more\n+ *              information.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable the calling code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers are more trusted by us, so are less likely to be under attacker control.\n+ *\n+ *   - Pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: random assignments are hard to influence for attackers.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and minimizing\n+ * susceptibility to censorship attacks. An attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one preferred connection).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution). The \"1 +\" is due to the fact that the\n+ *   attacker can be the first to announce through a preferred connection in this scenario, which very likely means\n+ *   they get the first request.\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh>=1\n+ *   are honest, where we assume that the attacker can disconnect and reconnect those connections, the distribution\n+ *   becomes k ~ P + NB(p=1-NP/NPh,r=1) (where NB stands for Negative Binomial distribution), which has mean\n+ *   P-1+NP/NPh.\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, and a NOTFOUND or a\n+    //   transaction was received in response (valid or not), or they timed out. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DisconnectedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash (both txid and wtxid ones).\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it.\n+     */\n+    void ForgetTxHash(const uint256& txhash);\n+\n+    /** Adds a new CANDIDATE announcement.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that the txid/wtxid property is ignored for determining uniqueness, so if an announcement\n+     * is added for a wtxid H, while one for txid H from the same peer already exists, it will be ignored. This is\n+     * harmless as the txhashes being equal implies it is a non-segwit transaction, so it doesn't matter how it is\n+     * fetched. The new announcement is given the specified preferred and reqtime values, and takes it is_wtxid from\n+     * the specified gtxid.\n+     */\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime);\n+\n+    /** Converts the CANDIDATE announcement for the provided peer and gtxid into a REQUESTED one.\n+     *\n+     * Expiry is set to the specified value. This can ONLY be called immediately after GetRequestable was called\n+     * (for the same peer), with only ForgetTx and other RequestedTx calls (both for other txhashes) in\n+     * between. Any other non-const operation removes the ability to call RequestedTx.\n+     */\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds expiry);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498985227",
      "id" : 498985227,
      "in_reply_to_id" : 498734530,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NTIyNw==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 151,
      "original_position" : 151,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 501359259,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498985227",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498985299"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498985299"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T18:30:11Z",
      "diff_hunk" : "@@ -806,73 +740,34 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest\n+    NodeId nodeid = node.GetId();\n+    if (!node.HasPermission(PF_RELAY) && m_txrequest.Count(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"overloaded\": if at least MAX_PEER_TX_IN_FLIGHT requests are in flight (and no PF_RELAY).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498985299",
      "id" : 498985299,
      "in_reply_to_id" : 498737921,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NTI5OQ==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 756,
      "original_position" : 208,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 501359382,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498985299",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498985344"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498985344"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T18:30:18Z",
      "diff_hunk" : "@@ -806,73 +740,34 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest\n+    NodeId nodeid = node.GetId();\n+    if (!node.HasPermission(PF_RELAY) && m_txrequest.Count(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"overloaded\": if at least MAX_PEER_TX_IN_FLIGHT requests are in flight (and no PF_RELAY).\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or PF_NOBAN permission)\n+    // - \"reqtime\": current time plus delays for:\n+    //   - NONPREF_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for announcements from txid peers while wtxid peers are available",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498985344",
      "id" : 498985344,
      "in_reply_to_id" : 498738238,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NTM0NA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 760,
      "original_position" : 212,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 501359439,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498985344",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498985400"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498985400"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T18:30:24Z",
      "diff_hunk" : "@@ -71,22 +71,22 @@ static constexpr std::chrono::minutes PING_INTERVAL{2};\n static const unsigned int MAX_LOCATOR_SZ = 101;\n /** The maximum number of entries in an 'inv' protocol message */\n static const unsigned int MAX_INV_SZ = 50000;\n-/** Maximum number of in-flight transactions from a peer */\n+/** Maximum number of in-flight transactions from a peer. It is not a hard limit, but the threshold\n+ *  at which point the OVERLOADED_PEER_TX_DELAY kicks in. */\n static constexpr int32_t MAX_PEER_TX_IN_FLIGHT = 100;\n-/** Maximum number of announced transactions from a peer */\n-static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 2 * MAX_INV_SZ;\n+/** Maximum number of transactions to consider for requesting, per peer. It provides a reasonable DoS limit to\n+ *  per-peer memory usage spent on announcements, while covering peers continuously sending INVs at the maximum\n+ *  rate (by our own policy, see INVENTORY_BROADCAST_PER_SECOND) for several minutes, while not receiving\n+ *  the actual transaction (from any peer) in response to requests for them. */\n+static constexpr int32_t MAX_PEER_TX_ANNOUNCEMENTS = 5000;\n /** How many microseconds to delay requesting transactions via txids, if we have wtxid-relaying peers */\n static constexpr std::chrono::microseconds TXID_RELAY_DELAY{std::chrono::seconds{2}};\n-/** How many microseconds to delay requesting transactions from inbound peers */\n-static constexpr std::chrono::microseconds INBOUND_PEER_TX_DELAY{std::chrono::seconds{2}};\n+/** How many microseconds to delay requesting transactions from non-preferred peers */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498985400",
      "id" : 498985400,
      "in_reply_to_id" : 498742352,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NTQwMA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 84,
      "original_position" : 19,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 501359511,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498985400",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498985451"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498985451"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T18:30:32Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo entries exist with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+\n+            // Looking up the last ByTxHash entry with the given txhash must return an Entry with that txhash or the\n+            // multi_index is very bad.\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{item.first, State::TOO_LARGE, 0}));\n+            assert(it_last != m_index.get<ByTxHash>().end() && it_last->m_txhash == item.first);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+\n+private:\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txhash that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txhash already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = m_computer(*std::prev(it));\n+            uint64_t priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in\n+            // the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Entry for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED entries.\n+\n+        // If this Entry's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Entry's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txhash, they are\n+     *  deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+     *  CANDIDATE_BEST. Returns whether the Entry still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED entry for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the entry COMPLETED, and select the next best entry (the first CANDIDATE_READY) if needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to EntryTxHashExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(EntryPeerExtractor(), std::less<EntryPeer>()),\n+            boost::make_tuple(EntryTxHashExtractor(m_computer), std::less<EntryTxHash>()),\n+            boost::make_tuple(EntryTimeExtractor(), std::less<EntryTime>())\n+        )) {}\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxHashExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+            // CANDIDATE_BEST, or delete all of a txhash's entries if no non-COMPLETED ones are left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(EntryTxHash{txhash, State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST entry for this (txhash, peer) combination. The case where\n+        // there is a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+        // automatically.\n+        if (m_index.get<ByPeer>().count(EntryPeer{peer, true, gtxid.GetHash()})) return;\n+\n+        // Find last entry for this txhash, and extract per-txhash information from it.\n+        Iter<ByTxHash> it_last = m_index.get<ByTxHash>().end();\n+        // First find the first entry past this txhash.\n+        it_last = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0});\n+        if (it_last != m_index.get<ByTxHash>().begin() && std::prev(it_last)->m_txhash == gtxid.GetHash()) {\n+            it_last--;\n+        } else {\n+            // No entry for this txhash exists yet.\n+            it_last = m_index.get<ByTxHash>().end();\n+        }\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498985451",
      "id" : 498985451,
      "in_reply_to_id" : 498746033,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NTQ1MQ==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 565,
      "original_position" : 547,
      "original_start_line" : 537,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 501359590,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498985451",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498985556"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498985556"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T18:30:45Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo entries exist with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+\n+            // Looking up the last ByTxHash entry with the given txhash must return an Entry with that txhash or the\n+            // multi_index is very bad.\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{item.first, State::TOO_LARGE, 0}));\n+            assert(it_last != m_index.get<ByTxHash>().end() && it_last->m_txhash == item.first);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+\n+private:\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txhash that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txhash already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = m_computer(*std::prev(it));\n+            uint64_t priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in\n+            // the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Entry for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED entries.\n+\n+        // If this Entry's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Entry's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txhash, they are\n+     *  deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+     *  CANDIDATE_BEST. Returns whether the Entry still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED entry for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the entry COMPLETED, and select the next best entry (the first CANDIDATE_READY) if needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to EntryTxHashExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(EntryPeerExtractor(), std::less<EntryPeer>()),\n+            boost::make_tuple(EntryTxHashExtractor(m_computer), std::less<EntryTxHash>()),\n+            boost::make_tuple(EntryTimeExtractor(), std::less<EntryTime>())\n+        )) {}\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxHashExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+            // CANDIDATE_BEST, or delete all of a txhash's entries if no non-COMPLETED ones are left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(EntryTxHash{txhash, State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST entry for this (txhash, peer) combination. The case where\n+        // there is a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498985556",
      "id" : 498985556,
      "in_reply_to_id" : 498746475,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NTU1Ng==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 533,
      "original_position" : 533,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 501359709,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498985556",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498985679"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498985679"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done (also for RequestedTx).",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T18:31:00Z",
      "diff_hunk" : "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction. Note that this only works\n+ *              per txhash, so if the same transaction is announced both through txid and wtxid, we have no means\n+ *              to prevent fetching both (the caller can however mitigate this by delaying one, see further).\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten only:\n+ *   - If a peer goes offline, all its announcements are forgotten.\n+ *   - If a transaction has been successfully received, or is otherwise no longer needed, the caller can call\n+ *     ForgetTxHash, which removes all announcements across all peers with the specified txhash.\n+ *   - If for a given txhash only already-requested announcements remain, they are all forgotten.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening transaction censoring attacks. The flip side is that as long as an attacker manages\n+ *              to prevent us from receiving a transaction, failed announcements (including those from honest peers)\n+ *              will linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a\n+ *              cap on the number of tracked announcements per peer. As failed requests in response to announcements\n+ *              from honest peers should be rare, this almost solely hinders attackers.\n+ *              Transaction censoring attacks can be done by announcing transactions quickly while not answering\n+ *              requests for them. See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more\n+ *              information.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable the calling code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers are more trusted by us, so are less likely to be under attacker control.\n+ *\n+ *   - Pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: random assignments are hard to influence for attackers.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and minimizing\n+ * susceptibility to censorship attacks. An attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one preferred connection).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution). The \"1 +\" is due to the fact that the\n+ *   attacker can be the first to announce through a preferred connection in this scenario, which very likely means\n+ *   they get the first request.\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh>=1\n+ *   are honest, where we assume that the attacker can disconnect and reconnect those connections, the distribution\n+ *   becomes k ~ P + NB(p=1-NP/NPh,r=1) (where NB stands for Negative Binomial distribution), which has mean\n+ *   P-1+NP/NPh.\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, and a NOTFOUND or a\n+    //   transaction was received in response (valid or not), or they timed out. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DisconnectedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash (both txid and wtxid ones).\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it.\n+     */\n+    void ForgetTxHash(const uint256& txhash);\n+\n+    /** Adds a new CANDIDATE announcement.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that the txid/wtxid property is ignored for determining uniqueness, so if an announcement\n+     * is added for a wtxid H, while one for txid H from the same peer already exists, it will be ignored. This is\n+     * harmless as the txhashes being equal implies it is a non-segwit transaction, so it doesn't matter how it is\n+     * fetched. The new announcement is given the specified preferred and reqtime values, and takes it is_wtxid from\n+     * the specified gtxid.\n+     */\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime);\n+\n+    /** Converts the CANDIDATE announcement for the provided peer and gtxid into a REQUESTED one.\n+     *\n+     * Expiry is set to the specified value. This can ONLY be called immediately after GetRequestable was called\n+     * (for the same peer), with only ForgetTx and other RequestedTx calls (both for other txhashes) in\n+     * between. Any other non-const operation removes the ability to call RequestedTx.\n+     */\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds expiry);\n+\n+    /** Converts any CANDIDATE or REQUESTED announcement to a COMPLETED one, if one exists.\n+     *\n+     * It should be called whenever a transaction or NOTFOUND was received from a peer. When a good transaction is\n+     * received, ForgetTx should be called instead of (or in addition to) this operation.\n+     */\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498985679",
      "id" : 498985679,
      "in_reply_to_id" : 498772237,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NTY3OQ==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 158,
      "original_position" : 158,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 501359866,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498985679",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498985836"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498985836"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Added a comment.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T18:31:19Z",
      "diff_hunk" : "@@ -4544,67 +4446,19 @@ bool PeerManager::SendMessages(CNode* pto)\n         //\n         // Message: getdata (non-blocks)\n         //\n-\n-        // For robustness, expire old requests after a long timeout, so that\n-        // we can resume downloading transactions from a peer even if they\n-        // were unresponsive in the past.\n-        // Eventually we should consider disconnecting peers, but this is\n-        // conservative.\n-        if (state.m_tx_download.m_check_expiry_timer <= current_time) {\n-            for (auto it=state.m_tx_download.m_tx_in_flight.begin(); it != state.m_tx_download.m_tx_in_flight.end();) {\n-                if (it->second <= current_time - TX_EXPIRY_INTERVAL) {\n-                    LogPrint(BCLog::NET, \"timeout of inflight tx %s from peer=%d\\n\", it->first.ToString(), pto->GetId());\n-                    state.m_tx_download.m_tx_announced.erase(it->first);\n-                    state.m_tx_download.m_tx_in_flight.erase(it++);\n-                } else {\n-                    ++it;\n-                }\n-            }\n-            // On average, we do this check every TX_EXPIRY_INTERVAL. Randomize\n-            // so that we're not doing this for all peers at the same time.\n-            state.m_tx_download.m_check_expiry_timer = current_time + TX_EXPIRY_INTERVAL / 2 + GetRandMicros(TX_EXPIRY_INTERVAL);\n-        }\n-\n-        auto& tx_process_time = state.m_tx_download.m_tx_process_time;\n-        while (!tx_process_time.empty() && tx_process_time.begin()->first <= current_time && state.m_tx_download.m_tx_in_flight.size() < MAX_PEER_TX_IN_FLIGHT) {\n-            const GenTxid gtxid = tx_process_time.begin()->second;\n-            // Erase this entry from tx_process_time (it may be added back for\n-            // processing at a later time, see below)\n-            tx_process_time.erase(tx_process_time.begin());\n+        for (const GenTxid& gtxid : m_txrequest.GetRequestable(pto->GetId(), current_time)) {\n             CInv inv(gtxid.IsWtxid() ? MSG_WTX : (MSG_TX | GetFetchFlags(*pto)), gtxid.GetHash());\n-            if (!AlreadyHaveTx(ToGenTxid(inv), m_mempool)) {\n-                // If this transaction was last requested more than 1 minute ago,\n-                // then request.\n-                const auto last_request_time = GetTxRequestTime(gtxid);\n-                if (last_request_time <= current_time - GETDATA_TX_INTERVAL) {\n-                    LogPrint(BCLog::NET, \"Requesting %s peer=%d\\n\", inv.ToString(), pto->GetId());\n-                    vGetData.push_back(inv);\n-                    if (vGetData.size() >= MAX_GETDATA_SZ) {\n-                        m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n-                        vGetData.clear();\n-                    }\n-                    UpdateTxRequestTime(gtxid, current_time);\n-                    state.m_tx_download.m_tx_in_flight.emplace(gtxid.GetHash(), current_time);\n-                } else {\n-                    // This transaction is in flight from someone else; queue\n-                    // up processing to happen after the download times out\n-                    // (with a slight delay for inbound peers, to prefer\n-                    // requests to outbound peers).\n-                    // Don't apply the txid-delay to re-requests of a\n-                    // transaction; the heuristic of delaying requests to\n-                    // txid-relay peers is to save bandwidth on initial\n-                    // announcement of a transaction, and doesn't make sense\n-                    // for a followup request if our first peer times out (and\n-                    // would open us up to an attacker using inbound\n-                    // wtxid-relay to prevent us from requesting transactions\n-                    // from outbound txid-relay peers).\n-                    const auto next_process_time = CalculateTxGetDataTime(gtxid, current_time, !state.fPreferredDownload, false);\n-                    tx_process_time.emplace(next_process_time, gtxid);\n+            if (!AlreadyHaveTx(gtxid, m_mempool)) {\n+                LogPrint(BCLog::NET, \"Requesting %s peer=%d\\n\", inv.ToString(), pto->GetId());\n+                vGetData.push_back(inv);\n+                if (vGetData.size() >= MAX_GETDATA_SZ) {\n+                    m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n+                    vGetData.clear();\n                 }\n+                m_txrequest.RequestedTx(pto->GetId(), gtxid, current_time + GETDATA_TX_INTERVAL);\n             } else {\n                 // We have already seen this transaction, no need to download.\n-                state.m_tx_download.m_tx_announced.erase(gtxid.GetHash());\n-                state.m_tx_download.m_tx_in_flight.erase(gtxid.GetHash());\n+                m_txrequest.ForgetTxHash(gtxid.GetHash());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498985836",
      "id" : 498985836,
      "in_reply_to_id" : 498775868,
      "line" : 4471,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NTgzNg==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 4471,
      "original_position" : 528,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 548,
      "pull_request_review_id" : 501360074,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498985836",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498985911"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498985911"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Indeed! Done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T18:31:29Z",
      "diff_hunk" : "@@ -4544,67 +4446,19 @@ bool PeerManager::SendMessages(CNode* pto)\n         //\n         // Message: getdata (non-blocks)\n         //\n-\n-        // For robustness, expire old requests after a long timeout, so that\n-        // we can resume downloading transactions from a peer even if they\n-        // were unresponsive in the past.\n-        // Eventually we should consider disconnecting peers, but this is\n-        // conservative.\n-        if (state.m_tx_download.m_check_expiry_timer <= current_time) {\n-            for (auto it=state.m_tx_download.m_tx_in_flight.begin(); it != state.m_tx_download.m_tx_in_flight.end();) {\n-                if (it->second <= current_time - TX_EXPIRY_INTERVAL) {\n-                    LogPrint(BCLog::NET, \"timeout of inflight tx %s from peer=%d\\n\", it->first.ToString(), pto->GetId());\n-                    state.m_tx_download.m_tx_announced.erase(it->first);\n-                    state.m_tx_download.m_tx_in_flight.erase(it++);\n-                } else {\n-                    ++it;\n-                }\n-            }\n-            // On average, we do this check every TX_EXPIRY_INTERVAL. Randomize\n-            // so that we're not doing this for all peers at the same time.\n-            state.m_tx_download.m_check_expiry_timer = current_time + TX_EXPIRY_INTERVAL / 2 + GetRandMicros(TX_EXPIRY_INTERVAL);\n-        }\n-\n-        auto& tx_process_time = state.m_tx_download.m_tx_process_time;\n-        while (!tx_process_time.empty() && tx_process_time.begin()->first <= current_time && state.m_tx_download.m_tx_in_flight.size() < MAX_PEER_TX_IN_FLIGHT) {\n-            const GenTxid gtxid = tx_process_time.begin()->second;\n-            // Erase this entry from tx_process_time (it may be added back for\n-            // processing at a later time, see below)\n-            tx_process_time.erase(tx_process_time.begin());\n+        for (const GenTxid& gtxid : m_txrequest.GetRequestable(pto->GetId(), current_time)) {\n             CInv inv(gtxid.IsWtxid() ? MSG_WTX : (MSG_TX | GetFetchFlags(*pto)), gtxid.GetHash());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498985911",
      "id" : 498985911,
      "in_reply_to_id" : 498779231,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NTkxMQ==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 4450,
      "original_position" : 487,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 501360170,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498985911",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498986149"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498986149"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'll do some benchmarks.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T18:31:55Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo entries exist with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+\n+            // Looking up the last ByTxHash entry with the given txhash must return an Entry with that txhash or the\n+            // multi_index is very bad.\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{item.first, State::TOO_LARGE, 0}));\n+            assert(it_last != m_index.get<ByTxHash>().end() && it_last->m_txhash == item.first);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+\n+private:\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txhash that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txhash already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = m_computer(*std::prev(it));\n+            uint64_t priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in\n+            // the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Entry for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED entries.\n+\n+        // If this Entry's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Entry's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txhash, they are\n+     *  deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+     *  CANDIDATE_BEST. Returns whether the Entry still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED entry for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the entry COMPLETED, and select the next best entry (the first CANDIDATE_READY) if needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to EntryTxHashExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(EntryPeerExtractor(), std::less<EntryPeer>()),\n+            boost::make_tuple(EntryTxHashExtractor(m_computer), std::less<EntryTxHash>()),\n+            boost::make_tuple(EntryTimeExtractor(), std::less<EntryTime>())\n+        )) {}\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxHashExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+            // CANDIDATE_BEST, or delete all of a txhash's entries if no non-COMPLETED ones are left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(EntryTxHash{txhash, State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST entry for this (txhash, peer) combination. The case where\n+        // there is a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+        // automatically.\n+        if (m_index.get<ByPeer>().count(EntryPeer{peer, true, gtxid.GetHash()})) return;\n+\n+        // Find last entry for this txhash, and extract per-txhash information from it.\n+        Iter<ByTxHash> it_last = m_index.get<ByTxHash>().end();\n+        // First find the first entry past this txhash.\n+        it_last = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0});\n+        if (it_last != m_index.get<ByTxHash>().begin() && std::prev(it_last)->m_txhash == gtxid.GetHash()) {\n+            it_last--;\n+        } else {\n+            // No entry for this txhash exists yet.\n+            it_last = m_index.get<ByTxHash>().end();\n+        }\n+\n+        // Try creating the entry with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST entry already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_sequence);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+    }\n+\n+    //! Find the GenTxids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now)\n+    {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498986149",
      "id" : 498986149,
      "in_reply_to_id" : 498781706,
      "line" : 579,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NjE0OQ==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 579,
      "original_position" : 561,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 579,
      "pull_request_review_id" : 501360470,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498986149",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498986306"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498986306"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Added a `SequenceNumber` and `Priority` type alias for uint64_t.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T18:32:16Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498986306",
      "id" : 498986306,
      "in_reply_to_id" : 498783476,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NjMwNg==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 64,
      "original_position" : 64,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 501360669,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498986306",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498987047"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498987047"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yeah, the reason is that we want to sort by sequence number, but those aren't included in the output itself, so we need some kind of proxy. It could be a list of (sequence, gtxid) pairs that are sorted, but that would still require an extraction step to convert it to just gtxids. This seems simplest.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T18:33:46Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo entries exist with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+\n+            // Looking up the last ByTxHash entry with the given txhash must return an Entry with that txhash or the\n+            // multi_index is very bad.\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{item.first, State::TOO_LARGE, 0}));\n+            assert(it_last != m_index.get<ByTxHash>().end() && it_last->m_txhash == item.first);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+\n+private:\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txhash that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txhash already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = m_computer(*std::prev(it));\n+            uint64_t priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in\n+            // the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Entry for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED entries.\n+\n+        // If this Entry's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Entry's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txhash, they are\n+     *  deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+     *  CANDIDATE_BEST. Returns whether the Entry still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED entry for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the entry COMPLETED, and select the next best entry (the first CANDIDATE_READY) if needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to EntryTxHashExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(EntryPeerExtractor(), std::less<EntryPeer>()),\n+            boost::make_tuple(EntryTxHashExtractor(m_computer), std::less<EntryTxHash>()),\n+            boost::make_tuple(EntryTimeExtractor(), std::less<EntryTime>())\n+        )) {}\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxHashExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+            // CANDIDATE_BEST, or delete all of a txhash's entries if no non-COMPLETED ones are left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(EntryTxHash{txhash, State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST entry for this (txhash, peer) combination. The case where\n+        // there is a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+        // automatically.\n+        if (m_index.get<ByPeer>().count(EntryPeer{peer, true, gtxid.GetHash()})) return;\n+\n+        // Find last entry for this txhash, and extract per-txhash information from it.\n+        Iter<ByTxHash> it_last = m_index.get<ByTxHash>().end();\n+        // First find the first entry past this txhash.\n+        it_last = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0});\n+        if (it_last != m_index.get<ByTxHash>().begin() && std::prev(it_last)->m_txhash == gtxid.GetHash()) {\n+            it_last--;\n+        } else {\n+            // No entry for this txhash exists yet.\n+            it_last = m_index.get<ByTxHash>().end();\n+        }\n+\n+        // Try creating the entry with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST entry already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_sequence);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+    }\n+\n+    //! Find the GenTxids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now)\n+    {\n+        // Move time.\n+        SetTimePoint(now);\n+\n+        // Find all CANDIDATE_BEST entries for this peer.\n+        std::vector<std::pair<uint64_t, const Entry*>> selected;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498987047",
      "id" : 498987047,
      "in_reply_to_id" : 498784855,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4NzA0Nw==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 566,
      "original_position" : 566,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 501361613,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498987047",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498987967"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498987967"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done, renamed a few things:\r\n* Entry -> Announcement\r\n* Entry{TxHash,Peer,Time} -> By{TxHash,Peer,Time}View\r\n* Entry{TxHash,Peer,Time}Extractor -> By{TxHash,Peer,Time}ViewExtractor\r\n\r\nNo more \"entr\" anywhere in txrequest (I did not make the same change in the fuzz test, though).",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T18:35:36Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498987967",
      "id" : 498987967,
      "in_reply_to_id" : 498788277,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4Nzk2Nw==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 56,
      "original_position" : 56,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 501362772,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498987967",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498988308"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498988308"
         }
      },
      "author_association" : "MEMBER",
      "body" : "State::COMPLETED. That doesn't just cover failure, but there is no observable difference between failed and otherwise completed announcements.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T18:36:25Z",
      "diff_hunk" : "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498988308",
      "id" : 498988308,
      "in_reply_to_id" : 498825108,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4ODMwOA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 33,
      "original_position" : 32,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 501363256,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498988308",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498988383"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498988383"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Gone.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T18:36:35Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo entries exist with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+\n+            // Looking up the last ByTxHash entry with the given txhash must return an Entry with that txhash or the\n+            // multi_index is very bad.\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{item.first, State::TOO_LARGE, 0}));\n+            assert(it_last != m_index.get<ByTxHash>().end() && it_last->m_txhash == item.first);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+\n+private:\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txhash that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txhash already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = m_computer(*std::prev(it));\n+            uint64_t priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in\n+            // the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Entry for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED entries.\n+\n+        // If this Entry's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Entry's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txhash, they are\n+     *  deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+     *  CANDIDATE_BEST. Returns whether the Entry still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED entry for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the entry COMPLETED, and select the next best entry (the first CANDIDATE_READY) if needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to EntryTxHashExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(EntryPeerExtractor(), std::less<EntryPeer>()),\n+            boost::make_tuple(EntryTxHashExtractor(m_computer), std::less<EntryTxHash>()),\n+            boost::make_tuple(EntryTimeExtractor(), std::less<EntryTime>())\n+        )) {}\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxHashExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+            // CANDIDATE_BEST, or delete all of a txhash's entries if no non-COMPLETED ones are left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(EntryTxHash{txhash, State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST entry for this (txhash, peer) combination. The case where\n+        // there is a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+        // automatically.\n+        if (m_index.get<ByPeer>().count(EntryPeer{peer, true, gtxid.GetHash()})) return;\n+\n+        // Find last entry for this txhash, and extract per-txhash information from it.\n+        Iter<ByTxHash> it_last = m_index.get<ByTxHash>().end();\n+        // First find the first entry past this txhash.\n+        it_last = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0});\n+        if (it_last != m_index.get<ByTxHash>().begin() && std::prev(it_last)->m_txhash == gtxid.GetHash()) {\n+            it_last--;\n+        } else {\n+            // No entry for this txhash exists yet.\n+            it_last = m_index.get<ByTxHash>().end();\n+        }\n+\n+        // Try creating the entry with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST entry already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_sequence);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+    }\n+\n+    //! Find the GenTxids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now)\n+    {\n+        // Move time.\n+        SetTimePoint(now);\n+\n+        // Find all CANDIDATE_BEST entries for this peer.\n+        std::vector<std::pair<uint64_t, const Entry*>> selected;\n+        auto it_peer = m_index.get<ByPeer>().lower_bound(EntryPeer{peer, true, UINT256_ZERO});\n+        while (it_peer != m_index.get<ByPeer>().end() && it_peer->m_peer == peer &&\n+            it_peer->GetState() == State::CANDIDATE_BEST) {\n+            selected.emplace_back(it_peer->m_sequence, &*it_peer);\n+            ++it_peer;\n+        }\n+\n+        // Return them, sorted by sequence number.\n+        std::sort(selected.begin(), selected.end());\n+        std::vector<GenTxid> ret;\n+        for (const auto& item : selected) {\n+            ret.emplace_back(item.second->m_is_wtxid, item.second->m_txhash);\n+        }\n+        return ret;\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds expiry)\n+    {\n+        auto it = m_index.get<ByPeer>().find(EntryPeer{peer, true, gtxid.GetHash()});\n+        // RequestedTx can only be called on CANDIDATE_BEST entries (this is implied by its condition that it can\n+        // only be called on GenTxids returned by GetRequestable (and only AlreadyHave and RequestedTx can be called\n+        // in between, which preserve the state of other GenTxids).\n+        assert(it != m_index.get<ByPeer>().end());\n+        assert(it->GetState() == State::CANDIDATE_BEST);\n+        Modify<ByPeer>(it, [expiry](Entry& entry) {\n+            entry.SetState(State::REQUESTED);\n+            entry.m_time = expiry;\n+        });\n+\n+        // Update the per-txhash data (of the last Entry for this txhash) to reflect that new ones are no longer\n+        // eligible for the \"first\" marker.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498988383",
      "id" : 498988383,
      "in_reply_to_id" : 498825307,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4ODM4Mw==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 597,
      "original_position" : 597,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 501363345,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498988383",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498991644"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498991644"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done (and in a few more places).",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T18:44:01Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo entries exist with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+\n+            // Looking up the last ByTxHash entry with the given txhash must return an Entry with that txhash or the\n+            // multi_index is very bad.\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{item.first, State::TOO_LARGE, 0}));\n+            assert(it_last != m_index.get<ByTxHash>().end() && it_last->m_txhash == item.first);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+\n+private:\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txhash that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txhash already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = m_computer(*std::prev(it));\n+            uint64_t priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        if (it->IsSelected()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r498991644",
      "id" : 498991644,
      "in_reply_to_id" : 498758268,
      "line" : 428,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk5MTY0NA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 428,
      "original_position" : 404,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 428,
      "pull_request_review_id" : 501367665,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498991644",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499015363"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499015363"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Here is the patch to make `RequestedTx` fully specified:\r\n\r\n```patch\r\ndiff --git a/src/txrequest.cpp b/src/txrequest.cpp\r\nindex af4b59755b..581b498180 100644\r\n--- a/src/txrequest.cpp\r\n+++ b/src/txrequest.cpp\r\n@@ -590,11 +590,29 @@ public:\r\n     void RequestedTx(NodeId peer, const uint256& txhash, std::chrono::microseconds expiry)\r\n     {\r\n         auto it = m_index.get<ByPeer>().find(ByPeerView{peer, true, txhash});\r\n-        // RequestedTx can only be called on CANDIDATE_BEST announcements (this is implied by its condition that it\r\n-        // can only be called on GenTxids returned by GetRequestable (and only ForgetTxHash and RequestedTx can be\r\n-        // called in between, which preserve the state of other GenTxids).\r\n-        assert(it != m_index.get<ByPeer>().end());\r\n-        assert(it->GetState() == State::CANDIDATE_BEST);\r\n+        if (it == m_index.get<ByPeer>().end()) {\r\n+            // There is no CANDIDATE_BEST entry, look for _READY or _DELAYED instead.\r\n+            it = m_index.get<ByPeer>().find(ByPeerView{peer, false, txhash});\r\n+            if (it == m_index.get<ByPeer>().end() || (it->GetState() != State::CANDIDATE_DELAYED &&\r\n+                it->GetState() != State::CANDIDATE_READY)) {\r\n+                // There is no CANDIDATE_* entry at all, give up.\r\n+                return;\r\n+            }\r\n+\r\n+            // Look for an existing CANDIDATE_BEST to demote to _READY, or REQUESTED to make COMPLETED.\r\n+            auto it_old = m_index.get<ByTxHash>().lower_bound(ByTxHashView{txhash, State::CANDIDATE_BEST, 0});\r\n+            if (it_old != m_index.get<ByTxHash>().end() && it_old->m_txhash == txhash) {\r\n+                if (it_old->GetState() == State::CANDIDATE_BEST) {\r\n+                    // It doesn't matter whether we pick CANDIDATE_READY or _DELAYED here, as SetTimePoint()\r\n+                    // will correct it at GetRequestable() time. If time only goes forward, it will always be\r\n+                    // _READY, so pick that to avoid extra work in SetTimePoint().\r\n+                    Modify<ByTxHash>(it_old, [](Announcement& ann) { ann.SetState(State::CANDIDATE_READY); });\r\n+                } else if (it_old->GetState() == State::REQUESTED) {\r\n+                    Modify<ByTxHash>(it_old, [](Announcement& ann) { ann.SetState(State::COMPLETED); });\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n         Modify<ByPeer>(it, [expiry](Announcement& ann) {\r\n             ann.SetState(State::REQUESTED);\r\n             ann.m_time = expiry;\r\n```\r\n\r\nWhen combined with the corresponding changes in src/test/fuzz/txrequest.cpp it's actually a net reduction in code. WDYT?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-02T19:38:54Z",
      "diff_hunk" : "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction. Note that this only works\n+ *              per txhash, so if the same transaction is announced both through txid and wtxid, we have no means\n+ *              to prevent fetching both (the caller can however mitigate this by delaying one, see further).\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten only:\n+ *   - If a peer goes offline, all its announcements are forgotten.\n+ *   - If a transaction has been successfully received, or is otherwise no longer needed, the caller can call\n+ *     ForgetTxHash, which removes all announcements across all peers with the specified txhash.\n+ *   - If for a given txhash only already-requested announcements remain, they are all forgotten.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening transaction censoring attacks. The flip side is that as long as an attacker manages\n+ *              to prevent us from receiving a transaction, failed announcements (including those from honest peers)\n+ *              will linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a\n+ *              cap on the number of tracked announcements per peer. As failed requests in response to announcements\n+ *              from honest peers should be rare, this almost solely hinders attackers.\n+ *              Transaction censoring attacks can be done by announcing transactions quickly while not answering\n+ *              requests for them. See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more\n+ *              information.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable the calling code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers are more trusted by us, so are less likely to be under attacker control.\n+ *\n+ *   - Pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: random assignments are hard to influence for attackers.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and minimizing\n+ * susceptibility to censorship attacks. An attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one preferred connection).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution). The \"1 +\" is due to the fact that the\n+ *   attacker can be the first to announce through a preferred connection in this scenario, which very likely means\n+ *   they get the first request.\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh>=1\n+ *   are honest, where we assume that the attacker can disconnect and reconnect those connections, the distribution\n+ *   becomes k ~ P + NB(p=1-NP/NPh,r=1) (where NB stands for Negative Binomial distribution), which has mean\n+ *   P-1+NP/NPh.\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, and a NOTFOUND or a\n+    //   transaction was received in response (valid or not), or they timed out. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DisconnectedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash (both txid and wtxid ones).\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it.\n+     */\n+    void ForgetTxHash(const uint256& txhash);\n+\n+    /** Adds a new CANDIDATE announcement.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that the txid/wtxid property is ignored for determining uniqueness, so if an announcement\n+     * is added for a wtxid H, while one for txid H from the same peer already exists, it will be ignored. This is\n+     * harmless as the txhashes being equal implies it is a non-segwit transaction, so it doesn't matter how it is\n+     * fetched. The new announcement is given the specified preferred and reqtime values, and takes it is_wtxid from\n+     * the specified gtxid.\n+     */\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime);\n+\n+    /** Converts the CANDIDATE announcement for the provided peer and gtxid into a REQUESTED one.\n+     *\n+     * Expiry is set to the specified value. This can ONLY be called immediately after GetRequestable was called\n+     * (for the same peer), with only ForgetTx and other RequestedTx calls (both for other txhashes) in\n+     * between. Any other non-const operation removes the ability to call RequestedTx.\n+     */\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds expiry);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499015363",
      "id" : 499015363,
      "in_reply_to_id" : 498734530,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxNTM2Mw==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 151,
      "original_position" : 151,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 501400125,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499015363",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499104292"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499104292"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Not sure what you mean here. There are four paths through the cascade of `if`s here and each value of `config >> 3` selects one of them.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-03T01:39:41Z",
      "diff_hunk" : "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds MIN_TIME = std::chrono::microseconds::min();\n+constexpr std::chrono::microseconds MAX_TIME = std::chrono::microseconds::max();\n+constexpr std::chrono::microseconds MICROSECOND = std::chrono::microseconds{1};\n+constexpr std::chrono::microseconds NO_TIME = std::chrono::microseconds{0};\n+\n+/** An Action is a function to call at a particular (simulated) timestamp. */\n+using Action = std::pair<std::chrono::microseconds, std::function<void()>>;\n+\n+/** Object that stores actions from multiple interleaved scenarios, and data shared across them.\n+ *\n+ * The Scenario below is used to fill this.\n+ */\n+struct Runner\n+{\n+    /** The TxRequestTracker being tested. */\n+    TxRequestTracker txrequest;\n+\n+    /** List of actions to be executed (in order of increasing timestamp). */\n+    std::vector<Action> actions;\n+\n+    /** Which node ids have been assigned already (to prevent reuse). */\n+    std::set<uint64_t> peerset;\n+\n+    /** Which txhashes have been assigned already (to prevent reuse). */\n+    std::set<uint256> txhashset;\n+};\n+\n+std::chrono::microseconds RandomTime(int bits=23) { return std::chrono::microseconds{1 + InsecureRandBits(bits)}; }\n+\n+/** A proxy for a Runner that helps build a sequence of consecutive test actions on a TxRequestTracker.\n+ *\n+ * Multiple Scenarios are used with a single Runner, resulting in interleaved actions.\n+ */\n+class Scenario\n+{\n+    Runner& m_runner;\n+    std::chrono::microseconds m_now;\n+    std::string m_testname;\n+\n+public:\n+    Scenario(Runner& runner, std::chrono::microseconds starttime) : m_runner(runner)\n+    {\n+        m_now = starttime + RandomTime() + RandomTime() + RandomTime();\n+    }\n+\n+    void SetTestName(std::string testname)\n+    {\n+        m_testname = std::move(testname);\n+    }\n+\n+    void AdvanceTime(std::chrono::microseconds amount)\n+    {\n+        assert(amount.count() >= 0);\n+        m_now += amount;\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ForgetTxHash(txhash);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool pref, std::chrono::microseconds reqtime = MIN_TIME)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedInv(peer, gtxid, pref, reqtime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.DisconnectedPeer(peer);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds exptime)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.RequestedTx(peer, gtxid, exptime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedResponse(peer, gtxid);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void Check(uint64_t peer, const std::vector<GenTxid>& expected, size_t candidates, size_t inflight,\n+        size_t completed, const std::string& checkname = \"\")\n+    {\n+        const auto comment = m_testname + \" \" + checkname;\n+        auto& runner = m_runner;\n+        const auto now = m_now;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            auto ret = runner.txrequest.GetRequestable(peer, now);\n+            runner.txrequest.SanityCheck();\n+            runner.txrequest.PostGetRequestableSanityCheck(now);\n+            size_t total = candidates + inflight + completed;\n+            size_t real_total = runner.txrequest.Count(peer);\n+            size_t real_candidates = runner.txrequest.CountCandidates(peer);\n+            size_t real_inflight = runner.txrequest.CountInFlight(peer);\n+            BOOST_CHECK_MESSAGE(real_total == total, strprintf(\"[\" + comment + \"] total %i (%i expected)\", real_total, total));\n+            BOOST_CHECK_MESSAGE(real_inflight == inflight, strprintf(\"[\" + comment + \"] inflight %i (%i expected)\", real_inflight, inflight));\n+            BOOST_CHECK_MESSAGE(real_candidates == candidates, strprintf(\"[\" + comment + \"] candidates %i (%i expected)\", real_candidates, candidates));\n+            BOOST_CHECK_MESSAGE(ret == expected, \"[\" + comment + \"] mismatching requestables\");\n+        });\n+    }\n+\n+    uint256 NewTxHash(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        uint256 ret;\n+        bool ok;\n+        do {\n+            ret = InsecureRand256();\n+            ok = true;\n+            for (const auto& order : orders) {\n+                for (size_t pos = 1; pos < order.size(); ++pos) {\n+                    uint64_t prio_prev = m_runner.txrequest.ComputePriority(ret, order[pos - 1], true);\n+                    uint64_t prio_cur = m_runner.txrequest.ComputePriority(ret, order[pos], true);\n+                    if (prio_prev >= prio_cur) {\n+                        ok = false;\n+                        break;\n+                    }\n+                }\n+                if (!ok) break;\n+            }\n+            if (ok) {\n+                ok = m_runner.txhashset.insert(ret).second;\n+            }\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    GenTxid NewGTxid(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        return {InsecureRandBool(), NewTxHash(orders)};\n+    }\n+\n+    uint64_t NewPeer()\n+    {\n+        bool ok;\n+        uint64_t ret;\n+        do {\n+            ret = InsecureRandBits(63);\n+            ok = m_runner.peerset.insert(ret).second;\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    std::chrono::microseconds Now() const { return m_now; }\n+};\n+\n+/** Add to scenario a test with a single tx announced by a single peer.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildSingleTest(Scenario& scenario, int config)\n+{\n+    auto peer = scenario.NewPeer();\n+    auto gtxid = scenario.NewGTxid();\n+    bool immediate = config & 1;\n+    bool preferred = config & 2;\n+    auto delay = immediate ? NO_TIME : RandomTime();\n+\n+    scenario.SetTestName(strprintf(\"Single(config=%i)\", config));\n+\n+    // Receive an announcement, either immediately requestable or delayed.\n+    scenario.ReceivedInv(peer, gtxid, preferred, immediate ? MIN_TIME : scenario.Now() + delay);\n+    if (immediate) {\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s1\");\n+    } else {\n+        scenario.Check(peer, {}, 1, 0, 0, \"s2\");\n+        scenario.AdvanceTime(delay - MICROSECOND);\n+        scenario.Check(peer, {}, 1, 0, 0, \"s3\");\n+        scenario.AdvanceTime(MICROSECOND);\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s4\");\n+    }\n+\n+    if (config >> 3) { // We'll request the transaction\n+        scenario.AdvanceTime(RandomTime());\n+        auto expiry = RandomTime();\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s5\");\n+        scenario.RequestedTx(peer, gtxid, scenario.Now() + expiry);\n+        scenario.Check(peer, {}, 0, 1, 0, \"s6\");\n+\n+        if ((config >> 3) == 1) { // The request will time out",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499104292",
      "id" : 499104292,
      "in_reply_to_id" : 498972630,
      "line" : 250,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwNDI5Mg==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 250,
      "original_position" : 220,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : 250,
      "pull_request_review_id" : 501511014,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499104292",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499105668"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499105668"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Turned it into a config bit.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-03T01:57:14Z",
      "diff_hunk" : "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds MIN_TIME = std::chrono::microseconds::min();\n+constexpr std::chrono::microseconds MAX_TIME = std::chrono::microseconds::max();\n+constexpr std::chrono::microseconds MICROSECOND = std::chrono::microseconds{1};\n+constexpr std::chrono::microseconds NO_TIME = std::chrono::microseconds{0};\n+\n+/** An Action is a function to call at a particular (simulated) timestamp. */\n+using Action = std::pair<std::chrono::microseconds, std::function<void()>>;\n+\n+/** Object that stores actions from multiple interleaved scenarios, and data shared across them.\n+ *\n+ * The Scenario below is used to fill this.\n+ */\n+struct Runner\n+{\n+    /** The TxRequestTracker being tested. */\n+    TxRequestTracker txrequest;\n+\n+    /** List of actions to be executed (in order of increasing timestamp). */\n+    std::vector<Action> actions;\n+\n+    /** Which node ids have been assigned already (to prevent reuse). */\n+    std::set<uint64_t> peerset;\n+\n+    /** Which txhashes have been assigned already (to prevent reuse). */\n+    std::set<uint256> txhashset;\n+};\n+\n+std::chrono::microseconds RandomTime(int bits=23) { return std::chrono::microseconds{1 + InsecureRandBits(bits)}; }\n+\n+/** A proxy for a Runner that helps build a sequence of consecutive test actions on a TxRequestTracker.\n+ *\n+ * Multiple Scenarios are used with a single Runner, resulting in interleaved actions.\n+ */\n+class Scenario\n+{\n+    Runner& m_runner;\n+    std::chrono::microseconds m_now;\n+    std::string m_testname;\n+\n+public:\n+    Scenario(Runner& runner, std::chrono::microseconds starttime) : m_runner(runner)\n+    {\n+        m_now = starttime + RandomTime() + RandomTime() + RandomTime();\n+    }\n+\n+    void SetTestName(std::string testname)\n+    {\n+        m_testname = std::move(testname);\n+    }\n+\n+    void AdvanceTime(std::chrono::microseconds amount)\n+    {\n+        assert(amount.count() >= 0);\n+        m_now += amount;\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ForgetTxHash(txhash);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool pref, std::chrono::microseconds reqtime = MIN_TIME)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedInv(peer, gtxid, pref, reqtime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.DisconnectedPeer(peer);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds exptime)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.RequestedTx(peer, gtxid, exptime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedResponse(peer, gtxid);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void Check(uint64_t peer, const std::vector<GenTxid>& expected, size_t candidates, size_t inflight,\n+        size_t completed, const std::string& checkname = \"\")\n+    {\n+        const auto comment = m_testname + \" \" + checkname;\n+        auto& runner = m_runner;\n+        const auto now = m_now;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            auto ret = runner.txrequest.GetRequestable(peer, now);\n+            runner.txrequest.SanityCheck();\n+            runner.txrequest.PostGetRequestableSanityCheck(now);\n+            size_t total = candidates + inflight + completed;\n+            size_t real_total = runner.txrequest.Count(peer);\n+            size_t real_candidates = runner.txrequest.CountCandidates(peer);\n+            size_t real_inflight = runner.txrequest.CountInFlight(peer);\n+            BOOST_CHECK_MESSAGE(real_total == total, strprintf(\"[\" + comment + \"] total %i (%i expected)\", real_total, total));\n+            BOOST_CHECK_MESSAGE(real_inflight == inflight, strprintf(\"[\" + comment + \"] inflight %i (%i expected)\", real_inflight, inflight));\n+            BOOST_CHECK_MESSAGE(real_candidates == candidates, strprintf(\"[\" + comment + \"] candidates %i (%i expected)\", real_candidates, candidates));\n+            BOOST_CHECK_MESSAGE(ret == expected, \"[\" + comment + \"] mismatching requestables\");\n+        });\n+    }\n+\n+    uint256 NewTxHash(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        uint256 ret;\n+        bool ok;\n+        do {\n+            ret = InsecureRand256();\n+            ok = true;\n+            for (const auto& order : orders) {\n+                for (size_t pos = 1; pos < order.size(); ++pos) {\n+                    uint64_t prio_prev = m_runner.txrequest.ComputePriority(ret, order[pos - 1], true);\n+                    uint64_t prio_cur = m_runner.txrequest.ComputePriority(ret, order[pos], true);\n+                    if (prio_prev >= prio_cur) {\n+                        ok = false;\n+                        break;\n+                    }\n+                }\n+                if (!ok) break;\n+            }\n+            if (ok) {\n+                ok = m_runner.txhashset.insert(ret).second;\n+            }\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    GenTxid NewGTxid(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        return {InsecureRandBool(), NewTxHash(orders)};\n+    }\n+\n+    uint64_t NewPeer()\n+    {\n+        bool ok;\n+        uint64_t ret;\n+        do {\n+            ret = InsecureRandBits(63);\n+            ok = m_runner.peerset.insert(ret).second;\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    std::chrono::microseconds Now() const { return m_now; }\n+};\n+\n+/** Add to scenario a test with a single tx announced by a single peer.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildSingleTest(Scenario& scenario, int config)\n+{\n+    auto peer = scenario.NewPeer();\n+    auto gtxid = scenario.NewGTxid();\n+    bool immediate = config & 1;\n+    bool preferred = config & 2;\n+    auto delay = immediate ? NO_TIME : RandomTime();\n+\n+    scenario.SetTestName(strprintf(\"Single(config=%i)\", config));\n+\n+    // Receive an announcement, either immediately requestable or delayed.\n+    scenario.ReceivedInv(peer, gtxid, preferred, immediate ? MIN_TIME : scenario.Now() + delay);\n+    if (immediate) {\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s1\");\n+    } else {\n+        scenario.Check(peer, {}, 1, 0, 0, \"s2\");\n+        scenario.AdvanceTime(delay - MICROSECOND);\n+        scenario.Check(peer, {}, 1, 0, 0, \"s3\");\n+        scenario.AdvanceTime(MICROSECOND);\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s4\");\n+    }\n+\n+    if (config >> 3) { // We'll request the transaction\n+        scenario.AdvanceTime(RandomTime());\n+        auto expiry = RandomTime();\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s5\");\n+        scenario.RequestedTx(peer, gtxid, scenario.Now() + expiry);\n+        scenario.Check(peer, {}, 0, 1, 0, \"s6\");\n+\n+        if ((config >> 3) == 1) { // The request will time out\n+            scenario.AdvanceTime(expiry - MICROSECOND);\n+            scenario.Check(peer, {}, 0, 1, 0, \"s7\");\n+            scenario.AdvanceTime(MICROSECOND);\n+            scenario.Check(peer, {}, 0, 0, 0, \"s8\");\n+            return;\n+        } else {\n+            scenario.AdvanceTime(std::chrono::microseconds{InsecureRandRange(expiry.count())});\n+            scenario.Check(peer, {}, 0, 1, 0, \"s9\");\n+            if ((config >> 3) == 3) { // A reponse will arrive for the transaction\n+                scenario.ReceivedResponse(peer, gtxid);\n+                scenario.Check(peer, {}, 0, 0, 0, \"s10\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    scenario.AdvanceTime(RandomTime());\n+    if (config & 4) { // The peer will go offline\n+        scenario.DisconnectedPeer(peer);\n+    } else { // The transaction is no longer needed\n+        scenario.ForgetTxHash(gtxid.GetHash());\n+    }\n+    scenario.Check(peer, {}, 0, 0, 0, \"s11\");\n+}\n+\n+/** Add to scenario a test with a single tx announced by two peers, to verify the\n+ *  right peer is selected for requests.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildPriorityTest(Scenario& scenario, int config)\n+{\n+    scenario.SetTestName(strprintf(\"Priority(config=%i)\", config));\n+\n+    // Three peers. They will announce in order.\n+    auto peer1 = scenario.NewPeer(), peer2 = scenario.NewPeer();\n+    // Construct a transaction that under random rules would be preferred by peer2 or peer1,\n+    // depending on configuration.\n+    bool prio1 = config & 1;\n+    auto gtxid = prio1 ? scenario.NewGTxid({{peer1, peer2}}) : scenario.NewGTxid({{peer2, peer1}});\n+    bool pref1 = config & 2, pref2 = config & 4;\n+\n+    scenario.ReceivedInv(peer1, gtxid, pref1, MIN_TIME);\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p1\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p2\");\n+\n+    scenario.ReceivedInv(peer2, gtxid, pref2, MIN_TIME);\n+    bool stage2_prio =\n+        // At this point, peer2 will be given priority if:\n+        // - It is preferred and peer1 is not\n+        (pref2 && !pref1) ||\n+        // - They're in the same preference class,\n+        //   and the randomized priority favors peer2 over peer1.\n+        (pref1 == pref2 && !prio1);\n+    uint64_t priopeer = stage2_prio ? peer2 : peer1, otherpeer = stage2_prio ? peer1 : peer2;\n+    scenario.Check(otherpeer, {}, 1, 0, 0, \"p3\");\n+    scenario.Check(priopeer, {gtxid}, 1, 0, 0, \"p4\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(otherpeer, {}, 1, 0, 0, \"p5\");\n+    scenario.Check(priopeer, {gtxid}, 1, 0, 0, \"p6\");\n+\n+    // We possibly request from the selected peer.\n+    if (config & 8) {\n+        scenario.RequestedTx(priopeer, gtxid, MAX_TIME);\n+        scenario.Check(priopeer, {}, 0, 1, 0, \"p7\");\n+        scenario.Check(otherpeer, {}, 1, 0, 0, \"p8\");\n+        if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    }\n+\n+    // The peer which was selected (or requested from) now goes offline, or a NOTFOUND is received from them.\n+    if (config & 16) {\n+        scenario.DisconnectedPeer(priopeer);\n+    } else {\n+        scenario.ReceivedResponse(priopeer, gtxid);\n+    }\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499105668",
      "id" : 499105668,
      "in_reply_to_id" : 498971329,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwNTY2OA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 297,
      "original_position" : 297,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 501512168,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499105668",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499105677"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499105677"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yes.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-03T01:57:24Z",
      "diff_hunk" : "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds MIN_TIME = std::chrono::microseconds::min();\n+constexpr std::chrono::microseconds MAX_TIME = std::chrono::microseconds::max();\n+constexpr std::chrono::microseconds MICROSECOND = std::chrono::microseconds{1};\n+constexpr std::chrono::microseconds NO_TIME = std::chrono::microseconds{0};\n+\n+/** An Action is a function to call at a particular (simulated) timestamp. */\n+using Action = std::pair<std::chrono::microseconds, std::function<void()>>;\n+\n+/** Object that stores actions from multiple interleaved scenarios, and data shared across them.\n+ *\n+ * The Scenario below is used to fill this.\n+ */\n+struct Runner\n+{\n+    /** The TxRequestTracker being tested. */\n+    TxRequestTracker txrequest;\n+\n+    /** List of actions to be executed (in order of increasing timestamp). */\n+    std::vector<Action> actions;\n+\n+    /** Which node ids have been assigned already (to prevent reuse). */\n+    std::set<uint64_t> peerset;\n+\n+    /** Which txhashes have been assigned already (to prevent reuse). */\n+    std::set<uint256> txhashset;\n+};\n+\n+std::chrono::microseconds RandomTime(int bits=23) { return std::chrono::microseconds{1 + InsecureRandBits(bits)}; }\n+\n+/** A proxy for a Runner that helps build a sequence of consecutive test actions on a TxRequestTracker.\n+ *\n+ * Multiple Scenarios are used with a single Runner, resulting in interleaved actions.\n+ */\n+class Scenario\n+{\n+    Runner& m_runner;\n+    std::chrono::microseconds m_now;\n+    std::string m_testname;\n+\n+public:\n+    Scenario(Runner& runner, std::chrono::microseconds starttime) : m_runner(runner)\n+    {\n+        m_now = starttime + RandomTime() + RandomTime() + RandomTime();\n+    }\n+\n+    void SetTestName(std::string testname)\n+    {\n+        m_testname = std::move(testname);\n+    }\n+\n+    void AdvanceTime(std::chrono::microseconds amount)\n+    {\n+        assert(amount.count() >= 0);\n+        m_now += amount;\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ForgetTxHash(txhash);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool pref, std::chrono::microseconds reqtime = MIN_TIME)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedInv(peer, gtxid, pref, reqtime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.DisconnectedPeer(peer);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds exptime)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.RequestedTx(peer, gtxid, exptime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedResponse(peer, gtxid);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void Check(uint64_t peer, const std::vector<GenTxid>& expected, size_t candidates, size_t inflight,\n+        size_t completed, const std::string& checkname = \"\")\n+    {\n+        const auto comment = m_testname + \" \" + checkname;\n+        auto& runner = m_runner;\n+        const auto now = m_now;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            auto ret = runner.txrequest.GetRequestable(peer, now);\n+            runner.txrequest.SanityCheck();\n+            runner.txrequest.PostGetRequestableSanityCheck(now);\n+            size_t total = candidates + inflight + completed;\n+            size_t real_total = runner.txrequest.Count(peer);\n+            size_t real_candidates = runner.txrequest.CountCandidates(peer);\n+            size_t real_inflight = runner.txrequest.CountInFlight(peer);\n+            BOOST_CHECK_MESSAGE(real_total == total, strprintf(\"[\" + comment + \"] total %i (%i expected)\", real_total, total));\n+            BOOST_CHECK_MESSAGE(real_inflight == inflight, strprintf(\"[\" + comment + \"] inflight %i (%i expected)\", real_inflight, inflight));\n+            BOOST_CHECK_MESSAGE(real_candidates == candidates, strprintf(\"[\" + comment + \"] candidates %i (%i expected)\", real_candidates, candidates));\n+            BOOST_CHECK_MESSAGE(ret == expected, \"[\" + comment + \"] mismatching requestables\");\n+        });\n+    }\n+\n+    uint256 NewTxHash(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        uint256 ret;\n+        bool ok;\n+        do {\n+            ret = InsecureRand256();\n+            ok = true;\n+            for (const auto& order : orders) {\n+                for (size_t pos = 1; pos < order.size(); ++pos) {\n+                    uint64_t prio_prev = m_runner.txrequest.ComputePriority(ret, order[pos - 1], true);\n+                    uint64_t prio_cur = m_runner.txrequest.ComputePriority(ret, order[pos], true);\n+                    if (prio_prev >= prio_cur) {\n+                        ok = false;\n+                        break;\n+                    }\n+                }\n+                if (!ok) break;\n+            }\n+            if (ok) {\n+                ok = m_runner.txhashset.insert(ret).second;\n+            }\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    GenTxid NewGTxid(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        return {InsecureRandBool(), NewTxHash(orders)};\n+    }\n+\n+    uint64_t NewPeer()\n+    {\n+        bool ok;\n+        uint64_t ret;\n+        do {\n+            ret = InsecureRandBits(63);\n+            ok = m_runner.peerset.insert(ret).second;\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    std::chrono::microseconds Now() const { return m_now; }\n+};\n+\n+/** Add to scenario a test with a single tx announced by a single peer.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildSingleTest(Scenario& scenario, int config)\n+{\n+    auto peer = scenario.NewPeer();\n+    auto gtxid = scenario.NewGTxid();\n+    bool immediate = config & 1;\n+    bool preferred = config & 2;\n+    auto delay = immediate ? NO_TIME : RandomTime();\n+\n+    scenario.SetTestName(strprintf(\"Single(config=%i)\", config));\n+\n+    // Receive an announcement, either immediately requestable or delayed.\n+    scenario.ReceivedInv(peer, gtxid, preferred, immediate ? MIN_TIME : scenario.Now() + delay);\n+    if (immediate) {\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s1\");\n+    } else {\n+        scenario.Check(peer, {}, 1, 0, 0, \"s2\");\n+        scenario.AdvanceTime(delay - MICROSECOND);\n+        scenario.Check(peer, {}, 1, 0, 0, \"s3\");\n+        scenario.AdvanceTime(MICROSECOND);\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s4\");\n+    }\n+\n+    if (config >> 3) { // We'll request the transaction\n+        scenario.AdvanceTime(RandomTime());\n+        auto expiry = RandomTime();\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s5\");\n+        scenario.RequestedTx(peer, gtxid, scenario.Now() + expiry);\n+        scenario.Check(peer, {}, 0, 1, 0, \"s6\");\n+\n+        if ((config >> 3) == 1) { // The request will time out\n+            scenario.AdvanceTime(expiry - MICROSECOND);\n+            scenario.Check(peer, {}, 0, 1, 0, \"s7\");\n+            scenario.AdvanceTime(MICROSECOND);\n+            scenario.Check(peer, {}, 0, 0, 0, \"s8\");\n+            return;\n+        } else {\n+            scenario.AdvanceTime(std::chrono::microseconds{InsecureRandRange(expiry.count())});\n+            scenario.Check(peer, {}, 0, 1, 0, \"s9\");\n+            if ((config >> 3) == 3) { // A reponse will arrive for the transaction\n+                scenario.ReceivedResponse(peer, gtxid);\n+                scenario.Check(peer, {}, 0, 0, 0, \"s10\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    scenario.AdvanceTime(RandomTime());\n+    if (config & 4) { // The peer will go offline\n+        scenario.DisconnectedPeer(peer);\n+    } else { // The transaction is no longer needed\n+        scenario.ForgetTxHash(gtxid.GetHash());\n+    }\n+    scenario.Check(peer, {}, 0, 0, 0, \"s11\");\n+}\n+\n+/** Add to scenario a test with a single tx announced by two peers, to verify the\n+ *  right peer is selected for requests.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildPriorityTest(Scenario& scenario, int config)\n+{\n+    scenario.SetTestName(strprintf(\"Priority(config=%i)\", config));\n+\n+    // Three peers. They will announce in order.\n+    auto peer1 = scenario.NewPeer(), peer2 = scenario.NewPeer();\n+    // Construct a transaction that under random rules would be preferred by peer2 or peer1,\n+    // depending on configuration.\n+    bool prio1 = config & 1;\n+    auto gtxid = prio1 ? scenario.NewGTxid({{peer1, peer2}}) : scenario.NewGTxid({{peer2, peer1}});\n+    bool pref1 = config & 2, pref2 = config & 4;\n+\n+    scenario.ReceivedInv(peer1, gtxid, pref1, MIN_TIME);\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p1\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499105677",
      "id" : 499105677,
      "in_reply_to_id" : 498967076,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwNTY3Nw==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 265,
      "original_position" : 265,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 501512181,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499105677",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499105712"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499105712"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yeah, I've added some comments.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-03T01:57:41Z",
      "diff_hunk" : "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds MIN_TIME = std::chrono::microseconds::min();\n+constexpr std::chrono::microseconds MAX_TIME = std::chrono::microseconds::max();\n+constexpr std::chrono::microseconds MICROSECOND = std::chrono::microseconds{1};\n+constexpr std::chrono::microseconds NO_TIME = std::chrono::microseconds{0};\n+\n+/** An Action is a function to call at a particular (simulated) timestamp. */\n+using Action = std::pair<std::chrono::microseconds, std::function<void()>>;\n+\n+/** Object that stores actions from multiple interleaved scenarios, and data shared across them.\n+ *\n+ * The Scenario below is used to fill this.\n+ */\n+struct Runner\n+{\n+    /** The TxRequestTracker being tested. */\n+    TxRequestTracker txrequest;\n+\n+    /** List of actions to be executed (in order of increasing timestamp). */\n+    std::vector<Action> actions;\n+\n+    /** Which node ids have been assigned already (to prevent reuse). */\n+    std::set<uint64_t> peerset;\n+\n+    /** Which txhashes have been assigned already (to prevent reuse). */\n+    std::set<uint256> txhashset;\n+};\n+\n+std::chrono::microseconds RandomTime(int bits=23) { return std::chrono::microseconds{1 + InsecureRandBits(bits)}; }\n+\n+/** A proxy for a Runner that helps build a sequence of consecutive test actions on a TxRequestTracker.\n+ *\n+ * Multiple Scenarios are used with a single Runner, resulting in interleaved actions.\n+ */\n+class Scenario\n+{\n+    Runner& m_runner;\n+    std::chrono::microseconds m_now;\n+    std::string m_testname;\n+\n+public:\n+    Scenario(Runner& runner, std::chrono::microseconds starttime) : m_runner(runner)\n+    {\n+        m_now = starttime + RandomTime() + RandomTime() + RandomTime();\n+    }\n+\n+    void SetTestName(std::string testname)\n+    {\n+        m_testname = std::move(testname);\n+    }\n+\n+    void AdvanceTime(std::chrono::microseconds amount)\n+    {\n+        assert(amount.count() >= 0);\n+        m_now += amount;\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ForgetTxHash(txhash);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool pref, std::chrono::microseconds reqtime = MIN_TIME)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedInv(peer, gtxid, pref, reqtime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.DisconnectedPeer(peer);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds exptime)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.RequestedTx(peer, gtxid, exptime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedResponse(peer, gtxid);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void Check(uint64_t peer, const std::vector<GenTxid>& expected, size_t candidates, size_t inflight,\n+        size_t completed, const std::string& checkname = \"\")\n+    {\n+        const auto comment = m_testname + \" \" + checkname;\n+        auto& runner = m_runner;\n+        const auto now = m_now;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            auto ret = runner.txrequest.GetRequestable(peer, now);\n+            runner.txrequest.SanityCheck();\n+            runner.txrequest.PostGetRequestableSanityCheck(now);\n+            size_t total = candidates + inflight + completed;\n+            size_t real_total = runner.txrequest.Count(peer);\n+            size_t real_candidates = runner.txrequest.CountCandidates(peer);\n+            size_t real_inflight = runner.txrequest.CountInFlight(peer);\n+            BOOST_CHECK_MESSAGE(real_total == total, strprintf(\"[\" + comment + \"] total %i (%i expected)\", real_total, total));\n+            BOOST_CHECK_MESSAGE(real_inflight == inflight, strprintf(\"[\" + comment + \"] inflight %i (%i expected)\", real_inflight, inflight));\n+            BOOST_CHECK_MESSAGE(real_candidates == candidates, strprintf(\"[\" + comment + \"] candidates %i (%i expected)\", real_candidates, candidates));\n+            BOOST_CHECK_MESSAGE(ret == expected, \"[\" + comment + \"] mismatching requestables\");\n+        });\n+    }\n+\n+    uint256 NewTxHash(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        uint256 ret;\n+        bool ok;\n+        do {\n+            ret = InsecureRand256();\n+            ok = true;\n+            for (const auto& order : orders) {\n+                for (size_t pos = 1; pos < order.size(); ++pos) {\n+                    uint64_t prio_prev = m_runner.txrequest.ComputePriority(ret, order[pos - 1], true);\n+                    uint64_t prio_cur = m_runner.txrequest.ComputePriority(ret, order[pos], true);\n+                    if (prio_prev >= prio_cur) {\n+                        ok = false;\n+                        break;\n+                    }\n+                }\n+                if (!ok) break;\n+            }\n+            if (ok) {\n+                ok = m_runner.txhashset.insert(ret).second;\n+            }\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    GenTxid NewGTxid(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        return {InsecureRandBool(), NewTxHash(orders)};\n+    }\n+\n+    uint64_t NewPeer()\n+    {\n+        bool ok;\n+        uint64_t ret;\n+        do {\n+            ret = InsecureRandBits(63);\n+            ok = m_runner.peerset.insert(ret).second;\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    std::chrono::microseconds Now() const { return m_now; }\n+};\n+\n+/** Add to scenario a test with a single tx announced by a single peer.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildSingleTest(Scenario& scenario, int config)\n+{\n+    auto peer = scenario.NewPeer();\n+    auto gtxid = scenario.NewGTxid();\n+    bool immediate = config & 1;\n+    bool preferred = config & 2;\n+    auto delay = immediate ? NO_TIME : RandomTime();\n+\n+    scenario.SetTestName(strprintf(\"Single(config=%i)\", config));\n+\n+    // Receive an announcement, either immediately requestable or delayed.\n+    scenario.ReceivedInv(peer, gtxid, preferred, immediate ? MIN_TIME : scenario.Now() + delay);\n+    if (immediate) {\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s1\");\n+    } else {\n+        scenario.Check(peer, {}, 1, 0, 0, \"s2\");\n+        scenario.AdvanceTime(delay - MICROSECOND);\n+        scenario.Check(peer, {}, 1, 0, 0, \"s3\");\n+        scenario.AdvanceTime(MICROSECOND);\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s4\");\n+    }\n+\n+    if (config >> 3) { // We'll request the transaction\n+        scenario.AdvanceTime(RandomTime());\n+        auto expiry = RandomTime();\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s5\");\n+        scenario.RequestedTx(peer, gtxid, scenario.Now() + expiry);\n+        scenario.Check(peer, {}, 0, 1, 0, \"s6\");\n+\n+        if ((config >> 3) == 1) { // The request will time out\n+            scenario.AdvanceTime(expiry - MICROSECOND);\n+            scenario.Check(peer, {}, 0, 1, 0, \"s7\");\n+            scenario.AdvanceTime(MICROSECOND);\n+            scenario.Check(peer, {}, 0, 0, 0, \"s8\");\n+            return;\n+        } else {\n+            scenario.AdvanceTime(std::chrono::microseconds{InsecureRandRange(expiry.count())});\n+            scenario.Check(peer, {}, 0, 1, 0, \"s9\");\n+            if ((config >> 3) == 3) { // A reponse will arrive for the transaction\n+                scenario.ReceivedResponse(peer, gtxid);\n+                scenario.Check(peer, {}, 0, 0, 0, \"s10\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    scenario.AdvanceTime(RandomTime());\n+    if (config & 4) { // The peer will go offline\n+        scenario.DisconnectedPeer(peer);\n+    } else { // The transaction is no longer needed\n+        scenario.ForgetTxHash(gtxid.GetHash());\n+    }\n+    scenario.Check(peer, {}, 0, 0, 0, \"s11\");\n+}\n+\n+/** Add to scenario a test with a single tx announced by two peers, to verify the\n+ *  right peer is selected for requests.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildPriorityTest(Scenario& scenario, int config)\n+{\n+    scenario.SetTestName(strprintf(\"Priority(config=%i)\", config));\n+\n+    // Three peers. They will announce in order.\n+    auto peer1 = scenario.NewPeer(), peer2 = scenario.NewPeer();\n+    // Construct a transaction that under random rules would be preferred by peer2 or peer1,\n+    // depending on configuration.\n+    bool prio1 = config & 1;\n+    auto gtxid = prio1 ? scenario.NewGTxid({{peer1, peer2}}) : scenario.NewGTxid({{peer2, peer1}});\n+    bool pref1 = config & 2, pref2 = config & 4;\n+\n+    scenario.ReceivedInv(peer1, gtxid, pref1, MIN_TIME);\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p1\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p2\");\n+\n+    scenario.ReceivedInv(peer2, gtxid, pref2, MIN_TIME);\n+    bool stage2_prio =\n+        // At this point, peer2 will be given priority if:\n+        // - It is preferred and peer1 is not\n+        (pref2 && !pref1) ||\n+        // - They're in the same preference class,\n+        //   and the randomized priority favors peer2 over peer1.\n+        (pref1 == pref2 && !prio1);\n+    uint64_t priopeer = stage2_prio ? peer2 : peer1, otherpeer = stage2_prio ? peer1 : peer2;\n+    scenario.Check(otherpeer, {}, 1, 0, 0, \"p3\");\n+    scenario.Check(priopeer, {gtxid}, 1, 0, 0, \"p4\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(otherpeer, {}, 1, 0, 0, \"p5\");\n+    scenario.Check(priopeer, {gtxid}, 1, 0, 0, \"p6\");\n+\n+    // We possibly request from the selected peer.\n+    if (config & 8) {\n+        scenario.RequestedTx(priopeer, gtxid, MAX_TIME);\n+        scenario.Check(priopeer, {}, 0, 1, 0, \"p7\");\n+        scenario.Check(otherpeer, {}, 1, 0, 0, \"p8\");\n+        if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    }\n+\n+    // The peer which was selected (or requested from) now goes offline, or a NOTFOUND is received from them.\n+    if (config & 16) {\n+        scenario.DisconnectedPeer(priopeer);\n+    } else {\n+        scenario.ReceivedResponse(priopeer, gtxid);\n+    }\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(priopeer, {}, 0, 0, !(config & 16), \"p8\");\n+    scenario.Check(otherpeer, {gtxid}, 1, 0, 0, \"p9\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+\n+    // Now the other peer goes offline.\n+    scenario.DisconnectedPeer(otherpeer);\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(peer1, {}, 0, 0, 0, \"p10\");\n+    scenario.Check(peer2, {}, 0, 0, 0, \"p11\");\n+}\n+\n+/** Add to scenario a randomized test in which N peers announce the same transaction, to verify\n+ *  the order in which they are requested.\n+ */\n+void BuildBigPriorityTest(Scenario& scenario, int peers)\n+{\n+    scenario.SetTestName(strprintf(\"BigPriority(peers=%i)\", peers));\n+\n+    // We will have N peers announce the same transaction.\n+    std::map<uint64_t, bool> preferred;\n+    std::vector<uint64_t> pref_order, npref_order;\n+    std::vector<uint64_t> pref_peers, npref_peers;\n+    int num_pref = InsecureRandRange(peers + 1) ; // Some preferred, ...\n+    int num_npref = peers - num_pref; // some not preferred.\n+    for (int i = 0; i < num_pref; ++i) {\n+        pref_peers.push_back(scenario.NewPeer());\n+        preferred[pref_peers.back()] = true;\n+    }\n+    for (int i = 0; i < num_npref; ++i) {\n+        npref_peers.push_back(scenario.NewPeer());\n+        preferred[npref_peers.back()] = false;\n+    }\n+    // Make a list of all peers, in order of intended request order (concatenation of pref_peers and\n+    // npref_peers).\n+    std::vector<uint64_t> request_order;\n+    for (int i = 0; i < num_pref; ++i) request_order.push_back(pref_peers[i]);\n+    for (int i = 0; i < num_npref; ++i) request_order.push_back(npref_peers[i]);\n+\n+    // Setup pref_order\n+    for (int i = 0; i < num_pref; ++i) {\n+        pref_order.push_back(pref_peers[i]);\n+    }\n+\n+    // Setup npref_order\n+    for (int i = 0; i < num_npref; ++i) {\n+        npref_order.push_back(npref_peers[i]);\n+    }\n+\n+    // Determine the announcement order randomly.\n+    std::vector<uint64_t> announce_order = request_order;\n+    Shuffle(announce_order.begin(), announce_order.end(), g_insecure_rand_ctx);\n+\n+    // Find a gtxid that has a prioritization consistent with the required pref_order and npref_order.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499105712",
      "id" : 499105712,
      "in_reply_to_id" : 498949341,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwNTcxMg==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 350,
      "original_position" : 350,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 501512216,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499105712",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499105743"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499105743"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Not really, one in 8. Given that every number of peers runs 30 times, I think that's plenty.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-03T01:58:05Z",
      "diff_hunk" : "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds MIN_TIME = std::chrono::microseconds::min();\n+constexpr std::chrono::microseconds MAX_TIME = std::chrono::microseconds::max();\n+constexpr std::chrono::microseconds MICROSECOND = std::chrono::microseconds{1};\n+constexpr std::chrono::microseconds NO_TIME = std::chrono::microseconds{0};\n+\n+/** An Action is a function to call at a particular (simulated) timestamp. */\n+using Action = std::pair<std::chrono::microseconds, std::function<void()>>;\n+\n+/** Object that stores actions from multiple interleaved scenarios, and data shared across them.\n+ *\n+ * The Scenario below is used to fill this.\n+ */\n+struct Runner\n+{\n+    /** The TxRequestTracker being tested. */\n+    TxRequestTracker txrequest;\n+\n+    /** List of actions to be executed (in order of increasing timestamp). */\n+    std::vector<Action> actions;\n+\n+    /** Which node ids have been assigned already (to prevent reuse). */\n+    std::set<uint64_t> peerset;\n+\n+    /** Which txhashes have been assigned already (to prevent reuse). */\n+    std::set<uint256> txhashset;\n+};\n+\n+std::chrono::microseconds RandomTime(int bits=23) { return std::chrono::microseconds{1 + InsecureRandBits(bits)}; }\n+\n+/** A proxy for a Runner that helps build a sequence of consecutive test actions on a TxRequestTracker.\n+ *\n+ * Multiple Scenarios are used with a single Runner, resulting in interleaved actions.\n+ */\n+class Scenario\n+{\n+    Runner& m_runner;\n+    std::chrono::microseconds m_now;\n+    std::string m_testname;\n+\n+public:\n+    Scenario(Runner& runner, std::chrono::microseconds starttime) : m_runner(runner)\n+    {\n+        m_now = starttime + RandomTime() + RandomTime() + RandomTime();\n+    }\n+\n+    void SetTestName(std::string testname)\n+    {\n+        m_testname = std::move(testname);\n+    }\n+\n+    void AdvanceTime(std::chrono::microseconds amount)\n+    {\n+        assert(amount.count() >= 0);\n+        m_now += amount;\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ForgetTxHash(txhash);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool pref, std::chrono::microseconds reqtime = MIN_TIME)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedInv(peer, gtxid, pref, reqtime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.DisconnectedPeer(peer);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds exptime)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.RequestedTx(peer, gtxid, exptime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedResponse(peer, gtxid);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void Check(uint64_t peer, const std::vector<GenTxid>& expected, size_t candidates, size_t inflight,\n+        size_t completed, const std::string& checkname = \"\")\n+    {\n+        const auto comment = m_testname + \" \" + checkname;\n+        auto& runner = m_runner;\n+        const auto now = m_now;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            auto ret = runner.txrequest.GetRequestable(peer, now);\n+            runner.txrequest.SanityCheck();\n+            runner.txrequest.PostGetRequestableSanityCheck(now);\n+            size_t total = candidates + inflight + completed;\n+            size_t real_total = runner.txrequest.Count(peer);\n+            size_t real_candidates = runner.txrequest.CountCandidates(peer);\n+            size_t real_inflight = runner.txrequest.CountInFlight(peer);\n+            BOOST_CHECK_MESSAGE(real_total == total, strprintf(\"[\" + comment + \"] total %i (%i expected)\", real_total, total));\n+            BOOST_CHECK_MESSAGE(real_inflight == inflight, strprintf(\"[\" + comment + \"] inflight %i (%i expected)\", real_inflight, inflight));\n+            BOOST_CHECK_MESSAGE(real_candidates == candidates, strprintf(\"[\" + comment + \"] candidates %i (%i expected)\", real_candidates, candidates));\n+            BOOST_CHECK_MESSAGE(ret == expected, \"[\" + comment + \"] mismatching requestables\");\n+        });\n+    }\n+\n+    uint256 NewTxHash(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        uint256 ret;\n+        bool ok;\n+        do {\n+            ret = InsecureRand256();\n+            ok = true;\n+            for (const auto& order : orders) {\n+                for (size_t pos = 1; pos < order.size(); ++pos) {\n+                    uint64_t prio_prev = m_runner.txrequest.ComputePriority(ret, order[pos - 1], true);\n+                    uint64_t prio_cur = m_runner.txrequest.ComputePriority(ret, order[pos], true);\n+                    if (prio_prev >= prio_cur) {\n+                        ok = false;\n+                        break;\n+                    }\n+                }\n+                if (!ok) break;\n+            }\n+            if (ok) {\n+                ok = m_runner.txhashset.insert(ret).second;\n+            }\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    GenTxid NewGTxid(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        return {InsecureRandBool(), NewTxHash(orders)};\n+    }\n+\n+    uint64_t NewPeer()\n+    {\n+        bool ok;\n+        uint64_t ret;\n+        do {\n+            ret = InsecureRandBits(63);\n+            ok = m_runner.peerset.insert(ret).second;\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    std::chrono::microseconds Now() const { return m_now; }\n+};\n+\n+/** Add to scenario a test with a single tx announced by a single peer.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildSingleTest(Scenario& scenario, int config)\n+{\n+    auto peer = scenario.NewPeer();\n+    auto gtxid = scenario.NewGTxid();\n+    bool immediate = config & 1;\n+    bool preferred = config & 2;\n+    auto delay = immediate ? NO_TIME : RandomTime();\n+\n+    scenario.SetTestName(strprintf(\"Single(config=%i)\", config));\n+\n+    // Receive an announcement, either immediately requestable or delayed.\n+    scenario.ReceivedInv(peer, gtxid, preferred, immediate ? MIN_TIME : scenario.Now() + delay);\n+    if (immediate) {\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s1\");\n+    } else {\n+        scenario.Check(peer, {}, 1, 0, 0, \"s2\");\n+        scenario.AdvanceTime(delay - MICROSECOND);\n+        scenario.Check(peer, {}, 1, 0, 0, \"s3\");\n+        scenario.AdvanceTime(MICROSECOND);\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s4\");\n+    }\n+\n+    if (config >> 3) { // We'll request the transaction\n+        scenario.AdvanceTime(RandomTime());\n+        auto expiry = RandomTime();\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s5\");\n+        scenario.RequestedTx(peer, gtxid, scenario.Now() + expiry);\n+        scenario.Check(peer, {}, 0, 1, 0, \"s6\");\n+\n+        if ((config >> 3) == 1) { // The request will time out\n+            scenario.AdvanceTime(expiry - MICROSECOND);\n+            scenario.Check(peer, {}, 0, 1, 0, \"s7\");\n+            scenario.AdvanceTime(MICROSECOND);\n+            scenario.Check(peer, {}, 0, 0, 0, \"s8\");\n+            return;\n+        } else {\n+            scenario.AdvanceTime(std::chrono::microseconds{InsecureRandRange(expiry.count())});\n+            scenario.Check(peer, {}, 0, 1, 0, \"s9\");\n+            if ((config >> 3) == 3) { // A reponse will arrive for the transaction\n+                scenario.ReceivedResponse(peer, gtxid);\n+                scenario.Check(peer, {}, 0, 0, 0, \"s10\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    scenario.AdvanceTime(RandomTime());\n+    if (config & 4) { // The peer will go offline\n+        scenario.DisconnectedPeer(peer);\n+    } else { // The transaction is no longer needed\n+        scenario.ForgetTxHash(gtxid.GetHash());\n+    }\n+    scenario.Check(peer, {}, 0, 0, 0, \"s11\");\n+}\n+\n+/** Add to scenario a test with a single tx announced by two peers, to verify the\n+ *  right peer is selected for requests.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildPriorityTest(Scenario& scenario, int config)\n+{\n+    scenario.SetTestName(strprintf(\"Priority(config=%i)\", config));\n+\n+    // Three peers. They will announce in order.\n+    auto peer1 = scenario.NewPeer(), peer2 = scenario.NewPeer();\n+    // Construct a transaction that under random rules would be preferred by peer2 or peer1,\n+    // depending on configuration.\n+    bool prio1 = config & 1;\n+    auto gtxid = prio1 ? scenario.NewGTxid({{peer1, peer2}}) : scenario.NewGTxid({{peer2, peer1}});\n+    bool pref1 = config & 2, pref2 = config & 4;\n+\n+    scenario.ReceivedInv(peer1, gtxid, pref1, MIN_TIME);\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p1\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p2\");\n+\n+    scenario.ReceivedInv(peer2, gtxid, pref2, MIN_TIME);\n+    bool stage2_prio =\n+        // At this point, peer2 will be given priority if:\n+        // - It is preferred and peer1 is not\n+        (pref2 && !pref1) ||\n+        // - They're in the same preference class,\n+        //   and the randomized priority favors peer2 over peer1.\n+        (pref1 == pref2 && !prio1);\n+    uint64_t priopeer = stage2_prio ? peer2 : peer1, otherpeer = stage2_prio ? peer1 : peer2;\n+    scenario.Check(otherpeer, {}, 1, 0, 0, \"p3\");\n+    scenario.Check(priopeer, {gtxid}, 1, 0, 0, \"p4\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(otherpeer, {}, 1, 0, 0, \"p5\");\n+    scenario.Check(priopeer, {gtxid}, 1, 0, 0, \"p6\");\n+\n+    // We possibly request from the selected peer.\n+    if (config & 8) {\n+        scenario.RequestedTx(priopeer, gtxid, MAX_TIME);\n+        scenario.Check(priopeer, {}, 0, 1, 0, \"p7\");\n+        scenario.Check(otherpeer, {}, 1, 0, 0, \"p8\");\n+        if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    }\n+\n+    // The peer which was selected (or requested from) now goes offline, or a NOTFOUND is received from them.\n+    if (config & 16) {\n+        scenario.DisconnectedPeer(priopeer);\n+    } else {\n+        scenario.ReceivedResponse(priopeer, gtxid);\n+    }\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(priopeer, {}, 0, 0, !(config & 16), \"p8\");\n+    scenario.Check(otherpeer, {gtxid}, 1, 0, 0, \"p9\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+\n+    // Now the other peer goes offline.\n+    scenario.DisconnectedPeer(otherpeer);\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(peer1, {}, 0, 0, 0, \"p10\");\n+    scenario.Check(peer2, {}, 0, 0, 0, \"p11\");\n+}\n+\n+/** Add to scenario a randomized test in which N peers announce the same transaction, to verify\n+ *  the order in which they are requested.\n+ */\n+void BuildBigPriorityTest(Scenario& scenario, int peers)\n+{\n+    scenario.SetTestName(strprintf(\"BigPriority(peers=%i)\", peers));\n+\n+    // We will have N peers announce the same transaction.\n+    std::map<uint64_t, bool> preferred;\n+    std::vector<uint64_t> pref_order, npref_order;\n+    std::vector<uint64_t> pref_peers, npref_peers;\n+    int num_pref = InsecureRandRange(peers + 1) ; // Some preferred, ...\n+    int num_npref = peers - num_pref; // some not preferred.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499105743",
      "id" : 499105743,
      "in_reply_to_id" : 498937736,
      "line" : 352,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwNTc0Mw==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 352,
      "original_position" : 321,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : 352,
      "pull_request_review_id" : 501512249,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499105743",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499105790"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499105790"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-03T01:58:57Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499105790",
      "id" : 499105790,
      "in_reply_to_id" : 498936239,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwNTc5MA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 282,
      "original_position" : 282,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 501512298,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499105790",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499106248"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499106248"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The sum of 3 uniformly random values is not uniformly random. I think the sum matches better with the distribution of timestamps that end up being generated during the scenarios (which are also sums of uniformly random values).",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-03T02:04:31Z",
      "diff_hunk" : "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds MIN_TIME = std::chrono::microseconds::min();\n+constexpr std::chrono::microseconds MAX_TIME = std::chrono::microseconds::max();\n+constexpr std::chrono::microseconds MICROSECOND = std::chrono::microseconds{1};\n+constexpr std::chrono::microseconds NO_TIME = std::chrono::microseconds{0};\n+\n+/** An Action is a function to call at a particular (simulated) timestamp. */\n+using Action = std::pair<std::chrono::microseconds, std::function<void()>>;\n+\n+/** Object that stores actions from multiple interleaved scenarios, and data shared across them.\n+ *\n+ * The Scenario below is used to fill this.\n+ */\n+struct Runner\n+{\n+    /** The TxRequestTracker being tested. */\n+    TxRequestTracker txrequest;\n+\n+    /** List of actions to be executed (in order of increasing timestamp). */\n+    std::vector<Action> actions;\n+\n+    /** Which node ids have been assigned already (to prevent reuse). */\n+    std::set<uint64_t> peerset;\n+\n+    /** Which txhashes have been assigned already (to prevent reuse). */\n+    std::set<uint256> txhashset;\n+};\n+\n+std::chrono::microseconds RandomTime(int bits=23) { return std::chrono::microseconds{1 + InsecureRandBits(bits)}; }\n+\n+/** A proxy for a Runner that helps build a sequence of consecutive test actions on a TxRequestTracker.\n+ *\n+ * Multiple Scenarios are used with a single Runner, resulting in interleaved actions.\n+ */\n+class Scenario\n+{\n+    Runner& m_runner;\n+    std::chrono::microseconds m_now;\n+    std::string m_testname;\n+\n+public:\n+    Scenario(Runner& runner, std::chrono::microseconds starttime) : m_runner(runner)\n+    {\n+        m_now = starttime + RandomTime() + RandomTime() + RandomTime();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499106248",
      "id" : 499106248,
      "in_reply_to_id" : 498893703,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwNjI0OA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 63,
      "original_position" : 63,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 501512667,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499106248",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499106453"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499106453"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Some variation in start time was achieved in the Scenario constructor. I've moved it here.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-03T02:07:16Z",
      "diff_hunk" : "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds MIN_TIME = std::chrono::microseconds::min();\n+constexpr std::chrono::microseconds MAX_TIME = std::chrono::microseconds::max();\n+constexpr std::chrono::microseconds MICROSECOND = std::chrono::microseconds{1};\n+constexpr std::chrono::microseconds NO_TIME = std::chrono::microseconds{0};\n+\n+/** An Action is a function to call at a particular (simulated) timestamp. */\n+using Action = std::pair<std::chrono::microseconds, std::function<void()>>;\n+\n+/** Object that stores actions from multiple interleaved scenarios, and data shared across them.\n+ *\n+ * The Scenario below is used to fill this.\n+ */\n+struct Runner\n+{\n+    /** The TxRequestTracker being tested. */\n+    TxRequestTracker txrequest;\n+\n+    /** List of actions to be executed (in order of increasing timestamp). */\n+    std::vector<Action> actions;\n+\n+    /** Which node ids have been assigned already (to prevent reuse). */\n+    std::set<uint64_t> peerset;\n+\n+    /** Which txhashes have been assigned already (to prevent reuse). */\n+    std::set<uint256> txhashset;\n+};\n+\n+std::chrono::microseconds RandomTime(int bits=23) { return std::chrono::microseconds{1 + InsecureRandBits(bits)}; }\n+\n+/** A proxy for a Runner that helps build a sequence of consecutive test actions on a TxRequestTracker.\n+ *\n+ * Multiple Scenarios are used with a single Runner, resulting in interleaved actions.\n+ */\n+class Scenario\n+{\n+    Runner& m_runner;\n+    std::chrono::microseconds m_now;\n+    std::string m_testname;\n+\n+public:\n+    Scenario(Runner& runner, std::chrono::microseconds starttime) : m_runner(runner)\n+    {\n+        m_now = starttime + RandomTime() + RandomTime() + RandomTime();\n+    }\n+\n+    void SetTestName(std::string testname)\n+    {\n+        m_testname = std::move(testname);\n+    }\n+\n+    void AdvanceTime(std::chrono::microseconds amount)\n+    {\n+        assert(amount.count() >= 0);\n+        m_now += amount;\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ForgetTxHash(txhash);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool pref, std::chrono::microseconds reqtime = MIN_TIME)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedInv(peer, gtxid, pref, reqtime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.DisconnectedPeer(peer);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds exptime)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.RequestedTx(peer, gtxid, exptime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedResponse(peer, gtxid);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void Check(uint64_t peer, const std::vector<GenTxid>& expected, size_t candidates, size_t inflight,\n+        size_t completed, const std::string& checkname = \"\")\n+    {\n+        const auto comment = m_testname + \" \" + checkname;\n+        auto& runner = m_runner;\n+        const auto now = m_now;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            auto ret = runner.txrequest.GetRequestable(peer, now);\n+            runner.txrequest.SanityCheck();\n+            runner.txrequest.PostGetRequestableSanityCheck(now);\n+            size_t total = candidates + inflight + completed;\n+            size_t real_total = runner.txrequest.Count(peer);\n+            size_t real_candidates = runner.txrequest.CountCandidates(peer);\n+            size_t real_inflight = runner.txrequest.CountInFlight(peer);\n+            BOOST_CHECK_MESSAGE(real_total == total, strprintf(\"[\" + comment + \"] total %i (%i expected)\", real_total, total));\n+            BOOST_CHECK_MESSAGE(real_inflight == inflight, strprintf(\"[\" + comment + \"] inflight %i (%i expected)\", real_inflight, inflight));\n+            BOOST_CHECK_MESSAGE(real_candidates == candidates, strprintf(\"[\" + comment + \"] candidates %i (%i expected)\", real_candidates, candidates));\n+            BOOST_CHECK_MESSAGE(ret == expected, \"[\" + comment + \"] mismatching requestables\");\n+        });\n+    }\n+\n+    uint256 NewTxHash(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        uint256 ret;\n+        bool ok;\n+        do {\n+            ret = InsecureRand256();\n+            ok = true;\n+            for (const auto& order : orders) {\n+                for (size_t pos = 1; pos < order.size(); ++pos) {\n+                    uint64_t prio_prev = m_runner.txrequest.ComputePriority(ret, order[pos - 1], true);\n+                    uint64_t prio_cur = m_runner.txrequest.ComputePriority(ret, order[pos], true);\n+                    if (prio_prev >= prio_cur) {\n+                        ok = false;\n+                        break;\n+                    }\n+                }\n+                if (!ok) break;\n+            }\n+            if (ok) {\n+                ok = m_runner.txhashset.insert(ret).second;\n+            }\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    GenTxid NewGTxid(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        return {InsecureRandBool(), NewTxHash(orders)};\n+    }\n+\n+    uint64_t NewPeer()\n+    {\n+        bool ok;\n+        uint64_t ret;\n+        do {\n+            ret = InsecureRandBits(63);\n+            ok = m_runner.peerset.insert(ret).second;\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    std::chrono::microseconds Now() const { return m_now; }\n+};\n+\n+/** Add to scenario a test with a single tx announced by a single peer.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildSingleTest(Scenario& scenario, int config)\n+{\n+    auto peer = scenario.NewPeer();\n+    auto gtxid = scenario.NewGTxid();\n+    bool immediate = config & 1;\n+    bool preferred = config & 2;\n+    auto delay = immediate ? NO_TIME : RandomTime();\n+\n+    scenario.SetTestName(strprintf(\"Single(config=%i)\", config));\n+\n+    // Receive an announcement, either immediately requestable or delayed.\n+    scenario.ReceivedInv(peer, gtxid, preferred, immediate ? MIN_TIME : scenario.Now() + delay);\n+    if (immediate) {\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s1\");\n+    } else {\n+        scenario.Check(peer, {}, 1, 0, 0, \"s2\");\n+        scenario.AdvanceTime(delay - MICROSECOND);\n+        scenario.Check(peer, {}, 1, 0, 0, \"s3\");\n+        scenario.AdvanceTime(MICROSECOND);\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s4\");\n+    }\n+\n+    if (config >> 3) { // We'll request the transaction\n+        scenario.AdvanceTime(RandomTime());\n+        auto expiry = RandomTime();\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s5\");\n+        scenario.RequestedTx(peer, gtxid, scenario.Now() + expiry);\n+        scenario.Check(peer, {}, 0, 1, 0, \"s6\");\n+\n+        if ((config >> 3) == 1) { // The request will time out\n+            scenario.AdvanceTime(expiry - MICROSECOND);\n+            scenario.Check(peer, {}, 0, 1, 0, \"s7\");\n+            scenario.AdvanceTime(MICROSECOND);\n+            scenario.Check(peer, {}, 0, 0, 0, \"s8\");\n+            return;\n+        } else {\n+            scenario.AdvanceTime(std::chrono::microseconds{InsecureRandRange(expiry.count())});\n+            scenario.Check(peer, {}, 0, 1, 0, \"s9\");\n+            if ((config >> 3) == 3) { // A reponse will arrive for the transaction\n+                scenario.ReceivedResponse(peer, gtxid);\n+                scenario.Check(peer, {}, 0, 0, 0, \"s10\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    scenario.AdvanceTime(RandomTime());\n+    if (config & 4) { // The peer will go offline\n+        scenario.DisconnectedPeer(peer);\n+    } else { // The transaction is no longer needed\n+        scenario.ForgetTxHash(gtxid.GetHash());\n+    }\n+    scenario.Check(peer, {}, 0, 0, 0, \"s11\");\n+}\n+\n+/** Add to scenario a test with a single tx announced by two peers, to verify the\n+ *  right peer is selected for requests.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildPriorityTest(Scenario& scenario, int config)\n+{\n+    scenario.SetTestName(strprintf(\"Priority(config=%i)\", config));\n+\n+    // Three peers. They will announce in order.\n+    auto peer1 = scenario.NewPeer(), peer2 = scenario.NewPeer();\n+    // Construct a transaction that under random rules would be preferred by peer2 or peer1,\n+    // depending on configuration.\n+    bool prio1 = config & 1;\n+    auto gtxid = prio1 ? scenario.NewGTxid({{peer1, peer2}}) : scenario.NewGTxid({{peer2, peer1}});\n+    bool pref1 = config & 2, pref2 = config & 4;\n+\n+    scenario.ReceivedInv(peer1, gtxid, pref1, MIN_TIME);\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p1\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p2\");\n+\n+    scenario.ReceivedInv(peer2, gtxid, pref2, MIN_TIME);\n+    bool stage2_prio =\n+        // At this point, peer2 will be given priority if:\n+        // - It is preferred and peer1 is not\n+        (pref2 && !pref1) ||\n+        // - They're in the same preference class,\n+        //   and the randomized priority favors peer2 over peer1.\n+        (pref1 == pref2 && !prio1);\n+    uint64_t priopeer = stage2_prio ? peer2 : peer1, otherpeer = stage2_prio ? peer1 : peer2;\n+    scenario.Check(otherpeer, {}, 1, 0, 0, \"p3\");\n+    scenario.Check(priopeer, {gtxid}, 1, 0, 0, \"p4\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(otherpeer, {}, 1, 0, 0, \"p5\");\n+    scenario.Check(priopeer, {gtxid}, 1, 0, 0, \"p6\");\n+\n+    // We possibly request from the selected peer.\n+    if (config & 8) {\n+        scenario.RequestedTx(priopeer, gtxid, MAX_TIME);\n+        scenario.Check(priopeer, {}, 0, 1, 0, \"p7\");\n+        scenario.Check(otherpeer, {}, 1, 0, 0, \"p8\");\n+        if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    }\n+\n+    // The peer which was selected (or requested from) now goes offline, or a NOTFOUND is received from them.\n+    if (config & 16) {\n+        scenario.DisconnectedPeer(priopeer);\n+    } else {\n+        scenario.ReceivedResponse(priopeer, gtxid);\n+    }\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(priopeer, {}, 0, 0, !(config & 16), \"p8\");\n+    scenario.Check(otherpeer, {gtxid}, 1, 0, 0, \"p9\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+\n+    // Now the other peer goes offline.\n+    scenario.DisconnectedPeer(otherpeer);\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(peer1, {}, 0, 0, 0, \"p10\");\n+    scenario.Check(peer2, {}, 0, 0, 0, \"p11\");\n+}\n+\n+/** Add to scenario a randomized test in which N peers announce the same transaction, to verify\n+ *  the order in which they are requested.\n+ */\n+void BuildBigPriorityTest(Scenario& scenario, int peers)\n+{\n+    scenario.SetTestName(strprintf(\"BigPriority(peers=%i)\", peers));\n+\n+    // We will have N peers announce the same transaction.\n+    std::map<uint64_t, bool> preferred;\n+    std::vector<uint64_t> pref_order, npref_order;\n+    std::vector<uint64_t> pref_peers, npref_peers;\n+    int num_pref = InsecureRandRange(peers + 1) ; // Some preferred, ...\n+    int num_npref = peers - num_pref; // some not preferred.\n+    for (int i = 0; i < num_pref; ++i) {\n+        pref_peers.push_back(scenario.NewPeer());\n+        preferred[pref_peers.back()] = true;\n+    }\n+    for (int i = 0; i < num_npref; ++i) {\n+        npref_peers.push_back(scenario.NewPeer());\n+        preferred[npref_peers.back()] = false;\n+    }\n+    // Make a list of all peers, in order of intended request order (concatenation of pref_peers and\n+    // npref_peers).\n+    std::vector<uint64_t> request_order;\n+    for (int i = 0; i < num_pref; ++i) request_order.push_back(pref_peers[i]);\n+    for (int i = 0; i < num_npref; ++i) request_order.push_back(npref_peers[i]);\n+\n+    // Setup pref_order\n+    for (int i = 0; i < num_pref; ++i) {\n+        pref_order.push_back(pref_peers[i]);\n+    }\n+\n+    // Setup npref_order\n+    for (int i = 0; i < num_npref; ++i) {\n+        npref_order.push_back(npref_peers[i]);\n+    }\n+\n+    // Determine the announcement order randomly.\n+    std::vector<uint64_t> announce_order = request_order;\n+    Shuffle(announce_order.begin(), announce_order.end(), g_insecure_rand_ctx);\n+\n+    // Find a gtxid that has a prioritization consistent with the required pref_order and npref_order.\n+    auto gtxid = scenario.NewGTxid({pref_order, npref_order});\n+\n+    // Decide reqtimes in opposite order of the eventual request order. So every time time jumps\n+    // past the next reqtime, the to-be-requested-from peer will change.\n+    std::map<uint64_t, std::chrono::microseconds> reqtimes;\n+    auto reqtime = scenario.Now();\n+    for (int i = peers - 1; i >= 0; --i) {\n+        reqtime += RandomTime();\n+        reqtimes[request_order[i]] = reqtime;\n+    }\n+\n+    // Actually announce from all peers simultaneously (but in announce_order).\n+    for (const auto peer : announce_order) {\n+        scenario.ReceivedInv(peer, gtxid, preferred[peer], reqtimes[peer]);\n+    }\n+    for (const auto peer : announce_order) {\n+        scenario.Check(peer, {}, 1, 0, 0, \"b1\");\n+    }\n+\n+    // Let time pass and observe the to-be-requested-from peer change.\n+    for (int i = peers - 1; i >= 0; --i) {\n+        scenario.AdvanceTime(reqtimes[request_order[i]] - scenario.Now() - MICROSECOND);\n+        scenario.Check(request_order[i], {}, 1, 0, 0, \"b2\");\n+        scenario.AdvanceTime(MICROSECOND);\n+        scenario.Check(request_order[i], {gtxid}, 1, 0, 0, \"b3\");\n+    }\n+\n+    // Peers now in random order go offline, or send NOTFOUNDs. Observe the to-be-requested-peer\n+    // change whenever the previous best one disappears.\n+    for (int i = 0; i < peers; ++i) {\n+        if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+        const int pos = InsecureRandRange(request_order.size());\n+        const auto peer = request_order[pos];\n+        request_order.erase(request_order.begin() + pos);\n+        if (InsecureRandBool()) {\n+            scenario.DisconnectedPeer(peer);\n+            scenario.Check(peer, {}, 0, 0, 0, \"b4\");\n+        } else {\n+            scenario.ReceivedResponse(peer, gtxid);\n+            scenario.Check(peer, {}, 0, 0, request_order.size() > 0, \"b5\");\n+        }\n+        if (request_order.size()) {\n+            scenario.Check(request_order[0], {gtxid}, 1, 0, 0, \"b6\");\n+        }\n+    }\n+\n+    // Everything is gone in the end.\n+    for (const auto peer : announce_order) {\n+        scenario.Check(peer, {}, 0, 0, 0, \"b7\");\n+    }\n+}\n+\n+/** Add to scenario a test with one peer announcing two transactions, to verify they are\n+ *  fetched in announcement order. */\n+void BuildRequestOrderTest(Scenario& scenario, int config)\n+{\n+    scenario.SetTestName(strprintf(\"RequestOrder(config=%i)\", config));\n+\n+    auto peer = scenario.NewPeer();\n+    auto gtxid1 = scenario.NewGTxid();\n+    auto gtxid2 = scenario.NewGTxid();\n+\n+    auto reqtime2 = scenario.Now() + RandomTime();\n+    auto reqtime1 = reqtime2 + RandomTime();\n+\n+    scenario.ReceivedInv(peer, gtxid1, config & 1, reqtime1);\n+    // Simulate time going backwards by giving the second announcement an earlier reqtime.\n+    scenario.ReceivedInv(peer, gtxid2, config & 2, reqtime2);\n+\n+    scenario.AdvanceTime(reqtime2 - MICROSECOND - scenario.Now());\n+    scenario.Check(peer, {}, 2, 0, 0, \"o1\");\n+    scenario.AdvanceTime(MICROSECOND);\n+    scenario.Check(peer, {gtxid2}, 2, 0, 0, \"o2\");\n+    scenario.AdvanceTime(reqtime1 - MICROSECOND - scenario.Now());\n+    scenario.Check(peer, {gtxid2}, 2, 0, 0, \"o3\");\n+    scenario.AdvanceTime(MICROSECOND);\n+    // Even with time going backwards in between announcements, the return value of GetRequestable is in\n+    // announcement order.\n+    scenario.Check(peer, {gtxid1, gtxid2}, 2, 0, 0, \"o4\");\n+\n+    scenario.DisconnectedPeer(peer);\n+    scenario.Check(peer, {}, 0, 0, 0, \"o5\");\n+}\n+\n+/** Add to scenario a test thats verifies behavior related to both txid and wtxid with the same\n+    hash being announced.\n+*/\n+void BuildWtxidTest(Scenario& scenario, int config)\n+{\n+    scenario.SetTestName(strprintf(\"Wtxid(config=%i)\", config));\n+\n+    auto peerT = scenario.NewPeer();\n+    auto peerW = scenario.NewPeer();\n+    auto txhash = scenario.NewTxHash();\n+    GenTxid txid{false, txhash};\n+    GenTxid wtxid{true, txhash};\n+\n+    auto reqtimeT = InsecureRandBool() ? MIN_TIME : scenario.Now() + RandomTime();\n+    auto reqtimeW = InsecureRandBool() ? MIN_TIME : scenario.Now() + RandomTime();\n+\n+    // Announce txid first or wtxid first.\n+    if (config & 1) {\n+        scenario.ReceivedInv(peerT, txid, config & 2, reqtimeT);\n+        if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+        scenario.ReceivedInv(peerW, wtxid, !(config & 2), reqtimeW);\n+    } else {\n+        scenario.ReceivedInv(peerW, wtxid, !(config & 2), reqtimeW);\n+        if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+        scenario.ReceivedInv(peerT, txid, config & 2, reqtimeT);\n+    }\n+\n+    // Let time pass if needed, and check that the preferred announcement (txid or wtxid)\n+    // is correctly to-be-requested (and with the correct wtxidness).\n+    auto max_reqtime = std::max(reqtimeT, reqtimeW);\n+    if (max_reqtime > scenario.Now()) scenario.AdvanceTime(max_reqtime - scenario.Now());\n+    if (config & 2) {\n+        scenario.Check(peerT, {txid}, 1, 0, 0, \"w1\");\n+        scenario.Check(peerW, {}, 1, 0, 0, \"w2\");\n+    } else {\n+        scenario.Check(peerT, {}, 1, 0, 0, \"w3\");\n+        scenario.Check(peerW, {wtxid}, 1, 0, 0, \"w4\");\n+    }\n+\n+    // If a good transaction with either that hash as wtxid or txid arrives, both\n+    // announcements are gone.\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.ForgetTxHash(txhash);\n+    scenario.Check(peerT, {}, 0, 0, 0, \"w5\");\n+    scenario.Check(peerW, {}, 0, 0, 0, \"w6\");\n+}\n+\n+void TestInterleavedScenarios()\n+{\n+    // Create a list of functions which add tests to scenarios.\n+    std::vector<std::function<void(Scenario&)>> builders;\n+    // Add instances of every test, for every configuration.\n+    for (int config = 0; config < 4; ++config) {\n+        builders.emplace_back([config](Scenario& scenario){ BuildWtxidTest(scenario, config); });\n+    }\n+    for (int config = 0; config < 4; ++config) {\n+        builders.emplace_back([config](Scenario& scenario){ BuildRequestOrderTest(scenario, config); });\n+    }\n+    for (int config = 0; config < 32; ++config) {\n+        builders.emplace_back([config](Scenario& scenario){ BuildSingleTest(scenario, config); });\n+    }\n+    for (int config = 0; config < 32; ++config) {\n+        builders.emplace_back([config](Scenario& scenario){ BuildPriorityTest(scenario, config); });\n+    }\n+    for (int peers = 1; peers <= 8; ++peers) {\n+        for (int i = 0; i < 10; ++i) {\n+            builders.emplace_back([peers](Scenario& scenario){ BuildBigPriorityTest(scenario, peers); });\n+        }\n+    }\n+    // Randomly shuffle all those functions.\n+    Shuffle(builders.begin(), builders.end(), g_insecure_rand_ctx);\n+\n+    Runner runner;\n+    auto starttime = RandomTime(44);\n+    // Construct many scenarios, and run (up to) 10 randomly-chosen tests consecutively in each.\n+    while (builders.size()) {\n+        Scenario scenario(runner, starttime);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499106453",
      "id" : 499106453,
      "in_reply_to_id" : 498899567,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwNjQ1Mw==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 511,
      "original_position" : 511,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 501512844,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499106453",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499107540"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499107540"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Added as an extra commit on top.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-03T02:22:37Z",
      "diff_hunk" : "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction. Note that this only works\n+ *              per txhash, so if the same transaction is announced both through txid and wtxid, we have no means\n+ *              to prevent fetching both (the caller can however mitigate this by delaying one, see further).\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten only:\n+ *   - If a peer goes offline, all its announcements are forgotten.\n+ *   - If a transaction has been successfully received, or is otherwise no longer needed, the caller can call\n+ *     ForgetTxHash, which removes all announcements across all peers with the specified txhash.\n+ *   - If for a given txhash only already-requested announcements remain, they are all forgotten.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening transaction censoring attacks. The flip side is that as long as an attacker manages\n+ *              to prevent us from receiving a transaction, failed announcements (including those from honest peers)\n+ *              will linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a\n+ *              cap on the number of tracked announcements per peer. As failed requests in response to announcements\n+ *              from honest peers should be rare, this almost solely hinders attackers.\n+ *              Transaction censoring attacks can be done by announcing transactions quickly while not answering\n+ *              requests for them. See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more\n+ *              information.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable the calling code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers are more trusted by us, so are less likely to be under attacker control.\n+ *\n+ *   - Pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: random assignments are hard to influence for attackers.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and minimizing\n+ * susceptibility to censorship attacks. An attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one preferred connection).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution). The \"1 +\" is due to the fact that the\n+ *   attacker can be the first to announce through a preferred connection in this scenario, which very likely means\n+ *   they get the first request.\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh>=1\n+ *   are honest, where we assume that the attacker can disconnect and reconnect those connections, the distribution\n+ *   becomes k ~ P + NB(p=1-NP/NPh,r=1) (where NB stands for Negative Binomial distribution), which has mean\n+ *   P-1+NP/NPh.\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, and a NOTFOUND or a\n+    //   transaction was received in response (valid or not), or they timed out. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DisconnectedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash (both txid and wtxid ones).\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it.\n+     */\n+    void ForgetTxHash(const uint256& txhash);\n+\n+    /** Adds a new CANDIDATE announcement.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that the txid/wtxid property is ignored for determining uniqueness, so if an announcement\n+     * is added for a wtxid H, while one for txid H from the same peer already exists, it will be ignored. This is\n+     * harmless as the txhashes being equal implies it is a non-segwit transaction, so it doesn't matter how it is\n+     * fetched. The new announcement is given the specified preferred and reqtime values, and takes it is_wtxid from\n+     * the specified gtxid.\n+     */\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime);\n+\n+    /** Converts the CANDIDATE announcement for the provided peer and gtxid into a REQUESTED one.\n+     *\n+     * Expiry is set to the specified value. This can ONLY be called immediately after GetRequestable was called\n+     * (for the same peer), with only ForgetTx and other RequestedTx calls (both for other txhashes) in\n+     * between. Any other non-const operation removes the ability to call RequestedTx.\n+     */\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds expiry);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499107540",
      "id" : 499107540,
      "in_reply_to_id" : 498734530,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwNzU0MA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 151,
      "original_position" : 151,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 501513830,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499107540",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499107593"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499107593"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I assume not, as this test only looks at what is being requested.\r\n\r\nCan you write out the actual scenario you have in mind (or even better, write a commit that adds it)?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-03T02:23:36Z",
      "diff_hunk" : "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds MIN_TIME = std::chrono::microseconds::min();\n+constexpr std::chrono::microseconds MAX_TIME = std::chrono::microseconds::max();\n+constexpr std::chrono::microseconds MICROSECOND = std::chrono::microseconds{1};\n+constexpr std::chrono::microseconds NO_TIME = std::chrono::microseconds{0};\n+\n+/** An Action is a function to call at a particular (simulated) timestamp. */\n+using Action = std::pair<std::chrono::microseconds, std::function<void()>>;\n+\n+/** Object that stores actions from multiple interleaved scenarios, and data shared across them.\n+ *\n+ * The Scenario below is used to fill this.\n+ */\n+struct Runner\n+{\n+    /** The TxRequestTracker being tested. */\n+    TxRequestTracker txrequest;\n+\n+    /** List of actions to be executed (in order of increasing timestamp). */\n+    std::vector<Action> actions;\n+\n+    /** Which node ids have been assigned already (to prevent reuse). */\n+    std::set<uint64_t> peerset;\n+\n+    /** Which txhashes have been assigned already (to prevent reuse). */\n+    std::set<uint256> txhashset;\n+};\n+\n+std::chrono::microseconds RandomTime(int bits=23) { return std::chrono::microseconds{1 + InsecureRandBits(bits)}; }\n+\n+/** A proxy for a Runner that helps build a sequence of consecutive test actions on a TxRequestTracker.\n+ *\n+ * Multiple Scenarios are used with a single Runner, resulting in interleaved actions.\n+ */\n+class Scenario\n+{\n+    Runner& m_runner;\n+    std::chrono::microseconds m_now;\n+    std::string m_testname;\n+\n+public:\n+    Scenario(Runner& runner, std::chrono::microseconds starttime) : m_runner(runner)\n+    {\n+        m_now = starttime + RandomTime() + RandomTime() + RandomTime();\n+    }\n+\n+    void SetTestName(std::string testname)\n+    {\n+        m_testname = std::move(testname);\n+    }\n+\n+    void AdvanceTime(std::chrono::microseconds amount)\n+    {\n+        assert(amount.count() >= 0);\n+        m_now += amount;\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ForgetTxHash(txhash);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool pref, std::chrono::microseconds reqtime = MIN_TIME)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedInv(peer, gtxid, pref, reqtime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.DisconnectedPeer(peer);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds exptime)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.RequestedTx(peer, gtxid, exptime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedResponse(peer, gtxid);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void Check(uint64_t peer, const std::vector<GenTxid>& expected, size_t candidates, size_t inflight,\n+        size_t completed, const std::string& checkname = \"\")\n+    {\n+        const auto comment = m_testname + \" \" + checkname;\n+        auto& runner = m_runner;\n+        const auto now = m_now;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            auto ret = runner.txrequest.GetRequestable(peer, now);\n+            runner.txrequest.SanityCheck();\n+            runner.txrequest.PostGetRequestableSanityCheck(now);\n+            size_t total = candidates + inflight + completed;\n+            size_t real_total = runner.txrequest.Count(peer);\n+            size_t real_candidates = runner.txrequest.CountCandidates(peer);\n+            size_t real_inflight = runner.txrequest.CountInFlight(peer);\n+            BOOST_CHECK_MESSAGE(real_total == total, strprintf(\"[\" + comment + \"] total %i (%i expected)\", real_total, total));\n+            BOOST_CHECK_MESSAGE(real_inflight == inflight, strprintf(\"[\" + comment + \"] inflight %i (%i expected)\", real_inflight, inflight));\n+            BOOST_CHECK_MESSAGE(real_candidates == candidates, strprintf(\"[\" + comment + \"] candidates %i (%i expected)\", real_candidates, candidates));\n+            BOOST_CHECK_MESSAGE(ret == expected, \"[\" + comment + \"] mismatching requestables\");\n+        });\n+    }\n+\n+    uint256 NewTxHash(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        uint256 ret;\n+        bool ok;\n+        do {\n+            ret = InsecureRand256();\n+            ok = true;\n+            for (const auto& order : orders) {\n+                for (size_t pos = 1; pos < order.size(); ++pos) {\n+                    uint64_t prio_prev = m_runner.txrequest.ComputePriority(ret, order[pos - 1], true);\n+                    uint64_t prio_cur = m_runner.txrequest.ComputePriority(ret, order[pos], true);\n+                    if (prio_prev >= prio_cur) {\n+                        ok = false;\n+                        break;\n+                    }\n+                }\n+                if (!ok) break;\n+            }\n+            if (ok) {\n+                ok = m_runner.txhashset.insert(ret).second;\n+            }\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    GenTxid NewGTxid(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        return {InsecureRandBool(), NewTxHash(orders)};\n+    }\n+\n+    uint64_t NewPeer()\n+    {\n+        bool ok;\n+        uint64_t ret;\n+        do {\n+            ret = InsecureRandBits(63);\n+            ok = m_runner.peerset.insert(ret).second;\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    std::chrono::microseconds Now() const { return m_now; }\n+};\n+\n+/** Add to scenario a test with a single tx announced by a single peer.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildSingleTest(Scenario& scenario, int config)\n+{\n+    auto peer = scenario.NewPeer();\n+    auto gtxid = scenario.NewGTxid();\n+    bool immediate = config & 1;\n+    bool preferred = config & 2;\n+    auto delay = immediate ? NO_TIME : RandomTime();\n+\n+    scenario.SetTestName(strprintf(\"Single(config=%i)\", config));\n+\n+    // Receive an announcement, either immediately requestable or delayed.\n+    scenario.ReceivedInv(peer, gtxid, preferred, immediate ? MIN_TIME : scenario.Now() + delay);\n+    if (immediate) {\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s1\");\n+    } else {\n+        scenario.Check(peer, {}, 1, 0, 0, \"s2\");\n+        scenario.AdvanceTime(delay - MICROSECOND);\n+        scenario.Check(peer, {}, 1, 0, 0, \"s3\");\n+        scenario.AdvanceTime(MICROSECOND);\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s4\");\n+    }\n+\n+    if (config >> 3) { // We'll request the transaction\n+        scenario.AdvanceTime(RandomTime());\n+        auto expiry = RandomTime();\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s5\");\n+        scenario.RequestedTx(peer, gtxid, scenario.Now() + expiry);\n+        scenario.Check(peer, {}, 0, 1, 0, \"s6\");\n+\n+        if ((config >> 3) == 1) { // The request will time out\n+            scenario.AdvanceTime(expiry - MICROSECOND);\n+            scenario.Check(peer, {}, 0, 1, 0, \"s7\");\n+            scenario.AdvanceTime(MICROSECOND);\n+            scenario.Check(peer, {}, 0, 0, 0, \"s8\");\n+            return;\n+        } else {\n+            scenario.AdvanceTime(std::chrono::microseconds{InsecureRandRange(expiry.count())});\n+            scenario.Check(peer, {}, 0, 1, 0, \"s9\");\n+            if ((config >> 3) == 3) { // A reponse will arrive for the transaction\n+                scenario.ReceivedResponse(peer, gtxid);\n+                scenario.Check(peer, {}, 0, 0, 0, \"s10\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    scenario.AdvanceTime(RandomTime());\n+    if (config & 4) { // The peer will go offline\n+        scenario.DisconnectedPeer(peer);\n+    } else { // The transaction is no longer needed\n+        scenario.ForgetTxHash(gtxid.GetHash());\n+    }\n+    scenario.Check(peer, {}, 0, 0, 0, \"s11\");\n+}\n+\n+/** Add to scenario a test with a single tx announced by two peers, to verify the\n+ *  right peer is selected for requests.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildPriorityTest(Scenario& scenario, int config)\n+{\n+    scenario.SetTestName(strprintf(\"Priority(config=%i)\", config));\n+\n+    // Three peers. They will announce in order.\n+    auto peer1 = scenario.NewPeer(), peer2 = scenario.NewPeer();\n+    // Construct a transaction that under random rules would be preferred by peer2 or peer1,\n+    // depending on configuration.\n+    bool prio1 = config & 1;\n+    auto gtxid = prio1 ? scenario.NewGTxid({{peer1, peer2}}) : scenario.NewGTxid({{peer2, peer1}});\n+    bool pref1 = config & 2, pref2 = config & 4;\n+\n+    scenario.ReceivedInv(peer1, gtxid, pref1, MIN_TIME);\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p1\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p2\");\n+\n+    scenario.ReceivedInv(peer2, gtxid, pref2, MIN_TIME);\n+    bool stage2_prio =\n+        // At this point, peer2 will be given priority if:\n+        // - It is preferred and peer1 is not\n+        (pref2 && !pref1) ||\n+        // - They're in the same preference class,\n+        //   and the randomized priority favors peer2 over peer1.\n+        (pref1 == pref2 && !prio1);\n+    uint64_t priopeer = stage2_prio ? peer2 : peer1, otherpeer = stage2_prio ? peer1 : peer2;\n+    scenario.Check(otherpeer, {}, 1, 0, 0, \"p3\");\n+    scenario.Check(priopeer, {gtxid}, 1, 0, 0, \"p4\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(otherpeer, {}, 1, 0, 0, \"p5\");\n+    scenario.Check(priopeer, {gtxid}, 1, 0, 0, \"p6\");\n+\n+    // We possibly request from the selected peer.\n+    if (config & 8) {\n+        scenario.RequestedTx(priopeer, gtxid, MAX_TIME);\n+        scenario.Check(priopeer, {}, 0, 1, 0, \"p7\");\n+        scenario.Check(otherpeer, {}, 1, 0, 0, \"p8\");\n+        if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    }\n+\n+    // The peer which was selected (or requested from) now goes offline, or a NOTFOUND is received from them.\n+    if (config & 16) {\n+        scenario.DisconnectedPeer(priopeer);\n+    } else {\n+        scenario.ReceivedResponse(priopeer, gtxid);\n+    }\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(priopeer, {}, 0, 0, !(config & 16), \"p8\");\n+    scenario.Check(otherpeer, {gtxid}, 1, 0, 0, \"p9\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+\n+    // Now the other peer goes offline.\n+    scenario.DisconnectedPeer(otherpeer);\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(peer1, {}, 0, 0, 0, \"p10\");\n+    scenario.Check(peer2, {}, 0, 0, 0, \"p11\");\n+}\n+\n+/** Add to scenario a randomized test in which N peers announce the same transaction, to verify\n+ *  the order in which they are requested.\n+ */\n+void BuildBigPriorityTest(Scenario& scenario, int peers)\n+{\n+    scenario.SetTestName(strprintf(\"BigPriority(peers=%i)\", peers));\n+\n+    // We will have N peers announce the same transaction.\n+    std::map<uint64_t, bool> preferred;\n+    std::vector<uint64_t> pref_order, npref_order;\n+    std::vector<uint64_t> pref_peers, npref_peers;\n+    int num_pref = InsecureRandRange(peers + 1) ; // Some preferred, ...\n+    int num_npref = peers - num_pref; // some not preferred.\n+    for (int i = 0; i < num_pref; ++i) {\n+        pref_peers.push_back(scenario.NewPeer());\n+        preferred[pref_peers.back()] = true;\n+    }\n+    for (int i = 0; i < num_npref; ++i) {\n+        npref_peers.push_back(scenario.NewPeer());\n+        preferred[npref_peers.back()] = false;\n+    }\n+    // Make a list of all peers, in order of intended request order (concatenation of pref_peers and\n+    // npref_peers).\n+    std::vector<uint64_t> request_order;\n+    for (int i = 0; i < num_pref; ++i) request_order.push_back(pref_peers[i]);\n+    for (int i = 0; i < num_npref; ++i) request_order.push_back(npref_peers[i]);\n+\n+    // Setup pref_order\n+    for (int i = 0; i < num_pref; ++i) {\n+        pref_order.push_back(pref_peers[i]);\n+    }\n+\n+    // Setup npref_order\n+    for (int i = 0; i < num_npref; ++i) {\n+        npref_order.push_back(npref_peers[i]);\n+    }\n+\n+    // Determine the announcement order randomly.\n+    std::vector<uint64_t> announce_order = request_order;\n+    Shuffle(announce_order.begin(), announce_order.end(), g_insecure_rand_ctx);\n+\n+    // Find a gtxid that has a prioritization consistent with the required pref_order and npref_order.\n+    auto gtxid = scenario.NewGTxid({pref_order, npref_order});\n+\n+    // Decide reqtimes in opposite order of the eventual request order. So every time time jumps\n+    // past the next reqtime, the to-be-requested-from peer will change.\n+    std::map<uint64_t, std::chrono::microseconds> reqtimes;\n+    auto reqtime = scenario.Now();\n+    for (int i = peers - 1; i >= 0; --i) {\n+        reqtime += RandomTime();\n+        reqtimes[request_order[i]] = reqtime;\n+    }\n+\n+    // Actually announce from all peers simultaneously (but in announce_order).\n+    for (const auto peer : announce_order) {\n+        scenario.ReceivedInv(peer, gtxid, preferred[peer], reqtimes[peer]);\n+    }\n+    for (const auto peer : announce_order) {\n+        scenario.Check(peer, {}, 1, 0, 0, \"b1\");\n+    }\n+\n+    // Let time pass and observe the to-be-requested-from peer change.\n+    for (int i = peers - 1; i >= 0; --i) {\n+        scenario.AdvanceTime(reqtimes[request_order[i]] - scenario.Now() - MICROSECOND);\n+        scenario.Check(request_order[i], {}, 1, 0, 0, \"b2\");\n+        scenario.AdvanceTime(MICROSECOND);\n+        scenario.Check(request_order[i], {gtxid}, 1, 0, 0, \"b3\");\n+    }\n+\n+    // Peers now in random order go offline, or send NOTFOUNDs. Observe the to-be-requested-peer\n+    // change whenever the previous best one disappears.\n+    for (int i = 0; i < peers; ++i) {\n+        if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+        const int pos = InsecureRandRange(request_order.size());\n+        const auto peer = request_order[pos];\n+        request_order.erase(request_order.begin() + pos);\n+        if (InsecureRandBool()) {\n+            scenario.DisconnectedPeer(peer);\n+            scenario.Check(peer, {}, 0, 0, 0, \"b4\");\n+        } else {\n+            scenario.ReceivedResponse(peer, gtxid);\n+            scenario.Check(peer, {}, 0, 0, request_order.size() > 0, \"b5\");\n+        }\n+        if (request_order.size()) {\n+            scenario.Check(request_order[0], {gtxid}, 1, 0, 0, \"b6\");\n+        }\n+    }\n+\n+    // Everything is gone in the end.\n+    for (const auto peer : announce_order) {\n+        scenario.Check(peer, {}, 0, 0, 0, \"b7\");\n+    }\n+}\n+\n+/** Add to scenario a test with one peer announcing two transactions, to verify they are\n+ *  fetched in announcement order. */\n+void BuildRequestOrderTest(Scenario& scenario, int config)\n+{\n+    scenario.SetTestName(strprintf(\"RequestOrder(config=%i)\", config));\n+\n+    auto peer = scenario.NewPeer();\n+    auto gtxid1 = scenario.NewGTxid();\n+    auto gtxid2 = scenario.NewGTxid();\n+\n+    auto reqtime2 = scenario.Now() + RandomTime();\n+    auto reqtime1 = reqtime2 + RandomTime();\n+\n+    scenario.ReceivedInv(peer, gtxid1, config & 1, reqtime1);\n+    // Simulate time going backwards by giving the second announcement an earlier reqtime.\n+    scenario.ReceivedInv(peer, gtxid2, config & 2, reqtime2);\n+\n+    scenario.AdvanceTime(reqtime2 - MICROSECOND - scenario.Now());\n+    scenario.Check(peer, {}, 2, 0, 0, \"o1\");\n+    scenario.AdvanceTime(MICROSECOND);\n+    scenario.Check(peer, {gtxid2}, 2, 0, 0, \"o2\");\n+    scenario.AdvanceTime(reqtime1 - MICROSECOND - scenario.Now());\n+    scenario.Check(peer, {gtxid2}, 2, 0, 0, \"o3\");\n+    scenario.AdvanceTime(MICROSECOND);\n+    // Even with time going backwards in between announcements, the return value of GetRequestable is in\n+    // announcement order.\n+    scenario.Check(peer, {gtxid1, gtxid2}, 2, 0, 0, \"o4\");\n+\n+    scenario.DisconnectedPeer(peer);\n+    scenario.Check(peer, {}, 0, 0, 0, \"o5\");\n+}\n+\n+/** Add to scenario a test thats verifies behavior related to both txid and wtxid with the same\n+    hash being announced.\n+*/\n+void BuildWtxidTest(Scenario& scenario, int config)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499107593",
      "id" : 499107593,
      "in_reply_to_id" : 498926860,
      "line" : 460,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwNzU5Mw==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 460,
      "original_position" : 438,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : 460,
      "pull_request_review_id" : 501513881,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499107593",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499107610"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499107610"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've changed the comments here a bit.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-03T02:23:53Z",
      "diff_hunk" : "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds MIN_TIME = std::chrono::microseconds::min();\n+constexpr std::chrono::microseconds MAX_TIME = std::chrono::microseconds::max();\n+constexpr std::chrono::microseconds MICROSECOND = std::chrono::microseconds{1};\n+constexpr std::chrono::microseconds NO_TIME = std::chrono::microseconds{0};\n+\n+/** An Action is a function to call at a particular (simulated) timestamp. */\n+using Action = std::pair<std::chrono::microseconds, std::function<void()>>;\n+\n+/** Object that stores actions from multiple interleaved scenarios, and data shared across them.\n+ *\n+ * The Scenario below is used to fill this.\n+ */\n+struct Runner\n+{\n+    /** The TxRequestTracker being tested. */\n+    TxRequestTracker txrequest;\n+\n+    /** List of actions to be executed (in order of increasing timestamp). */\n+    std::vector<Action> actions;\n+\n+    /** Which node ids have been assigned already (to prevent reuse). */\n+    std::set<uint64_t> peerset;\n+\n+    /** Which txhashes have been assigned already (to prevent reuse). */\n+    std::set<uint256> txhashset;\n+};\n+\n+std::chrono::microseconds RandomTime(int bits=23) { return std::chrono::microseconds{1 + InsecureRandBits(bits)}; }\n+\n+/** A proxy for a Runner that helps build a sequence of consecutive test actions on a TxRequestTracker.\n+ *\n+ * Multiple Scenarios are used with a single Runner, resulting in interleaved actions.\n+ */\n+class Scenario\n+{\n+    Runner& m_runner;\n+    std::chrono::microseconds m_now;\n+    std::string m_testname;\n+\n+public:\n+    Scenario(Runner& runner, std::chrono::microseconds starttime) : m_runner(runner)\n+    {\n+        m_now = starttime + RandomTime() + RandomTime() + RandomTime();\n+    }\n+\n+    void SetTestName(std::string testname)\n+    {\n+        m_testname = std::move(testname);\n+    }\n+\n+    void AdvanceTime(std::chrono::microseconds amount)\n+    {\n+        assert(amount.count() >= 0);\n+        m_now += amount;\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ForgetTxHash(txhash);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool pref, std::chrono::microseconds reqtime = MIN_TIME)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedInv(peer, gtxid, pref, reqtime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.DisconnectedPeer(peer);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds exptime)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.RequestedTx(peer, gtxid, exptime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedResponse(peer, gtxid);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void Check(uint64_t peer, const std::vector<GenTxid>& expected, size_t candidates, size_t inflight,\n+        size_t completed, const std::string& checkname = \"\")\n+    {\n+        const auto comment = m_testname + \" \" + checkname;\n+        auto& runner = m_runner;\n+        const auto now = m_now;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            auto ret = runner.txrequest.GetRequestable(peer, now);\n+            runner.txrequest.SanityCheck();\n+            runner.txrequest.PostGetRequestableSanityCheck(now);\n+            size_t total = candidates + inflight + completed;\n+            size_t real_total = runner.txrequest.Count(peer);\n+            size_t real_candidates = runner.txrequest.CountCandidates(peer);\n+            size_t real_inflight = runner.txrequest.CountInFlight(peer);\n+            BOOST_CHECK_MESSAGE(real_total == total, strprintf(\"[\" + comment + \"] total %i (%i expected)\", real_total, total));\n+            BOOST_CHECK_MESSAGE(real_inflight == inflight, strprintf(\"[\" + comment + \"] inflight %i (%i expected)\", real_inflight, inflight));\n+            BOOST_CHECK_MESSAGE(real_candidates == candidates, strprintf(\"[\" + comment + \"] candidates %i (%i expected)\", real_candidates, candidates));\n+            BOOST_CHECK_MESSAGE(ret == expected, \"[\" + comment + \"] mismatching requestables\");\n+        });\n+    }\n+\n+    uint256 NewTxHash(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        uint256 ret;\n+        bool ok;\n+        do {\n+            ret = InsecureRand256();\n+            ok = true;\n+            for (const auto& order : orders) {\n+                for (size_t pos = 1; pos < order.size(); ++pos) {\n+                    uint64_t prio_prev = m_runner.txrequest.ComputePriority(ret, order[pos - 1], true);\n+                    uint64_t prio_cur = m_runner.txrequest.ComputePriority(ret, order[pos], true);\n+                    if (prio_prev >= prio_cur) {\n+                        ok = false;\n+                        break;\n+                    }\n+                }\n+                if (!ok) break;\n+            }\n+            if (ok) {\n+                ok = m_runner.txhashset.insert(ret).second;\n+            }\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    GenTxid NewGTxid(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        return {InsecureRandBool(), NewTxHash(orders)};\n+    }\n+\n+    uint64_t NewPeer()\n+    {\n+        bool ok;\n+        uint64_t ret;\n+        do {\n+            ret = InsecureRandBits(63);\n+            ok = m_runner.peerset.insert(ret).second;\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    std::chrono::microseconds Now() const { return m_now; }\n+};\n+\n+/** Add to scenario a test with a single tx announced by a single peer.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildSingleTest(Scenario& scenario, int config)\n+{\n+    auto peer = scenario.NewPeer();\n+    auto gtxid = scenario.NewGTxid();\n+    bool immediate = config & 1;\n+    bool preferred = config & 2;\n+    auto delay = immediate ? NO_TIME : RandomTime();\n+\n+    scenario.SetTestName(strprintf(\"Single(config=%i)\", config));\n+\n+    // Receive an announcement, either immediately requestable or delayed.\n+    scenario.ReceivedInv(peer, gtxid, preferred, immediate ? MIN_TIME : scenario.Now() + delay);\n+    if (immediate) {\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s1\");\n+    } else {\n+        scenario.Check(peer, {}, 1, 0, 0, \"s2\");\n+        scenario.AdvanceTime(delay - MICROSECOND);\n+        scenario.Check(peer, {}, 1, 0, 0, \"s3\");\n+        scenario.AdvanceTime(MICROSECOND);\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s4\");\n+    }\n+\n+    if (config >> 3) { // We'll request the transaction\n+        scenario.AdvanceTime(RandomTime());\n+        auto expiry = RandomTime();\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s5\");\n+        scenario.RequestedTx(peer, gtxid, scenario.Now() + expiry);\n+        scenario.Check(peer, {}, 0, 1, 0, \"s6\");\n+\n+        if ((config >> 3) == 1) { // The request will time out\n+            scenario.AdvanceTime(expiry - MICROSECOND);\n+            scenario.Check(peer, {}, 0, 1, 0, \"s7\");\n+            scenario.AdvanceTime(MICROSECOND);\n+            scenario.Check(peer, {}, 0, 0, 0, \"s8\");\n+            return;\n+        } else {\n+            scenario.AdvanceTime(std::chrono::microseconds{InsecureRandRange(expiry.count())});\n+            scenario.Check(peer, {}, 0, 1, 0, \"s9\");\n+            if ((config >> 3) == 3) { // A reponse will arrive for the transaction\n+                scenario.ReceivedResponse(peer, gtxid);\n+                scenario.Check(peer, {}, 0, 0, 0, \"s10\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    scenario.AdvanceTime(RandomTime());\n+    if (config & 4) { // The peer will go offline\n+        scenario.DisconnectedPeer(peer);\n+    } else { // The transaction is no longer needed\n+        scenario.ForgetTxHash(gtxid.GetHash());\n+    }\n+    scenario.Check(peer, {}, 0, 0, 0, \"s11\");\n+}\n+\n+/** Add to scenario a test with a single tx announced by two peers, to verify the\n+ *  right peer is selected for requests.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildPriorityTest(Scenario& scenario, int config)\n+{\n+    scenario.SetTestName(strprintf(\"Priority(config=%i)\", config));\n+\n+    // Three peers. They will announce in order.\n+    auto peer1 = scenario.NewPeer(), peer2 = scenario.NewPeer();\n+    // Construct a transaction that under random rules would be preferred by peer2 or peer1,\n+    // depending on configuration.\n+    bool prio1 = config & 1;\n+    auto gtxid = prio1 ? scenario.NewGTxid({{peer1, peer2}}) : scenario.NewGTxid({{peer2, peer1}});\n+    bool pref1 = config & 2, pref2 = config & 4;\n+\n+    scenario.ReceivedInv(peer1, gtxid, pref1, MIN_TIME);\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p1\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p2\");\n+\n+    scenario.ReceivedInv(peer2, gtxid, pref2, MIN_TIME);\n+    bool stage2_prio =\n+        // At this point, peer2 will be given priority if:\n+        // - It is preferred and peer1 is not\n+        (pref2 && !pref1) ||\n+        // - They're in the same preference class,\n+        //   and the randomized priority favors peer2 over peer1.\n+        (pref1 == pref2 && !prio1);\n+    uint64_t priopeer = stage2_prio ? peer2 : peer1, otherpeer = stage2_prio ? peer1 : peer2;\n+    scenario.Check(otherpeer, {}, 1, 0, 0, \"p3\");\n+    scenario.Check(priopeer, {gtxid}, 1, 0, 0, \"p4\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(otherpeer, {}, 1, 0, 0, \"p5\");\n+    scenario.Check(priopeer, {gtxid}, 1, 0, 0, \"p6\");\n+\n+    // We possibly request from the selected peer.\n+    if (config & 8) {\n+        scenario.RequestedTx(priopeer, gtxid, MAX_TIME);\n+        scenario.Check(priopeer, {}, 0, 1, 0, \"p7\");\n+        scenario.Check(otherpeer, {}, 1, 0, 0, \"p8\");\n+        if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    }\n+\n+    // The peer which was selected (or requested from) now goes offline, or a NOTFOUND is received from them.\n+    if (config & 16) {\n+        scenario.DisconnectedPeer(priopeer);\n+    } else {\n+        scenario.ReceivedResponse(priopeer, gtxid);\n+    }\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(priopeer, {}, 0, 0, !(config & 16), \"p8\");\n+    scenario.Check(otherpeer, {gtxid}, 1, 0, 0, \"p9\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+\n+    // Now the other peer goes offline.\n+    scenario.DisconnectedPeer(otherpeer);\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(peer1, {}, 0, 0, 0, \"p10\");\n+    scenario.Check(peer2, {}, 0, 0, 0, \"p11\");\n+}\n+\n+/** Add to scenario a randomized test in which N peers announce the same transaction, to verify\n+ *  the order in which they are requested.\n+ */\n+void BuildBigPriorityTest(Scenario& scenario, int peers)\n+{\n+    scenario.SetTestName(strprintf(\"BigPriority(peers=%i)\", peers));\n+\n+    // We will have N peers announce the same transaction.\n+    std::map<uint64_t, bool> preferred;\n+    std::vector<uint64_t> pref_order, npref_order;\n+    std::vector<uint64_t> pref_peers, npref_peers;\n+    int num_pref = InsecureRandRange(peers + 1) ; // Some preferred, ...\n+    int num_npref = peers - num_pref; // some not preferred.\n+    for (int i = 0; i < num_pref; ++i) {\n+        pref_peers.push_back(scenario.NewPeer());\n+        preferred[pref_peers.back()] = true;\n+    }\n+    for (int i = 0; i < num_npref; ++i) {\n+        npref_peers.push_back(scenario.NewPeer());\n+        preferred[npref_peers.back()] = false;\n+    }\n+    // Make a list of all peers, in order of intended request order (concatenation of pref_peers and\n+    // npref_peers).\n+    std::vector<uint64_t> request_order;\n+    for (int i = 0; i < num_pref; ++i) request_order.push_back(pref_peers[i]);\n+    for (int i = 0; i < num_npref; ++i) request_order.push_back(npref_peers[i]);\n+\n+    // Setup pref_order\n+    for (int i = 0; i < num_pref; ++i) {\n+        pref_order.push_back(pref_peers[i]);\n+    }\n+\n+    // Setup npref_order\n+    for (int i = 0; i < num_npref; ++i) {\n+        npref_order.push_back(npref_peers[i]);\n+    }\n+\n+    // Determine the announcement order randomly.\n+    std::vector<uint64_t> announce_order = request_order;\n+    Shuffle(announce_order.begin(), announce_order.end(), g_insecure_rand_ctx);\n+\n+    // Find a gtxid that has a prioritization consistent with the required pref_order and npref_order.\n+    auto gtxid = scenario.NewGTxid({pref_order, npref_order});\n+\n+    // Decide reqtimes in opposite order of the eventual request order. So every time time jumps",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499107610",
      "id" : 499107610,
      "in_reply_to_id" : 498956144,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwNzYxMA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 353,
      "original_position" : 353,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 501513899,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499107610",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499127674"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499127674"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In a TxRequestTracker with N peers and 5000 (unique) txids each, in a stable state (where `GetRequestable` returns nothing):\r\n* N=10, around 50 ns per `GetRequestable`.\r\n* N=20, 60 ns\r\n* N=50, 80 ns\r\n* N=100, 90 ns\r\n* N=200, 180 ns\r\n* N=500, 230 ns\r\n* N=1000, 240 ns\r\n* N=2000, 500 ns.\r\n* N=20000, 1500 ns.\r\n\r\n(these numbers grow much faster than what would be expected from O(log n) growth, but I suspect memory hierarchy effects play a role)\r\n\r\nFWIW, calling ReceivedInv 500000 times in a row takes around 1us per call.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-03T08:15:53Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo entries exist with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+\n+            // Looking up the last ByTxHash entry with the given txhash must return an Entry with that txhash or the\n+            // multi_index is very bad.\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{item.first, State::TOO_LARGE, 0}));\n+            assert(it_last != m_index.get<ByTxHash>().end() && it_last->m_txhash == item.first);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+\n+private:\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txhash that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txhash already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = m_computer(*std::prev(it));\n+            uint64_t priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in\n+            // the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Entry for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED entries.\n+\n+        // If this Entry's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Entry's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txhash, they are\n+     *  deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+     *  CANDIDATE_BEST. Returns whether the Entry still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED entry for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the entry COMPLETED, and select the next best entry (the first CANDIDATE_READY) if needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to EntryTxHashExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(EntryPeerExtractor(), std::less<EntryPeer>()),\n+            boost::make_tuple(EntryTxHashExtractor(m_computer), std::less<EntryTxHash>()),\n+            boost::make_tuple(EntryTimeExtractor(), std::less<EntryTime>())\n+        )) {}\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxHashExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+            // CANDIDATE_BEST, or delete all of a txhash's entries if no non-COMPLETED ones are left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(EntryTxHash{txhash, State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST entry for this (txhash, peer) combination. The case where\n+        // there is a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+        // automatically.\n+        if (m_index.get<ByPeer>().count(EntryPeer{peer, true, gtxid.GetHash()})) return;\n+\n+        // Find last entry for this txhash, and extract per-txhash information from it.\n+        Iter<ByTxHash> it_last = m_index.get<ByTxHash>().end();\n+        // First find the first entry past this txhash.\n+        it_last = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0});\n+        if (it_last != m_index.get<ByTxHash>().begin() && std::prev(it_last)->m_txhash == gtxid.GetHash()) {\n+            it_last--;\n+        } else {\n+            // No entry for this txhash exists yet.\n+            it_last = m_index.get<ByTxHash>().end();\n+        }\n+\n+        // Try creating the entry with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST entry already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_sequence);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+    }\n+\n+    //! Find the GenTxids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now)\n+    {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499127674",
      "id" : 499127674,
      "in_reply_to_id" : 498781706,
      "line" : 579,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEyNzY3NA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 579,
      "original_position" : 561,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 579,
      "pull_request_review_id" : 501529921,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499127674",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499130027"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499130027"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think that ~without~ following this change all the remaining asserts are redundant internal checks, rather than \"invalid use of API\" ones, which I think is a plus. Also makes perfect sense (in retrospect) that that would then make the fuzz tester a bunch simpler.\r\n\r\nI think that means that you can call TxRequestTracker methods with any params and the behaviours well-defined, reasonably logical, and as efficient as possible. I think this even maintains the amortized complexity, which surprises me.\r\n\r\nSo yeah, I like this! Maybe change the \"There is no CANDIDATE_BEST entry\" comment to note that this path only occurs if the API caller requests an txid that wasn't just returned from `GetRequestable` -- ie, they either have a bug due to a race condition of not dealing with the results of GetRequestable for one peer before calling it again later, or they're doing their own selection of which announcement to request beyond relying on TxRequestTracker's algorithm?\r\n\r\nMaybe the \"give up\"  case would be clearer if there was a bit more of the \"why\" spelled out too?\r\n\r\n```c++\r\n            if (it == m_index.get<ByPeer>().end()) {\r\n                // This txid wasn't tracked for this peer; caller should have called ReceivedInv() first.\r\n                return;\r\n            } else if (it->GetState() != State::CANDIDATE_DELAYED && it->GetState() != State::CANDIDATE_READY)) {\r\n                // Only progress to REQUESTED from CANDIDATE to ensure the state machine is finite\r\n                return;\r\n           }\r\n```",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-03T08:54:13Z",
      "diff_hunk" : "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction. Note that this only works\n+ *              per txhash, so if the same transaction is announced both through txid and wtxid, we have no means\n+ *              to prevent fetching both (the caller can however mitigate this by delaying one, see further).\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten only:\n+ *   - If a peer goes offline, all its announcements are forgotten.\n+ *   - If a transaction has been successfully received, or is otherwise no longer needed, the caller can call\n+ *     ForgetTxHash, which removes all announcements across all peers with the specified txhash.\n+ *   - If for a given txhash only already-requested announcements remain, they are all forgotten.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening transaction censoring attacks. The flip side is that as long as an attacker manages\n+ *              to prevent us from receiving a transaction, failed announcements (including those from honest peers)\n+ *              will linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a\n+ *              cap on the number of tracked announcements per peer. As failed requests in response to announcements\n+ *              from honest peers should be rare, this almost solely hinders attackers.\n+ *              Transaction censoring attacks can be done by announcing transactions quickly while not answering\n+ *              requests for them. See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more\n+ *              information.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable the calling code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers are more trusted by us, so are less likely to be under attacker control.\n+ *\n+ *   - Pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: random assignments are hard to influence for attackers.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and minimizing\n+ * susceptibility to censorship attacks. An attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one preferred connection).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution). The \"1 +\" is due to the fact that the\n+ *   attacker can be the first to announce through a preferred connection in this scenario, which very likely means\n+ *   they get the first request.\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh>=1\n+ *   are honest, where we assume that the attacker can disconnect and reconnect those connections, the distribution\n+ *   becomes k ~ P + NB(p=1-NP/NPh,r=1) (where NB stands for Negative Binomial distribution), which has mean\n+ *   P-1+NP/NPh.\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, and a NOTFOUND or a\n+    //   transaction was received in response (valid or not), or they timed out. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DisconnectedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash (both txid and wtxid ones).\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it.\n+     */\n+    void ForgetTxHash(const uint256& txhash);\n+\n+    /** Adds a new CANDIDATE announcement.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that the txid/wtxid property is ignored for determining uniqueness, so if an announcement\n+     * is added for a wtxid H, while one for txid H from the same peer already exists, it will be ignored. This is\n+     * harmless as the txhashes being equal implies it is a non-segwit transaction, so it doesn't matter how it is\n+     * fetched. The new announcement is given the specified preferred and reqtime values, and takes it is_wtxid from\n+     * the specified gtxid.\n+     */\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime);\n+\n+    /** Converts the CANDIDATE announcement for the provided peer and gtxid into a REQUESTED one.\n+     *\n+     * Expiry is set to the specified value. This can ONLY be called immediately after GetRequestable was called\n+     * (for the same peer), with only ForgetTx and other RequestedTx calls (both for other txhashes) in\n+     * between. Any other non-const operation removes the ability to call RequestedTx.\n+     */\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds expiry);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499130027",
      "id" : 499130027,
      "in_reply_to_id" : 498734530,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEzMDAyNw==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 151,
      "original_position" : 151,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 501531807,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499130027",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499173475"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499173475"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done, switched to the fully-defined version (squashed into the appropriate commits). I added some of @ajtowns's comments, and more.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-03T19:03:27Z",
      "diff_hunk" : "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction. Note that this only works\n+ *              per txhash, so if the same transaction is announced both through txid and wtxid, we have no means\n+ *              to prevent fetching both (the caller can however mitigate this by delaying one, see further).\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten only:\n+ *   - If a peer goes offline, all its announcements are forgotten.\n+ *   - If a transaction has been successfully received, or is otherwise no longer needed, the caller can call\n+ *     ForgetTxHash, which removes all announcements across all peers with the specified txhash.\n+ *   - If for a given txhash only already-requested announcements remain, they are all forgotten.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening transaction censoring attacks. The flip side is that as long as an attacker manages\n+ *              to prevent us from receiving a transaction, failed announcements (including those from honest peers)\n+ *              will linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a\n+ *              cap on the number of tracked announcements per peer. As failed requests in response to announcements\n+ *              from honest peers should be rare, this almost solely hinders attackers.\n+ *              Transaction censoring attacks can be done by announcing transactions quickly while not answering\n+ *              requests for them. See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more\n+ *              information.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable the calling code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers are more trusted by us, so are less likely to be under attacker control.\n+ *\n+ *   - Pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: random assignments are hard to influence for attackers.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and minimizing\n+ * susceptibility to censorship attacks. An attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one preferred connection).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution). The \"1 +\" is due to the fact that the\n+ *   attacker can be the first to announce through a preferred connection in this scenario, which very likely means\n+ *   they get the first request.\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh>=1\n+ *   are honest, where we assume that the attacker can disconnect and reconnect those connections, the distribution\n+ *   becomes k ~ P + NB(p=1-NP/NPh,r=1) (where NB stands for Negative Binomial distribution), which has mean\n+ *   P-1+NP/NPh.\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, and a NOTFOUND or a\n+    //   transaction was received in response (valid or not), or they timed out. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DisconnectedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash (both txid and wtxid ones).\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it.\n+     */\n+    void ForgetTxHash(const uint256& txhash);\n+\n+    /** Adds a new CANDIDATE announcement.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that the txid/wtxid property is ignored for determining uniqueness, so if an announcement\n+     * is added for a wtxid H, while one for txid H from the same peer already exists, it will be ignored. This is\n+     * harmless as the txhashes being equal implies it is a non-segwit transaction, so it doesn't matter how it is\n+     * fetched. The new announcement is given the specified preferred and reqtime values, and takes it is_wtxid from\n+     * the specified gtxid.\n+     */\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime);\n+\n+    /** Converts the CANDIDATE announcement for the provided peer and gtxid into a REQUESTED one.\n+     *\n+     * Expiry is set to the specified value. This can ONLY be called immediately after GetRequestable was called\n+     * (for the same peer), with only ForgetTx and other RequestedTx calls (both for other txhashes) in\n+     * between. Any other non-const operation removes the ability to call RequestedTx.\n+     */\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds expiry);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499173475",
      "id" : 499173475,
      "in_reply_to_id" : 498734530,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3MzQ3NQ==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 151,
      "original_position" : 151,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 501567441,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499173475",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499223778"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499223778"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Another benchmark: I tweaked the unit test:\r\n* Run all tests 12000 times\r\n* Sanity checks turned off\r\n* Randomly removed 90% of GetRequestable calls (there is a far from representative number of them otherwise).\r\n\r\n... and then timed the actual execution of the queued actions, and while gathering statistics about the number of calls, and the Size() of the data structure:\r\n* Runtime: 7.38015 s\r\n* Size: 620626 +- 177327\r\n* ReceivedInvs calls: 6494712\r\n* RequestedTx calls: 678552\r\n* ReceivedResponse calls: 2664704\r\n* DisconnectedPeer calls: 3490732\r\n* ForgetTxHash calls: 145404\r\n* GetRequestable calls: 3581653\r\n\r\nSo the size is relatively close to 625000 (the limit at 5000 tx/peer, 125 peers). The scenarios themselves are not representative for this, as they have far fewer transactions per peer. However, I believe there is reason to assume that the number of tx/peer doesn't matter (except for the peak latency of DisconnectedPeer, but averaged out, it's still amortized).\r\n\r\nSo this means that the average time per announcement (summed over all calls affecting that announcement) in these scenarios (which may be nonrepresentative) is around 1.1 us/announcement.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-04T09:12:42Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo entries exist with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+\n+            // Looking up the last ByTxHash entry with the given txhash must return an Entry with that txhash or the\n+            // multi_index is very bad.\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{item.first, State::TOO_LARGE, 0}));\n+            assert(it_last != m_index.get<ByTxHash>().end() && it_last->m_txhash == item.first);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+\n+private:\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txhash that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txhash already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = m_computer(*std::prev(it));\n+            uint64_t priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in\n+            // the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Entry for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED entries.\n+\n+        // If this Entry's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Entry's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txhash, they are\n+     *  deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+     *  CANDIDATE_BEST. Returns whether the Entry still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED entry for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the entry COMPLETED, and select the next best entry (the first CANDIDATE_READY) if needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to EntryTxHashExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(EntryPeerExtractor(), std::less<EntryPeer>()),\n+            boost::make_tuple(EntryTxHashExtractor(m_computer), std::less<EntryTxHash>()),\n+            boost::make_tuple(EntryTimeExtractor(), std::less<EntryTime>())\n+        )) {}\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxHashExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+            // CANDIDATE_BEST, or delete all of a txhash's entries if no non-COMPLETED ones are left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(EntryTxHash{txhash, State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST entry for this (txhash, peer) combination. The case where\n+        // there is a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+        // automatically.\n+        if (m_index.get<ByPeer>().count(EntryPeer{peer, true, gtxid.GetHash()})) return;\n+\n+        // Find last entry for this txhash, and extract per-txhash information from it.\n+        Iter<ByTxHash> it_last = m_index.get<ByTxHash>().end();\n+        // First find the first entry past this txhash.\n+        it_last = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0});\n+        if (it_last != m_index.get<ByTxHash>().begin() && std::prev(it_last)->m_txhash == gtxid.GetHash()) {\n+            it_last--;\n+        } else {\n+            // No entry for this txhash exists yet.\n+            it_last = m_index.get<ByTxHash>().end();\n+        }\n+\n+        // Try creating the entry with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST entry already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_sequence);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+    }\n+\n+    //! Find the GenTxids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now)\n+    {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499223778",
      "id" : 499223778,
      "in_reply_to_id" : 498781706,
      "line" : 579,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIyMzc3OA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 579,
      "original_position" : 561,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 579,
      "pull_request_review_id" : 501604914,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499223778",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499455683"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499455683"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yeah, I understood the sorting step, and was just wondering why not create a vector of (seq, gtxid) pairs. As you point out, you'd still need an extraction (copy) step afterwards, so that seems less efficient.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T09:17:38Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo entries exist with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+\n+            // Looking up the last ByTxHash entry with the given txhash must return an Entry with that txhash or the\n+            // multi_index is very bad.\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{item.first, State::TOO_LARGE, 0}));\n+            assert(it_last != m_index.get<ByTxHash>().end() && it_last->m_txhash == item.first);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+\n+private:\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txhash that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txhash already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = m_computer(*std::prev(it));\n+            uint64_t priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in\n+            // the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Entry for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED entries.\n+\n+        // If this Entry's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Entry's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txhash, they are\n+     *  deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+     *  CANDIDATE_BEST. Returns whether the Entry still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED entry for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the entry COMPLETED, and select the next best entry (the first CANDIDATE_READY) if needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to EntryTxHashExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(EntryPeerExtractor(), std::less<EntryPeer>()),\n+            boost::make_tuple(EntryTxHashExtractor(m_computer), std::less<EntryTxHash>()),\n+            boost::make_tuple(EntryTimeExtractor(), std::less<EntryTime>())\n+        )) {}\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxHashExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+            // CANDIDATE_BEST, or delete all of a txhash's entries if no non-COMPLETED ones are left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(EntryTxHash{txhash, State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST entry for this (txhash, peer) combination. The case where\n+        // there is a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+        // automatically.\n+        if (m_index.get<ByPeer>().count(EntryPeer{peer, true, gtxid.GetHash()})) return;\n+\n+        // Find last entry for this txhash, and extract per-txhash information from it.\n+        Iter<ByTxHash> it_last = m_index.get<ByTxHash>().end();\n+        // First find the first entry past this txhash.\n+        it_last = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0});\n+        if (it_last != m_index.get<ByTxHash>().begin() && std::prev(it_last)->m_txhash == gtxid.GetHash()) {\n+            it_last--;\n+        } else {\n+            // No entry for this txhash exists yet.\n+            it_last = m_index.get<ByTxHash>().end();\n+        }\n+\n+        // Try creating the entry with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST entry already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_sequence);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+    }\n+\n+    //! Find the GenTxids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now)\n+    {\n+        // Move time.\n+        SetTimePoint(now);\n+\n+        // Find all CANDIDATE_BEST entries for this peer.\n+        std::vector<std::pair<uint64_t, const Entry*>> selected;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499455683",
      "id" : 499455683,
      "in_reply_to_id" : 498784855,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1NTY4Mw==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 566,
      "original_position" : 566,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 501866056,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499455683",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499465538"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499465538"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Oops. Confused myself with the gtxid constructors. These are indeed different!\r\n\r\nThanks for removing the for loop. Makes it a lot clearer what's going on.\r\n\r\nIt would be better if these lines were above the `TxValidationState state;` declaration, but that's maybe unrelated to this PR, since the code you're replacing should also have been above that declaration.\r\n",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T09:32:13Z",
      "diff_hunk" : "@@ -2994,9 +2898,7 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n         TxValidationState state;\n \n         for (const GenTxid& gtxid : {GenTxid(false, txid), GenTxid(true, wtxid)}) {\n-            nodestate->m_tx_download.m_tx_announced.erase(gtxid.GetHash());\n-            nodestate->m_tx_download.m_tx_in_flight.erase(gtxid.GetHash());\n-            EraseTxRequest(gtxid);\n+            m_txrequest.ReceivedResponse(pfrom.GetId(), gtxid);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499465538",
      "id" : 499465538,
      "in_reply_to_id" : 498773268,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ2NTUzOA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 2901,
      "original_position" : 276,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 501878646,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499465538",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499468847"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499468847"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think we'll also enter this branch if there's an announcement for this peer/txhash that's REQUESTED or COMPLETE. If that's true, I think we should update the comment to \"The txhash was not tracked for this peer or has already been requested from this peer...\"",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T09:37:27Z",
      "diff_hunk" : "@@ -0,0 +1,716 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of ByTxHashView relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE announcement whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED announcement already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority announcement among all CANDIDATE_READY (and _BEST) ones for that\n+     *  txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED announcement. */\n+    REQUESTED,\n+    /** A CANDIDATE announcement that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED announcement. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+//! Type alias for sequence numbers.\n+using SequenceNumber = uint64_t;\n+\n+/** An announcement. This is the data we track for each txid or wtxid that is announced to us by each peer. */\n+struct Announcement {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const NodeId m_peer;\n+    /** What sequence number this announcement has. */\n+    const SequenceNumber m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this announcement is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this announcement is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this announcement can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new announcement from scratch, initially in CANDIDATE_DELAYED state. */\n+    Announcement(const GenTxid& gtxid, NodeId peer, bool preferred, std::chrono::microseconds reqtime,\n+        SequenceNumber sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+//! Type alias for priorities.\n+using Priority = uint64_t;\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    Priority operator()(const uint256& txhash, NodeId peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    Priority operator()(const Announcement& ann) const\n+    {\n+        return operator()(ann.m_txhash, ann.m_peer, ann.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a By*View data type to represent the view of Announcement it is sorted\n+// by, and an By*ViewExtractor type to convert an Announcement into the By*View type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing announcements by peer/txhash, by checking both (peer, false, txhash) and\n+//   (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST announcements for a given peer in GetRequestable.\n+struct ByPeer {};\n+using ByPeerView = std::tuple<NodeId, bool, const uint256&>;\n+struct ByPeerViewExtractor\n+{\n+    using result_type = ByPeerView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByPeerView{ann.m_peer, ann.GetState() == State::CANDIDATE_BEST, ann.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Announcements with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Announcement exists for that txhash.\n+// * Determining when no more non-COMPLETED Announcements for a given txhash exist, so the COMPLETED ones can be\n+//   deleted.\n+struct ByTxHash {};\n+using ByTxHashView = std::tuple<const uint256&, State, Priority>;\n+class ByTxHashViewExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    ByTxHashViewExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = ByTxHashView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        const State state = ann.GetState();\n+        const Priority prio = (state == State::CANDIDATE_READY) ? m_computer(ann) : 0;\n+        return ByTxHashView{ann.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED announcements whose reqtime has passed, and REQUESTED announcements whose expiry has\n+//   passed.\n+// * Finding CANDIDATE_READY/BEST announcements whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using ByTimeView = std::pair<int, std::chrono::microseconds>;\n+struct ByTimeViewExtractor\n+{\n+    using result_type = ByTimeView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByTimeView{ann.IsWaiting() ? 0 : ann.IsSelectable() ? 2 : 1, ann.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Announcement objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Announcement,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, ByPeerViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, ByTxHashViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, ByTimeViewExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of announcements for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED announcements for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED announcements for this peer.\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST announcement if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an announcement for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** Compare two PeerInfo objects. Only used for sanity checking. */\n+bool operator==(const PeerInfo& a, const PeerInfo& b)\n+{\n+    return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+           std::tie(b.m_total, b.m_completed, b.m_requested);\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<NodeId, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<NodeId, PeerInfo> ret;\n+    for (const Announcement& ann : index) {\n+        PeerInfo& info = ret[ann.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (ann.GetState() == State::REQUESTED);\n+        info.m_completed += (ann.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Announcement& ann : index) {\n+        TxHashInfo& info = ret[ann.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (ann.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (ann.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (ann.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (ann.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (ann.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(ann);\n+        }\n+        if (ann.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(ann));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(ann.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    SequenceNumber m_current_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure. See SanityCheck() for the invariants that apply to it.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<NodeId, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo entries exist with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // announcement.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST announcement, the CANDIDATE_BEST one must be\n+            // at least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+\n+            // Looking up the last ByTxHash announcement with the given txhash must return an Announcement with that\n+            // txhash or the multi_index is very bad.\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                ByTxHashView{item.first, State::TOO_LARGE, 0}));\n+            assert(it_last != m_index.get<ByTxHash>().end() && it_last->m_txhash == item.first);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const Announcement& ann : m_index) {\n+            if (ann.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(ann.m_time > now);\n+            } else if (ann.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(ann.m_time <= now);\n+            }\n+        }\n+    }\n+\n+private:\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED announcement into a CANDIDATE_READY. If this makes it the new best\n+    //! CANDIDATE_READY (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new\n+    //! CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY announcements, the best one (lowest\n+        // priority) comes first. Thus, if an existing _BEST exists for the same txhash that this announcement may\n+        // be preferred over, it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() announcement for this txhash\n+            // already.\n+            Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            Priority priority_old = m_computer(*std::prev(it));\n+            Priority priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST announcement already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an announcement to something non-IsSelected(). If it was IsSelected(), the next best\n+    //! announcement will be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST\n+            // announcement in the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Announcement& ann){ ann.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Announcement for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED announcements.\n+\n+        // If this Announcement's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Announcement's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any announcement to a COMPLETED one. If there are no non-COMPLETED announcements left for this\n+     *  txhash, they are deleted. If this was a REQUESTED announcement, and there are other CANDIDATEs left, the\n+     *  best one is made CANDIDATE_BEST. Returns whether the Announcement still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED announcement for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the announcement COMPLETED, and select the next best announcement (the first CANDIDATE_READY) if\n+        // needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED annoucements with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED announcements with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} announcements with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY announcements back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to ByTxHashViewExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(ByPeerViewExtractor(), std::less<ByPeerView>()),\n+            boost::make_tuple(ByTxHashViewExtractor(m_computer), std::less<ByTxHashView>()),\n+            boost::make_tuple(ByTimeViewExtractor(), std::less<ByTimeView>())\n+        )) {}\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful ByTxHashViewExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DisconnectedPeer(NodeId peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(ByPeerView{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the announcement isn't already COMPLETED, first make it COMPLETED (which will mark other\n+            // CANDIDATEs as CANDIDATE_BEST, or delete all of a txhash's announcements if no non-COMPLETED ones are\n+            // left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the announcement (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(ByTxHashView{txhash, State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(NodeId peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST announcement for this (txhash, peer) combination. The case\n+        // where there is a non-CANDIDATE_BEST announcement already will be caught by the uniqueness property of the\n+        // ByPeer index when we try to emplace the new object below.\n+        if (m_index.get<ByPeer>().count(ByPeerView{peer, true, gtxid.GetHash()})) return;\n+\n+        // Try creating the announcement with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST announcement already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_current_sequence);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_current_sequence;\n+    }\n+\n+    //! Find the GenTxids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(NodeId peer, std::chrono::microseconds now)\n+    {\n+        // Move time.\n+        SetTimePoint(now);\n+\n+        // Find all CANDIDATE_BEST announcements for this peer.\n+        std::vector<std::pair<SequenceNumber, const Announcement*>> selected;\n+        auto it_peer = m_index.get<ByPeer>().lower_bound(ByPeerView{peer, true, UINT256_ZERO});\n+        while (it_peer != m_index.get<ByPeer>().end() && it_peer->m_peer == peer &&\n+            it_peer->GetState() == State::CANDIDATE_BEST) {\n+            selected.emplace_back(it_peer->m_sequence, &*it_peer);\n+            ++it_peer;\n+        }\n+\n+        // Return them, sorted by sequence number.\n+        std::sort(selected.begin(), selected.end());\n+        std::vector<GenTxid> ret;\n+        for (const auto& item : selected) {\n+            ret.emplace_back(item.second->m_is_wtxid, item.second->m_txhash);\n+        }\n+        return ret;\n+    }\n+\n+    void RequestedTx(NodeId peer, const uint256& txhash, std::chrono::microseconds expiry)\n+    {\n+        auto it = m_index.get<ByPeer>().find(ByPeerView{peer, true, txhash});\n+        if (it == m_index.get<ByPeer>().end()) {\n+            // There is no CANDIDATE_BEST announcement, look for a _READY or _DELAYED instead. If the caller only\n+            // ever invokes RequestedTx with the values returned by GetRequestable, and no other non-const functions\n+            // other than ForgetTxHash and GetRequestable in between, this branch will never execute (as txhashes\n+            // returned by GetRequestable always correspond to CANDIDATE_BEST announcements).\n+\n+            it = m_index.get<ByPeer>().find(ByPeerView{peer, false, txhash});\n+            if (it == m_index.get<ByPeer>().end() || (it->GetState() != State::CANDIDATE_DELAYED &&\n+                it->GetState() != State::CANDIDATE_READY)) {\n+                // The txhash was not tracked for this peer, so we have nothing to do. The caller should have called",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499468847",
      "id" : 499468847,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ2ODg0Nw==",
      "original_commit_id" : "6fa4512fb450d709006fd6b242975fd3ce2f5340",
      "original_line" : 602,
      "original_position" : 602,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 501882930,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499468847",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499469100"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499469100"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It's still here :)",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T09:37:57Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499469100",
      "id" : 499469100,
      "in_reply_to_id" : 498727923,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ2OTEwMA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 278,
      "original_position" : 269,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 501882930,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499469100",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499479782"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499479782"
         }
      },
      "author_association" : "MEMBER",
      "body" : "These seem like good numbers.\r\n\r\nI was going to suggest moving`SetTimePoint()` out of `GetRequestable()` and only calling it once per message handler thread loop (e.g. in a global tasks function like https://github.com/bitcoin/bitcoin/pull/19364/commits/0ea9abf9b4c3694dede390b759df01c1ce0d3166), since it doesn't need to be called in the context of an individual peer, and it doesn't need to be called frequently. However, it doesn't seem like there's a good reason to do that from a performance standpoint.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T09:56:08Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo entries exist with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+\n+            // Looking up the last ByTxHash entry with the given txhash must return an Entry with that txhash or the\n+            // multi_index is very bad.\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{item.first, State::TOO_LARGE, 0}));\n+            assert(it_last != m_index.get<ByTxHash>().end() && it_last->m_txhash == item.first);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+\n+private:\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txhash that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txhash already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = m_computer(*std::prev(it));\n+            uint64_t priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in\n+            // the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Entry for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED entries.\n+\n+        // If this Entry's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Entry's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txhash, they are\n+     *  deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+     *  CANDIDATE_BEST. Returns whether the Entry still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED entry for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the entry COMPLETED, and select the next best entry (the first CANDIDATE_READY) if needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to EntryTxHashExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(EntryPeerExtractor(), std::less<EntryPeer>()),\n+            boost::make_tuple(EntryTxHashExtractor(m_computer), std::less<EntryTxHash>()),\n+            boost::make_tuple(EntryTimeExtractor(), std::less<EntryTime>())\n+        )) {}\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxHashExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+            // CANDIDATE_BEST, or delete all of a txhash's entries if no non-COMPLETED ones are left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(EntryTxHash{txhash, State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST entry for this (txhash, peer) combination. The case where\n+        // there is a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+        // automatically.\n+        if (m_index.get<ByPeer>().count(EntryPeer{peer, true, gtxid.GetHash()})) return;\n+\n+        // Find last entry for this txhash, and extract per-txhash information from it.\n+        Iter<ByTxHash> it_last = m_index.get<ByTxHash>().end();\n+        // First find the first entry past this txhash.\n+        it_last = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0});\n+        if (it_last != m_index.get<ByTxHash>().begin() && std::prev(it_last)->m_txhash == gtxid.GetHash()) {\n+            it_last--;\n+        } else {\n+            // No entry for this txhash exists yet.\n+            it_last = m_index.get<ByTxHash>().end();\n+        }\n+\n+        // Try creating the entry with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST entry already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_sequence);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+    }\n+\n+    //! Find the GenTxids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now)\n+    {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499479782",
      "id" : 499479782,
      "in_reply_to_id" : 498781706,
      "line" : 579,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ3OTc4Mg==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 579,
      "original_position" : 561,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 579,
      "pull_request_review_id" : 501882930,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499479782",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499480702"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499480702"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I also like this. Good change!",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T09:57:39Z",
      "diff_hunk" : "@@ -0,0 +1,200 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction. Note that this only works\n+ *              per txhash, so if the same transaction is announced both through txid and wtxid, we have no means\n+ *              to prevent fetching both (the caller can however mitigate this by delaying one, see further).\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten only:\n+ *   - If a peer goes offline, all its announcements are forgotten.\n+ *   - If a transaction has been successfully received, or is otherwise no longer needed, the caller can call\n+ *     ForgetTxHash, which removes all announcements across all peers with the specified txhash.\n+ *   - If for a given txhash only already-requested announcements remain, they are all forgotten.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening transaction censoring attacks. The flip side is that as long as an attacker manages\n+ *              to prevent us from receiving a transaction, failed announcements (including those from honest peers)\n+ *              will linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a\n+ *              cap on the number of tracked announcements per peer. As failed requests in response to announcements\n+ *              from honest peers should be rare, this almost solely hinders attackers.\n+ *              Transaction censoring attacks can be done by announcing transactions quickly while not answering\n+ *              requests for them. See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more\n+ *              information.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable the calling code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers are more trusted by us, so are less likely to be under attacker control.\n+ *\n+ *   - Pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: random assignments are hard to influence for attackers.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and minimizing\n+ * susceptibility to censorship attacks. An attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one preferred connection).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution). The \"1 +\" is due to the fact that the\n+ *   attacker can be the first to announce through a preferred connection in this scenario, which very likely means\n+ *   they get the first request.\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh>=1\n+ *   are honest, where we assume that the attacker can disconnect and reconnect those connections, the distribution\n+ *   becomes k ~ P + NB(p=1-NP/NPh,r=1) (where NB stands for Negative Binomial distribution), which has mean\n+ *   P-1+NP/NPh.\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, and a NOTFOUND or a\n+    //   transaction was received in response (valid or not), or they timed out. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DisconnectedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash (both txid and wtxid ones).\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it.\n+     */\n+    void ForgetTxHash(const uint256& txhash);\n+\n+    /** Adds a new CANDIDATE announcement.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that the txid/wtxid property is ignored for determining uniqueness, so if an announcement\n+     * is added for a wtxid H, while one for txid H from the same peer already exists, it will be ignored. This is\n+     * harmless as the txhashes being equal implies it is a non-segwit transaction, so it doesn't matter how it is\n+     * fetched. The new announcement is given the specified preferred and reqtime values, and takes it is_wtxid from\n+     * the specified gtxid.\n+     */\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime);\n+\n+    /** Converts the CANDIDATE announcement for the provided peer and gtxid into a REQUESTED one.\n+     *\n+     * Expiry is set to the specified value. This can ONLY be called immediately after GetRequestable was called\n+     * (for the same peer), with only ForgetTx and other RequestedTx calls (both for other txhashes) in\n+     * between. Any other non-const operation removes the ability to call RequestedTx.\n+     */\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds expiry);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499480702",
      "id" : 499480702,
      "in_reply_to_id" : 498734530,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ4MDcwMg==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 151,
      "original_position" : 151,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 501882930,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499480702",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499493545"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499493545"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n            assert(it_last != m_index.get<ByTxHash>().begin() && it_last->m_txhash == item.first);\r\n```\r\n\r\n`it_last` is the return value of a `std::prev()` call, so I think by definition it can't be the `end` iterator.\r\n\r\nAlternatively you could do something like:\r\n\r\n```\r\n            auto it_last = m_index.get<ByTxHash>().upper_bound(\r\n                ByTxHashView{item.first, State::COMPLETED, <max uint256>}));\r\n            assert(it_last != m_index.get<ByTxHash>().end() && it_last->m_txhash == item.first);\r\n            auto it_next = std::next(it_last);\r\n            assert(it_next == m_index.get<ByTxHash>().end() || it_next->m_txhash != item.first);\r\n```\r\n\r\n(which would remove the need for a dummy `TOO_LARGE` entry in the State enum).",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T10:20:50Z",
      "diff_hunk" : "@@ -0,0 +1,716 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of ByTxHashView relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE announcement whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED announcement already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority announcement among all CANDIDATE_READY (and _BEST) ones for that\n+     *  txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED announcement. */\n+    REQUESTED,\n+    /** A CANDIDATE announcement that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED announcement. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+//! Type alias for sequence numbers.\n+using SequenceNumber = uint64_t;\n+\n+/** An announcement. This is the data we track for each txid or wtxid that is announced to us by each peer. */\n+struct Announcement {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const NodeId m_peer;\n+    /** What sequence number this announcement has. */\n+    const SequenceNumber m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this announcement is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this announcement is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this announcement can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new announcement from scratch, initially in CANDIDATE_DELAYED state. */\n+    Announcement(const GenTxid& gtxid, NodeId peer, bool preferred, std::chrono::microseconds reqtime,\n+        SequenceNumber sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+//! Type alias for priorities.\n+using Priority = uint64_t;\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    Priority operator()(const uint256& txhash, NodeId peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    Priority operator()(const Announcement& ann) const\n+    {\n+        return operator()(ann.m_txhash, ann.m_peer, ann.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a By*View data type to represent the view of Announcement it is sorted\n+// by, and an By*ViewExtractor type to convert an Announcement into the By*View type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing announcements by peer/txhash, by checking both (peer, false, txhash) and\n+//   (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST announcements for a given peer in GetRequestable.\n+struct ByPeer {};\n+using ByPeerView = std::tuple<NodeId, bool, const uint256&>;\n+struct ByPeerViewExtractor\n+{\n+    using result_type = ByPeerView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByPeerView{ann.m_peer, ann.GetState() == State::CANDIDATE_BEST, ann.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Announcements with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Announcement exists for that txhash.\n+// * Determining when no more non-COMPLETED Announcements for a given txhash exist, so the COMPLETED ones can be\n+//   deleted.\n+struct ByTxHash {};\n+using ByTxHashView = std::tuple<const uint256&, State, Priority>;\n+class ByTxHashViewExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    ByTxHashViewExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = ByTxHashView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        const State state = ann.GetState();\n+        const Priority prio = (state == State::CANDIDATE_READY) ? m_computer(ann) : 0;\n+        return ByTxHashView{ann.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED announcements whose reqtime has passed, and REQUESTED announcements whose expiry has\n+//   passed.\n+// * Finding CANDIDATE_READY/BEST announcements whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using ByTimeView = std::pair<int, std::chrono::microseconds>;\n+struct ByTimeViewExtractor\n+{\n+    using result_type = ByTimeView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByTimeView{ann.IsWaiting() ? 0 : ann.IsSelectable() ? 2 : 1, ann.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Announcement objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Announcement,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, ByPeerViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, ByTxHashViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, ByTimeViewExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of announcements for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED announcements for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED announcements for this peer.\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST announcement if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an announcement for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** Compare two PeerInfo objects. Only used for sanity checking. */\n+bool operator==(const PeerInfo& a, const PeerInfo& b)\n+{\n+    return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+           std::tie(b.m_total, b.m_completed, b.m_requested);\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<NodeId, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<NodeId, PeerInfo> ret;\n+    for (const Announcement& ann : index) {\n+        PeerInfo& info = ret[ann.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (ann.GetState() == State::REQUESTED);\n+        info.m_completed += (ann.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Announcement& ann : index) {\n+        TxHashInfo& info = ret[ann.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (ann.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (ann.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (ann.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (ann.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (ann.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(ann);\n+        }\n+        if (ann.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(ann));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(ann.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    SequenceNumber m_current_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure. See SanityCheck() for the invariants that apply to it.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<NodeId, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo entries exist with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // announcement.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST announcement, the CANDIDATE_BEST one must be\n+            // at least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+\n+            // Looking up the last ByTxHash announcement with the given txhash must return an Announcement with that\n+            // txhash or the multi_index is very bad.\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                ByTxHashView{item.first, State::TOO_LARGE, 0}));\n+            assert(it_last != m_index.get<ByTxHash>().end() && it_last->m_txhash == item.first);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499493545",
      "id" : 499493545,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ5MzU0NQ==",
      "original_commit_id" : "6fa4512fb450d709006fd6b242975fd3ce2f5340",
      "original_line" : 339,
      "original_position" : 339,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 501915024,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499493545",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499503606"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499503606"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think `AddTxAnnouncement` or similar would be a better name for this function. Calling this function does not imply that we'll ever request the transaction from this peer.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T10:39:20Z",
      "diff_hunk" : "@@ -816,73 +750,34 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499503606",
      "id" : 499503606,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUwMzYwNg==",
      "original_commit_id" : "6fa4512fb450d709006fd6b242975fd3ce2f5340",
      "original_line" : 755,
      "original_position" : 185,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 501915024,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499503606",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499505840"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499505840"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Move this two lines down (so it's immediately above the one place where `overloaded` is used).\r\n\r\nCould also mark these two bools as `const`, but meh.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T10:43:42Z",
      "diff_hunk" : "@@ -816,73 +750,34 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest\n+    NodeId nodeid = node.GetId();\n+    if (!node.HasPermission(PF_RELAY) && m_txrequest.Count(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or PF_NOBAN permission)\n+    // - \"reqtime\": current time plus delays for:\n+    //   - NONPREF_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for txid announcements while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from peers which have at least\n+    //     MAX_PEER_TX_IN_FLIGHT requests in flight (and don't have PF_RELAY).\n+    auto delay = std::chrono::microseconds{0};\n+    bool preferred = state->fPreferredDownload;\n+    bool overloaded = !node.HasPermission(PF_RELAY) && m_txrequest.CountInFlight(nodeid) >= MAX_PEER_TX_IN_FLIGHT;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499505840",
      "id" : 499505840,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUwNTg0MA==",
      "original_commit_id" : "6fa4512fb450d709006fd6b242975fd3ce2f5340",
      "original_line" : 774,
      "original_position" : 217,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 501915024,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499505840",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499507369"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499507369"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This comment is now wrong.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T10:46:45Z",
      "diff_hunk" : "@@ -3772,22 +3685,14 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n     if (msg_type == NetMsgType::NOTFOUND) {\n         // Remove the NOTFOUND transactions from the peer\n         LOCK(cs_main);\n-        CNodeState *state = State(pfrom.GetId());\n         std::vector<CInv> vInv;\n         vRecv >> vInv;\n-        if (vInv.size() <= MAX_PEER_TX_IN_FLIGHT + MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+        if (vInv.size() <= MAX_PEER_TX_ANNOUNCEMENTS + MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n             for (CInv &inv : vInv) {\n                 if (inv.IsGenTxMsg()) {\n                     // If we receive a NOTFOUND message for a txid we requested, erase\n                     // it from our data structures for this peer.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499507369",
      "id" : 499507369,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUwNzM2OQ==",
      "original_commit_id" : "6fa4512fb450d709006fd6b242975fd3ce2f5340",
      "original_line" : 3694,
      "original_position" : 357,
      "original_start_line" : 3693,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 501915024,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499507369",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499511223"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499511223"
         }
      },
      "author_association" : "MEMBER",
      "body" : "A peer can cause us to do up to 5016 calls into `ReceivedResponse()` per `notfound` message, where each `RecievedResponse()` call results in two `find()` operations into the index that can be up to 625k. Is that likely to be costly?\r\n\r\nPreviously, the limit on `notfound` processing was 116 `find()` calls into a map of maxsize 100.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T10:54:44Z",
      "diff_hunk" : "@@ -3772,22 +3685,14 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n     if (msg_type == NetMsgType::NOTFOUND) {\n         // Remove the NOTFOUND transactions from the peer\n         LOCK(cs_main);\n-        CNodeState *state = State(pfrom.GetId());\n         std::vector<CInv> vInv;\n         vRecv >> vInv;\n-        if (vInv.size() <= MAX_PEER_TX_IN_FLIGHT + MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+        if (vInv.size() <= MAX_PEER_TX_ANNOUNCEMENTS + MAX_BLOCKS_IN_TRANSIT_PER_PEER) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499511223",
      "id" : 499511223,
      "line" : 3688,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUxMTIyMw==",
      "original_commit_id" : "6fa4512fb450d709006fd6b242975fd3ce2f5340",
      "original_line" : 3688,
      "original_position" : 353,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 363,
      "pull_request_review_id" : 501915024,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499511223",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499511969"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499511969"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Delete this comment.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T10:56:09Z",
      "diff_hunk" : "@@ -3772,22 +3685,14 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n     if (msg_type == NetMsgType::NOTFOUND) {\n         // Remove the NOTFOUND transactions from the peer",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499511969",
      "id" : 499511969,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUxMTk2OQ==",
      "original_commit_id" : "6fa4512fb450d709006fd6b242975fd3ce2f5340",
      "original_line" : 3686,
      "original_position" : 347,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 501915024,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499511969",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499512149"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499512149"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It doesn't make much difference, but this cs_main scope can now move down into the if block.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T10:56:30Z",
      "diff_hunk" : "@@ -3772,22 +3685,14 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n     if (msg_type == NetMsgType::NOTFOUND) {\n         // Remove the NOTFOUND transactions from the peer\n         LOCK(cs_main);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499512149",
      "id" : 499512149,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUxMjE0OQ==",
      "original_commit_id" : "6fa4512fb450d709006fd6b242975fd3ce2f5340",
      "original_line" : 3687,
      "original_position" : 348,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 501915024,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499512149",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499515932"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499515932"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Moving `SetTimePoint()` out of `GetRequestable()` might have better worst-case behaviour in the event of arbitrarily non-monotonic clocks In particular, currently you could have, say, two peers, peer=1 with no announcements, and peer=2 with N announcements all with a reqtime = t. If you call `GetRequestable(peer=1, now=t+1)` then you'll get an empty vector as the result, but update all N announcements to CANDIDATE_BEST, but if time goes backwards, and you then call `GetRequestable(peer=2, now=t-1)` you'll update all the announcements back to CANDIDATE_DELAYED, and all get an empty vector, and make no progress. If you did `SetTimePoint()` first, then called `GetRequestable()` for each peer without updating the timepoint, you'd either have `now=t-1` and not do any work, or you'd have `now=t+1` and would make forward progress. I think the constraint would be \"call SetTimePoint, then for each peer call GetRequestable, and for each resulting tx, call RequestedTx for it\" with the result being something along the lines of \"amortized time complexity is `O(log(max_concurrent_announcements))`\".\r\n\r\nFWIW, I think something along those lines is worth considering as a post-merge TODO -- perhaps as part of doing a fuzz tester for how net_processing uses txrequest or something, but don't think there is a need to hold things up for it.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T11:04:04Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo entries exist with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+\n+            // Looking up the last ByTxHash entry with the given txhash must return an Entry with that txhash or the\n+            // multi_index is very bad.\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{item.first, State::TOO_LARGE, 0}));\n+            assert(it_last != m_index.get<ByTxHash>().end() && it_last->m_txhash == item.first);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+\n+private:\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txhash that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txhash already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = m_computer(*std::prev(it));\n+            uint64_t priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in\n+            // the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Entry for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED entries.\n+\n+        // If this Entry's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Entry's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txhash, they are\n+     *  deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+     *  CANDIDATE_BEST. Returns whether the Entry still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED entry for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the entry COMPLETED, and select the next best entry (the first CANDIDATE_READY) if needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to EntryTxHashExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(EntryPeerExtractor(), std::less<EntryPeer>()),\n+            boost::make_tuple(EntryTxHashExtractor(m_computer), std::less<EntryTxHash>()),\n+            boost::make_tuple(EntryTimeExtractor(), std::less<EntryTime>())\n+        )) {}\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxHashExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+            // CANDIDATE_BEST, or delete all of a txhash's entries if no non-COMPLETED ones are left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(EntryTxHash{txhash, State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST entry for this (txhash, peer) combination. The case where\n+        // there is a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+        // automatically.\n+        if (m_index.get<ByPeer>().count(EntryPeer{peer, true, gtxid.GetHash()})) return;\n+\n+        // Find last entry for this txhash, and extract per-txhash information from it.\n+        Iter<ByTxHash> it_last = m_index.get<ByTxHash>().end();\n+        // First find the first entry past this txhash.\n+        it_last = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0});\n+        if (it_last != m_index.get<ByTxHash>().begin() && std::prev(it_last)->m_txhash == gtxid.GetHash()) {\n+            it_last--;\n+        } else {\n+            // No entry for this txhash exists yet.\n+            it_last = m_index.get<ByTxHash>().end();\n+        }\n+\n+        // Try creating the entry with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST entry already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_sequence);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+    }\n+\n+    //! Find the GenTxids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now)\n+    {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499515932",
      "id" : 499515932,
      "in_reply_to_id" : 498781706,
      "line" : 579,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUxNTkzMg==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 579,
      "original_position" : 561,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 579,
      "pull_request_review_id" : 501944132,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499515932",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499521161"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499521161"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I also have a slight preference that this is guarded by its own mutex since I don't like adding yet more non-validation state to cs_main, but agree that it should be straightforward to move it later.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T11:14:10Z",
      "diff_hunk" : "@@ -806,73 +740,35 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499521161",
      "id" : 499521161,
      "in_reply_to_id" : 497882360,
      "line" : 757,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUyMTE2MQ==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 757,
      "original_position" : 190,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 193,
      "pull_request_review_id" : 501915024,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499521161",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499523971"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499523971"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`(txhash, state, priority)` and \"Note, `priority == 0` whenever `state != CANDIDATE_READY`\" below might be clearer.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T11:19:41Z",
      "diff_hunk" : "@@ -0,0 +1,577 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of ByTxHashView relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE announcement whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED announcement already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority announcement among all CANDIDATE_READY (and _BEST) ones for that\n+     *  txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED announcement. */\n+    REQUESTED,\n+    /** A CANDIDATE announcement that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED announcement. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+//! Type alias for sequence numbers.\n+using SequenceNumber = uint64_t;\n+\n+/** An announcement. This is the data we track for each txid or wtxid that is announced to us by each peer. */\n+struct Announcement {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const NodeId m_peer;\n+    /** What sequence number this announcement has. */\n+    const SequenceNumber m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this announcement is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this announcement is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this announcement can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new announcement from scratch, initially in CANDIDATE_DELAYED state. */\n+    Announcement(const GenTxid& gtxid, NodeId peer, bool preferred, std::chrono::microseconds reqtime,\n+        SequenceNumber sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+//! Type alias for priorities.\n+using Priority = uint64_t;\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    Priority operator()(const uint256& txhash, NodeId peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    Priority operator()(const Announcement& ann) const\n+    {\n+        return operator()(ann.m_txhash, ann.m_peer, ann.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a By*View data type to represent the view of Announcement it is sorted\n+// by, and an By*ViewExtractor type to convert an Announcement into the By*View type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing announcements by peer/txhash, by checking both (peer, false, txhash) and\n+//   (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST announcements for a given peer in GetRequestable.\n+struct ByPeer {};\n+using ByPeerView = std::tuple<NodeId, bool, const uint256&>;\n+struct ByPeerViewExtractor\n+{\n+    using result_type = ByPeerView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByPeerView{ann.m_peer, ann.GetState() == State::CANDIDATE_BEST, ann.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499523971",
      "id" : 499523971,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUyMzk3MQ==",
      "original_commit_id" : "a60ad12fb9bac2e4a8fe9018754444d48ba817ea",
      "original_line" : 157,
      "original_position" : 157,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 501954745,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499523971",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499532324"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499532324"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`assert(new_state == COMPLETED || new_state == CANDIDATE_DELAYED);` ? The existing `assert(!it->IsSelected());` at the end would also allow `new_state == CANDIDATE_READY` which I don't think would be handled correctly (in that if it were the first READY, it should be assigned BEST but will not be).",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T11:35:22Z",
      "diff_hunk" : "@@ -0,0 +1,577 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of ByTxHashView relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE announcement whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED announcement already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority announcement among all CANDIDATE_READY (and _BEST) ones for that\n+     *  txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED announcement. */\n+    REQUESTED,\n+    /** A CANDIDATE announcement that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED announcement. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+//! Type alias for sequence numbers.\n+using SequenceNumber = uint64_t;\n+\n+/** An announcement. This is the data we track for each txid or wtxid that is announced to us by each peer. */\n+struct Announcement {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const NodeId m_peer;\n+    /** What sequence number this announcement has. */\n+    const SequenceNumber m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this announcement is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this announcement is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this announcement can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new announcement from scratch, initially in CANDIDATE_DELAYED state. */\n+    Announcement(const GenTxid& gtxid, NodeId peer, bool preferred, std::chrono::microseconds reqtime,\n+        SequenceNumber sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+//! Type alias for priorities.\n+using Priority = uint64_t;\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    Priority operator()(const uint256& txhash, NodeId peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    Priority operator()(const Announcement& ann) const\n+    {\n+        return operator()(ann.m_txhash, ann.m_peer, ann.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a By*View data type to represent the view of Announcement it is sorted\n+// by, and an By*ViewExtractor type to convert an Announcement into the By*View type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing announcements by peer/txhash, by checking both (peer, false, txhash) and\n+//   (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST announcements for a given peer in GetRequestable.\n+struct ByPeer {};\n+using ByPeerView = std::tuple<NodeId, bool, const uint256&>;\n+struct ByPeerViewExtractor\n+{\n+    using result_type = ByPeerView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByPeerView{ann.m_peer, ann.GetState() == State::CANDIDATE_BEST, ann.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Announcements with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Announcement exists for that txhash.\n+// * Determining when no more non-COMPLETED Announcements for a given txhash exist, so the COMPLETED ones can be\n+//   deleted.\n+struct ByTxHash {};\n+using ByTxHashView = std::tuple<const uint256&, State, Priority>;\n+class ByTxHashViewExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    ByTxHashViewExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = ByTxHashView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        const State state = ann.GetState();\n+        const Priority prio = (state == State::CANDIDATE_READY) ? m_computer(ann) : 0;\n+        return ByTxHashView{ann.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED announcements whose reqtime has passed, and REQUESTED announcements whose expiry has\n+//   passed.\n+// * Finding CANDIDATE_READY/BEST announcements whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using ByTimeView = std::pair<int, std::chrono::microseconds>;\n+struct ByTimeViewExtractor\n+{\n+    using result_type = ByTimeView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByTimeView{ann.IsWaiting() ? 0 : ann.IsSelectable() ? 2 : 1, ann.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Announcement objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Announcement,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, ByPeerViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, ByTxHashViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, ByTimeViewExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of announcements for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED announcements for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED announcements for this peer.\n+};\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    SequenceNumber m_current_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<NodeId, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED announcement into a CANDIDATE_READY. If this makes it the new best\n+    //! CANDIDATE_READY (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new\n+    //! CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY announcements, the best one (lowest\n+        // priority) comes first. Thus, if an existing _BEST exists for the same txhash that this announcement may\n+        // be preferred over, it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() announcement for this txhash\n+            // already.\n+            Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            Priority priority_old = m_computer(*std::prev(it));\n+            Priority priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST announcement already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an announcement to something non-IsSelected(). If it was IsSelected(), the next best\n+    //! announcement will be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499532324",
      "id" : 499532324,
      "line" : 427,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUzMjMyNA==",
      "original_commit_id" : "a60ad12fb9bac2e4a8fe9018754444d48ba817ea",
      "original_line" : 427,
      "original_position" : 295,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 427,
      "pull_request_review_id" : 501954745,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499532324",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499563280"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499563280"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`ByTxHashView` takes the uint256 as the first param, the last one is just a uint64_t Priority, so replacing with `COMPLETED, std::numeric_limits<Priority>::max()` should be straightforward (`1` would also be fine, since COMPLETED means priority is `0`). Seems to pass the fuzz tester okay. Adding a `static constexpr auto PRIORITY_MAX` alias and using it for `m_priority_best_candidate_ready` as well may make sense.\r\n\r\nBut... is this test even useful? `it_last` was needed in order to sanity check the first markers, but with them gone now...",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T12:33:27Z",
      "diff_hunk" : "@@ -0,0 +1,716 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of ByTxHashView relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE announcement whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED announcement already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority announcement among all CANDIDATE_READY (and _BEST) ones for that\n+     *  txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED announcement. */\n+    REQUESTED,\n+    /** A CANDIDATE announcement that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED announcement. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+//! Type alias for sequence numbers.\n+using SequenceNumber = uint64_t;\n+\n+/** An announcement. This is the data we track for each txid or wtxid that is announced to us by each peer. */\n+struct Announcement {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const NodeId m_peer;\n+    /** What sequence number this announcement has. */\n+    const SequenceNumber m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this announcement is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this announcement is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this announcement can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new announcement from scratch, initially in CANDIDATE_DELAYED state. */\n+    Announcement(const GenTxid& gtxid, NodeId peer, bool preferred, std::chrono::microseconds reqtime,\n+        SequenceNumber sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+//! Type alias for priorities.\n+using Priority = uint64_t;\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    Priority operator()(const uint256& txhash, NodeId peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    Priority operator()(const Announcement& ann) const\n+    {\n+        return operator()(ann.m_txhash, ann.m_peer, ann.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a By*View data type to represent the view of Announcement it is sorted\n+// by, and an By*ViewExtractor type to convert an Announcement into the By*View type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing announcements by peer/txhash, by checking both (peer, false, txhash) and\n+//   (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST announcements for a given peer in GetRequestable.\n+struct ByPeer {};\n+using ByPeerView = std::tuple<NodeId, bool, const uint256&>;\n+struct ByPeerViewExtractor\n+{\n+    using result_type = ByPeerView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByPeerView{ann.m_peer, ann.GetState() == State::CANDIDATE_BEST, ann.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Announcements with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Announcement exists for that txhash.\n+// * Determining when no more non-COMPLETED Announcements for a given txhash exist, so the COMPLETED ones can be\n+//   deleted.\n+struct ByTxHash {};\n+using ByTxHashView = std::tuple<const uint256&, State, Priority>;\n+class ByTxHashViewExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    ByTxHashViewExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = ByTxHashView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        const State state = ann.GetState();\n+        const Priority prio = (state == State::CANDIDATE_READY) ? m_computer(ann) : 0;\n+        return ByTxHashView{ann.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED announcements whose reqtime has passed, and REQUESTED announcements whose expiry has\n+//   passed.\n+// * Finding CANDIDATE_READY/BEST announcements whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using ByTimeView = std::pair<int, std::chrono::microseconds>;\n+struct ByTimeViewExtractor\n+{\n+    using result_type = ByTimeView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByTimeView{ann.IsWaiting() ? 0 : ann.IsSelectable() ? 2 : 1, ann.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Announcement objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Announcement,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, ByPeerViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, ByTxHashViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, ByTimeViewExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of announcements for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED announcements for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED announcements for this peer.\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST announcement if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an announcement for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** Compare two PeerInfo objects. Only used for sanity checking. */\n+bool operator==(const PeerInfo& a, const PeerInfo& b)\n+{\n+    return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+           std::tie(b.m_total, b.m_completed, b.m_requested);\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<NodeId, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<NodeId, PeerInfo> ret;\n+    for (const Announcement& ann : index) {\n+        PeerInfo& info = ret[ann.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (ann.GetState() == State::REQUESTED);\n+        info.m_completed += (ann.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Announcement& ann : index) {\n+        TxHashInfo& info = ret[ann.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (ann.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (ann.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (ann.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (ann.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (ann.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(ann);\n+        }\n+        if (ann.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(ann));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(ann.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    SequenceNumber m_current_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure. See SanityCheck() for the invariants that apply to it.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<NodeId, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo entries exist with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // announcement.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST announcement, the CANDIDATE_BEST one must be\n+            // at least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+\n+            // Looking up the last ByTxHash announcement with the given txhash must return an Announcement with that\n+            // txhash or the multi_index is very bad.\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                ByTxHashView{item.first, State::TOO_LARGE, 0}));\n+            assert(it_last != m_index.get<ByTxHash>().end() && it_last->m_txhash == item.first);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499563280",
      "id" : 499563280,
      "in_reply_to_id" : 499493545,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU2MzI4MA==",
      "original_commit_id" : "6fa4512fb450d709006fd6b242975fd3ce2f5340",
      "original_line" : 339,
      "original_position" : 339,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 501954745,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499563280",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499567299"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499567299"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think the constraints on the ordering here are:\r\n * COMPLETED comes last, so that looping `it = Erase<ByTxHash>(it)` starting from the only non-completed entry for a txhash will erase all the entries for that txhash\r\n * BEST and REQUESTED are next to each other so that it's easy to enforce the \"only one best or requestable per txhash\"\r\n * BEST/REQUESTED comes immediately before/after READY so that it's easy to compare a new best READY with the existing BEST\r\n\r\nBut I think there's no longer anything preventing changing the ordering to match the expected transitions, ie `DELAYED, READY, BEST, REQUESTED, COMPLETED` (and changing the best priority to be the highest value rather than the lowest). I'm presuming that's due to no longer doing first markers, but maybe I've missed something?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T12:40:18Z",
      "diff_hunk" : "@@ -0,0 +1,577 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of ByTxHashView relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE announcement whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED announcement already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority announcement among all CANDIDATE_READY (and _BEST) ones for that\n+     *  txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED announcement. */\n+    REQUESTED,\n+    /** A CANDIDATE announcement that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED announcement. */\n+    COMPLETED,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499567299",
      "id" : 499567299,
      "line" : 50,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU2NzI5OQ==",
      "original_commit_id" : "a60ad12fb9bac2e4a8fe9018754444d48ba817ea",
      "original_line" : 50,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 50,
      "pull_request_review_id" : 501954745,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499567299",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499581088"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499581088"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Maybe\r\n\r\n```c++\r\nenum class WaitState {\r\n    WAITING,\r\n    COMPLETED,\r\n    SELECTABLE,\r\n};\r\nstatic inline WaitState GetWaitState(const Announcement& ann) {\r\n    return (ann.IsWaiting() ? WaitState::WAITING : ann.IsSelectable() ? WaitState::SELECTABLE, WaitState::COMPLETED);\r\n}\r\n```\r\n\r\nand say `sorted by (wait_state, time)`, and describe it is easy to find all the WAITING announcements prior to a time point (for when the event they were waiting for has happened), and all the SELECTABLE announcements after a time point (for when time goes backwards)? (Alternatively, FUTURE_EVENT, NO_EVENT, and PAST_EVENT would be more generic wait states)",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T13:02:21Z",
      "diff_hunk" : "@@ -0,0 +1,577 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of ByTxHashView relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE announcement whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED announcement already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority announcement among all CANDIDATE_READY (and _BEST) ones for that\n+     *  txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED announcement. */\n+    REQUESTED,\n+    /** A CANDIDATE announcement that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED announcement. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+//! Type alias for sequence numbers.\n+using SequenceNumber = uint64_t;\n+\n+/** An announcement. This is the data we track for each txid or wtxid that is announced to us by each peer. */\n+struct Announcement {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const NodeId m_peer;\n+    /** What sequence number this announcement has. */\n+    const SequenceNumber m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this announcement is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this announcement is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this announcement can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new announcement from scratch, initially in CANDIDATE_DELAYED state. */\n+    Announcement(const GenTxid& gtxid, NodeId peer, bool preferred, std::chrono::microseconds reqtime,\n+        SequenceNumber sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+//! Type alias for priorities.\n+using Priority = uint64_t;\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    Priority operator()(const uint256& txhash, NodeId peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    Priority operator()(const Announcement& ann) const\n+    {\n+        return operator()(ann.m_txhash, ann.m_peer, ann.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a By*View data type to represent the view of Announcement it is sorted\n+// by, and an By*ViewExtractor type to convert an Announcement into the By*View type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing announcements by peer/txhash, by checking both (peer, false, txhash) and\n+//   (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST announcements for a given peer in GetRequestable.\n+struct ByPeer {};\n+using ByPeerView = std::tuple<NodeId, bool, const uint256&>;\n+struct ByPeerViewExtractor\n+{\n+    using result_type = ByPeerView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByPeerView{ann.m_peer, ann.GetState() == State::CANDIDATE_BEST, ann.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Announcements with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Announcement exists for that txhash.\n+// * Determining when no more non-COMPLETED Announcements for a given txhash exist, so the COMPLETED ones can be\n+//   deleted.\n+struct ByTxHash {};\n+using ByTxHashView = std::tuple<const uint256&, State, Priority>;\n+class ByTxHashViewExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    ByTxHashViewExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = ByTxHashView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        const State state = ann.GetState();\n+        const Priority prio = (state == State::CANDIDATE_READY) ? m_computer(ann) : 0;\n+        return ByTxHashView{ann.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499581088",
      "id" : 499581088,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU4MTA4OA==",
      "original_commit_id" : "a60ad12fb9bac2e4a8fe9018754444d48ba817ea",
      "original_line" : 181,
      "original_position" : 181,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 501954745,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499581088",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499591256"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499591256"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "At some point in the future it would probably be good to expose expiring requests somehow -- peers might want to deprioritise those peers or disconnect them, eg.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T13:18:27Z",
      "diff_hunk" : "@@ -0,0 +1,577 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of ByTxHashView relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE announcement whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED announcement already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority announcement among all CANDIDATE_READY (and _BEST) ones for that\n+     *  txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED announcement. */\n+    REQUESTED,\n+    /** A CANDIDATE announcement that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED announcement. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+//! Type alias for sequence numbers.\n+using SequenceNumber = uint64_t;\n+\n+/** An announcement. This is the data we track for each txid or wtxid that is announced to us by each peer. */\n+struct Announcement {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const NodeId m_peer;\n+    /** What sequence number this announcement has. */\n+    const SequenceNumber m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this announcement is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this announcement is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this announcement can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new announcement from scratch, initially in CANDIDATE_DELAYED state. */\n+    Announcement(const GenTxid& gtxid, NodeId peer, bool preferred, std::chrono::microseconds reqtime,\n+        SequenceNumber sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+//! Type alias for priorities.\n+using Priority = uint64_t;\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    Priority operator()(const uint256& txhash, NodeId peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    Priority operator()(const Announcement& ann) const\n+    {\n+        return operator()(ann.m_txhash, ann.m_peer, ann.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a By*View data type to represent the view of Announcement it is sorted\n+// by, and an By*ViewExtractor type to convert an Announcement into the By*View type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing announcements by peer/txhash, by checking both (peer, false, txhash) and\n+//   (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST announcements for a given peer in GetRequestable.\n+struct ByPeer {};\n+using ByPeerView = std::tuple<NodeId, bool, const uint256&>;\n+struct ByPeerViewExtractor\n+{\n+    using result_type = ByPeerView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByPeerView{ann.m_peer, ann.GetState() == State::CANDIDATE_BEST, ann.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Announcements with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Announcement exists for that txhash.\n+// * Determining when no more non-COMPLETED Announcements for a given txhash exist, so the COMPLETED ones can be\n+//   deleted.\n+struct ByTxHash {};\n+using ByTxHashView = std::tuple<const uint256&, State, Priority>;\n+class ByTxHashViewExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    ByTxHashViewExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = ByTxHashView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        const State state = ann.GetState();\n+        const Priority prio = (state == State::CANDIDATE_READY) ? m_computer(ann) : 0;\n+        return ByTxHashView{ann.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED announcements whose reqtime has passed, and REQUESTED announcements whose expiry has\n+//   passed.\n+// * Finding CANDIDATE_READY/BEST announcements whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using ByTimeView = std::pair<int, std::chrono::microseconds>;\n+struct ByTimeViewExtractor\n+{\n+    using result_type = ByTimeView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByTimeView{ann.IsWaiting() ? 0 : ann.IsSelectable() ? 2 : 1, ann.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Announcement objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Announcement,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, ByPeerViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, ByTxHashViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, ByTimeViewExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of announcements for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED announcements for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED announcements for this peer.\n+};\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    SequenceNumber m_current_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<NodeId, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED announcement into a CANDIDATE_READY. If this makes it the new best\n+    //! CANDIDATE_READY (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new\n+    //! CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY announcements, the best one (lowest\n+        // priority) comes first. Thus, if an existing _BEST exists for the same txhash that this announcement may\n+        // be preferred over, it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() announcement for this txhash\n+            // already.\n+            Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            Priority priority_old = m_computer(*std::prev(it));\n+            Priority priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST announcement already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an announcement to something non-IsSelected(). If it was IsSelected(), the next best\n+    //! announcement will be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST\n+            // announcement in the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Announcement& ann){ ann.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Announcement for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED announcements.\n+\n+        // If this Announcement's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Announcement's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any announcement to a COMPLETED one. If there are no non-COMPLETED announcements left for this\n+     *  txhash, they are deleted. If this was a REQUESTED announcement, and there are other CANDIDATEs left, the\n+     *  best one is made CANDIDATE_BEST. Returns whether the Announcement still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED announcement for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the announcement COMPLETED, and select the next best announcement (the first CANDIDATE_READY) if\n+        // needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED annoucements with expiry <= now are turned into COMPLETED.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499591256",
      "id" : 499591256,
      "line" : 485,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU5MTI1Ng==",
      "original_commit_id" : "a60ad12fb9bac2e4a8fe9018754444d48ba817ea",
      "original_line" : 485,
      "original_position" : 353,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 485,
      "pull_request_review_id" : 501954745,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499591256",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499605596"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499605596"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`ret.reserve(selected.size())` ?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T13:39:07Z",
      "diff_hunk" : "@@ -0,0 +1,577 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of ByTxHashView relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE announcement whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED announcement already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority announcement among all CANDIDATE_READY (and _BEST) ones for that\n+     *  txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED announcement. */\n+    REQUESTED,\n+    /** A CANDIDATE announcement that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED announcement. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+//! Type alias for sequence numbers.\n+using SequenceNumber = uint64_t;\n+\n+/** An announcement. This is the data we track for each txid or wtxid that is announced to us by each peer. */\n+struct Announcement {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const NodeId m_peer;\n+    /** What sequence number this announcement has. */\n+    const SequenceNumber m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this announcement is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this announcement is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this announcement can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new announcement from scratch, initially in CANDIDATE_DELAYED state. */\n+    Announcement(const GenTxid& gtxid, NodeId peer, bool preferred, std::chrono::microseconds reqtime,\n+        SequenceNumber sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+//! Type alias for priorities.\n+using Priority = uint64_t;\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    Priority operator()(const uint256& txhash, NodeId peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    Priority operator()(const Announcement& ann) const\n+    {\n+        return operator()(ann.m_txhash, ann.m_peer, ann.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a By*View data type to represent the view of Announcement it is sorted\n+// by, and an By*ViewExtractor type to convert an Announcement into the By*View type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing announcements by peer/txhash, by checking both (peer, false, txhash) and\n+//   (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST announcements for a given peer in GetRequestable.\n+struct ByPeer {};\n+using ByPeerView = std::tuple<NodeId, bool, const uint256&>;\n+struct ByPeerViewExtractor\n+{\n+    using result_type = ByPeerView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByPeerView{ann.m_peer, ann.GetState() == State::CANDIDATE_BEST, ann.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Announcements with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Announcement exists for that txhash.\n+// * Determining when no more non-COMPLETED Announcements for a given txhash exist, so the COMPLETED ones can be\n+//   deleted.\n+struct ByTxHash {};\n+using ByTxHashView = std::tuple<const uint256&, State, Priority>;\n+class ByTxHashViewExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    ByTxHashViewExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = ByTxHashView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        const State state = ann.GetState();\n+        const Priority prio = (state == State::CANDIDATE_READY) ? m_computer(ann) : 0;\n+        return ByTxHashView{ann.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED announcements whose reqtime has passed, and REQUESTED announcements whose expiry has\n+//   passed.\n+// * Finding CANDIDATE_READY/BEST announcements whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using ByTimeView = std::pair<int, std::chrono::microseconds>;\n+struct ByTimeViewExtractor\n+{\n+    using result_type = ByTimeView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByTimeView{ann.IsWaiting() ? 0 : ann.IsSelectable() ? 2 : 1, ann.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Announcement objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Announcement,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, ByPeerViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, ByTxHashViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, ByTimeViewExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of announcements for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED announcements for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED announcements for this peer.\n+};\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    SequenceNumber m_current_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<NodeId, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED announcement into a CANDIDATE_READY. If this makes it the new best\n+    //! CANDIDATE_READY (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new\n+    //! CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY announcements, the best one (lowest\n+        // priority) comes first. Thus, if an existing _BEST exists for the same txhash that this announcement may\n+        // be preferred over, it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() announcement for this txhash\n+            // already.\n+            Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            Priority priority_old = m_computer(*std::prev(it));\n+            Priority priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST announcement already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an announcement to something non-IsSelected(). If it was IsSelected(), the next best\n+    //! announcement will be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST\n+            // announcement in the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Announcement& ann){ ann.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Announcement for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED announcements.\n+\n+        // If this Announcement's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Announcement's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any announcement to a COMPLETED one. If there are no non-COMPLETED announcements left for this\n+     *  txhash, they are deleted. If this was a REQUESTED announcement, and there are other CANDIDATEs left, the\n+     *  best one is made CANDIDATE_BEST. Returns whether the Announcement still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED announcement for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the announcement COMPLETED, and select the next best announcement (the first CANDIDATE_READY) if\n+        // needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED annoucements with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED announcements with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} announcements with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY announcements back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to ByTxHashViewExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(ByPeerViewExtractor(), std::less<ByPeerView>()),\n+            boost::make_tuple(ByTxHashViewExtractor(m_computer), std::less<ByTxHashView>()),\n+            boost::make_tuple(ByTimeViewExtractor(), std::less<ByTimeView>())\n+        )) {}\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful ByTxHashViewExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DisconnectedPeer(NodeId peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(ByPeerView{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the announcement isn't already COMPLETED, first make it COMPLETED (which will mark other\n+            // CANDIDATEs as CANDIDATE_BEST, or delete all of a txhash's announcements if no non-COMPLETED ones are\n+            // left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the announcement (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(ByTxHashView{txhash, State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(NodeId peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST announcement for this (txhash, peer) combination. The case\n+        // where there is a non-CANDIDATE_BEST announcement already will be caught by the uniqueness property of the\n+        // ByPeer index when we try to emplace the new object below.\n+        if (m_index.get<ByPeer>().count(ByPeerView{peer, true, gtxid.GetHash()})) return;\n+\n+        // Try creating the announcement with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST announcement already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_current_sequence);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_current_sequence;\n+    }\n+\n+    //! Find the GenTxids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(NodeId peer, std::chrono::microseconds now)\n+    {\n+        // Move time.\n+        SetTimePoint(now);\n+\n+        // Find all CANDIDATE_BEST announcements for this peer.\n+        std::vector<std::pair<SequenceNumber, const Announcement*>> selected;\n+        auto it_peer = m_index.get<ByPeer>().lower_bound(ByPeerView{peer, true, UINT256_ZERO});\n+        while (it_peer != m_index.get<ByPeer>().end() && it_peer->m_peer == peer &&\n+            it_peer->GetState() == State::CANDIDATE_BEST) {\n+            selected.emplace_back(it_peer->m_sequence, &*it_peer);\n+            ++it_peer;\n+        }\n+\n+        // Return them, sorted by sequence number.\n+        std::sort(selected.begin(), selected.end());\n+        std::vector<GenTxid> ret;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499605596",
      "id" : 499605596,
      "line" : 594,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYwNTU5Ng==",
      "original_commit_id" : "a60ad12fb9bac2e4a8fe9018754444d48ba817ea",
      "original_line" : 594,
      "original_position" : 462,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 594,
      "pull_request_review_id" : 501954745,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499605596",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499627889"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499627889"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In future, might be useful to return `it->GetState() == REQUESTED ? it->m_time : min()` here to allow the caller to estimate relay latency for a peer, in case they wanted to use that info to adjust that peer's expiry delay.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T14:10:51Z",
      "diff_hunk" : "@@ -0,0 +1,577 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of ByTxHashView relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE announcement whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED announcement already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority announcement among all CANDIDATE_READY (and _BEST) ones for that\n+     *  txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED announcement. */\n+    REQUESTED,\n+    /** A CANDIDATE announcement that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED announcement. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+//! Type alias for sequence numbers.\n+using SequenceNumber = uint64_t;\n+\n+/** An announcement. This is the data we track for each txid or wtxid that is announced to us by each peer. */\n+struct Announcement {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const NodeId m_peer;\n+    /** What sequence number this announcement has. */\n+    const SequenceNumber m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this announcement is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this announcement is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this announcement can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new announcement from scratch, initially in CANDIDATE_DELAYED state. */\n+    Announcement(const GenTxid& gtxid, NodeId peer, bool preferred, std::chrono::microseconds reqtime,\n+        SequenceNumber sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+//! Type alias for priorities.\n+using Priority = uint64_t;\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    Priority operator()(const uint256& txhash, NodeId peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    Priority operator()(const Announcement& ann) const\n+    {\n+        return operator()(ann.m_txhash, ann.m_peer, ann.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a By*View data type to represent the view of Announcement it is sorted\n+// by, and an By*ViewExtractor type to convert an Announcement into the By*View type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing announcements by peer/txhash, by checking both (peer, false, txhash) and\n+//   (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST announcements for a given peer in GetRequestable.\n+struct ByPeer {};\n+using ByPeerView = std::tuple<NodeId, bool, const uint256&>;\n+struct ByPeerViewExtractor\n+{\n+    using result_type = ByPeerView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByPeerView{ann.m_peer, ann.GetState() == State::CANDIDATE_BEST, ann.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Announcements with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Announcement exists for that txhash.\n+// * Determining when no more non-COMPLETED Announcements for a given txhash exist, so the COMPLETED ones can be\n+//   deleted.\n+struct ByTxHash {};\n+using ByTxHashView = std::tuple<const uint256&, State, Priority>;\n+class ByTxHashViewExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    ByTxHashViewExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = ByTxHashView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        const State state = ann.GetState();\n+        const Priority prio = (state == State::CANDIDATE_READY) ? m_computer(ann) : 0;\n+        return ByTxHashView{ann.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED announcements whose reqtime has passed, and REQUESTED announcements whose expiry has\n+//   passed.\n+// * Finding CANDIDATE_READY/BEST announcements whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using ByTimeView = std::pair<int, std::chrono::microseconds>;\n+struct ByTimeViewExtractor\n+{\n+    using result_type = ByTimeView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByTimeView{ann.IsWaiting() ? 0 : ann.IsSelectable() ? 2 : 1, ann.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Announcement objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Announcement,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, ByPeerViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, ByTxHashViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, ByTimeViewExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of announcements for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED announcements for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED announcements for this peer.\n+};\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    SequenceNumber m_current_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<NodeId, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED announcement into a CANDIDATE_READY. If this makes it the new best\n+    //! CANDIDATE_READY (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new\n+    //! CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY announcements, the best one (lowest\n+        // priority) comes first. Thus, if an existing _BEST exists for the same txhash that this announcement may\n+        // be preferred over, it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() announcement for this txhash\n+            // already.\n+            Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            Priority priority_old = m_computer(*std::prev(it));\n+            Priority priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST announcement already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an announcement to something non-IsSelected(). If it was IsSelected(), the next best\n+    //! announcement will be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST\n+            // announcement in the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Announcement& ann){ ann.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Announcement for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED announcements.\n+\n+        // If this Announcement's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Announcement's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any announcement to a COMPLETED one. If there are no non-COMPLETED announcements left for this\n+     *  txhash, they are deleted. If this was a REQUESTED announcement, and there are other CANDIDATEs left, the\n+     *  best one is made CANDIDATE_BEST. Returns whether the Announcement still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED announcement for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the announcement COMPLETED, and select the next best announcement (the first CANDIDATE_READY) if\n+        // needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED annoucements with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED announcements with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} announcements with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY announcements back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to ByTxHashViewExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(ByPeerViewExtractor(), std::less<ByPeerView>()),\n+            boost::make_tuple(ByTxHashViewExtractor(m_computer), std::less<ByTxHashView>()),\n+            boost::make_tuple(ByTimeViewExtractor(), std::less<ByTimeView>())\n+        )) {}\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful ByTxHashViewExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DisconnectedPeer(NodeId peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(ByPeerView{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the announcement isn't already COMPLETED, first make it COMPLETED (which will mark other\n+            // CANDIDATEs as CANDIDATE_BEST, or delete all of a txhash's announcements if no non-COMPLETED ones are\n+            // left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the announcement (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(ByTxHashView{txhash, State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(NodeId peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST announcement for this (txhash, peer) combination. The case\n+        // where there is a non-CANDIDATE_BEST announcement already will be caught by the uniqueness property of the\n+        // ByPeer index when we try to emplace the new object below.\n+        if (m_index.get<ByPeer>().count(ByPeerView{peer, true, gtxid.GetHash()})) return;\n+\n+        // Try creating the announcement with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST announcement already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_current_sequence);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_current_sequence;\n+    }\n+\n+    //! Find the GenTxids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(NodeId peer, std::chrono::microseconds now)\n+    {\n+        // Move time.\n+        SetTimePoint(now);\n+\n+        // Find all CANDIDATE_BEST announcements for this peer.\n+        std::vector<std::pair<SequenceNumber, const Announcement*>> selected;\n+        auto it_peer = m_index.get<ByPeer>().lower_bound(ByPeerView{peer, true, UINT256_ZERO});\n+        while (it_peer != m_index.get<ByPeer>().end() && it_peer->m_peer == peer &&\n+            it_peer->GetState() == State::CANDIDATE_BEST) {\n+            selected.emplace_back(it_peer->m_sequence, &*it_peer);\n+            ++it_peer;\n+        }\n+\n+        // Return them, sorted by sequence number.\n+        std::sort(selected.begin(), selected.end());\n+        std::vector<GenTxid> ret;\n+        for (const auto& item : selected) {\n+            ret.emplace_back(item.second->m_is_wtxid, item.second->m_txhash);\n+        }\n+        return ret;\n+    }\n+\n+    void RequestedTx(NodeId peer, const uint256& txhash, std::chrono::microseconds expiry)\n+    {\n+        auto it = m_index.get<ByPeer>().find(ByPeerView{peer, true, txhash});\n+        if (it == m_index.get<ByPeer>().end()) {\n+            // There is no CANDIDATE_BEST announcement, look for a _READY or _DELAYED instead. If the caller only\n+            // ever invokes RequestedTx with the values returned by GetRequestable, and no other non-const functions\n+            // other than ForgetTxHash and GetRequestable in between, this branch will never execute (as txhashes\n+            // returned by GetRequestable always correspond to CANDIDATE_BEST announcements).\n+\n+            it = m_index.get<ByPeer>().find(ByPeerView{peer, false, txhash});\n+            if (it == m_index.get<ByPeer>().end() || (it->GetState() != State::CANDIDATE_DELAYED &&\n+                it->GetState() != State::CANDIDATE_READY)) {\n+                // The txhash was not tracked for this peer, so we have nothing to do. The caller should have called\n+                // ReceivedInv first.\n+                return;\n+            }\n+\n+            // Look for an existing CANDIDATE_BEST or REQUESTED.\n+            auto it_old = m_index.get<ByTxHash>().lower_bound(ByTxHashView{txhash, State::CANDIDATE_BEST, 0});\n+            if (it_old != m_index.get<ByTxHash>().end() && it_old->m_txhash == txhash) {\n+                if (it_old->GetState() == State::CANDIDATE_BEST) {\n+                    // The data structure's invariants require that there can be at most one CANDIDATE_BEST or one\n+                    // REQUESTED announcement per txhash (but not both simultaneously), so we have to convert any\n+                    // existing CANDIDATE_BEST to another CANDIDATE_* when constructing another REQUESTED.\n+                    // It doesn't matter whether we pick CANDIDATE_READY or _DELAYED here, as SetTimePoint()\n+                    // will correct it at GetRequestable() time. If time only goes forward, it will always be\n+                    // _READY, so pick that to avoid extra work in SetTimePoint().\n+                    Modify<ByTxHash>(it_old, [](Announcement& ann) { ann.SetState(State::CANDIDATE_READY); });\n+                } else if (it_old->GetState() == State::REQUESTED) {\n+                    // As we're no longer waiting for a response to the previous REQUESTED announcement, convert it\n+                    // to COMPLETED. This also helps guaranteeing progress.\n+                    Modify<ByTxHash>(it_old, [](Announcement& ann) { ann.SetState(State::COMPLETED); });\n+                }\n+            }\n+        }\n+\n+        Modify<ByPeer>(it, [expiry](Announcement& ann) {\n+            ann.SetState(State::REQUESTED);\n+            ann.m_time = expiry;\n+        });\n+    }\n+\n+    void ReceivedResponse(NodeId peer, const uint256& txhash)\n+    {\n+        // We need to search the ByPeer index for both (peer, false, txhash) and (peer, true, txhash).\n+        auto it = m_index.get<ByPeer>().find(ByPeerView{peer, false, txhash});\n+        if (it == m_index.get<ByPeer>().end()) {\n+            it = m_index.get<ByPeer>().find(ByPeerView{peer, true, txhash});\n+        }\n+        if (it != m_index.get<ByPeer>().end()) MakeCompleted(m_index.project<ByTxHash>(it));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499627889",
      "id" : 499627889,
      "line" : 652,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYyNzg4OQ==",
      "original_commit_id" : "a60ad12fb9bac2e4a8fe9018754444d48ba817ea",
      "original_line" : 652,
      "original_position" : 518,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 652,
      "pull_request_review_id" : 501954745,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499627889",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499629695"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499629695"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Should be \"already-failed\" not \"already-requested\" per the terminology above (\"Whether or not the transaction request failed already (timed out, or NOTFOUND was received)\")",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T14:13:34Z",
      "diff_hunk" : "@@ -0,0 +1,193 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <net.h> // For NodeId\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction. Note that this only works\n+ *              per txhash, so if the same transaction is announced both through txid and wtxid, we have no means\n+ *              to prevent fetching both (the caller can however mitigate this by delaying one, see further).\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten only:\n+ *   - If a peer goes offline, all its announcements are forgotten.\n+ *   - If a transaction has been successfully received, or is otherwise no longer needed, the caller can call\n+ *     ForgetTxHash, which removes all announcements across all peers with the specified txhash.\n+ *   - If for a given txhash only already-requested announcements remain, they are all forgotten.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499629695",
      "id" : 499629695,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYyOTY5NQ==",
      "original_commit_id" : "a60ad12fb9bac2e4a8fe9018754444d48ba817ea",
      "original_line" : 49,
      "original_position" : 49,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 501954745,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499629695",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499661041"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499661041"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Maybe `RandomTime_15s()` and `RandomTime_1y()` (assuming I've done the math right for bits=23 and bits=44 which are the only ways this is called) ?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T14:55:01Z",
      "diff_hunk" : "@@ -0,0 +1,558 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds MIN_TIME = std::chrono::microseconds::min();\n+constexpr std::chrono::microseconds MAX_TIME = std::chrono::microseconds::max();\n+constexpr std::chrono::microseconds MICROSECOND = std::chrono::microseconds{1};\n+constexpr std::chrono::microseconds NO_TIME = std::chrono::microseconds{0};\n+\n+/** An Action is a function to call at a particular (simulated) timestamp. */\n+using Action = std::pair<std::chrono::microseconds, std::function<void()>>;\n+\n+/** Object that stores actions from multiple interleaved scenarios, and data shared across them.\n+ *\n+ * The Scenario below is used to fill this.\n+ */\n+struct Runner\n+{\n+    /** The TxRequestTracker being tested. */\n+    TxRequestTracker txrequest;\n+\n+    /** List of actions to be executed (in order of increasing timestamp). */\n+    std::vector<Action> actions;\n+\n+    /** Which node ids have been assigned already (to prevent reuse). */\n+    std::set<NodeId> peerset;\n+\n+    /** Which txhashes have been assigned already (to prevent reuse). */\n+    std::set<uint256> txhashset;\n+};\n+\n+std::chrono::microseconds RandomTime(int bits=23) { return std::chrono::microseconds{1 + InsecureRandBits(bits)}; }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499661041",
      "id" : 499661041,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY2MTA0MQ==",
      "original_commit_id" : "744eb10ecfa133a4a2de468aeb701255438e4427",
      "original_line" : 48,
      "original_position" : 48,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 501954745,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499661041",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499662302"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499662302"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I'm not really following the unit testing strategy here; in particular what all the interleaving ends up doing, and what cases are really covered, and what the effect of doing some things exhaustively and other things randomly is . Feels like there's a lot of novel scaffolding hiding what's actual tested.\r\n\r\nIt might be good to create some template magic for the Action/Runner/Scenario pattern, and use that more consistently? At the very least the versionbits tests feel to me like they suffer a bit from the same sort of problem?\r\n\r\nI think this test setup only simulates a monotonic clock (vs txrequest.cpp's note that supporting time going backwards \"makes it much easier to specify and test TxRequestTracker::Impl's behaviour\")",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T14:56:44Z",
      "diff_hunk" : "@@ -0,0 +1,558 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds MIN_TIME = std::chrono::microseconds::min();\n+constexpr std::chrono::microseconds MAX_TIME = std::chrono::microseconds::max();\n+constexpr std::chrono::microseconds MICROSECOND = std::chrono::microseconds{1};\n+constexpr std::chrono::microseconds NO_TIME = std::chrono::microseconds{0};\n+\n+/** An Action is a function to call at a particular (simulated) timestamp. */\n+using Action = std::pair<std::chrono::microseconds, std::function<void()>>;\n+\n+/** Object that stores actions from multiple interleaved scenarios, and data shared across them.\n+ *\n+ * The Scenario below is used to fill this.\n+ */\n+struct Runner\n+{\n+    /** The TxRequestTracker being tested. */\n+    TxRequestTracker txrequest;\n+\n+    /** List of actions to be executed (in order of increasing timestamp). */\n+    std::vector<Action> actions;\n+\n+    /** Which node ids have been assigned already (to prevent reuse). */\n+    std::set<NodeId> peerset;\n+\n+    /** Which txhashes have been assigned already (to prevent reuse). */\n+    std::set<uint256> txhashset;\n+};\n+\n+std::chrono::microseconds RandomTime(int bits=23) { return std::chrono::microseconds{1 + InsecureRandBits(bits)}; }\n+\n+/** A proxy for a Runner that helps build a sequence of consecutive test actions on a TxRequestTracker.\n+ *\n+ * Multiple Scenarios are used with a single Runner, resulting in interleaved actions.\n+ */\n+class Scenario",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499662302",
      "id" : 499662302,
      "line" : 60,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY2MjMwMg==",
      "original_commit_id" : "744eb10ecfa133a4a2de468aeb701255438e4427",
      "original_line" : 60,
      "original_position" : 54,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : 60,
      "pull_request_review_id" : 501954745,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499662302",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499672470"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499672470"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`NodeId` and `Priority` instead of `uint64_t` and `::min()` instead of `m_priority_candidate_best = 0`?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T15:10:51Z",
      "diff_hunk" : "@@ -216,6 +216,70 @@ struct PeerInfo {\n     size_t m_requested = 0; //!< Number of REQUESTED announcements for this peer.\n };\n \n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST announcement if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an announcement for this txhash for.\n+    std::vector<uint64_t> m_peers;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499672470",
      "id" : 499672470,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY3MjQ3MA==",
      "original_commit_id" : "744eb10ecfa133a4a2de468aeb701255438e4427",
      "original_line" : 235,
      "original_position" : 20,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 501954745,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499672470",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499680741"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499680741"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`244466666` (pronounced \"one 2, three 4, five 6\")  or `1123581321` are also amusing. Super helpful review comments 'r us!",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T15:22:25Z",
      "diff_hunk" : "@@ -0,0 +1,361 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txrequest.h>\n+#include <test/fuzz/fuzz.h>\n+#include <crypto/common.h>\n+#include <crypto/siphash.h>\n+\n+#include <bitset>\n+#include <cstdint>\n+#include <queue>\n+#include <vector>\n+\n+namespace {\n+\n+constexpr int MAX_TXHASHES = 16;\n+constexpr int MAX_PEERS = 16;\n+\n+//! Randomly generated GenTxids used in this test (length is MAX_TX).\n+uint256 TXHASHES[MAX_TXHASHES];\n+\n+/** Precomputed random durations (positive and negative, each ~exponentially distributed). */\n+std::chrono::microseconds DELAYS[256];\n+\n+struct Initializer\n+{\n+    Initializer()\n+    {\n+        // Use deterministic RNG to fill in txids and delays.\n+        // Non-determinism hurts fuzzing.\n+        FastRandomContext rng(true);\n+        for (int txhash = 0; txhash < MAX_TXHASHES; txhash += 1) {\n+            do {\n+                TXHASHES[txhash] = rng.rand256();\n+            } while (*(TXHASHES[txhash].begin() + 31) != txhash || *(TXHASHES[txhash].begin()) != txhash);\n+        }\n+        for (int i = 0; i < 16; ++i) {\n+            DELAYS[i] = std::chrono::microseconds{i};\n+        }\n+        for (int i = 16; i < 128; ++i) {\n+            DELAYS[i] = DELAYS[i - 1] + std::chrono::microseconds{1 + rng.randbits(((i - 10) * 2) / 9)};\n+        }\n+        for (int i = 128; i < 256; ++i) {\n+            DELAYS[i] = -DELAYS[255 - i];\n+        }\n+    }\n+} g_initializer;\n+\n+/** Tester class for TxRequestTracker\n+ *\n+ * It includes a naive reimplementation of its behavior, for a limited set\n+ * of MAX_TXHASHES distinct txids, and MAX_PEERS peer identifiers.\n+ *\n+ * All of the public member functions perform the same operation on\n+ * an actual TxRequestTracker and on the state of the reimplementation.\n+ * The output of GetRequestable is compared with the expected value\n+ * as well.\n+ *\n+ * Check() calls the TxRequestTracker's sanity check, plus compares the\n+ * output of the constant accessors (Size(), CountLoad(), CountTracked())\n+ * with expected values.\n+ */\n+class Tester\n+{\n+    //! TxRequestTracker object being tested.\n+    TxRequestTracker m_tracker;\n+\n+    //! States for txid/peer combinations in the naive data structure.\n+    enum class State {\n+        NOTHING, //!< Absence of this txid/peer combination\n+\n+        // Note that this implementation does not distinguish between BEST/NEW/OTHER variants of CANDIDATE.\n+        CANDIDATE,\n+        REQUESTED,\n+        COMPLETED,\n+    };\n+\n+    //! Sequence numbers, incremented whenever a new CANDIDATE is added.\n+    uint64_t m_current_sequence{0};\n+\n+    //! List of future 'events' (all inserted reqtimes/exptimes). This is used to implement AdvanceToEvent.\n+    std::priority_queue<std::chrono::microseconds, std::vector<std::chrono::microseconds>, std::greater<std::chrono::microseconds>> m_events;\n+\n+    //! Information about a txhash/peer combination.\n+    struct Announcement\n+    {\n+        std::chrono::microseconds m_time;\n+        uint64_t m_sequence;\n+        State m_state{State::NOTHING};\n+        bool m_preferred;\n+        bool m_is_wtxid;\n+        uint64_t m_priority; //!< Precomputed priority.\n+    };\n+\n+    //! Information about all txhash/peer combination.\n+    Announcement m_announcements[MAX_TXHASHES][MAX_PEERS];\n+\n+    //! The current time; can move forward and backward.\n+    std::chrono::microseconds m_now{112223333};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499680741",
      "id" : 499680741,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY4MDc0MQ==",
      "original_commit_id" : "9fb42eeb59246479e3c7ec7e3575b3835a9fd27b",
      "original_line" : 102,
      "original_position" : 102,
      "original_start_line" : null,
      "path" : "src/test/fuzz/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 501954745,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499680741",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499684028"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499684028"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Maybe:\r\n\r\n```\r\nif (ann.m_state != NOTHING) {\r\n    if (ann.m_state != COMPLETED) return;\r\n    all_nothing = false;\r\n}\r\n```\r\n\r\nHad to double take to realise that not being CANDIDATE, REQUESTED or NOTHING here meant it was definitely COMPLETED. No big deal.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T15:27:10Z",
      "diff_hunk" : "@@ -0,0 +1,361 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txrequest.h>\n+#include <test/fuzz/fuzz.h>\n+#include <crypto/common.h>\n+#include <crypto/siphash.h>\n+\n+#include <bitset>\n+#include <cstdint>\n+#include <queue>\n+#include <vector>\n+\n+namespace {\n+\n+constexpr int MAX_TXHASHES = 16;\n+constexpr int MAX_PEERS = 16;\n+\n+//! Randomly generated GenTxids used in this test (length is MAX_TX).\n+uint256 TXHASHES[MAX_TXHASHES];\n+\n+/** Precomputed random durations (positive and negative, each ~exponentially distributed). */\n+std::chrono::microseconds DELAYS[256];\n+\n+struct Initializer\n+{\n+    Initializer()\n+    {\n+        // Use deterministic RNG to fill in txids and delays.\n+        // Non-determinism hurts fuzzing.\n+        FastRandomContext rng(true);\n+        for (int txhash = 0; txhash < MAX_TXHASHES; txhash += 1) {\n+            do {\n+                TXHASHES[txhash] = rng.rand256();\n+            } while (*(TXHASHES[txhash].begin() + 31) != txhash || *(TXHASHES[txhash].begin()) != txhash);\n+        }\n+        for (int i = 0; i < 16; ++i) {\n+            DELAYS[i] = std::chrono::microseconds{i};\n+        }\n+        for (int i = 16; i < 128; ++i) {\n+            DELAYS[i] = DELAYS[i - 1] + std::chrono::microseconds{1 + rng.randbits(((i - 10) * 2) / 9)};\n+        }\n+        for (int i = 128; i < 256; ++i) {\n+            DELAYS[i] = -DELAYS[255 - i];\n+        }\n+    }\n+} g_initializer;\n+\n+/** Tester class for TxRequestTracker\n+ *\n+ * It includes a naive reimplementation of its behavior, for a limited set\n+ * of MAX_TXHASHES distinct txids, and MAX_PEERS peer identifiers.\n+ *\n+ * All of the public member functions perform the same operation on\n+ * an actual TxRequestTracker and on the state of the reimplementation.\n+ * The output of GetRequestable is compared with the expected value\n+ * as well.\n+ *\n+ * Check() calls the TxRequestTracker's sanity check, plus compares the\n+ * output of the constant accessors (Size(), CountLoad(), CountTracked())\n+ * with expected values.\n+ */\n+class Tester\n+{\n+    //! TxRequestTracker object being tested.\n+    TxRequestTracker m_tracker;\n+\n+    //! States for txid/peer combinations in the naive data structure.\n+    enum class State {\n+        NOTHING, //!< Absence of this txid/peer combination\n+\n+        // Note that this implementation does not distinguish between BEST/NEW/OTHER variants of CANDIDATE.\n+        CANDIDATE,\n+        REQUESTED,\n+        COMPLETED,\n+    };\n+\n+    //! Sequence numbers, incremented whenever a new CANDIDATE is added.\n+    uint64_t m_current_sequence{0};\n+\n+    //! List of future 'events' (all inserted reqtimes/exptimes). This is used to implement AdvanceToEvent.\n+    std::priority_queue<std::chrono::microseconds, std::vector<std::chrono::microseconds>, std::greater<std::chrono::microseconds>> m_events;\n+\n+    //! Information about a txhash/peer combination.\n+    struct Announcement\n+    {\n+        std::chrono::microseconds m_time;\n+        uint64_t m_sequence;\n+        State m_state{State::NOTHING};\n+        bool m_preferred;\n+        bool m_is_wtxid;\n+        uint64_t m_priority; //!< Precomputed priority.\n+    };\n+\n+    //! Information about all txhash/peer combination.\n+    Announcement m_announcements[MAX_TXHASHES][MAX_PEERS];\n+\n+    //! The current time; can move forward and backward.\n+    std::chrono::microseconds m_now{112223333};\n+\n+    //! Delete txhashes whose only announcements are COMPLETED.\n+    void Cleanup(int txhash)\n+    {\n+        bool all_nothing = true;\n+        for (int peer = 0; peer < MAX_PEERS; ++peer) {\n+            const Announcement& ann = m_announcements[txhash][peer];\n+            if (ann.m_state == State::CANDIDATE || ann.m_state == State::REQUESTED) return;\n+            if (ann.m_state != State::NOTHING) all_nothing = false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499684028",
      "id" : 499684028,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY4NDAyOA==",
      "original_commit_id" : "9fb42eeb59246479e3c7ec7e3575b3835a9fd27b",
      "original_line" : 111,
      "original_position" : 111,
      "original_start_line" : null,
      "path" : "src/test/fuzz/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 501954745,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499684028",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499724149"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499724149"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`auto* state =` ? Was wondering if we were returning a reference and making an unnecessary copy.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T16:27:25Z",
      "diff_hunk" : "@@ -816,73 +747,34 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest\n+    NodeId nodeid = node.GetId();\n+    if (m_txrequest.Count(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499724149",
      "id" : 499724149,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcyNDE0OQ==",
      "original_commit_id" : "89a01b891284f584bbf341f25b587614e417b564",
      "original_line" : 760,
      "original_position" : 183,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 501954745,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499724149",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499728201"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499728201"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`if (tx.HasWitness()) ReceivedResponse(wtxid);` ? Or is the idea that txrequest is so cheap it's better to let it check if the extra call is redundant?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T16:34:22Z",
      "diff_hunk" : "@@ -3004,11 +2897,8 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n \n         TxValidationState state;\n \n-        for (const GenTxid& gtxid : {GenTxid(false, txid), GenTxid(true, wtxid)}) {\n-            nodestate->m_tx_download.m_tx_announced.erase(gtxid.GetHash());\n-            nodestate->m_tx_download.m_tx_in_flight.erase(gtxid.GetHash());\n-            EraseTxRequest(gtxid);\n-        }\n+        m_txrequest.ReceivedResponse(pfrom.GetId(), txid);\n+        m_txrequest.ReceivedResponse(pfrom.GetId(), wtxid);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499728201",
      "id" : 499728201,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcyODIwMQ==",
      "original_commit_id" : "89a01b891284f584bbf341f25b587614e417b564",
      "original_line" : 2901,
      "original_position" : 233,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 501954745,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499728201",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499731414"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499731414"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Might be worth adding some sort of sanity check to see that there aren't any code paths where we fail to call `DisconnectedPeer` and end up leaving `CANDIDATE_BEST` entries in the tracker that will never get cleared?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T16:39:58Z",
      "diff_hunk" : "@@ -956,6 +848,7 @@ void PeerManager::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n         mapBlocksInFlight.erase(entry.hash);\n     }\n     EraseOrphansFor(nodeid);\n+    m_txrequest.DisconnectedPeer(nodeid);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499731414",
      "id" : 499731414,
      "line" : 854,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczMTQxNA==",
      "original_commit_id" : "89a01b891284f584bbf341f25b587614e417b564",
      "original_line" : 854,
      "original_position" : 210,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 233,
      "pull_request_review_id" : 501954745,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499731414",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499747735"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499747735"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Could just send 44 NOTFOUND messages with 116 entries instead of one with 5016 for almost exactly the same overhead; and they should be plenty fast anyway, I think, especially compared to looking up the UTXO database when we receive a transaction. Since we've increased the in flight limit, I think it makes sense to increase the notfound limit correspondingly.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T17:08:34Z",
      "diff_hunk" : "@@ -3772,22 +3685,14 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n     if (msg_type == NetMsgType::NOTFOUND) {\n         // Remove the NOTFOUND transactions from the peer\n         LOCK(cs_main);\n-        CNodeState *state = State(pfrom.GetId());\n         std::vector<CInv> vInv;\n         vRecv >> vInv;\n-        if (vInv.size() <= MAX_PEER_TX_IN_FLIGHT + MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+        if (vInv.size() <= MAX_PEER_TX_ANNOUNCEMENTS + MAX_BLOCKS_IN_TRANSIT_PER_PEER) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499747735",
      "id" : 499747735,
      "in_reply_to_id" : 499511223,
      "line" : 3688,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0NzczNQ==",
      "original_commit_id" : "6fa4512fb450d709006fd6b242975fd3ce2f5340",
      "original_line" : 3688,
      "original_position" : 353,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 363,
      "pull_request_review_id" : 501954745,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499747735",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499749174"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499749174"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Commit for this change says \"orphan fetches\" but it's really \"fetches of orphan's parents\"...",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T17:11:23Z",
      "diff_hunk" : "@@ -806,73 +740,35 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest\n+    NodeId nodeid = node.GetId();\n+    if (!node.HasPermission(PF_RELAY) && m_txrequest.Count(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"overloaded\": if at least MAX_PEER_TX_IN_FLIGHT requests are in flight (and no PF_RELAY).\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or PF_NOBAN permission)\n+    // - \"reqtime\": immediately if none of the penalties below apply, otherwise current time plus:\n+    //   - INBOUND_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for announcements from txid peers while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from overloaded peers\n+    auto delay = std::chrono::microseconds{0};\n+    bool preferred = state->fPreferredDownload;\n+    bool overloaded = !node.HasPermission(PF_RELAY) && m_txrequest.CountInFlight(nodeid) >= MAX_PEER_TX_IN_FLIGHT;\n+    if (!preferred) delay += INBOUND_PEER_TX_DELAY;\n+    if (!gtxid.IsWtxid() && g_wtxid_relay_peers > 0) delay += TXID_RELAY_DELAY;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499749174",
      "id" : 499749174,
      "in_reply_to_id" : 497863468,
      "line" : 775,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0OTE3NA==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 775,
      "original_position" : 216,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 218,
      "pull_request_review_id" : 501954745,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499749174",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499761594"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499761594"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Random idea that I don't think we should do right now: I think we could limit this attack further if we added a `bool m_horribly_delayed : 1;` bit to each announcement. Change the ordering for choosing BEST to be `(preferred, horribly_delayed, priority)` and flip the horribly_delayed bit as part of `SetTimePoint()` when `req_time + txrequest.m_horrible_delay_time < now`, where `m_horrible_delay_time` is on the order of 10 to 60 minutes. That might also be roughly reasonable logic to do some debug logging so it's possible to catch weird behaviour in the wild.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T17:33:43Z",
      "diff_hunk" : "@@ -0,0 +1,193 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <net.h> // For NodeId\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction. Note that this only works\n+ *              per txhash, so if the same transaction is announced both through txid and wtxid, we have no means\n+ *              to prevent fetching both (the caller can however mitigate this by delaying one, see further).\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten only:\n+ *   - If a peer goes offline, all its announcements are forgotten.\n+ *   - If a transaction has been successfully received, or is otherwise no longer needed, the caller can call\n+ *     ForgetTxHash, which removes all announcements across all peers with the specified txhash.\n+ *   - If for a given txhash only already-requested announcements remain, they are all forgotten.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening transaction censoring attacks. The flip side is that as long as an attacker manages\n+ *              to prevent us from receiving a transaction, failed announcements (including those from honest peers)\n+ *              will linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a\n+ *              cap on the number of tracked announcements per peer. As failed requests in response to announcements\n+ *              from honest peers should be rare, this almost solely hinders attackers.\n+ *              Transaction censoring attacks can be done by announcing transactions quickly while not answering\n+ *              requests for them. See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more\n+ *              information.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable the calling code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers are more trusted by us, so are less likely to be under attacker control.\n+ *\n+ *   - Pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: random assignments are hard to influence for attackers.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and minimizing\n+ * susceptibility to censorship attacks. An attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one preferred connection).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution). The \"1 +\" is due to the fact that the\n+ *   attacker can be the first to announce through a preferred connection in this scenario, which very likely means\n+ *   they get the first request.\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh>=1\n+ *   are honest, where we assume that the attacker can disconnect and reconnect those connections, the distribution\n+ *   becomes k ~ P + NB(p=1-NP/NPh,r=1) (where NB stands for Negative Binomial distribution), which has mean\n+ *   P-1+NP/NPh.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499761594",
      "id" : 499761594,
      "line" : 88,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2MTU5NA==",
      "original_commit_id" : "a60ad12fb9bac2e4a8fe9018754444d48ba817ea",
      "original_line" : 88,
      "original_position" : 87,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 88,
      "pull_request_review_id" : 502274287,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499761594",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499786489"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499786489"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I agree with the goal of eventually having this not under cs_main, but the hard part will be disentangling the existing code calling into txrequest not covered by cs_main. Just adding another lock in addition to cs_main here isn't helping with that part, so I prefer doing this as a follow-up (together with probably a bigger part of net_processing also losing cs_main).",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T18:20:23Z",
      "diff_hunk" : "@@ -806,73 +740,35 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499786489",
      "id" : 499786489,
      "in_reply_to_id" : 497882360,
      "line" : 757,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4NjQ4OQ==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 757,
      "original_position" : 190,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 193,
      "pull_request_review_id" : 502307794,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499786489",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499796319"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499796319"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Hmm, that's interesting. Before the `RequestedTx` change I'd be hesitant about such a change, as it'd make specifying the conditions under which it can be called even more cumbersome. There isn't much concern about that anymore, though.\r\n\r\n@ajtowns Right, or more generally: if your clock is arbitrarily jittery, increasing the frequency of SetTimePoint calls will result in up to proportionally more work.\r\n\r\nThere may be some impact on how strong the \"first non-delayed announcement\" effect is, though (which was the reason for dropping the \"first\" marker rule): if SetTimePoint is only called once per loop, the request will go to any of the peers that announced a txhash in one loop, rather than the actual first one. This may need some investigation.\r\n\r\nSo indeed, I'd keep this for a follow-up.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T18:39:08Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo entries exist with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+\n+            // Looking up the last ByTxHash entry with the given txhash must return an Entry with that txhash or the\n+            // multi_index is very bad.\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{item.first, State::TOO_LARGE, 0}));\n+            assert(it_last != m_index.get<ByTxHash>().end() && it_last->m_txhash == item.first);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+\n+private:\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txhash that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txhash already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = m_computer(*std::prev(it));\n+            uint64_t priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in\n+            // the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Entry for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED entries.\n+\n+        // If this Entry's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Entry's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txhash, they are\n+     *  deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+     *  CANDIDATE_BEST. Returns whether the Entry still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED entry for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the entry COMPLETED, and select the next best entry (the first CANDIDATE_READY) if needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to EntryTxHashExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(EntryPeerExtractor(), std::less<EntryPeer>()),\n+            boost::make_tuple(EntryTxHashExtractor(m_computer), std::less<EntryTxHash>()),\n+            boost::make_tuple(EntryTimeExtractor(), std::less<EntryTime>())\n+        )) {}\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxHashExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+            // CANDIDATE_BEST, or delete all of a txhash's entries if no non-COMPLETED ones are left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(EntryTxHash{txhash, State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST entry for this (txhash, peer) combination. The case where\n+        // there is a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+        // automatically.\n+        if (m_index.get<ByPeer>().count(EntryPeer{peer, true, gtxid.GetHash()})) return;\n+\n+        // Find last entry for this txhash, and extract per-txhash information from it.\n+        Iter<ByTxHash> it_last = m_index.get<ByTxHash>().end();\n+        // First find the first entry past this txhash.\n+        it_last = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0});\n+        if (it_last != m_index.get<ByTxHash>().begin() && std::prev(it_last)->m_txhash == gtxid.GetHash()) {\n+            it_last--;\n+        } else {\n+            // No entry for this txhash exists yet.\n+            it_last = m_index.get<ByTxHash>().end();\n+        }\n+\n+        // Try creating the entry with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST entry already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_sequence);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+    }\n+\n+    //! Find the GenTxids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now)\n+    {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499796319",
      "id" : 499796319,
      "in_reply_to_id" : 498781706,
      "line" : 579,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc5NjMxOQ==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 579,
      "original_position" : 561,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 579,
      "pull_request_review_id" : 502320988,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499796319",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499796821"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499796821"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've changed some comments here, let me know if it's better.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T18:40:02Z",
      "diff_hunk" : "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds MIN_TIME = std::chrono::microseconds::min();\n+constexpr std::chrono::microseconds MAX_TIME = std::chrono::microseconds::max();\n+constexpr std::chrono::microseconds MICROSECOND = std::chrono::microseconds{1};\n+constexpr std::chrono::microseconds NO_TIME = std::chrono::microseconds{0};\n+\n+/** An Action is a function to call at a particular (simulated) timestamp. */\n+using Action = std::pair<std::chrono::microseconds, std::function<void()>>;\n+\n+/** Object that stores actions from multiple interleaved scenarios, and data shared across them.\n+ *\n+ * The Scenario below is used to fill this.\n+ */\n+struct Runner\n+{\n+    /** The TxRequestTracker being tested. */\n+    TxRequestTracker txrequest;\n+\n+    /** List of actions to be executed (in order of increasing timestamp). */\n+    std::vector<Action> actions;\n+\n+    /** Which node ids have been assigned already (to prevent reuse). */\n+    std::set<uint64_t> peerset;\n+\n+    /** Which txhashes have been assigned already (to prevent reuse). */\n+    std::set<uint256> txhashset;\n+};\n+\n+std::chrono::microseconds RandomTime(int bits=23) { return std::chrono::microseconds{1 + InsecureRandBits(bits)}; }\n+\n+/** A proxy for a Runner that helps build a sequence of consecutive test actions on a TxRequestTracker.\n+ *\n+ * Multiple Scenarios are used with a single Runner, resulting in interleaved actions.\n+ */\n+class Scenario\n+{\n+    Runner& m_runner;\n+    std::chrono::microseconds m_now;\n+    std::string m_testname;\n+\n+public:\n+    Scenario(Runner& runner, std::chrono::microseconds starttime) : m_runner(runner)\n+    {\n+        m_now = starttime + RandomTime() + RandomTime() + RandomTime();\n+    }\n+\n+    void SetTestName(std::string testname)\n+    {\n+        m_testname = std::move(testname);\n+    }\n+\n+    void AdvanceTime(std::chrono::microseconds amount)\n+    {\n+        assert(amount.count() >= 0);\n+        m_now += amount;\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ForgetTxHash(txhash);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool pref, std::chrono::microseconds reqtime = MIN_TIME)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedInv(peer, gtxid, pref, reqtime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.DisconnectedPeer(peer);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds exptime)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.RequestedTx(peer, gtxid, exptime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedResponse(peer, gtxid);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void Check(uint64_t peer, const std::vector<GenTxid>& expected, size_t candidates, size_t inflight,\n+        size_t completed, const std::string& checkname = \"\")\n+    {\n+        const auto comment = m_testname + \" \" + checkname;\n+        auto& runner = m_runner;\n+        const auto now = m_now;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            auto ret = runner.txrequest.GetRequestable(peer, now);\n+            runner.txrequest.SanityCheck();\n+            runner.txrequest.PostGetRequestableSanityCheck(now);\n+            size_t total = candidates + inflight + completed;\n+            size_t real_total = runner.txrequest.Count(peer);\n+            size_t real_candidates = runner.txrequest.CountCandidates(peer);\n+            size_t real_inflight = runner.txrequest.CountInFlight(peer);\n+            BOOST_CHECK_MESSAGE(real_total == total, strprintf(\"[\" + comment + \"] total %i (%i expected)\", real_total, total));\n+            BOOST_CHECK_MESSAGE(real_inflight == inflight, strprintf(\"[\" + comment + \"] inflight %i (%i expected)\", real_inflight, inflight));\n+            BOOST_CHECK_MESSAGE(real_candidates == candidates, strprintf(\"[\" + comment + \"] candidates %i (%i expected)\", real_candidates, candidates));\n+            BOOST_CHECK_MESSAGE(ret == expected, \"[\" + comment + \"] mismatching requestables\");\n+        });\n+    }\n+\n+    uint256 NewTxHash(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        uint256 ret;\n+        bool ok;\n+        do {\n+            ret = InsecureRand256();\n+            ok = true;\n+            for (const auto& order : orders) {\n+                for (size_t pos = 1; pos < order.size(); ++pos) {\n+                    uint64_t prio_prev = m_runner.txrequest.ComputePriority(ret, order[pos - 1], true);\n+                    uint64_t prio_cur = m_runner.txrequest.ComputePriority(ret, order[pos], true);\n+                    if (prio_prev >= prio_cur) {\n+                        ok = false;\n+                        break;\n+                    }\n+                }\n+                if (!ok) break;\n+            }\n+            if (ok) {\n+                ok = m_runner.txhashset.insert(ret).second;\n+            }\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    GenTxid NewGTxid(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        return {InsecureRandBool(), NewTxHash(orders)};\n+    }\n+\n+    uint64_t NewPeer()\n+    {\n+        bool ok;\n+        uint64_t ret;\n+        do {\n+            ret = InsecureRandBits(63);\n+            ok = m_runner.peerset.insert(ret).second;\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    std::chrono::microseconds Now() const { return m_now; }\n+};\n+\n+/** Add to scenario a test with a single tx announced by a single peer.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildSingleTest(Scenario& scenario, int config)\n+{\n+    auto peer = scenario.NewPeer();\n+    auto gtxid = scenario.NewGTxid();\n+    bool immediate = config & 1;\n+    bool preferred = config & 2;\n+    auto delay = immediate ? NO_TIME : RandomTime();\n+\n+    scenario.SetTestName(strprintf(\"Single(config=%i)\", config));\n+\n+    // Receive an announcement, either immediately requestable or delayed.\n+    scenario.ReceivedInv(peer, gtxid, preferred, immediate ? MIN_TIME : scenario.Now() + delay);\n+    if (immediate) {\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s1\");\n+    } else {\n+        scenario.Check(peer, {}, 1, 0, 0, \"s2\");\n+        scenario.AdvanceTime(delay - MICROSECOND);\n+        scenario.Check(peer, {}, 1, 0, 0, \"s3\");\n+        scenario.AdvanceTime(MICROSECOND);\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s4\");\n+    }\n+\n+    if (config >> 3) { // We'll request the transaction\n+        scenario.AdvanceTime(RandomTime());\n+        auto expiry = RandomTime();\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s5\");\n+        scenario.RequestedTx(peer, gtxid, scenario.Now() + expiry);\n+        scenario.Check(peer, {}, 0, 1, 0, \"s6\");\n+\n+        if ((config >> 3) == 1) { // The request will time out\n+            scenario.AdvanceTime(expiry - MICROSECOND);\n+            scenario.Check(peer, {}, 0, 1, 0, \"s7\");\n+            scenario.AdvanceTime(MICROSECOND);\n+            scenario.Check(peer, {}, 0, 0, 0, \"s8\");\n+            return;\n+        } else {\n+            scenario.AdvanceTime(std::chrono::microseconds{InsecureRandRange(expiry.count())});\n+            scenario.Check(peer, {}, 0, 1, 0, \"s9\");\n+            if ((config >> 3) == 3) { // A reponse will arrive for the transaction\n+                scenario.ReceivedResponse(peer, gtxid);\n+                scenario.Check(peer, {}, 0, 0, 0, \"s10\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    scenario.AdvanceTime(RandomTime());\n+    if (config & 4) { // The peer will go offline\n+        scenario.DisconnectedPeer(peer);\n+    } else { // The transaction is no longer needed\n+        scenario.ForgetTxHash(gtxid.GetHash());\n+    }\n+    scenario.Check(peer, {}, 0, 0, 0, \"s11\");\n+}\n+\n+/** Add to scenario a test with a single tx announced by two peers, to verify the\n+ *  right peer is selected for requests.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildPriorityTest(Scenario& scenario, int config)\n+{\n+    scenario.SetTestName(strprintf(\"Priority(config=%i)\", config));\n+\n+    // Three peers. They will announce in order.\n+    auto peer1 = scenario.NewPeer(), peer2 = scenario.NewPeer();\n+    // Construct a transaction that under random rules would be preferred by peer2 or peer1,\n+    // depending on configuration.\n+    bool prio1 = config & 1;\n+    auto gtxid = prio1 ? scenario.NewGTxid({{peer1, peer2}}) : scenario.NewGTxid({{peer2, peer1}});\n+    bool pref1 = config & 2, pref2 = config & 4;\n+\n+    scenario.ReceivedInv(peer1, gtxid, pref1, MIN_TIME);\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p1\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p2\");\n+\n+    scenario.ReceivedInv(peer2, gtxid, pref2, MIN_TIME);\n+    bool stage2_prio =\n+        // At this point, peer2 will be given priority if:\n+        // - It is preferred and peer1 is not\n+        (pref2 && !pref1) ||\n+        // - They're in the same preference class,\n+        //   and the randomized priority favors peer2 over peer1.\n+        (pref1 == pref2 && !prio1);\n+    uint64_t priopeer = stage2_prio ? peer2 : peer1, otherpeer = stage2_prio ? peer1 : peer2;\n+    scenario.Check(otherpeer, {}, 1, 0, 0, \"p3\");\n+    scenario.Check(priopeer, {gtxid}, 1, 0, 0, \"p4\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(otherpeer, {}, 1, 0, 0, \"p5\");\n+    scenario.Check(priopeer, {gtxid}, 1, 0, 0, \"p6\");\n+\n+    // We possibly request from the selected peer.\n+    if (config & 8) {\n+        scenario.RequestedTx(priopeer, gtxid, MAX_TIME);\n+        scenario.Check(priopeer, {}, 0, 1, 0, \"p7\");\n+        scenario.Check(otherpeer, {}, 1, 0, 0, \"p8\");\n+        if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    }\n+\n+    // The peer which was selected (or requested from) now goes offline, or a NOTFOUND is received from them.\n+    if (config & 16) {\n+        scenario.DisconnectedPeer(priopeer);\n+    } else {\n+        scenario.ReceivedResponse(priopeer, gtxid);\n+    }\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(priopeer, {}, 0, 0, !(config & 16), \"p8\");\n+    scenario.Check(otherpeer, {gtxid}, 1, 0, 0, \"p9\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+\n+    // Now the other peer goes offline.\n+    scenario.DisconnectedPeer(otherpeer);\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(peer1, {}, 0, 0, 0, \"p10\");\n+    scenario.Check(peer2, {}, 0, 0, 0, \"p11\");\n+}\n+\n+/** Add to scenario a randomized test in which N peers announce the same transaction, to verify\n+ *  the order in which they are requested.\n+ */\n+void BuildBigPriorityTest(Scenario& scenario, int peers)\n+{\n+    scenario.SetTestName(strprintf(\"BigPriority(peers=%i)\", peers));\n+\n+    // We will have N peers announce the same transaction.\n+    std::map<uint64_t, bool> preferred;\n+    std::vector<uint64_t> pref_order, npref_order;\n+    std::vector<uint64_t> pref_peers, npref_peers;\n+    int num_pref = InsecureRandRange(peers + 1) ; // Some preferred, ...\n+    int num_npref = peers - num_pref; // some not preferred.\n+    for (int i = 0; i < num_pref; ++i) {\n+        pref_peers.push_back(scenario.NewPeer());\n+        preferred[pref_peers.back()] = true;\n+    }\n+    for (int i = 0; i < num_npref; ++i) {\n+        npref_peers.push_back(scenario.NewPeer());\n+        preferred[npref_peers.back()] = false;\n+    }\n+    // Make a list of all peers, in order of intended request order (concatenation of pref_peers and\n+    // npref_peers).\n+    std::vector<uint64_t> request_order;\n+    for (int i = 0; i < num_pref; ++i) request_order.push_back(pref_peers[i]);\n+    for (int i = 0; i < num_npref; ++i) request_order.push_back(npref_peers[i]);\n+\n+    // Setup pref_order\n+    for (int i = 0; i < num_pref; ++i) {\n+        pref_order.push_back(pref_peers[i]);\n+    }\n+\n+    // Setup npref_order\n+    for (int i = 0; i < num_npref; ++i) {\n+        npref_order.push_back(npref_peers[i]);\n+    }\n+\n+    // Determine the announcement order randomly.\n+    std::vector<uint64_t> announce_order = request_order;\n+    Shuffle(announce_order.begin(), announce_order.end(), g_insecure_rand_ctx);\n+\n+    // Find a gtxid that has a prioritization consistent with the required pref_order and npref_order.\n+    auto gtxid = scenario.NewGTxid({pref_order, npref_order});\n+\n+    // Decide reqtimes in opposite order of the eventual request order. So every time time jumps\n+    // past the next reqtime, the to-be-requested-from peer will change.\n+    std::map<uint64_t, std::chrono::microseconds> reqtimes;\n+    auto reqtime = scenario.Now();\n+    for (int i = peers - 1; i >= 0; --i) {\n+        reqtime += RandomTime();\n+        reqtimes[request_order[i]] = reqtime;\n+    }\n+\n+    // Actually announce from all peers simultaneously (but in announce_order).\n+    for (const auto peer : announce_order) {\n+        scenario.ReceivedInv(peer, gtxid, preferred[peer], reqtimes[peer]);\n+    }\n+    for (const auto peer : announce_order) {\n+        scenario.Check(peer, {}, 1, 0, 0, \"b1\");\n+    }\n+\n+    // Let time pass and observe the to-be-requested-from peer change.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499796821",
      "id" : 499796821,
      "in_reply_to_id" : 498961964,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc5NjgyMQ==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 370,
      "original_position" : 370,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 502321634,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499796821",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499796950"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499796950"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've changed some comments.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T18:40:16Z",
      "diff_hunk" : "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds MIN_TIME = std::chrono::microseconds::min();\n+constexpr std::chrono::microseconds MAX_TIME = std::chrono::microseconds::max();\n+constexpr std::chrono::microseconds MICROSECOND = std::chrono::microseconds{1};\n+constexpr std::chrono::microseconds NO_TIME = std::chrono::microseconds{0};\n+\n+/** An Action is a function to call at a particular (simulated) timestamp. */\n+using Action = std::pair<std::chrono::microseconds, std::function<void()>>;\n+\n+/** Object that stores actions from multiple interleaved scenarios, and data shared across them.\n+ *\n+ * The Scenario below is used to fill this.\n+ */\n+struct Runner\n+{\n+    /** The TxRequestTracker being tested. */\n+    TxRequestTracker txrequest;\n+\n+    /** List of actions to be executed (in order of increasing timestamp). */\n+    std::vector<Action> actions;\n+\n+    /** Which node ids have been assigned already (to prevent reuse). */\n+    std::set<uint64_t> peerset;\n+\n+    /** Which txhashes have been assigned already (to prevent reuse). */\n+    std::set<uint256> txhashset;\n+};\n+\n+std::chrono::microseconds RandomTime(int bits=23) { return std::chrono::microseconds{1 + InsecureRandBits(bits)}; }\n+\n+/** A proxy for a Runner that helps build a sequence of consecutive test actions on a TxRequestTracker.\n+ *\n+ * Multiple Scenarios are used with a single Runner, resulting in interleaved actions.\n+ */\n+class Scenario\n+{\n+    Runner& m_runner;\n+    std::chrono::microseconds m_now;\n+    std::string m_testname;\n+\n+public:\n+    Scenario(Runner& runner, std::chrono::microseconds starttime) : m_runner(runner)\n+    {\n+        m_now = starttime + RandomTime() + RandomTime() + RandomTime();\n+    }\n+\n+    void SetTestName(std::string testname)\n+    {\n+        m_testname = std::move(testname);\n+    }\n+\n+    void AdvanceTime(std::chrono::microseconds amount)\n+    {\n+        assert(amount.count() >= 0);\n+        m_now += amount;\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ForgetTxHash(txhash);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool pref, std::chrono::microseconds reqtime = MIN_TIME)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedInv(peer, gtxid, pref, reqtime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.DisconnectedPeer(peer);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds exptime)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.RequestedTx(peer, gtxid, exptime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedResponse(peer, gtxid);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void Check(uint64_t peer, const std::vector<GenTxid>& expected, size_t candidates, size_t inflight,\n+        size_t completed, const std::string& checkname = \"\")\n+    {\n+        const auto comment = m_testname + \" \" + checkname;\n+        auto& runner = m_runner;\n+        const auto now = m_now;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            auto ret = runner.txrequest.GetRequestable(peer, now);\n+            runner.txrequest.SanityCheck();\n+            runner.txrequest.PostGetRequestableSanityCheck(now);\n+            size_t total = candidates + inflight + completed;\n+            size_t real_total = runner.txrequest.Count(peer);\n+            size_t real_candidates = runner.txrequest.CountCandidates(peer);\n+            size_t real_inflight = runner.txrequest.CountInFlight(peer);\n+            BOOST_CHECK_MESSAGE(real_total == total, strprintf(\"[\" + comment + \"] total %i (%i expected)\", real_total, total));\n+            BOOST_CHECK_MESSAGE(real_inflight == inflight, strprintf(\"[\" + comment + \"] inflight %i (%i expected)\", real_inflight, inflight));\n+            BOOST_CHECK_MESSAGE(real_candidates == candidates, strprintf(\"[\" + comment + \"] candidates %i (%i expected)\", real_candidates, candidates));\n+            BOOST_CHECK_MESSAGE(ret == expected, \"[\" + comment + \"] mismatching requestables\");\n+        });\n+    }\n+\n+    uint256 NewTxHash(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        uint256 ret;\n+        bool ok;\n+        do {\n+            ret = InsecureRand256();\n+            ok = true;\n+            for (const auto& order : orders) {\n+                for (size_t pos = 1; pos < order.size(); ++pos) {\n+                    uint64_t prio_prev = m_runner.txrequest.ComputePriority(ret, order[pos - 1], true);\n+                    uint64_t prio_cur = m_runner.txrequest.ComputePriority(ret, order[pos], true);\n+                    if (prio_prev >= prio_cur) {\n+                        ok = false;\n+                        break;\n+                    }\n+                }\n+                if (!ok) break;\n+            }\n+            if (ok) {\n+                ok = m_runner.txhashset.insert(ret).second;\n+            }\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    GenTxid NewGTxid(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        return {InsecureRandBool(), NewTxHash(orders)};\n+    }\n+\n+    uint64_t NewPeer()\n+    {\n+        bool ok;\n+        uint64_t ret;\n+        do {\n+            ret = InsecureRandBits(63);\n+            ok = m_runner.peerset.insert(ret).second;\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    std::chrono::microseconds Now() const { return m_now; }\n+};\n+\n+/** Add to scenario a test with a single tx announced by a single peer.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildSingleTest(Scenario& scenario, int config)\n+{\n+    auto peer = scenario.NewPeer();\n+    auto gtxid = scenario.NewGTxid();\n+    bool immediate = config & 1;\n+    bool preferred = config & 2;\n+    auto delay = immediate ? NO_TIME : RandomTime();\n+\n+    scenario.SetTestName(strprintf(\"Single(config=%i)\", config));\n+\n+    // Receive an announcement, either immediately requestable or delayed.\n+    scenario.ReceivedInv(peer, gtxid, preferred, immediate ? MIN_TIME : scenario.Now() + delay);\n+    if (immediate) {\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s1\");\n+    } else {\n+        scenario.Check(peer, {}, 1, 0, 0, \"s2\");\n+        scenario.AdvanceTime(delay - MICROSECOND);\n+        scenario.Check(peer, {}, 1, 0, 0, \"s3\");\n+        scenario.AdvanceTime(MICROSECOND);\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s4\");\n+    }\n+\n+    if (config >> 3) { // We'll request the transaction\n+        scenario.AdvanceTime(RandomTime());\n+        auto expiry = RandomTime();\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s5\");\n+        scenario.RequestedTx(peer, gtxid, scenario.Now() + expiry);\n+        scenario.Check(peer, {}, 0, 1, 0, \"s6\");\n+\n+        if ((config >> 3) == 1) { // The request will time out\n+            scenario.AdvanceTime(expiry - MICROSECOND);\n+            scenario.Check(peer, {}, 0, 1, 0, \"s7\");\n+            scenario.AdvanceTime(MICROSECOND);\n+            scenario.Check(peer, {}, 0, 0, 0, \"s8\");\n+            return;\n+        } else {\n+            scenario.AdvanceTime(std::chrono::microseconds{InsecureRandRange(expiry.count())});\n+            scenario.Check(peer, {}, 0, 1, 0, \"s9\");\n+            if ((config >> 3) == 3) { // A reponse will arrive for the transaction\n+                scenario.ReceivedResponse(peer, gtxid);\n+                scenario.Check(peer, {}, 0, 0, 0, \"s10\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    scenario.AdvanceTime(RandomTime());\n+    if (config & 4) { // The peer will go offline\n+        scenario.DisconnectedPeer(peer);\n+    } else { // The transaction is no longer needed\n+        scenario.ForgetTxHash(gtxid.GetHash());\n+    }\n+    scenario.Check(peer, {}, 0, 0, 0, \"s11\");\n+}\n+\n+/** Add to scenario a test with a single tx announced by two peers, to verify the\n+ *  right peer is selected for requests.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildPriorityTest(Scenario& scenario, int config)\n+{\n+    scenario.SetTestName(strprintf(\"Priority(config=%i)\", config));\n+\n+    // Three peers. They will announce in order.\n+    auto peer1 = scenario.NewPeer(), peer2 = scenario.NewPeer();\n+    // Construct a transaction that under random rules would be preferred by peer2 or peer1,\n+    // depending on configuration.\n+    bool prio1 = config & 1;\n+    auto gtxid = prio1 ? scenario.NewGTxid({{peer1, peer2}}) : scenario.NewGTxid({{peer2, peer1}});\n+    bool pref1 = config & 2, pref2 = config & 4;\n+\n+    scenario.ReceivedInv(peer1, gtxid, pref1, MIN_TIME);\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p1\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p2\");\n+\n+    scenario.ReceivedInv(peer2, gtxid, pref2, MIN_TIME);\n+    bool stage2_prio =\n+        // At this point, peer2 will be given priority if:\n+        // - It is preferred and peer1 is not\n+        (pref2 && !pref1) ||\n+        // - They're in the same preference class,\n+        //   and the randomized priority favors peer2 over peer1.\n+        (pref1 == pref2 && !prio1);\n+    uint64_t priopeer = stage2_prio ? peer2 : peer1, otherpeer = stage2_prio ? peer1 : peer2;\n+    scenario.Check(otherpeer, {}, 1, 0, 0, \"p3\");\n+    scenario.Check(priopeer, {gtxid}, 1, 0, 0, \"p4\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(otherpeer, {}, 1, 0, 0, \"p5\");\n+    scenario.Check(priopeer, {gtxid}, 1, 0, 0, \"p6\");\n+\n+    // We possibly request from the selected peer.\n+    if (config & 8) {\n+        scenario.RequestedTx(priopeer, gtxid, MAX_TIME);\n+        scenario.Check(priopeer, {}, 0, 1, 0, \"p7\");\n+        scenario.Check(otherpeer, {}, 1, 0, 0, \"p8\");\n+        if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    }\n+\n+    // The peer which was selected (or requested from) now goes offline, or a NOTFOUND is received from them.\n+    if (config & 16) {\n+        scenario.DisconnectedPeer(priopeer);\n+    } else {\n+        scenario.ReceivedResponse(priopeer, gtxid);\n+    }\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(priopeer, {}, 0, 0, !(config & 16), \"p8\");\n+    scenario.Check(otherpeer, {gtxid}, 1, 0, 0, \"p9\");\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+\n+    // Now the other peer goes offline.\n+    scenario.DisconnectedPeer(otherpeer);\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime());\n+    scenario.Check(peer1, {}, 0, 0, 0, \"p10\");\n+    scenario.Check(peer2, {}, 0, 0, 0, \"p11\");\n+}\n+\n+/** Add to scenario a randomized test in which N peers announce the same transaction, to verify\n+ *  the order in which they are requested.\n+ */\n+void BuildBigPriorityTest(Scenario& scenario, int peers)\n+{\n+    scenario.SetTestName(strprintf(\"BigPriority(peers=%i)\", peers));\n+\n+    // We will have N peers announce the same transaction.\n+    std::map<uint64_t, bool> preferred;\n+    std::vector<uint64_t> pref_order, npref_order;\n+    std::vector<uint64_t> pref_peers, npref_peers;\n+    int num_pref = InsecureRandRange(peers + 1) ; // Some preferred, ...\n+    int num_npref = peers - num_pref; // some not preferred.\n+    for (int i = 0; i < num_pref; ++i) {\n+        pref_peers.push_back(scenario.NewPeer());\n+        preferred[pref_peers.back()] = true;\n+    }\n+    for (int i = 0; i < num_npref; ++i) {\n+        npref_peers.push_back(scenario.NewPeer());\n+        preferred[npref_peers.back()] = false;\n+    }\n+    // Make a list of all peers, in order of intended request order (concatenation of pref_peers and\n+    // npref_peers).\n+    std::vector<uint64_t> request_order;\n+    for (int i = 0; i < num_pref; ++i) request_order.push_back(pref_peers[i]);\n+    for (int i = 0; i < num_npref; ++i) request_order.push_back(npref_peers[i]);\n+\n+    // Setup pref_order\n+    for (int i = 0; i < num_pref; ++i) {\n+        pref_order.push_back(pref_peers[i]);\n+    }\n+\n+    // Setup npref_order\n+    for (int i = 0; i < num_npref; ++i) {\n+        npref_order.push_back(npref_peers[i]);\n+    }\n+\n+    // Determine the announcement order randomly.\n+    std::vector<uint64_t> announce_order = request_order;\n+    Shuffle(announce_order.begin(), announce_order.end(), g_insecure_rand_ctx);\n+\n+    // Find a gtxid that has a prioritization consistent with the required pref_order and npref_order.\n+    auto gtxid = scenario.NewGTxid({pref_order, npref_order});\n+\n+    // Decide reqtimes in opposite order of the eventual request order. So every time time jumps\n+    // past the next reqtime, the to-be-requested-from peer will change.\n+    std::map<uint64_t, std::chrono::microseconds> reqtimes;\n+    auto reqtime = scenario.Now();\n+    for (int i = peers - 1; i >= 0; --i) {\n+        reqtime += RandomTime();\n+        reqtimes[request_order[i]] = reqtime;\n+    }\n+\n+    // Actually announce from all peers simultaneously (but in announce_order).\n+    for (const auto peer : announce_order) {\n+        scenario.ReceivedInv(peer, gtxid, preferred[peer], reqtimes[peer]);\n+    }\n+    for (const auto peer : announce_order) {\n+        scenario.Check(peer, {}, 1, 0, 0, \"b1\");\n+    }\n+\n+    // Let time pass and observe the to-be-requested-from peer change.\n+    for (int i = peers - 1; i >= 0; --i) {\n+        scenario.AdvanceTime(reqtimes[request_order[i]] - scenario.Now() - MICROSECOND);\n+        scenario.Check(request_order[i], {}, 1, 0, 0, \"b2\");\n+        scenario.AdvanceTime(MICROSECOND);\n+        scenario.Check(request_order[i], {gtxid}, 1, 0, 0, \"b3\");\n+    }\n+\n+    // Peers now in random order go offline, or send NOTFOUNDs. Observe the to-be-requested-peer\n+    // change whenever the previous best one disappears.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499796950",
      "id" : 499796950,
      "in_reply_to_id" : 498963087,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc5Njk1MA==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 379,
      "original_position" : 379,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 502321807,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499796950",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499813414"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499813414"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Right, I don't think this is a DoS vector as it's fairly cheap per byte compared to many other requests.\r\n\r\nThe only concern would be latency, e.g. might it cause a significant interruption of a net processing loop to process 5016 NOTFOUNDs at once? I think not, but if it is, we may use the split processing technique used for getdata and orphan processing - independent of what the limit here is.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T19:10:48Z",
      "diff_hunk" : "@@ -3772,22 +3685,14 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n     if (msg_type == NetMsgType::NOTFOUND) {\n         // Remove the NOTFOUND transactions from the peer\n         LOCK(cs_main);\n-        CNodeState *state = State(pfrom.GetId());\n         std::vector<CInv> vInv;\n         vRecv >> vInv;\n-        if (vInv.size() <= MAX_PEER_TX_IN_FLIGHT + MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+        if (vInv.size() <= MAX_PEER_TX_ANNOUNCEMENTS + MAX_BLOCKS_IN_TRANSIT_PER_PEER) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499813414",
      "id" : 499813414,
      "in_reply_to_id" : 499511223,
      "line" : 3688,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgxMzQxNA==",
      "original_commit_id" : "6fa4512fb450d709006fd6b242975fd3ce2f5340",
      "original_line" : 3688,
      "original_position" : 353,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 363,
      "pull_request_review_id" : 502343584,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499813414",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499843653"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499843653"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T20:09:59Z",
      "diff_hunk" : "@@ -806,73 +740,35 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest\n+    NodeId nodeid = node.GetId();\n+    if (!node.HasPermission(PF_RELAY) && m_txrequest.Count(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"overloaded\": if at least MAX_PEER_TX_IN_FLIGHT requests are in flight (and no PF_RELAY).\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or PF_NOBAN permission)\n+    // - \"reqtime\": immediately if none of the penalties below apply, otherwise current time plus:\n+    //   - INBOUND_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for announcements from txid peers while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from overloaded peers\n+    auto delay = std::chrono::microseconds{0};\n+    bool preferred = state->fPreferredDownload;\n+    bool overloaded = !node.HasPermission(PF_RELAY) && m_txrequest.CountInFlight(nodeid) >= MAX_PEER_TX_IN_FLIGHT;\n+    if (!preferred) delay += INBOUND_PEER_TX_DELAY;\n+    if (!gtxid.IsWtxid() && g_wtxid_relay_peers > 0) delay += TXID_RELAY_DELAY;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499843653",
      "id" : 499843653,
      "in_reply_to_id" : 497863468,
      "line" : 775,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg0MzY1Mw==",
      "original_commit_id" : "ee3a74a4e5d29257405f0a0919030996727d5f80",
      "original_line" : 775,
      "original_position" : 216,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 218,
      "pull_request_review_id" : 502383550,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499843653",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499843825"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499843825"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Really done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T20:10:19Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499843825",
      "id" : 499843825,
      "in_reply_to_id" : 498727923,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg0MzgyNQ==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 278,
      "original_position" : 269,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 502383766,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499843825",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499844082"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499844082"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yeah, trying to minimize diff - this shouldn't matter much.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T20:10:47Z",
      "diff_hunk" : "@@ -2994,9 +2898,7 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n         TxValidationState state;\n \n         for (const GenTxid& gtxid : {GenTxid(false, txid), GenTxid(true, wtxid)}) {\n-            nodestate->m_tx_download.m_tx_announced.erase(gtxid.GetHash());\n-            nodestate->m_tx_download.m_tx_in_flight.erase(gtxid.GetHash());\n-            EraseTxRequest(gtxid);\n+            m_txrequest.ReceivedResponse(pfrom.GetId(), gtxid);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499844082",
      "id" : 499844082,
      "in_reply_to_id" : 498773268,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg0NDA4Mg==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 2901,
      "original_position" : 276,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 502384087,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499844082",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499844446"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499844446"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've made it conditional with an `if InsecureRandBool()` around it.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T20:11:29Z",
      "diff_hunk" : "@@ -0,0 +1,539 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds MIN_TIME = std::chrono::microseconds::min();\n+constexpr std::chrono::microseconds MAX_TIME = std::chrono::microseconds::max();\n+constexpr std::chrono::microseconds MICROSECOND = std::chrono::microseconds{1};\n+constexpr std::chrono::microseconds NO_TIME = std::chrono::microseconds{0};\n+\n+/** An Action is a function to call at a particular (simulated) timestamp. */\n+using Action = std::pair<std::chrono::microseconds, std::function<void()>>;\n+\n+/** Object that stores actions from multiple interleaved scenarios, and data shared across them.\n+ *\n+ * The Scenario below is used to fill this.\n+ */\n+struct Runner\n+{\n+    /** The TxRequestTracker being tested. */\n+    TxRequestTracker txrequest;\n+\n+    /** List of actions to be executed (in order of increasing timestamp). */\n+    std::vector<Action> actions;\n+\n+    /** Which node ids have been assigned already (to prevent reuse). */\n+    std::set<uint64_t> peerset;\n+\n+    /** Which txhashes have been assigned already (to prevent reuse). */\n+    std::set<uint256> txhashset;\n+};\n+\n+std::chrono::microseconds RandomTime(int bits=23) { return std::chrono::microseconds{1 + InsecureRandBits(bits)}; }\n+\n+/** A proxy for a Runner that helps build a sequence of consecutive test actions on a TxRequestTracker.\n+ *\n+ * Multiple Scenarios are used with a single Runner, resulting in interleaved actions.\n+ */\n+class Scenario\n+{\n+    Runner& m_runner;\n+    std::chrono::microseconds m_now;\n+    std::string m_testname;\n+\n+public:\n+    Scenario(Runner& runner, std::chrono::microseconds starttime) : m_runner(runner)\n+    {\n+        m_now = starttime + RandomTime() + RandomTime() + RandomTime();\n+    }\n+\n+    void SetTestName(std::string testname)\n+    {\n+        m_testname = std::move(testname);\n+    }\n+\n+    void AdvanceTime(std::chrono::microseconds amount)\n+    {\n+        assert(amount.count() >= 0);\n+        m_now += amount;\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ForgetTxHash(txhash);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool pref, std::chrono::microseconds reqtime = MIN_TIME)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedInv(peer, gtxid, pref, reqtime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.DisconnectedPeer(peer);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds exptime)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.RequestedTx(peer, gtxid, exptime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedResponse(peer, gtxid);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    void Check(uint64_t peer, const std::vector<GenTxid>& expected, size_t candidates, size_t inflight,\n+        size_t completed, const std::string& checkname = \"\")\n+    {\n+        const auto comment = m_testname + \" \" + checkname;\n+        auto& runner = m_runner;\n+        const auto now = m_now;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            auto ret = runner.txrequest.GetRequestable(peer, now);\n+            runner.txrequest.SanityCheck();\n+            runner.txrequest.PostGetRequestableSanityCheck(now);\n+            size_t total = candidates + inflight + completed;\n+            size_t real_total = runner.txrequest.Count(peer);\n+            size_t real_candidates = runner.txrequest.CountCandidates(peer);\n+            size_t real_inflight = runner.txrequest.CountInFlight(peer);\n+            BOOST_CHECK_MESSAGE(real_total == total, strprintf(\"[\" + comment + \"] total %i (%i expected)\", real_total, total));\n+            BOOST_CHECK_MESSAGE(real_inflight == inflight, strprintf(\"[\" + comment + \"] inflight %i (%i expected)\", real_inflight, inflight));\n+            BOOST_CHECK_MESSAGE(real_candidates == candidates, strprintf(\"[\" + comment + \"] candidates %i (%i expected)\", real_candidates, candidates));\n+            BOOST_CHECK_MESSAGE(ret == expected, \"[\" + comment + \"] mismatching requestables\");\n+        });\n+    }\n+\n+    uint256 NewTxHash(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        uint256 ret;\n+        bool ok;\n+        do {\n+            ret = InsecureRand256();\n+            ok = true;\n+            for (const auto& order : orders) {\n+                for (size_t pos = 1; pos < order.size(); ++pos) {\n+                    uint64_t prio_prev = m_runner.txrequest.ComputePriority(ret, order[pos - 1], true);\n+                    uint64_t prio_cur = m_runner.txrequest.ComputePriority(ret, order[pos], true);\n+                    if (prio_prev >= prio_cur) {\n+                        ok = false;\n+                        break;\n+                    }\n+                }\n+                if (!ok) break;\n+            }\n+            if (ok) {\n+                ok = m_runner.txhashset.insert(ret).second;\n+            }\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    GenTxid NewGTxid(const std::vector<std::vector<uint64_t>>& orders = {})\n+    {\n+        return {InsecureRandBool(), NewTxHash(orders)};\n+    }\n+\n+    uint64_t NewPeer()\n+    {\n+        bool ok;\n+        uint64_t ret;\n+        do {\n+            ret = InsecureRandBits(63);\n+            ok = m_runner.peerset.insert(ret).second;\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    std::chrono::microseconds Now() const { return m_now; }\n+};\n+\n+/** Add to scenario a test with a single tx announced by a single peer.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildSingleTest(Scenario& scenario, int config)\n+{\n+    auto peer = scenario.NewPeer();\n+    auto gtxid = scenario.NewGTxid();\n+    bool immediate = config & 1;\n+    bool preferred = config & 2;\n+    auto delay = immediate ? NO_TIME : RandomTime();\n+\n+    scenario.SetTestName(strprintf(\"Single(config=%i)\", config));\n+\n+    // Receive an announcement, either immediately requestable or delayed.\n+    scenario.ReceivedInv(peer, gtxid, preferred, immediate ? MIN_TIME : scenario.Now() + delay);\n+    if (immediate) {\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s1\");\n+    } else {\n+        scenario.Check(peer, {}, 1, 0, 0, \"s2\");\n+        scenario.AdvanceTime(delay - MICROSECOND);\n+        scenario.Check(peer, {}, 1, 0, 0, \"s3\");\n+        scenario.AdvanceTime(MICROSECOND);\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s4\");\n+    }\n+\n+    if (config >> 3) { // We'll request the transaction\n+        scenario.AdvanceTime(RandomTime());\n+        auto expiry = RandomTime();\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s5\");\n+        scenario.RequestedTx(peer, gtxid, scenario.Now() + expiry);\n+        scenario.Check(peer, {}, 0, 1, 0, \"s6\");\n+\n+        if ((config >> 3) == 1) { // The request will time out\n+            scenario.AdvanceTime(expiry - MICROSECOND);\n+            scenario.Check(peer, {}, 0, 1, 0, \"s7\");\n+            scenario.AdvanceTime(MICROSECOND);\n+            scenario.Check(peer, {}, 0, 0, 0, \"s8\");\n+            return;\n+        } else {\n+            scenario.AdvanceTime(std::chrono::microseconds{InsecureRandRange(expiry.count())});\n+            scenario.Check(peer, {}, 0, 1, 0, \"s9\");\n+            if ((config >> 3) == 3) { // A reponse will arrive for the transaction\n+                scenario.ReceivedResponse(peer, gtxid);\n+                scenario.Check(peer, {}, 0, 0, 0, \"s10\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    scenario.AdvanceTime(RandomTime());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499844446",
      "id" : 499844446,
      "in_reply_to_id" : 498973098,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg0NDQ0Ng==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 261,
      "original_position" : 237,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 502384581,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499844446",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499844557"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499844557"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Agreed. I've rewritten this a bit.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T20:11:43Z",
      "diff_hunk" : "@@ -0,0 +1,716 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of ByTxHashView relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE announcement whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED announcement already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority announcement among all CANDIDATE_READY (and _BEST) ones for that\n+     *  txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED announcement. */\n+    REQUESTED,\n+    /** A CANDIDATE announcement that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED announcement. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+//! Type alias for sequence numbers.\n+using SequenceNumber = uint64_t;\n+\n+/** An announcement. This is the data we track for each txid or wtxid that is announced to us by each peer. */\n+struct Announcement {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const NodeId m_peer;\n+    /** What sequence number this announcement has. */\n+    const SequenceNumber m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this announcement is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this announcement is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this announcement can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new announcement from scratch, initially in CANDIDATE_DELAYED state. */\n+    Announcement(const GenTxid& gtxid, NodeId peer, bool preferred, std::chrono::microseconds reqtime,\n+        SequenceNumber sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+//! Type alias for priorities.\n+using Priority = uint64_t;\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    Priority operator()(const uint256& txhash, NodeId peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    Priority operator()(const Announcement& ann) const\n+    {\n+        return operator()(ann.m_txhash, ann.m_peer, ann.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a By*View data type to represent the view of Announcement it is sorted\n+// by, and an By*ViewExtractor type to convert an Announcement into the By*View type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing announcements by peer/txhash, by checking both (peer, false, txhash) and\n+//   (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST announcements for a given peer in GetRequestable.\n+struct ByPeer {};\n+using ByPeerView = std::tuple<NodeId, bool, const uint256&>;\n+struct ByPeerViewExtractor\n+{\n+    using result_type = ByPeerView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByPeerView{ann.m_peer, ann.GetState() == State::CANDIDATE_BEST, ann.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Announcements with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Announcement exists for that txhash.\n+// * Determining when no more non-COMPLETED Announcements for a given txhash exist, so the COMPLETED ones can be\n+//   deleted.\n+struct ByTxHash {};\n+using ByTxHashView = std::tuple<const uint256&, State, Priority>;\n+class ByTxHashViewExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    ByTxHashViewExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = ByTxHashView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        const State state = ann.GetState();\n+        const Priority prio = (state == State::CANDIDATE_READY) ? m_computer(ann) : 0;\n+        return ByTxHashView{ann.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED announcements whose reqtime has passed, and REQUESTED announcements whose expiry has\n+//   passed.\n+// * Finding CANDIDATE_READY/BEST announcements whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using ByTimeView = std::pair<int, std::chrono::microseconds>;\n+struct ByTimeViewExtractor\n+{\n+    using result_type = ByTimeView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByTimeView{ann.IsWaiting() ? 0 : ann.IsSelectable() ? 2 : 1, ann.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Announcement objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Announcement,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, ByPeerViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, ByTxHashViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, ByTimeViewExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of announcements for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED announcements for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED announcements for this peer.\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST announcement if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an announcement for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** Compare two PeerInfo objects. Only used for sanity checking. */\n+bool operator==(const PeerInfo& a, const PeerInfo& b)\n+{\n+    return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+           std::tie(b.m_total, b.m_completed, b.m_requested);\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<NodeId, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<NodeId, PeerInfo> ret;\n+    for (const Announcement& ann : index) {\n+        PeerInfo& info = ret[ann.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (ann.GetState() == State::REQUESTED);\n+        info.m_completed += (ann.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Announcement& ann : index) {\n+        TxHashInfo& info = ret[ann.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (ann.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (ann.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (ann.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (ann.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (ann.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(ann);\n+        }\n+        if (ann.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(ann));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(ann.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    SequenceNumber m_current_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure. See SanityCheck() for the invariants that apply to it.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<NodeId, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo entries exist with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // announcement.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST announcement, the CANDIDATE_BEST one must be\n+            // at least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+\n+            // Looking up the last ByTxHash announcement with the given txhash must return an Announcement with that\n+            // txhash or the multi_index is very bad.\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                ByTxHashView{item.first, State::TOO_LARGE, 0}));\n+            assert(it_last != m_index.get<ByTxHash>().end() && it_last->m_txhash == item.first);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const Announcement& ann : m_index) {\n+            if (ann.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(ann.m_time > now);\n+            } else if (ann.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(ann.m_time <= now);\n+            }\n+        }\n+    }\n+\n+private:\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED announcement into a CANDIDATE_READY. If this makes it the new best\n+    //! CANDIDATE_READY (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new\n+    //! CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY announcements, the best one (lowest\n+        // priority) comes first. Thus, if an existing _BEST exists for the same txhash that this announcement may\n+        // be preferred over, it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() announcement for this txhash\n+            // already.\n+            Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            Priority priority_old = m_computer(*std::prev(it));\n+            Priority priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST announcement already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an announcement to something non-IsSelected(). If it was IsSelected(), the next best\n+    //! announcement will be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST\n+            // announcement in the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Announcement& ann){ ann.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Announcement for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED announcements.\n+\n+        // If this Announcement's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Announcement's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any announcement to a COMPLETED one. If there are no non-COMPLETED announcements left for this\n+     *  txhash, they are deleted. If this was a REQUESTED announcement, and there are other CANDIDATEs left, the\n+     *  best one is made CANDIDATE_BEST. Returns whether the Announcement still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED announcement for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the announcement COMPLETED, and select the next best announcement (the first CANDIDATE_READY) if\n+        // needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED annoucements with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED announcements with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} announcements with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY announcements back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to ByTxHashViewExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(ByPeerViewExtractor(), std::less<ByPeerView>()),\n+            boost::make_tuple(ByTxHashViewExtractor(m_computer), std::less<ByTxHashView>()),\n+            boost::make_tuple(ByTimeViewExtractor(), std::less<ByTimeView>())\n+        )) {}\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful ByTxHashViewExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DisconnectedPeer(NodeId peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(ByPeerView{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the announcement isn't already COMPLETED, first make it COMPLETED (which will mark other\n+            // CANDIDATEs as CANDIDATE_BEST, or delete all of a txhash's announcements if no non-COMPLETED ones are\n+            // left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the announcement (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(ByTxHashView{txhash, State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(NodeId peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST announcement for this (txhash, peer) combination. The case\n+        // where there is a non-CANDIDATE_BEST announcement already will be caught by the uniqueness property of the\n+        // ByPeer index when we try to emplace the new object below.\n+        if (m_index.get<ByPeer>().count(ByPeerView{peer, true, gtxid.GetHash()})) return;\n+\n+        // Try creating the announcement with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST announcement already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_current_sequence);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_current_sequence;\n+    }\n+\n+    //! Find the GenTxids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(NodeId peer, std::chrono::microseconds now)\n+    {\n+        // Move time.\n+        SetTimePoint(now);\n+\n+        // Find all CANDIDATE_BEST announcements for this peer.\n+        std::vector<std::pair<SequenceNumber, const Announcement*>> selected;\n+        auto it_peer = m_index.get<ByPeer>().lower_bound(ByPeerView{peer, true, UINT256_ZERO});\n+        while (it_peer != m_index.get<ByPeer>().end() && it_peer->m_peer == peer &&\n+            it_peer->GetState() == State::CANDIDATE_BEST) {\n+            selected.emplace_back(it_peer->m_sequence, &*it_peer);\n+            ++it_peer;\n+        }\n+\n+        // Return them, sorted by sequence number.\n+        std::sort(selected.begin(), selected.end());\n+        std::vector<GenTxid> ret;\n+        for (const auto& item : selected) {\n+            ret.emplace_back(item.second->m_is_wtxid, item.second->m_txhash);\n+        }\n+        return ret;\n+    }\n+\n+    void RequestedTx(NodeId peer, const uint256& txhash, std::chrono::microseconds expiry)\n+    {\n+        auto it = m_index.get<ByPeer>().find(ByPeerView{peer, true, txhash});\n+        if (it == m_index.get<ByPeer>().end()) {\n+            // There is no CANDIDATE_BEST announcement, look for a _READY or _DELAYED instead. If the caller only\n+            // ever invokes RequestedTx with the values returned by GetRequestable, and no other non-const functions\n+            // other than ForgetTxHash and GetRequestable in between, this branch will never execute (as txhashes\n+            // returned by GetRequestable always correspond to CANDIDATE_BEST announcements).\n+\n+            it = m_index.get<ByPeer>().find(ByPeerView{peer, false, txhash});\n+            if (it == m_index.get<ByPeer>().end() || (it->GetState() != State::CANDIDATE_DELAYED &&\n+                it->GetState() != State::CANDIDATE_READY)) {\n+                // The txhash was not tracked for this peer, so we have nothing to do. The caller should have called",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499844557",
      "id" : 499844557,
      "in_reply_to_id" : 499468847,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg0NDU1Nw==",
      "original_commit_id" : "6fa4512fb450d709006fd6b242975fd3ce2f5340",
      "original_line" : 602,
      "original_position" : 602,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 502384753,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499844557",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499844934"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499844934"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've just deleted this (as well as the TOO_LARGE enum value). It was only needed when the SanityCheck code actually needed it_last for the per-txhash flags which are gone now.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T20:12:29Z",
      "diff_hunk" : "@@ -0,0 +1,716 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of ByTxHashView relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE announcement whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED announcement already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority announcement among all CANDIDATE_READY (and _BEST) ones for that\n+     *  txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED announcement. */\n+    REQUESTED,\n+    /** A CANDIDATE announcement that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED announcement. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+//! Type alias for sequence numbers.\n+using SequenceNumber = uint64_t;\n+\n+/** An announcement. This is the data we track for each txid or wtxid that is announced to us by each peer. */\n+struct Announcement {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const NodeId m_peer;\n+    /** What sequence number this announcement has. */\n+    const SequenceNumber m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this announcement is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this announcement is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this announcement can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new announcement from scratch, initially in CANDIDATE_DELAYED state. */\n+    Announcement(const GenTxid& gtxid, NodeId peer, bool preferred, std::chrono::microseconds reqtime,\n+        SequenceNumber sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+//! Type alias for priorities.\n+using Priority = uint64_t;\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    Priority operator()(const uint256& txhash, NodeId peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    Priority operator()(const Announcement& ann) const\n+    {\n+        return operator()(ann.m_txhash, ann.m_peer, ann.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a By*View data type to represent the view of Announcement it is sorted\n+// by, and an By*ViewExtractor type to convert an Announcement into the By*View type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing announcements by peer/txhash, by checking both (peer, false, txhash) and\n+//   (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST announcements for a given peer in GetRequestable.\n+struct ByPeer {};\n+using ByPeerView = std::tuple<NodeId, bool, const uint256&>;\n+struct ByPeerViewExtractor\n+{\n+    using result_type = ByPeerView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByPeerView{ann.m_peer, ann.GetState() == State::CANDIDATE_BEST, ann.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Announcements with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Announcement exists for that txhash.\n+// * Determining when no more non-COMPLETED Announcements for a given txhash exist, so the COMPLETED ones can be\n+//   deleted.\n+struct ByTxHash {};\n+using ByTxHashView = std::tuple<const uint256&, State, Priority>;\n+class ByTxHashViewExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    ByTxHashViewExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = ByTxHashView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        const State state = ann.GetState();\n+        const Priority prio = (state == State::CANDIDATE_READY) ? m_computer(ann) : 0;\n+        return ByTxHashView{ann.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED announcements whose reqtime has passed, and REQUESTED announcements whose expiry has\n+//   passed.\n+// * Finding CANDIDATE_READY/BEST announcements whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using ByTimeView = std::pair<int, std::chrono::microseconds>;\n+struct ByTimeViewExtractor\n+{\n+    using result_type = ByTimeView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByTimeView{ann.IsWaiting() ? 0 : ann.IsSelectable() ? 2 : 1, ann.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Announcement objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Announcement,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, ByPeerViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, ByTxHashViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, ByTimeViewExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of announcements for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED announcements for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED announcements for this peer.\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST announcement if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an announcement for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** Compare two PeerInfo objects. Only used for sanity checking. */\n+bool operator==(const PeerInfo& a, const PeerInfo& b)\n+{\n+    return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+           std::tie(b.m_total, b.m_completed, b.m_requested);\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<NodeId, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<NodeId, PeerInfo> ret;\n+    for (const Announcement& ann : index) {\n+        PeerInfo& info = ret[ann.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (ann.GetState() == State::REQUESTED);\n+        info.m_completed += (ann.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Announcement& ann : index) {\n+        TxHashInfo& info = ret[ann.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (ann.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (ann.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (ann.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (ann.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (ann.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(ann);\n+        }\n+        if (ann.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(ann));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(ann.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    SequenceNumber m_current_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure. See SanityCheck() for the invariants that apply to it.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<NodeId, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo entries exist with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // announcement.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST announcement, the CANDIDATE_BEST one must be\n+            // at least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+\n+            // Looking up the last ByTxHash announcement with the given txhash must return an Announcement with that\n+            // txhash or the multi_index is very bad.\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                ByTxHashView{item.first, State::TOO_LARGE, 0}));\n+            assert(it_last != m_index.get<ByTxHash>().end() && it_last->m_txhash == item.first);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499844934",
      "id" : 499844934,
      "in_reply_to_id" : 499493545,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg0NDkzNA==",
      "original_commit_id" : "6fa4512fb450d709006fd6b242975fd3ce2f5340",
      "original_line" : 339,
      "original_position" : 339,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 502385256,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499844934",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499845033"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499845033"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ok, renamed.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T20:12:40Z",
      "diff_hunk" : "@@ -816,73 +750,34 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499845033",
      "id" : 499845033,
      "in_reply_to_id" : 499503606,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg0NTAzMw==",
      "original_commit_id" : "6fa4512fb450d709006fd6b242975fd3ce2f5340",
      "original_line" : 755,
      "original_position" : 185,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 502385392,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499845033",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499845151"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499845151"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done, also the meh.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T20:12:53Z",
      "diff_hunk" : "@@ -816,73 +750,34 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest\n+    NodeId nodeid = node.GetId();\n+    if (!node.HasPermission(PF_RELAY) && m_txrequest.Count(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+\n+    // Decide the TxRequestTracker parameters for this announcement:\n+    // - \"preferred\": if fPreferredDownload is set (= outbound, or PF_NOBAN permission)\n+    // - \"reqtime\": current time plus delays for:\n+    //   - NONPREF_PEER_TX_DELAY for announcements from non-preferred connections\n+    //   - TXID_RELAY_DELAY for txid announcements while wtxid peers are available\n+    //   - OVERLOADED_PEER_TX_DELAY for announcements from peers which have at least\n+    //     MAX_PEER_TX_IN_FLIGHT requests in flight (and don't have PF_RELAY).\n+    auto delay = std::chrono::microseconds{0};\n+    bool preferred = state->fPreferredDownload;\n+    bool overloaded = !node.HasPermission(PF_RELAY) && m_txrequest.CountInFlight(nodeid) >= MAX_PEER_TX_IN_FLIGHT;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499845151",
      "id" : 499845151,
      "in_reply_to_id" : 499505840,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg0NTE1MQ==",
      "original_commit_id" : "6fa4512fb450d709006fd6b242975fd3ce2f5340",
      "original_line" : 774,
      "original_position" : 217,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 502385534,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499845151",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499845237"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499845237"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T20:13:03Z",
      "diff_hunk" : "@@ -3772,22 +3685,14 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n     if (msg_type == NetMsgType::NOTFOUND) {\n         // Remove the NOTFOUND transactions from the peer\n         LOCK(cs_main);\n-        CNodeState *state = State(pfrom.GetId());\n         std::vector<CInv> vInv;\n         vRecv >> vInv;\n-        if (vInv.size() <= MAX_PEER_TX_IN_FLIGHT + MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+        if (vInv.size() <= MAX_PEER_TX_ANNOUNCEMENTS + MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n             for (CInv &inv : vInv) {\n                 if (inv.IsGenTxMsg()) {\n                     // If we receive a NOTFOUND message for a txid we requested, erase\n                     // it from our data structures for this peer.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499845237",
      "id" : 499845237,
      "in_reply_to_id" : 499507369,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg0NTIzNw==",
      "original_commit_id" : "6fa4512fb450d709006fd6b242975fd3ce2f5340",
      "original_line" : 3694,
      "original_position" : 357,
      "original_start_line" : 3693,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 502385655,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499845237",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499845608"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499845608"
         }
      },
      "author_association" : "MEMBER",
      "body" : "What a wasted opportunity to say \"Remove the STALE comment from the pr\" instead.\r\n\r\nDone.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T20:13:50Z",
      "diff_hunk" : "@@ -3772,22 +3685,14 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n     if (msg_type == NetMsgType::NOTFOUND) {\n         // Remove the NOTFOUND transactions from the peer",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499845608",
      "id" : 499845608,
      "in_reply_to_id" : 499511969,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg0NTYwOA==",
      "original_commit_id" : "6fa4512fb450d709006fd6b242975fd3ce2f5340",
      "original_line" : 3686,
      "original_position" : 347,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 502386204,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499845608",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499845940"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499845940"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done. I haven't moved it into the loop as I expect common iterations of the loop to be faster or at least in the same order of magnitude as grabbing a lock.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T20:14:27Z",
      "diff_hunk" : "@@ -3772,22 +3685,14 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n     if (msg_type == NetMsgType::NOTFOUND) {\n         // Remove the NOTFOUND transactions from the peer\n         LOCK(cs_main);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499845940",
      "id" : 499845940,
      "in_reply_to_id" : 499512149,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg0NTk0MA==",
      "original_commit_id" : "6fa4512fb450d709006fd6b242975fd3ce2f5340",
      "original_line" : 3687,
      "original_position" : 348,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 502386616,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499845940",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499846639"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499846639"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done, that's more readable indeed.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T20:15:49Z",
      "diff_hunk" : "@@ -0,0 +1,577 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of ByTxHashView relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE announcement whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED announcement already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority announcement among all CANDIDATE_READY (and _BEST) ones for that\n+     *  txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED announcement. */\n+    REQUESTED,\n+    /** A CANDIDATE announcement that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED announcement. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+//! Type alias for sequence numbers.\n+using SequenceNumber = uint64_t;\n+\n+/** An announcement. This is the data we track for each txid or wtxid that is announced to us by each peer. */\n+struct Announcement {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const NodeId m_peer;\n+    /** What sequence number this announcement has. */\n+    const SequenceNumber m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this announcement is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this announcement is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this announcement can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new announcement from scratch, initially in CANDIDATE_DELAYED state. */\n+    Announcement(const GenTxid& gtxid, NodeId peer, bool preferred, std::chrono::microseconds reqtime,\n+        SequenceNumber sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+//! Type alias for priorities.\n+using Priority = uint64_t;\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    Priority operator()(const uint256& txhash, NodeId peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    Priority operator()(const Announcement& ann) const\n+    {\n+        return operator()(ann.m_txhash, ann.m_peer, ann.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a By*View data type to represent the view of Announcement it is sorted\n+// by, and an By*ViewExtractor type to convert an Announcement into the By*View type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing announcements by peer/txhash, by checking both (peer, false, txhash) and\n+//   (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST announcements for a given peer in GetRequestable.\n+struct ByPeer {};\n+using ByPeerView = std::tuple<NodeId, bool, const uint256&>;\n+struct ByPeerViewExtractor\n+{\n+    using result_type = ByPeerView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByPeerView{ann.m_peer, ann.GetState() == State::CANDIDATE_BEST, ann.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499846639",
      "id" : 499846639,
      "in_reply_to_id" : 499523971,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg0NjYzOQ==",
      "original_commit_id" : "a60ad12fb9bac2e4a8fe9018754444d48ba817ea",
      "original_line" : 157,
      "original_position" : 157,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 502387514,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499846639",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499847441"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499847441"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.\r\n\r\nIt's borderline, I think, as you could read the comments for this function do not claim they'll do anything but change the state of the passed iterator to the passed value - only about other announcements. Still, better to be explicit so added an assert.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T20:17:22Z",
      "diff_hunk" : "@@ -0,0 +1,577 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of ByTxHashView relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE announcement whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED announcement already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority announcement among all CANDIDATE_READY (and _BEST) ones for that\n+     *  txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED announcement. */\n+    REQUESTED,\n+    /** A CANDIDATE announcement that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED announcement. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+//! Type alias for sequence numbers.\n+using SequenceNumber = uint64_t;\n+\n+/** An announcement. This is the data we track for each txid or wtxid that is announced to us by each peer. */\n+struct Announcement {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const NodeId m_peer;\n+    /** What sequence number this announcement has. */\n+    const SequenceNumber m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this announcement is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this announcement is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this announcement can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new announcement from scratch, initially in CANDIDATE_DELAYED state. */\n+    Announcement(const GenTxid& gtxid, NodeId peer, bool preferred, std::chrono::microseconds reqtime,\n+        SequenceNumber sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+//! Type alias for priorities.\n+using Priority = uint64_t;\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    Priority operator()(const uint256& txhash, NodeId peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    Priority operator()(const Announcement& ann) const\n+    {\n+        return operator()(ann.m_txhash, ann.m_peer, ann.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a By*View data type to represent the view of Announcement it is sorted\n+// by, and an By*ViewExtractor type to convert an Announcement into the By*View type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing announcements by peer/txhash, by checking both (peer, false, txhash) and\n+//   (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST announcements for a given peer in GetRequestable.\n+struct ByPeer {};\n+using ByPeerView = std::tuple<NodeId, bool, const uint256&>;\n+struct ByPeerViewExtractor\n+{\n+    using result_type = ByPeerView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByPeerView{ann.m_peer, ann.GetState() == State::CANDIDATE_BEST, ann.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Announcements with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Announcement exists for that txhash.\n+// * Determining when no more non-COMPLETED Announcements for a given txhash exist, so the COMPLETED ones can be\n+//   deleted.\n+struct ByTxHash {};\n+using ByTxHashView = std::tuple<const uint256&, State, Priority>;\n+class ByTxHashViewExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    ByTxHashViewExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = ByTxHashView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        const State state = ann.GetState();\n+        const Priority prio = (state == State::CANDIDATE_READY) ? m_computer(ann) : 0;\n+        return ByTxHashView{ann.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED announcements whose reqtime has passed, and REQUESTED announcements whose expiry has\n+//   passed.\n+// * Finding CANDIDATE_READY/BEST announcements whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using ByTimeView = std::pair<int, std::chrono::microseconds>;\n+struct ByTimeViewExtractor\n+{\n+    using result_type = ByTimeView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByTimeView{ann.IsWaiting() ? 0 : ann.IsSelectable() ? 2 : 1, ann.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Announcement objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Announcement,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, ByPeerViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, ByTxHashViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, ByTimeViewExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of announcements for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED announcements for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED announcements for this peer.\n+};\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    SequenceNumber m_current_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<NodeId, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED announcement into a CANDIDATE_READY. If this makes it the new best\n+    //! CANDIDATE_READY (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new\n+    //! CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY announcements, the best one (lowest\n+        // priority) comes first. Thus, if an existing _BEST exists for the same txhash that this announcement may\n+        // be preferred over, it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() announcement for this txhash\n+            // already.\n+            Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            Priority priority_old = m_computer(*std::prev(it));\n+            Priority priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST announcement already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an announcement to something non-IsSelected(). If it was IsSelected(), the next best\n+    //! announcement will be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499847441",
      "id" : 499847441,
      "in_reply_to_id" : 499532324,
      "line" : 427,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg0NzQ0MQ==",
      "original_commit_id" : "a60ad12fb9bac2e4a8fe9018754444d48ba817ea",
      "original_line" : 427,
      "original_position" : 295,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 427,
      "pull_request_review_id" : 502388547,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499847441",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499847764"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499847764"
         }
      },
      "author_association" : "MEMBER",
      "body" : "That would be a more logical ordering. Let me try what would be needed to make this work later.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T20:18:01Z",
      "diff_hunk" : "@@ -0,0 +1,577 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of ByTxHashView relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE announcement whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED announcement already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority announcement among all CANDIDATE_READY (and _BEST) ones for that\n+     *  txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED announcement. */\n+    REQUESTED,\n+    /** A CANDIDATE announcement that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED announcement. */\n+    COMPLETED,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499847764",
      "id" : 499847764,
      "in_reply_to_id" : 499567299,
      "line" : 50,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg0Nzc2NA==",
      "original_commit_id" : "a60ad12fb9bac2e4a8fe9018754444d48ba817ea",
      "original_line" : 50,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 50,
      "pull_request_review_id" : 502388962,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499847764",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499847825"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499847825"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nice, done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T20:18:09Z",
      "diff_hunk" : "@@ -0,0 +1,577 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of ByTxHashView relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE announcement whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED announcement already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority announcement among all CANDIDATE_READY (and _BEST) ones for that\n+     *  txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED announcement. */\n+    REQUESTED,\n+    /** A CANDIDATE announcement that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED announcement. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+//! Type alias for sequence numbers.\n+using SequenceNumber = uint64_t;\n+\n+/** An announcement. This is the data we track for each txid or wtxid that is announced to us by each peer. */\n+struct Announcement {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const NodeId m_peer;\n+    /** What sequence number this announcement has. */\n+    const SequenceNumber m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this announcement is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this announcement is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this announcement can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new announcement from scratch, initially in CANDIDATE_DELAYED state. */\n+    Announcement(const GenTxid& gtxid, NodeId peer, bool preferred, std::chrono::microseconds reqtime,\n+        SequenceNumber sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+//! Type alias for priorities.\n+using Priority = uint64_t;\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    Priority operator()(const uint256& txhash, NodeId peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    Priority operator()(const Announcement& ann) const\n+    {\n+        return operator()(ann.m_txhash, ann.m_peer, ann.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a By*View data type to represent the view of Announcement it is sorted\n+// by, and an By*ViewExtractor type to convert an Announcement into the By*View type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing announcements by peer/txhash, by checking both (peer, false, txhash) and\n+//   (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST announcements for a given peer in GetRequestable.\n+struct ByPeer {};\n+using ByPeerView = std::tuple<NodeId, bool, const uint256&>;\n+struct ByPeerViewExtractor\n+{\n+    using result_type = ByPeerView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByPeerView{ann.m_peer, ann.GetState() == State::CANDIDATE_BEST, ann.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Announcements with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Announcement exists for that txhash.\n+// * Determining when no more non-COMPLETED Announcements for a given txhash exist, so the COMPLETED ones can be\n+//   deleted.\n+struct ByTxHash {};\n+using ByTxHashView = std::tuple<const uint256&, State, Priority>;\n+class ByTxHashViewExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    ByTxHashViewExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = ByTxHashView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        const State state = ann.GetState();\n+        const Priority prio = (state == State::CANDIDATE_READY) ? m_computer(ann) : 0;\n+        return ByTxHashView{ann.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499847825",
      "id" : 499847825,
      "in_reply_to_id" : 499581088,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg0NzgyNQ==",
      "original_commit_id" : "a60ad12fb9bac2e4a8fe9018754444d48ba817ea",
      "original_line" : 181,
      "original_position" : 181,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 502389051,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499847825",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499848146"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499848146"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Agree, but that sounds like really a follow-up (or even a follow-up issue to investigate the use of that first).",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T20:18:47Z",
      "diff_hunk" : "@@ -0,0 +1,577 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of ByTxHashView relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE announcement whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED announcement already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority announcement among all CANDIDATE_READY (and _BEST) ones for that\n+     *  txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED announcement. */\n+    REQUESTED,\n+    /** A CANDIDATE announcement that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED announcement. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+//! Type alias for sequence numbers.\n+using SequenceNumber = uint64_t;\n+\n+/** An announcement. This is the data we track for each txid or wtxid that is announced to us by each peer. */\n+struct Announcement {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const NodeId m_peer;\n+    /** What sequence number this announcement has. */\n+    const SequenceNumber m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this announcement is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this announcement is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this announcement can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new announcement from scratch, initially in CANDIDATE_DELAYED state. */\n+    Announcement(const GenTxid& gtxid, NodeId peer, bool preferred, std::chrono::microseconds reqtime,\n+        SequenceNumber sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+//! Type alias for priorities.\n+using Priority = uint64_t;\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    Priority operator()(const uint256& txhash, NodeId peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    Priority operator()(const Announcement& ann) const\n+    {\n+        return operator()(ann.m_txhash, ann.m_peer, ann.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a By*View data type to represent the view of Announcement it is sorted\n+// by, and an By*ViewExtractor type to convert an Announcement into the By*View type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing announcements by peer/txhash, by checking both (peer, false, txhash) and\n+//   (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST announcements for a given peer in GetRequestable.\n+struct ByPeer {};\n+using ByPeerView = std::tuple<NodeId, bool, const uint256&>;\n+struct ByPeerViewExtractor\n+{\n+    using result_type = ByPeerView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByPeerView{ann.m_peer, ann.GetState() == State::CANDIDATE_BEST, ann.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Announcements with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Announcement exists for that txhash.\n+// * Determining when no more non-COMPLETED Announcements for a given txhash exist, so the COMPLETED ones can be\n+//   deleted.\n+struct ByTxHash {};\n+using ByTxHashView = std::tuple<const uint256&, State, Priority>;\n+class ByTxHashViewExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    ByTxHashViewExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = ByTxHashView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        const State state = ann.GetState();\n+        const Priority prio = (state == State::CANDIDATE_READY) ? m_computer(ann) : 0;\n+        return ByTxHashView{ann.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED announcements whose reqtime has passed, and REQUESTED announcements whose expiry has\n+//   passed.\n+// * Finding CANDIDATE_READY/BEST announcements whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using ByTimeView = std::pair<int, std::chrono::microseconds>;\n+struct ByTimeViewExtractor\n+{\n+    using result_type = ByTimeView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByTimeView{ann.IsWaiting() ? 0 : ann.IsSelectable() ? 2 : 1, ann.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Announcement objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Announcement,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, ByPeerViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, ByTxHashViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, ByTimeViewExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of announcements for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED announcements for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED announcements for this peer.\n+};\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    SequenceNumber m_current_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<NodeId, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED announcement into a CANDIDATE_READY. If this makes it the new best\n+    //! CANDIDATE_READY (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new\n+    //! CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY announcements, the best one (lowest\n+        // priority) comes first. Thus, if an existing _BEST exists for the same txhash that this announcement may\n+        // be preferred over, it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() announcement for this txhash\n+            // already.\n+            Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            Priority priority_old = m_computer(*std::prev(it));\n+            Priority priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST announcement already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an announcement to something non-IsSelected(). If it was IsSelected(), the next best\n+    //! announcement will be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST\n+            // announcement in the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Announcement& ann){ ann.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Announcement for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED announcements.\n+\n+        // If this Announcement's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Announcement's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any announcement to a COMPLETED one. If there are no non-COMPLETED announcements left for this\n+     *  txhash, they are deleted. If this was a REQUESTED announcement, and there are other CANDIDATEs left, the\n+     *  best one is made CANDIDATE_BEST. Returns whether the Announcement still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED announcement for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the announcement COMPLETED, and select the next best announcement (the first CANDIDATE_READY) if\n+        // needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED annoucements with expiry <= now are turned into COMPLETED.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499848146",
      "id" : 499848146,
      "in_reply_to_id" : 499591256,
      "line" : 485,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg0ODE0Ng==",
      "original_commit_id" : "a60ad12fb9bac2e4a8fe9018754444d48ba817ea",
      "original_line" : 485,
      "original_position" : 353,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 485,
      "pull_request_review_id" : 502389476,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499848146",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499848208"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499848208"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T20:18:55Z",
      "diff_hunk" : "@@ -0,0 +1,577 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of ByTxHashView relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE announcement whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED announcement already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority announcement among all CANDIDATE_READY (and _BEST) ones for that\n+     *  txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED announcement. */\n+    REQUESTED,\n+    /** A CANDIDATE announcement that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED announcement. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+//! Type alias for sequence numbers.\n+using SequenceNumber = uint64_t;\n+\n+/** An announcement. This is the data we track for each txid or wtxid that is announced to us by each peer. */\n+struct Announcement {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const NodeId m_peer;\n+    /** What sequence number this announcement has. */\n+    const SequenceNumber m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this announcement is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this announcement is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this announcement can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new announcement from scratch, initially in CANDIDATE_DELAYED state. */\n+    Announcement(const GenTxid& gtxid, NodeId peer, bool preferred, std::chrono::microseconds reqtime,\n+        SequenceNumber sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+//! Type alias for priorities.\n+using Priority = uint64_t;\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    Priority operator()(const uint256& txhash, NodeId peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    Priority operator()(const Announcement& ann) const\n+    {\n+        return operator()(ann.m_txhash, ann.m_peer, ann.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a By*View data type to represent the view of Announcement it is sorted\n+// by, and an By*ViewExtractor type to convert an Announcement into the By*View type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing announcements by peer/txhash, by checking both (peer, false, txhash) and\n+//   (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST announcements for a given peer in GetRequestable.\n+struct ByPeer {};\n+using ByPeerView = std::tuple<NodeId, bool, const uint256&>;\n+struct ByPeerViewExtractor\n+{\n+    using result_type = ByPeerView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByPeerView{ann.m_peer, ann.GetState() == State::CANDIDATE_BEST, ann.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Announcements with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Announcement exists for that txhash.\n+// * Determining when no more non-COMPLETED Announcements for a given txhash exist, so the COMPLETED ones can be\n+//   deleted.\n+struct ByTxHash {};\n+using ByTxHashView = std::tuple<const uint256&, State, Priority>;\n+class ByTxHashViewExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    ByTxHashViewExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = ByTxHashView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        const State state = ann.GetState();\n+        const Priority prio = (state == State::CANDIDATE_READY) ? m_computer(ann) : 0;\n+        return ByTxHashView{ann.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED announcements whose reqtime has passed, and REQUESTED announcements whose expiry has\n+//   passed.\n+// * Finding CANDIDATE_READY/BEST announcements whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using ByTimeView = std::pair<int, std::chrono::microseconds>;\n+struct ByTimeViewExtractor\n+{\n+    using result_type = ByTimeView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByTimeView{ann.IsWaiting() ? 0 : ann.IsSelectable() ? 2 : 1, ann.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Announcement objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Announcement,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, ByPeerViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, ByTxHashViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, ByTimeViewExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of announcements for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED announcements for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED announcements for this peer.\n+};\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    SequenceNumber m_current_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<NodeId, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED announcement into a CANDIDATE_READY. If this makes it the new best\n+    //! CANDIDATE_READY (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new\n+    //! CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY announcements, the best one (lowest\n+        // priority) comes first. Thus, if an existing _BEST exists for the same txhash that this announcement may\n+        // be preferred over, it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() announcement for this txhash\n+            // already.\n+            Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            Priority priority_old = m_computer(*std::prev(it));\n+            Priority priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST announcement already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an announcement to something non-IsSelected(). If it was IsSelected(), the next best\n+    //! announcement will be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST\n+            // announcement in the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Announcement& ann){ ann.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Announcement for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED announcements.\n+\n+        // If this Announcement's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Announcement's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any announcement to a COMPLETED one. If there are no non-COMPLETED announcements left for this\n+     *  txhash, they are deleted. If this was a REQUESTED announcement, and there are other CANDIDATEs left, the\n+     *  best one is made CANDIDATE_BEST. Returns whether the Announcement still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED announcement for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the announcement COMPLETED, and select the next best announcement (the first CANDIDATE_READY) if\n+        // needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED annoucements with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED announcements with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} announcements with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY announcements back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to ByTxHashViewExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(ByPeerViewExtractor(), std::less<ByPeerView>()),\n+            boost::make_tuple(ByTxHashViewExtractor(m_computer), std::less<ByTxHashView>()),\n+            boost::make_tuple(ByTimeViewExtractor(), std::less<ByTimeView>())\n+        )) {}\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful ByTxHashViewExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DisconnectedPeer(NodeId peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(ByPeerView{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the announcement isn't already COMPLETED, first make it COMPLETED (which will mark other\n+            // CANDIDATEs as CANDIDATE_BEST, or delete all of a txhash's announcements if no non-COMPLETED ones are\n+            // left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the announcement (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(ByTxHashView{txhash, State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(NodeId peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST announcement for this (txhash, peer) combination. The case\n+        // where there is a non-CANDIDATE_BEST announcement already will be caught by the uniqueness property of the\n+        // ByPeer index when we try to emplace the new object below.\n+        if (m_index.get<ByPeer>().count(ByPeerView{peer, true, gtxid.GetHash()})) return;\n+\n+        // Try creating the announcement with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST announcement already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_current_sequence);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_current_sequence;\n+    }\n+\n+    //! Find the GenTxids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(NodeId peer, std::chrono::microseconds now)\n+    {\n+        // Move time.\n+        SetTimePoint(now);\n+\n+        // Find all CANDIDATE_BEST announcements for this peer.\n+        std::vector<std::pair<SequenceNumber, const Announcement*>> selected;\n+        auto it_peer = m_index.get<ByPeer>().lower_bound(ByPeerView{peer, true, UINT256_ZERO});\n+        while (it_peer != m_index.get<ByPeer>().end() && it_peer->m_peer == peer &&\n+            it_peer->GetState() == State::CANDIDATE_BEST) {\n+            selected.emplace_back(it_peer->m_sequence, &*it_peer);\n+            ++it_peer;\n+        }\n+\n+        // Return them, sorted by sequence number.\n+        std::sort(selected.begin(), selected.end());\n+        std::vector<GenTxid> ret;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499848208",
      "id" : 499848208,
      "in_reply_to_id" : 499605596,
      "line" : 594,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg0ODIwOA==",
      "original_commit_id" : "a60ad12fb9bac2e4a8fe9018754444d48ba817ea",
      "original_line" : 594,
      "original_position" : 462,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 594,
      "pull_request_review_id" : 502389560,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499848208",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499848391"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499848391"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yeah, future work...",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T20:19:13Z",
      "diff_hunk" : "@@ -0,0 +1,577 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of ByTxHashView relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE announcement whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED announcement already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority announcement among all CANDIDATE_READY (and _BEST) ones for that\n+     *  txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED announcement. */\n+    REQUESTED,\n+    /** A CANDIDATE announcement that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED announcement. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+//! Type alias for sequence numbers.\n+using SequenceNumber = uint64_t;\n+\n+/** An announcement. This is the data we track for each txid or wtxid that is announced to us by each peer. */\n+struct Announcement {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const NodeId m_peer;\n+    /** What sequence number this announcement has. */\n+    const SequenceNumber m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this announcement is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this announcement is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this announcement can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new announcement from scratch, initially in CANDIDATE_DELAYED state. */\n+    Announcement(const GenTxid& gtxid, NodeId peer, bool preferred, std::chrono::microseconds reqtime,\n+        SequenceNumber sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+//! Type alias for priorities.\n+using Priority = uint64_t;\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    Priority operator()(const uint256& txhash, NodeId peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    Priority operator()(const Announcement& ann) const\n+    {\n+        return operator()(ann.m_txhash, ann.m_peer, ann.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a By*View data type to represent the view of Announcement it is sorted\n+// by, and an By*ViewExtractor type to convert an Announcement into the By*View type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing announcements by peer/txhash, by checking both (peer, false, txhash) and\n+//   (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST announcements for a given peer in GetRequestable.\n+struct ByPeer {};\n+using ByPeerView = std::tuple<NodeId, bool, const uint256&>;\n+struct ByPeerViewExtractor\n+{\n+    using result_type = ByPeerView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByPeerView{ann.m_peer, ann.GetState() == State::CANDIDATE_BEST, ann.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Announcements with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Announcement exists for that txhash.\n+// * Determining when no more non-COMPLETED Announcements for a given txhash exist, so the COMPLETED ones can be\n+//   deleted.\n+struct ByTxHash {};\n+using ByTxHashView = std::tuple<const uint256&, State, Priority>;\n+class ByTxHashViewExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    ByTxHashViewExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = ByTxHashView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        const State state = ann.GetState();\n+        const Priority prio = (state == State::CANDIDATE_READY) ? m_computer(ann) : 0;\n+        return ByTxHashView{ann.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED announcements whose reqtime has passed, and REQUESTED announcements whose expiry has\n+//   passed.\n+// * Finding CANDIDATE_READY/BEST announcements whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using ByTimeView = std::pair<int, std::chrono::microseconds>;\n+struct ByTimeViewExtractor\n+{\n+    using result_type = ByTimeView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByTimeView{ann.IsWaiting() ? 0 : ann.IsSelectable() ? 2 : 1, ann.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Announcement objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Announcement,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, ByPeerViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, ByTxHashViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, ByTimeViewExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of announcements for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED announcements for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED announcements for this peer.\n+};\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    SequenceNumber m_current_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<NodeId, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED announcement into a CANDIDATE_READY. If this makes it the new best\n+    //! CANDIDATE_READY (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new\n+    //! CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY announcements, the best one (lowest\n+        // priority) comes first. Thus, if an existing _BEST exists for the same txhash that this announcement may\n+        // be preferred over, it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() announcement for this txhash\n+            // already.\n+            Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            Priority priority_old = m_computer(*std::prev(it));\n+            Priority priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST announcement already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an announcement to something non-IsSelected(). If it was IsSelected(), the next best\n+    //! announcement will be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST\n+            // announcement in the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Announcement& ann){ ann.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Announcement for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED announcements.\n+\n+        // If this Announcement's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Announcement's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any announcement to a COMPLETED one. If there are no non-COMPLETED announcements left for this\n+     *  txhash, they are deleted. If this was a REQUESTED announcement, and there are other CANDIDATEs left, the\n+     *  best one is made CANDIDATE_BEST. Returns whether the Announcement still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED announcement for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the announcement COMPLETED, and select the next best announcement (the first CANDIDATE_READY) if\n+        // needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED annoucements with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED announcements with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} announcements with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY announcements back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to ByTxHashViewExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(ByPeerViewExtractor(), std::less<ByPeerView>()),\n+            boost::make_tuple(ByTxHashViewExtractor(m_computer), std::less<ByTxHashView>()),\n+            boost::make_tuple(ByTimeViewExtractor(), std::less<ByTimeView>())\n+        )) {}\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful ByTxHashViewExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DisconnectedPeer(NodeId peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(ByPeerView{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the announcement isn't already COMPLETED, first make it COMPLETED (which will mark other\n+            // CANDIDATEs as CANDIDATE_BEST, or delete all of a txhash's announcements if no non-COMPLETED ones are\n+            // left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the announcement (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(ByTxHashView{txhash, State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(NodeId peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST announcement for this (txhash, peer) combination. The case\n+        // where there is a non-CANDIDATE_BEST announcement already will be caught by the uniqueness property of the\n+        // ByPeer index when we try to emplace the new object below.\n+        if (m_index.get<ByPeer>().count(ByPeerView{peer, true, gtxid.GetHash()})) return;\n+\n+        // Try creating the announcement with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST announcement already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_current_sequence);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_current_sequence;\n+    }\n+\n+    //! Find the GenTxids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(NodeId peer, std::chrono::microseconds now)\n+    {\n+        // Move time.\n+        SetTimePoint(now);\n+\n+        // Find all CANDIDATE_BEST announcements for this peer.\n+        std::vector<std::pair<SequenceNumber, const Announcement*>> selected;\n+        auto it_peer = m_index.get<ByPeer>().lower_bound(ByPeerView{peer, true, UINT256_ZERO});\n+        while (it_peer != m_index.get<ByPeer>().end() && it_peer->m_peer == peer &&\n+            it_peer->GetState() == State::CANDIDATE_BEST) {\n+            selected.emplace_back(it_peer->m_sequence, &*it_peer);\n+            ++it_peer;\n+        }\n+\n+        // Return them, sorted by sequence number.\n+        std::sort(selected.begin(), selected.end());\n+        std::vector<GenTxid> ret;\n+        for (const auto& item : selected) {\n+            ret.emplace_back(item.second->m_is_wtxid, item.second->m_txhash);\n+        }\n+        return ret;\n+    }\n+\n+    void RequestedTx(NodeId peer, const uint256& txhash, std::chrono::microseconds expiry)\n+    {\n+        auto it = m_index.get<ByPeer>().find(ByPeerView{peer, true, txhash});\n+        if (it == m_index.get<ByPeer>().end()) {\n+            // There is no CANDIDATE_BEST announcement, look for a _READY or _DELAYED instead. If the caller only\n+            // ever invokes RequestedTx with the values returned by GetRequestable, and no other non-const functions\n+            // other than ForgetTxHash and GetRequestable in between, this branch will never execute (as txhashes\n+            // returned by GetRequestable always correspond to CANDIDATE_BEST announcements).\n+\n+            it = m_index.get<ByPeer>().find(ByPeerView{peer, false, txhash});\n+            if (it == m_index.get<ByPeer>().end() || (it->GetState() != State::CANDIDATE_DELAYED &&\n+                it->GetState() != State::CANDIDATE_READY)) {\n+                // The txhash was not tracked for this peer, so we have nothing to do. The caller should have called\n+                // ReceivedInv first.\n+                return;\n+            }\n+\n+            // Look for an existing CANDIDATE_BEST or REQUESTED.\n+            auto it_old = m_index.get<ByTxHash>().lower_bound(ByTxHashView{txhash, State::CANDIDATE_BEST, 0});\n+            if (it_old != m_index.get<ByTxHash>().end() && it_old->m_txhash == txhash) {\n+                if (it_old->GetState() == State::CANDIDATE_BEST) {\n+                    // The data structure's invariants require that there can be at most one CANDIDATE_BEST or one\n+                    // REQUESTED announcement per txhash (but not both simultaneously), so we have to convert any\n+                    // existing CANDIDATE_BEST to another CANDIDATE_* when constructing another REQUESTED.\n+                    // It doesn't matter whether we pick CANDIDATE_READY or _DELAYED here, as SetTimePoint()\n+                    // will correct it at GetRequestable() time. If time only goes forward, it will always be\n+                    // _READY, so pick that to avoid extra work in SetTimePoint().\n+                    Modify<ByTxHash>(it_old, [](Announcement& ann) { ann.SetState(State::CANDIDATE_READY); });\n+                } else if (it_old->GetState() == State::REQUESTED) {\n+                    // As we're no longer waiting for a response to the previous REQUESTED announcement, convert it\n+                    // to COMPLETED. This also helps guaranteeing progress.\n+                    Modify<ByTxHash>(it_old, [](Announcement& ann) { ann.SetState(State::COMPLETED); });\n+                }\n+            }\n+        }\n+\n+        Modify<ByPeer>(it, [expiry](Announcement& ann) {\n+            ann.SetState(State::REQUESTED);\n+            ann.m_time = expiry;\n+        });\n+    }\n+\n+    void ReceivedResponse(NodeId peer, const uint256& txhash)\n+    {\n+        // We need to search the ByPeer index for both (peer, false, txhash) and (peer, true, txhash).\n+        auto it = m_index.get<ByPeer>().find(ByPeerView{peer, false, txhash});\n+        if (it == m_index.get<ByPeer>().end()) {\n+            it = m_index.get<ByPeer>().find(ByPeerView{peer, true, txhash});\n+        }\n+        if (it != m_index.get<ByPeer>().end()) MakeCompleted(m_index.project<ByTxHash>(it));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499848391",
      "id" : 499848391,
      "in_reply_to_id" : 499627889,
      "line" : 652,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg0ODM5MQ==",
      "original_commit_id" : "a60ad12fb9bac2e4a8fe9018754444d48ba817ea",
      "original_line" : 652,
      "original_position" : 518,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 652,
      "pull_request_review_id" : 502389800,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499848391",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499848478"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499848478"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T20:19:22Z",
      "diff_hunk" : "@@ -0,0 +1,193 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <net.h> // For NodeId\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction. Note that this only works\n+ *              per txhash, so if the same transaction is announced both through txid and wtxid, we have no means\n+ *              to prevent fetching both (the caller can however mitigate this by delaying one, see further).\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten only:\n+ *   - If a peer goes offline, all its announcements are forgotten.\n+ *   - If a transaction has been successfully received, or is otherwise no longer needed, the caller can call\n+ *     ForgetTxHash, which removes all announcements across all peers with the specified txhash.\n+ *   - If for a given txhash only already-requested announcements remain, they are all forgotten.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499848478",
      "id" : 499848478,
      "in_reply_to_id" : 499629695,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg0ODQ3OA==",
      "original_commit_id" : "a60ad12fb9bac2e4a8fe9018754444d48ba817ea",
      "original_line" : 49,
      "original_position" : 49,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 502389919,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499848478",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499848693"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499848693"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done. Your math was almost right (it's 8s and half a year).",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T20:19:49Z",
      "diff_hunk" : "@@ -0,0 +1,558 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds MIN_TIME = std::chrono::microseconds::min();\n+constexpr std::chrono::microseconds MAX_TIME = std::chrono::microseconds::max();\n+constexpr std::chrono::microseconds MICROSECOND = std::chrono::microseconds{1};\n+constexpr std::chrono::microseconds NO_TIME = std::chrono::microseconds{0};\n+\n+/** An Action is a function to call at a particular (simulated) timestamp. */\n+using Action = std::pair<std::chrono::microseconds, std::function<void()>>;\n+\n+/** Object that stores actions from multiple interleaved scenarios, and data shared across them.\n+ *\n+ * The Scenario below is used to fill this.\n+ */\n+struct Runner\n+{\n+    /** The TxRequestTracker being tested. */\n+    TxRequestTracker txrequest;\n+\n+    /** List of actions to be executed (in order of increasing timestamp). */\n+    std::vector<Action> actions;\n+\n+    /** Which node ids have been assigned already (to prevent reuse). */\n+    std::set<NodeId> peerset;\n+\n+    /** Which txhashes have been assigned already (to prevent reuse). */\n+    std::set<uint256> txhashset;\n+};\n+\n+std::chrono::microseconds RandomTime(int bits=23) { return std::chrono::microseconds{1 + InsecureRandBits(bits)}; }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499848693",
      "id" : 499848693,
      "in_reply_to_id" : 499661041,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg0ODY5Mw==",
      "original_commit_id" : "744eb10ecfa133a4a2de468aeb701255438e4427",
      "original_line" : 48,
      "original_position" : 48,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 502390202,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499848693",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499852565"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499852565"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've added this comment blob to explain it better:\r\n\r\n> Each Scenario is a proxy through which actions for the (sequential) execution of various tests are added to a Runner. The actions from multiple scenarios are then run concurrently, resulting in these tests being performed against a TxRequestTracker in parallel. Every test has its own unique txhashes and NodeIds which are not reused in other tests, and thus they should be independent from each other. Running them in parallel however means that we verify the behavior (w.r.t. one test's txhashes and NodeIds) even when the state of the data structure is more complicated due to the presence of other tests.\r\n\r\nDoes that help?\r\n\r\nAbstracting out this scaffolding seems potentially useful, but for a follow-up.\r\n\r\n> I think this test setup only simulates a monotonic clock (vs txrequest.cpp's note that supporting time going backwards \"makes it much easier to specify and test TxRequestTracker::Impl's behaviour\")\r\n\r\nThe tests are indeed restricted to a clock that is increasing monotonically between subsequent calls to GetRequestable. I had some infrastructure here earlier to allow a scenario to have both a \"real clock\" and a \"jittered clock\", where the first one is used to order Actions, and the second one determines the timestamps passed to `GetRequestable`, but I feared the mental overhead to that isn't worth it. Whether TxRequestTracker does something reasonable under insane call sequences is tested by the fuzzer already, so I think this one can be restricted to more normal situations, and test that what's done isn't just reasonable, but also matches more high-level expected behavior.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T20:27:01Z",
      "diff_hunk" : "@@ -0,0 +1,558 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds MIN_TIME = std::chrono::microseconds::min();\n+constexpr std::chrono::microseconds MAX_TIME = std::chrono::microseconds::max();\n+constexpr std::chrono::microseconds MICROSECOND = std::chrono::microseconds{1};\n+constexpr std::chrono::microseconds NO_TIME = std::chrono::microseconds{0};\n+\n+/** An Action is a function to call at a particular (simulated) timestamp. */\n+using Action = std::pair<std::chrono::microseconds, std::function<void()>>;\n+\n+/** Object that stores actions from multiple interleaved scenarios, and data shared across them.\n+ *\n+ * The Scenario below is used to fill this.\n+ */\n+struct Runner\n+{\n+    /** The TxRequestTracker being tested. */\n+    TxRequestTracker txrequest;\n+\n+    /** List of actions to be executed (in order of increasing timestamp). */\n+    std::vector<Action> actions;\n+\n+    /** Which node ids have been assigned already (to prevent reuse). */\n+    std::set<NodeId> peerset;\n+\n+    /** Which txhashes have been assigned already (to prevent reuse). */\n+    std::set<uint256> txhashset;\n+};\n+\n+std::chrono::microseconds RandomTime(int bits=23) { return std::chrono::microseconds{1 + InsecureRandBits(bits)}; }\n+\n+/** A proxy for a Runner that helps build a sequence of consecutive test actions on a TxRequestTracker.\n+ *\n+ * Multiple Scenarios are used with a single Runner, resulting in interleaved actions.\n+ */\n+class Scenario",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499852565",
      "id" : 499852565,
      "in_reply_to_id" : 499662302,
      "line" : 60,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg1MjU2NQ==",
      "original_commit_id" : "744eb10ecfa133a4a2de468aeb701255438e4427",
      "original_line" : 60,
      "original_position" : 54,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : 60,
      "pull_request_review_id" : 502395145,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499852565",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499852827"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499852827"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T20:27:34Z",
      "diff_hunk" : "@@ -216,6 +216,70 @@ struct PeerInfo {\n     size_t m_requested = 0; //!< Number of REQUESTED announcements for this peer.\n };\n \n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST announcement if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an announcement for this txhash for.\n+    std::vector<uint64_t> m_peers;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499852827",
      "id" : 499852827,
      "in_reply_to_id" : 499672470,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg1MjgyNw==",
      "original_commit_id" : "744eb10ecfa133a4a2de468aeb701255438e4427",
      "original_line" : 235,
      "original_position" : 20,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 502395533,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499852827",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499852985"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499852985"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Major improvement, done!",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T20:27:52Z",
      "diff_hunk" : "@@ -0,0 +1,361 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txrequest.h>\n+#include <test/fuzz/fuzz.h>\n+#include <crypto/common.h>\n+#include <crypto/siphash.h>\n+\n+#include <bitset>\n+#include <cstdint>\n+#include <queue>\n+#include <vector>\n+\n+namespace {\n+\n+constexpr int MAX_TXHASHES = 16;\n+constexpr int MAX_PEERS = 16;\n+\n+//! Randomly generated GenTxids used in this test (length is MAX_TX).\n+uint256 TXHASHES[MAX_TXHASHES];\n+\n+/** Precomputed random durations (positive and negative, each ~exponentially distributed). */\n+std::chrono::microseconds DELAYS[256];\n+\n+struct Initializer\n+{\n+    Initializer()\n+    {\n+        // Use deterministic RNG to fill in txids and delays.\n+        // Non-determinism hurts fuzzing.\n+        FastRandomContext rng(true);\n+        for (int txhash = 0; txhash < MAX_TXHASHES; txhash += 1) {\n+            do {\n+                TXHASHES[txhash] = rng.rand256();\n+            } while (*(TXHASHES[txhash].begin() + 31) != txhash || *(TXHASHES[txhash].begin()) != txhash);\n+        }\n+        for (int i = 0; i < 16; ++i) {\n+            DELAYS[i] = std::chrono::microseconds{i};\n+        }\n+        for (int i = 16; i < 128; ++i) {\n+            DELAYS[i] = DELAYS[i - 1] + std::chrono::microseconds{1 + rng.randbits(((i - 10) * 2) / 9)};\n+        }\n+        for (int i = 128; i < 256; ++i) {\n+            DELAYS[i] = -DELAYS[255 - i];\n+        }\n+    }\n+} g_initializer;\n+\n+/** Tester class for TxRequestTracker\n+ *\n+ * It includes a naive reimplementation of its behavior, for a limited set\n+ * of MAX_TXHASHES distinct txids, and MAX_PEERS peer identifiers.\n+ *\n+ * All of the public member functions perform the same operation on\n+ * an actual TxRequestTracker and on the state of the reimplementation.\n+ * The output of GetRequestable is compared with the expected value\n+ * as well.\n+ *\n+ * Check() calls the TxRequestTracker's sanity check, plus compares the\n+ * output of the constant accessors (Size(), CountLoad(), CountTracked())\n+ * with expected values.\n+ */\n+class Tester\n+{\n+    //! TxRequestTracker object being tested.\n+    TxRequestTracker m_tracker;\n+\n+    //! States for txid/peer combinations in the naive data structure.\n+    enum class State {\n+        NOTHING, //!< Absence of this txid/peer combination\n+\n+        // Note that this implementation does not distinguish between BEST/NEW/OTHER variants of CANDIDATE.\n+        CANDIDATE,\n+        REQUESTED,\n+        COMPLETED,\n+    };\n+\n+    //! Sequence numbers, incremented whenever a new CANDIDATE is added.\n+    uint64_t m_current_sequence{0};\n+\n+    //! List of future 'events' (all inserted reqtimes/exptimes). This is used to implement AdvanceToEvent.\n+    std::priority_queue<std::chrono::microseconds, std::vector<std::chrono::microseconds>, std::greater<std::chrono::microseconds>> m_events;\n+\n+    //! Information about a txhash/peer combination.\n+    struct Announcement\n+    {\n+        std::chrono::microseconds m_time;\n+        uint64_t m_sequence;\n+        State m_state{State::NOTHING};\n+        bool m_preferred;\n+        bool m_is_wtxid;\n+        uint64_t m_priority; //!< Precomputed priority.\n+    };\n+\n+    //! Information about all txhash/peer combination.\n+    Announcement m_announcements[MAX_TXHASHES][MAX_PEERS];\n+\n+    //! The current time; can move forward and backward.\n+    std::chrono::microseconds m_now{112223333};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499852985",
      "id" : 499852985,
      "in_reply_to_id" : 499680741,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg1Mjk4NQ==",
      "original_commit_id" : "9fb42eeb59246479e3c7ec7e3575b3835a9fd27b",
      "original_line" : 102,
      "original_position" : 102,
      "original_start_line" : null,
      "path" : "src/test/fuzz/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 502395725,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499852985",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499853151"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499853151"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T20:28:07Z",
      "diff_hunk" : "@@ -0,0 +1,361 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txrequest.h>\n+#include <test/fuzz/fuzz.h>\n+#include <crypto/common.h>\n+#include <crypto/siphash.h>\n+\n+#include <bitset>\n+#include <cstdint>\n+#include <queue>\n+#include <vector>\n+\n+namespace {\n+\n+constexpr int MAX_TXHASHES = 16;\n+constexpr int MAX_PEERS = 16;\n+\n+//! Randomly generated GenTxids used in this test (length is MAX_TX).\n+uint256 TXHASHES[MAX_TXHASHES];\n+\n+/** Precomputed random durations (positive and negative, each ~exponentially distributed). */\n+std::chrono::microseconds DELAYS[256];\n+\n+struct Initializer\n+{\n+    Initializer()\n+    {\n+        // Use deterministic RNG to fill in txids and delays.\n+        // Non-determinism hurts fuzzing.\n+        FastRandomContext rng(true);\n+        for (int txhash = 0; txhash < MAX_TXHASHES; txhash += 1) {\n+            do {\n+                TXHASHES[txhash] = rng.rand256();\n+            } while (*(TXHASHES[txhash].begin() + 31) != txhash || *(TXHASHES[txhash].begin()) != txhash);\n+        }\n+        for (int i = 0; i < 16; ++i) {\n+            DELAYS[i] = std::chrono::microseconds{i};\n+        }\n+        for (int i = 16; i < 128; ++i) {\n+            DELAYS[i] = DELAYS[i - 1] + std::chrono::microseconds{1 + rng.randbits(((i - 10) * 2) / 9)};\n+        }\n+        for (int i = 128; i < 256; ++i) {\n+            DELAYS[i] = -DELAYS[255 - i];\n+        }\n+    }\n+} g_initializer;\n+\n+/** Tester class for TxRequestTracker\n+ *\n+ * It includes a naive reimplementation of its behavior, for a limited set\n+ * of MAX_TXHASHES distinct txids, and MAX_PEERS peer identifiers.\n+ *\n+ * All of the public member functions perform the same operation on\n+ * an actual TxRequestTracker and on the state of the reimplementation.\n+ * The output of GetRequestable is compared with the expected value\n+ * as well.\n+ *\n+ * Check() calls the TxRequestTracker's sanity check, plus compares the\n+ * output of the constant accessors (Size(), CountLoad(), CountTracked())\n+ * with expected values.\n+ */\n+class Tester\n+{\n+    //! TxRequestTracker object being tested.\n+    TxRequestTracker m_tracker;\n+\n+    //! States for txid/peer combinations in the naive data structure.\n+    enum class State {\n+        NOTHING, //!< Absence of this txid/peer combination\n+\n+        // Note that this implementation does not distinguish between BEST/NEW/OTHER variants of CANDIDATE.\n+        CANDIDATE,\n+        REQUESTED,\n+        COMPLETED,\n+    };\n+\n+    //! Sequence numbers, incremented whenever a new CANDIDATE is added.\n+    uint64_t m_current_sequence{0};\n+\n+    //! List of future 'events' (all inserted reqtimes/exptimes). This is used to implement AdvanceToEvent.\n+    std::priority_queue<std::chrono::microseconds, std::vector<std::chrono::microseconds>, std::greater<std::chrono::microseconds>> m_events;\n+\n+    //! Information about a txhash/peer combination.\n+    struct Announcement\n+    {\n+        std::chrono::microseconds m_time;\n+        uint64_t m_sequence;\n+        State m_state{State::NOTHING};\n+        bool m_preferred;\n+        bool m_is_wtxid;\n+        uint64_t m_priority; //!< Precomputed priority.\n+    };\n+\n+    //! Information about all txhash/peer combination.\n+    Announcement m_announcements[MAX_TXHASHES][MAX_PEERS];\n+\n+    //! The current time; can move forward and backward.\n+    std::chrono::microseconds m_now{112223333};\n+\n+    //! Delete txhashes whose only announcements are COMPLETED.\n+    void Cleanup(int txhash)\n+    {\n+        bool all_nothing = true;\n+        for (int peer = 0; peer < MAX_PEERS; ++peer) {\n+            const Announcement& ann = m_announcements[txhash][peer];\n+            if (ann.m_state == State::CANDIDATE || ann.m_state == State::REQUESTED) return;\n+            if (ann.m_state != State::NOTHING) all_nothing = false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499853151",
      "id" : 499853151,
      "in_reply_to_id" : 499684028,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg1MzE1MQ==",
      "original_commit_id" : "9fb42eeb59246479e3c7ec7e3575b3835a9fd27b",
      "original_line" : 111,
      "original_position" : 111,
      "original_start_line" : null,
      "path" : "src/test/fuzz/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 502395860,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499853151",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499853402"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499853402"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Clearly this shouldn't be an `auto` type if it's confusing. Just made the type explicit.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T20:28:33Z",
      "diff_hunk" : "@@ -816,73 +747,34 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n+} // namespace\n \n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManager::RequestTx(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    AssertLockHeld(cs_main); // For m_txrequest\n+    NodeId nodeid = node.GetId();\n+    if (m_txrequest.Count(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499853402",
      "id" : 499853402,
      "in_reply_to_id" : 499724149,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg1MzQwMg==",
      "original_commit_id" : "89a01b891284f584bbf341f25b587614e417b564",
      "original_line" : 760,
      "original_position" : 183,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 502396141,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499853402",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499853758"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499853758"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't think it matters much as it's fairly cheap, plus doesn't change worst case behaviour (attacker can use witness-carrying transactions). Still, done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T20:29:13Z",
      "diff_hunk" : "@@ -3004,11 +2897,8 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n \n         TxValidationState state;\n \n-        for (const GenTxid& gtxid : {GenTxid(false, txid), GenTxid(true, wtxid)}) {\n-            nodestate->m_tx_download.m_tx_announced.erase(gtxid.GetHash());\n-            nodestate->m_tx_download.m_tx_in_flight.erase(gtxid.GetHash());\n-            EraseTxRequest(gtxid);\n-        }\n+        m_txrequest.ReceivedResponse(pfrom.GetId(), txid);\n+        m_txrequest.ReceivedResponse(pfrom.GetId(), wtxid);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499853758",
      "id" : 499853758,
      "in_reply_to_id" : 499728201,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg1Mzc1OA==",
      "original_commit_id" : "89a01b891284f584bbf341f25b587614e417b564",
      "original_line" : 2901,
      "original_position" : 233,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 502396562,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499853758",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499853876"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499853876"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Good idea, done.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T20:29:24Z",
      "diff_hunk" : "@@ -956,6 +848,7 @@ void PeerManager::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n         mapBlocksInFlight.erase(entry.hash);\n     }\n     EraseOrphansFor(nodeid);\n+    m_txrequest.DisconnectedPeer(nodeid);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499853876",
      "id" : 499853876,
      "in_reply_to_id" : 499731414,
      "line" : 854,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg1Mzg3Ng==",
      "original_commit_id" : "89a01b891284f584bbf341f25b587614e417b564",
      "original_line" : 854,
      "original_position" : 210,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 233,
      "pull_request_review_id" : 502396705,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499853876",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499854307"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499854307"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nice idea. I was thinking in a similar direction, but couldn't figure out how to make it efficient. Updating the flag after the fact is a neat solution.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T20:30:17Z",
      "diff_hunk" : "@@ -0,0 +1,193 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <net.h> // For NodeId\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction. Note that this only works\n+ *              per txhash, so if the same transaction is announced both through txid and wtxid, we have no means\n+ *              to prevent fetching both (the caller can however mitigate this by delaying one, see further).\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten only:\n+ *   - If a peer goes offline, all its announcements are forgotten.\n+ *   - If a transaction has been successfully received, or is otherwise no longer needed, the caller can call\n+ *     ForgetTxHash, which removes all announcements across all peers with the specified txhash.\n+ *   - If for a given txhash only already-requested announcements remain, they are all forgotten.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening transaction censoring attacks. The flip side is that as long as an attacker manages\n+ *              to prevent us from receiving a transaction, failed announcements (including those from honest peers)\n+ *              will linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a\n+ *              cap on the number of tracked announcements per peer. As failed requests in response to announcements\n+ *              from honest peers should be rare, this almost solely hinders attackers.\n+ *              Transaction censoring attacks can be done by announcing transactions quickly while not answering\n+ *              requests for them. See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more\n+ *              information.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable the calling code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers are more trusted by us, so are less likely to be under attacker control.\n+ *\n+ *   - Pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: random assignments are hard to influence for attackers.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and minimizing\n+ * susceptibility to censorship attacks. An attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one preferred connection).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution). The \"1 +\" is due to the fact that the\n+ *   attacker can be the first to announce through a preferred connection in this scenario, which very likely means\n+ *   they get the first request.\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh>=1\n+ *   are honest, where we assume that the attacker can disconnect and reconnect those connections, the distribution\n+ *   becomes k ~ P + NB(p=1-NP/NPh,r=1) (where NB stands for Negative Binomial distribution), which has mean\n+ *   P-1+NP/NPh.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499854307",
      "id" : 499854307,
      "in_reply_to_id" : 499761594,
      "line" : 88,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg1NDMwNw==",
      "original_commit_id" : "a60ad12fb9bac2e4a8fe9018754444d48ba817ea",
      "original_line" : 88,
      "original_position" : 87,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 88,
      "pull_request_review_id" : 502397263,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499854307",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499932949"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499932949"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think that describing ForgetTxHash to be called when a good transaction is received doesn't match its usage.\r\n\r\nWe call it ForgetTxHash (8ef5953), in net_processing, at transaction reception :\r\n* L2933, when a transaction has been accepted to the mempool\r\n* L2996, when an orphan  transaction is added to the orphan pool\r\n* L3014, when an orphan transaction is added to the rejection filter for cause of invalid parent\r\n* L3034, when a non-witness stripped transaction has failed mempool acceptance and is added to the rejection filter\r\n\r\nIn the 3 later cases, the transaction can't be qualified to be mempool-valid. Beyond block connection, it might be better to say, \"ForgetTxHash should be called once the transaction has been evaluated at least once by the mempool\". What we do with this evaluation result is not matter of the TxRequestTracker ?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-05T23:53:33Z",
      "diff_hunk" : "@@ -0,0 +1,206 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <net.h> // For NodeId\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or invalid transaction or NOTFOUND was\n+ *   received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction. Note that this only works\n+ *              per txhash, so if the same transaction is announced both through txid and wtxid, we have no means\n+ *              to prevent fetching both (the caller can however mitigate this by delaying one, see further).\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten only:\n+ *   - If a peer goes offline, all its announcements are forgotten.\n+ *   - If a transaction has been successfully received, or is otherwise no longer needed, the caller can call\n+ *     ForgetTxHash, which removes all announcements across all peers with the specified txhash.\n+ *   - If for a given txhash only already-failed announcements remain, they are all forgotten.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening transaction censoring attacks. The flip side is that as long as an attacker manages\n+ *              to prevent us from receiving a transaction, failed announcements (including those from honest peers)\n+ *              will linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a\n+ *              cap on the number of tracked announcements per peer. As failed requests in response to announcements\n+ *              from honest peers should be rare, this almost solely hinders attackers.\n+ *              Transaction censoring attacks can be done by announcing transactions quickly while not answering\n+ *              requests for them. See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more\n+ *              information.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable the calling code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers are more trusted by us, so are less likely to be under attacker control.\n+ *\n+ *   - Pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: random assignments are hard to influence for attackers.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and minimizing\n+ * susceptibility to censorship attacks. An attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one preferred connection).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution). The \"1 +\" is due to the fact that the\n+ *   attacker can be the first to announce through a preferred connection in this scenario, which very likely means\n+ *   they get the first request.\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh>=1\n+ *   are honest, where we assume that the attacker can disconnect and reconnect those connections, the distribution\n+ *   becomes k ~ P + NB(p=1-NP/NPh,r=1) (where NB stands for Negative Binomial distribution), which has mean\n+ *   P-1+NP/NPh.\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of \"announcements\", one for each peer/txhash\n+    // combination:\n+    //\n+    // - CANDIDATE announcements represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED announcements represent transactions that have been requested, and which we're awaiting a\n+    //   response for from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED announcements represent transactions that have been requested from a peer, and a NOTFOUND or a\n+    //   transaction was received in response (valid or not), or they timed out. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED announcements for a given txhash remain (so no CANDIDATE\n+    //   or REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all announcements for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DisconnectedPeer(NodeId peer);\n+\n+    /** Deletes all announcements for a given txhash (both txid and wtxid ones).\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it.\n+     */\n+    void ForgetTxHash(const uint256& txhash);\n+\n+    /** Adds a new CANDIDATE announcement.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that the txid/wtxid property is ignored for determining uniqueness, so if an announcement\n+     * is added for a wtxid H, while one for txid H from the same peer already exists, it will be ignored. This is\n+     * harmless as the txhashes being equal implies it is a non-segwit transaction, so it doesn't matter how it is\n+     * fetched. The new announcement is given the specified preferred and reqtime values, and takes its is_wtxid\n+     * from the specified gtxid.\n+     */\n+    void ReceivedInv(NodeId peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime);\n+\n+    /** Find the txids to request now from peer.\n+     *\n+     * It does the following:\n+     *  - Convert all REQUESTED announcements (for all txhashes/peers) with (expiry <= now) to COMPLETED ones.\n+     *  - Requestable announcements are selected: CANDIDATE announcements from the specified peer with\n+     *    (reqtime <= now) for which no existing REQUESTED announcement with the same txhash exists, and for which\n+     *    the specified peer is the best choice among all (reqtime <= now) CANDIDATE announcements with the same\n+     *    txhash (subject to preferredness rules, and tiebreaking using a deterministic salted hash of peer and\n+     *    txhash).\n+     *  - The selected announcements are converted to GenTxids using their is_wtxid flag, and returned in\n+     *    announcement order (even if multiple were added at the same time, or when the clock went backwards while\n+     *    they were being added).\n+     */\n+    std::vector<GenTxid> GetRequestable(NodeId peer, std::chrono::microseconds now);\n+\n+    /** Marks a transaction as requested, with a specified expiry.\n+     *\n+     * If no CANDIDATE announcement for the provided peer and txhash exists, this call has no effect. Otherwise:\n+     *  - That announcement is converted to REQUESTED.\n+     *  - If any other REQUESTED announcement for the same txhash already existed, it means an unexpected request\n+     *    was made (GetRequestable will never advise doing so). In this case it is converted to COMPLETED, as we're\n+     *    no longer waiting for a response to it.\n+     */\n+    void RequestedTx(NodeId peer, const uint256& txhash, std::chrono::microseconds expiry);\n+\n+    /** Converts any CANDIDATE or REQUESTED announcement to a COMPLETED one, if one exists.\n+     *\n+     * It should be called whenever a transaction or NOTFOUND was received from a peer. When a good transaction is\n+     * received, ForgetTxHash should be called instead of (or in addition to) this operation.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499932949",
      "id" : 499932949,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkzMjk0OQ==",
      "original_commit_id" : "8ef5953e478b820fb5f33ba428c6b207af81d3db",
      "original_line" : 175,
      "original_position" : 175,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 502496543,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499932949",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499943473"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499943473"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Announcements sizes are only compared at fuzzer input exhaustion not after every `ReceivedInv`. It would add little value to check them after every `ReceivedInv` to catch Tester/TxRequestTracker divergence at that point ? They may converge at the end and thus a divergence during the running wouldn't be detected ?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-06T00:32:34Z",
      "diff_hunk" : "@@ -0,0 +1,363 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txrequest.h>\n+#include <test/fuzz/fuzz.h>\n+#include <crypto/common.h>\n+#include <crypto/siphash.h>\n+\n+#include <bitset>\n+#include <cstdint>\n+#include <queue>\n+#include <vector>\n+\n+namespace {\n+\n+constexpr int MAX_TXHASHES = 16;\n+constexpr int MAX_PEERS = 16;\n+\n+//! Randomly generated GenTxids used in this test (length is MAX_TX).\n+uint256 TXHASHES[MAX_TXHASHES];\n+\n+/** Precomputed random durations (positive and negative, each ~exponentially distributed). */\n+std::chrono::microseconds DELAYS[256];\n+\n+struct Initializer\n+{\n+    Initializer()\n+    {\n+        // Use deterministic RNG to fill in txids and delays.\n+        // Non-determinism hurts fuzzing.\n+        FastRandomContext rng(true);\n+        for (int txhash = 0; txhash < MAX_TXHASHES; txhash += 1) {\n+            do {\n+                TXHASHES[txhash] = rng.rand256();\n+            } while (*(TXHASHES[txhash].begin() + 31) != txhash || *(TXHASHES[txhash].begin()) != txhash);\n+        }\n+        for (int i = 0; i < 16; ++i) {\n+            DELAYS[i] = std::chrono::microseconds{i};\n+        }\n+        for (int i = 16; i < 128; ++i) {\n+            DELAYS[i] = DELAYS[i - 1] + std::chrono::microseconds{1 + rng.randbits(((i - 10) * 2) / 9)};\n+        }\n+        for (int i = 128; i < 256; ++i) {\n+            DELAYS[i] = -DELAYS[255 - i];\n+        }\n+    }\n+} g_initializer;\n+\n+/** Tester class for TxRequestTracker\n+ *\n+ * It includes a naive reimplementation of its behavior, for a limited set\n+ * of MAX_TXHASHES distinct txids, and MAX_PEERS peer identifiers.\n+ *\n+ * All of the public member functions perform the same operation on\n+ * an actual TxRequestTracker and on the state of the reimplementation.\n+ * The output of GetRequestable is compared with the expected value\n+ * as well.\n+ *\n+ * Check() calls the TxRequestTracker's sanity check, plus compares the\n+ * output of the constant accessors (Size(), CountLoad(), CountTracked())\n+ * with expected values.\n+ */\n+class Tester\n+{\n+    //! TxRequestTracker object being tested.\n+    TxRequestTracker m_tracker;\n+\n+    //! States for txid/peer combinations in the naive data structure.\n+    enum class State {\n+        NOTHING, //!< Absence of this txid/peer combination\n+\n+        // Note that this implementation does not distinguish between BEST/NEW/OTHER variants of CANDIDATE.\n+        CANDIDATE,\n+        REQUESTED,\n+        COMPLETED,\n+    };\n+\n+    //! Sequence numbers, incremented whenever a new CANDIDATE is added.\n+    uint64_t m_current_sequence{0};\n+\n+    //! List of future 'events' (all inserted reqtimes/exptimes). This is used to implement AdvanceToEvent.\n+    std::priority_queue<std::chrono::microseconds, std::vector<std::chrono::microseconds>, std::greater<std::chrono::microseconds>> m_events;\n+\n+    //! Information about a txhash/peer combination.\n+    struct Announcement\n+    {\n+        std::chrono::microseconds m_time;\n+        uint64_t m_sequence;\n+        State m_state{State::NOTHING};\n+        bool m_preferred;\n+        bool m_is_wtxid;\n+        uint64_t m_priority; //!< Precomputed priority.\n+    };\n+\n+    //! Information about all txhash/peer combination.\n+    Announcement m_announcements[MAX_TXHASHES][MAX_PEERS];\n+\n+    //! The current time; can move forward and backward.\n+    std::chrono::microseconds m_now{244466666};\n+\n+    //! Delete txhashes whose only announcements are COMPLETED.\n+    void Cleanup(int txhash)\n+    {\n+        bool all_nothing = true;\n+        for (int peer = 0; peer < MAX_PEERS; ++peer) {\n+            const Announcement& ann = m_announcements[txhash][peer];\n+            if (ann.m_state != State::NOTHING) {\n+                if (ann.m_state != State::COMPLETED) return;\n+                all_nothing = false;\n+            }\n+        }\n+        if (all_nothing) return;\n+        for (int peer = 0; peer < MAX_PEERS; ++peer) {\n+            m_announcements[txhash][peer].m_state = State::NOTHING;\n+        }\n+    }\n+\n+    //! Find the current best peer to request from for a txhash (or -1 if none).\n+    int GetSelected(int txhash) const\n+    {\n+        int ret = -1;\n+        uint64_t ret_priority = 0;\n+        for (int peer = 0; peer < MAX_PEERS; ++peer) {\n+            const Announcement& ann = m_announcements[txhash][peer];\n+            // Return -1 if there already is a (non-expired) in-flight request.\n+            if (ann.m_state == State::REQUESTED) return -1;\n+            // If it's a viable candidate, see if it has lower priority than the best one so far.\n+            if (ann.m_state == State::CANDIDATE && ann.m_time <= m_now) {\n+                if (ret == -1 || ann.m_priority < ret_priority) {\n+                    std::tie(ret, ret_priority) = std::tie(peer, ann.m_priority);\n+                }\n+            }\n+        }\n+        return ret;\n+    }\n+\n+public:\n+    Tester() : m_tracker(true) {}\n+\n+    std::chrono::microseconds Now() const { return m_now; }\n+\n+    void AdvanceTime(std::chrono::microseconds offset)\n+    {\n+        m_now += offset;\n+        while (!m_events.empty() && m_events.top() <= m_now) m_events.pop();\n+    }\n+\n+    void AdvanceToEvent()\n+    {\n+        while (!m_events.empty() && m_events.top() <= m_now) m_events.pop();\n+        if (!m_events.empty()) {\n+            m_now = m_events.top();\n+            m_events.pop();\n+        }\n+    }\n+\n+    void DisconnectedPeer(int peer)\n+    {\n+        // Apply to naive structure: all announcements for that peer are wiped.\n+        for (int txhash = 0; txhash < MAX_TXHASHES; ++txhash) {\n+            if (m_announcements[txhash][peer].m_state != State::NOTHING) {\n+                m_announcements[txhash][peer].m_state = State::NOTHING;\n+                Cleanup(txhash);\n+            }\n+        }\n+\n+        // Call TxRequestTracker's implementation.\n+        m_tracker.DisconnectedPeer(peer);\n+    }\n+\n+    void ForgetTxHash(int txhash)\n+    {\n+        // Apply to naive structure: all announcements for that txhash are wiped.\n+        for (int peer = 0; peer < MAX_PEERS; ++peer) {\n+            m_announcements[txhash][peer].m_state = State::NOTHING;\n+        }\n+        Cleanup(txhash);\n+\n+        // Call TxRequestTracker's implementation.\n+        m_tracker.ForgetTxHash(TXHASHES[txhash]);\n+    }\n+\n+    void ReceivedInv(int peer, int txhash, bool is_wtxid, bool preferred, std::chrono::microseconds reqtime)\n+    {\n+        // Apply to naive structure: if no announcement for txidnum/peer combination\n+        // already, create a new CANDIDATE; otherwise do nothing.\n+        Announcement& ann = m_announcements[txhash][peer];\n+        if (ann.m_state == State::NOTHING) {\n+            ann.m_preferred = preferred;\n+            ann.m_state = State::CANDIDATE;\n+            ann.m_time = reqtime;\n+            ann.m_is_wtxid = is_wtxid;\n+            ann.m_sequence = m_current_sequence++;\n+            ann.m_priority = m_tracker.ComputePriority(TXHASHES[txhash], peer, ann.m_preferred);\n+\n+            // Add event so that AdvanceToEvent can quickly jump to the point where its reqtime passes.\n+            if (reqtime > m_now) m_events.push(reqtime);\n+        }\n+\n+        // Call TxRequestTracker's implementation.\n+        m_tracker.ReceivedInv(peer, GenTxid{is_wtxid, TXHASHES[txhash]}, preferred, reqtime);\n+    }\n+\n+    void RequestedTx(int peer, int txhash, std::chrono::microseconds exptime)\n+    {\n+        // Apply to naive structure: if a CANDIDATE announcement exists for peer/txhash,\n+        // convert it to REQUESTED, and change any existing REQUESTED announcement for the same txhash to COMPLETED.\n+        if (m_announcements[txhash][peer].m_state == State::CANDIDATE) {\n+            for (int peer2 = 0; peer2 < MAX_PEERS; ++peer2) {\n+                if (m_announcements[txhash][peer2].m_state == State::REQUESTED) {\n+                    m_announcements[txhash][peer2].m_state = State::COMPLETED;\n+                }\n+            }\n+            m_announcements[txhash][peer].m_state = State::REQUESTED;\n+            m_announcements[txhash][peer].m_time = exptime;\n+        }\n+\n+        // Add event so that AdvanceToEvent can quickly jump to the point where its exptime passes.\n+        if (exptime > m_now) m_events.push(exptime);\n+\n+        // Call TxRequestTracker's implementation.\n+        m_tracker.RequestedTx(peer, TXHASHES[txhash], exptime);\n+    }\n+\n+    void ReceivedResponse(int peer, int txhash)\n+    {\n+        // Apply to naive structure: convert anything to COMPLETED.\n+        if (m_announcements[txhash][peer].m_state != State::NOTHING) {\n+            m_announcements[txhash][peer].m_state = State::COMPLETED;\n+            Cleanup(txhash);\n+        }\n+\n+        // Call TxRequestTracker's implementation.\n+        m_tracker.ReceivedResponse(peer, TXHASHES[txhash]);\n+    }\n+\n+    void GetRequestable(int peer)\n+    {\n+        // Implement using naive structure:\n+        std::vector<std::tuple<uint64_t, int, bool>> result; //!< list of (sequence number, txhash, is_wtxid) pairs.\n+        for (int txhash = 0; txhash < MAX_TXHASHES; ++txhash) {\n+            // Mark any expired REQUESTED announcements as COMPLETED.\n+            for (int peer2 = 0; peer2 < MAX_PEERS; ++peer2) {\n+                Announcement& ann2 = m_announcements[txhash][peer2];\n+                if (ann2.m_state == State::REQUESTED && ann2.m_time <= m_now) {\n+                    ann2.m_state = State::COMPLETED;\n+                    break;\n+                }\n+            }\n+            // And delete txids with only COMPLETED announcements left.\n+            Cleanup(txhash);\n+            // CANDIDATEs for which this announcement has the lowest priority get returned.\n+            const Announcement& ann = m_announcements[txhash][peer];\n+            if (ann.m_state == State::CANDIDATE && GetSelected(txhash) == peer) {\n+                result.emplace_back(ann.m_sequence, txhash, ann.m_is_wtxid);\n+            }\n+        }\n+        // Sort the results by sequence number.\n+        std::sort(result.begin(), result.end());\n+\n+        // Compare with TxRequestTracker's implementation.\n+        const auto actual = m_tracker.GetRequestable(peer, m_now);\n+\n+        m_tracker.PostGetRequestableSanityCheck(m_now);\n+        assert(result.size() == actual.size());\n+        for (size_t pos = 0; pos < actual.size(); ++pos) {\n+            assert(TXHASHES[std::get<1>(result[pos])] == actual[pos].GetHash());\n+            assert(std::get<2>(result[pos]) == actual[pos].IsWtxid());\n+        }\n+    }\n+\n+    void Check()\n+    {\n+        // Compare CountTracked and CountLoad with naive structure.\n+        size_t total = 0;\n+        for (int peer = 0; peer < MAX_PEERS; ++peer) {\n+            size_t tracked = 0;\n+            size_t inflight = 0;\n+            size_t candidates = 0;\n+            for (int txhash = 0; txhash < MAX_TXHASHES; ++txhash) {\n+                tracked += m_announcements[txhash][peer].m_state != State::NOTHING;\n+                inflight += m_announcements[txhash][peer].m_state == State::REQUESTED;\n+                candidates += m_announcements[txhash][peer].m_state == State::CANDIDATE;\n+            }\n+            assert(m_tracker.Count(peer) == tracked);\n+            assert(m_tracker.CountInFlight(peer) == inflight);\n+            assert(m_tracker.CountCandidates(peer) == candidates);\n+            total += tracked;\n+        }\n+        // Compare Size.\n+        assert(m_tracker.Size() == total);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499943473",
      "id" : 499943473,
      "line" : 294,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk0MzQ3Mw==",
      "original_commit_id" : "8ef5953e478b820fb5f33ba428c6b207af81d3db",
      "original_line" : 294,
      "original_position" : 294,
      "original_start_line" : null,
      "path" : "src/test/fuzz/txrequest.cpp",
      "position" : 294,
      "pull_request_review_id" : 502496543,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499943473",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499956327"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499956327"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In that case, a shorter fuzzer input would have caught the issue instead, I think.\r\n\r\nPerhaps it's worth seeing how much performance impact doing it all the time has; if it's not too much maybe it's worth changing.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-06T01:23:55Z",
      "diff_hunk" : "@@ -0,0 +1,363 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txrequest.h>\n+#include <test/fuzz/fuzz.h>\n+#include <crypto/common.h>\n+#include <crypto/siphash.h>\n+\n+#include <bitset>\n+#include <cstdint>\n+#include <queue>\n+#include <vector>\n+\n+namespace {\n+\n+constexpr int MAX_TXHASHES = 16;\n+constexpr int MAX_PEERS = 16;\n+\n+//! Randomly generated GenTxids used in this test (length is MAX_TX).\n+uint256 TXHASHES[MAX_TXHASHES];\n+\n+/** Precomputed random durations (positive and negative, each ~exponentially distributed). */\n+std::chrono::microseconds DELAYS[256];\n+\n+struct Initializer\n+{\n+    Initializer()\n+    {\n+        // Use deterministic RNG to fill in txids and delays.\n+        // Non-determinism hurts fuzzing.\n+        FastRandomContext rng(true);\n+        for (int txhash = 0; txhash < MAX_TXHASHES; txhash += 1) {\n+            do {\n+                TXHASHES[txhash] = rng.rand256();\n+            } while (*(TXHASHES[txhash].begin() + 31) != txhash || *(TXHASHES[txhash].begin()) != txhash);\n+        }\n+        for (int i = 0; i < 16; ++i) {\n+            DELAYS[i] = std::chrono::microseconds{i};\n+        }\n+        for (int i = 16; i < 128; ++i) {\n+            DELAYS[i] = DELAYS[i - 1] + std::chrono::microseconds{1 + rng.randbits(((i - 10) * 2) / 9)};\n+        }\n+        for (int i = 128; i < 256; ++i) {\n+            DELAYS[i] = -DELAYS[255 - i];\n+        }\n+    }\n+} g_initializer;\n+\n+/** Tester class for TxRequestTracker\n+ *\n+ * It includes a naive reimplementation of its behavior, for a limited set\n+ * of MAX_TXHASHES distinct txids, and MAX_PEERS peer identifiers.\n+ *\n+ * All of the public member functions perform the same operation on\n+ * an actual TxRequestTracker and on the state of the reimplementation.\n+ * The output of GetRequestable is compared with the expected value\n+ * as well.\n+ *\n+ * Check() calls the TxRequestTracker's sanity check, plus compares the\n+ * output of the constant accessors (Size(), CountLoad(), CountTracked())\n+ * with expected values.\n+ */\n+class Tester\n+{\n+    //! TxRequestTracker object being tested.\n+    TxRequestTracker m_tracker;\n+\n+    //! States for txid/peer combinations in the naive data structure.\n+    enum class State {\n+        NOTHING, //!< Absence of this txid/peer combination\n+\n+        // Note that this implementation does not distinguish between BEST/NEW/OTHER variants of CANDIDATE.\n+        CANDIDATE,\n+        REQUESTED,\n+        COMPLETED,\n+    };\n+\n+    //! Sequence numbers, incremented whenever a new CANDIDATE is added.\n+    uint64_t m_current_sequence{0};\n+\n+    //! List of future 'events' (all inserted reqtimes/exptimes). This is used to implement AdvanceToEvent.\n+    std::priority_queue<std::chrono::microseconds, std::vector<std::chrono::microseconds>, std::greater<std::chrono::microseconds>> m_events;\n+\n+    //! Information about a txhash/peer combination.\n+    struct Announcement\n+    {\n+        std::chrono::microseconds m_time;\n+        uint64_t m_sequence;\n+        State m_state{State::NOTHING};\n+        bool m_preferred;\n+        bool m_is_wtxid;\n+        uint64_t m_priority; //!< Precomputed priority.\n+    };\n+\n+    //! Information about all txhash/peer combination.\n+    Announcement m_announcements[MAX_TXHASHES][MAX_PEERS];\n+\n+    //! The current time; can move forward and backward.\n+    std::chrono::microseconds m_now{244466666};\n+\n+    //! Delete txhashes whose only announcements are COMPLETED.\n+    void Cleanup(int txhash)\n+    {\n+        bool all_nothing = true;\n+        for (int peer = 0; peer < MAX_PEERS; ++peer) {\n+            const Announcement& ann = m_announcements[txhash][peer];\n+            if (ann.m_state != State::NOTHING) {\n+                if (ann.m_state != State::COMPLETED) return;\n+                all_nothing = false;\n+            }\n+        }\n+        if (all_nothing) return;\n+        for (int peer = 0; peer < MAX_PEERS; ++peer) {\n+            m_announcements[txhash][peer].m_state = State::NOTHING;\n+        }\n+    }\n+\n+    //! Find the current best peer to request from for a txhash (or -1 if none).\n+    int GetSelected(int txhash) const\n+    {\n+        int ret = -1;\n+        uint64_t ret_priority = 0;\n+        for (int peer = 0; peer < MAX_PEERS; ++peer) {\n+            const Announcement& ann = m_announcements[txhash][peer];\n+            // Return -1 if there already is a (non-expired) in-flight request.\n+            if (ann.m_state == State::REQUESTED) return -1;\n+            // If it's a viable candidate, see if it has lower priority than the best one so far.\n+            if (ann.m_state == State::CANDIDATE && ann.m_time <= m_now) {\n+                if (ret == -1 || ann.m_priority < ret_priority) {\n+                    std::tie(ret, ret_priority) = std::tie(peer, ann.m_priority);\n+                }\n+            }\n+        }\n+        return ret;\n+    }\n+\n+public:\n+    Tester() : m_tracker(true) {}\n+\n+    std::chrono::microseconds Now() const { return m_now; }\n+\n+    void AdvanceTime(std::chrono::microseconds offset)\n+    {\n+        m_now += offset;\n+        while (!m_events.empty() && m_events.top() <= m_now) m_events.pop();\n+    }\n+\n+    void AdvanceToEvent()\n+    {\n+        while (!m_events.empty() && m_events.top() <= m_now) m_events.pop();\n+        if (!m_events.empty()) {\n+            m_now = m_events.top();\n+            m_events.pop();\n+        }\n+    }\n+\n+    void DisconnectedPeer(int peer)\n+    {\n+        // Apply to naive structure: all announcements for that peer are wiped.\n+        for (int txhash = 0; txhash < MAX_TXHASHES; ++txhash) {\n+            if (m_announcements[txhash][peer].m_state != State::NOTHING) {\n+                m_announcements[txhash][peer].m_state = State::NOTHING;\n+                Cleanup(txhash);\n+            }\n+        }\n+\n+        // Call TxRequestTracker's implementation.\n+        m_tracker.DisconnectedPeer(peer);\n+    }\n+\n+    void ForgetTxHash(int txhash)\n+    {\n+        // Apply to naive structure: all announcements for that txhash are wiped.\n+        for (int peer = 0; peer < MAX_PEERS; ++peer) {\n+            m_announcements[txhash][peer].m_state = State::NOTHING;\n+        }\n+        Cleanup(txhash);\n+\n+        // Call TxRequestTracker's implementation.\n+        m_tracker.ForgetTxHash(TXHASHES[txhash]);\n+    }\n+\n+    void ReceivedInv(int peer, int txhash, bool is_wtxid, bool preferred, std::chrono::microseconds reqtime)\n+    {\n+        // Apply to naive structure: if no announcement for txidnum/peer combination\n+        // already, create a new CANDIDATE; otherwise do nothing.\n+        Announcement& ann = m_announcements[txhash][peer];\n+        if (ann.m_state == State::NOTHING) {\n+            ann.m_preferred = preferred;\n+            ann.m_state = State::CANDIDATE;\n+            ann.m_time = reqtime;\n+            ann.m_is_wtxid = is_wtxid;\n+            ann.m_sequence = m_current_sequence++;\n+            ann.m_priority = m_tracker.ComputePriority(TXHASHES[txhash], peer, ann.m_preferred);\n+\n+            // Add event so that AdvanceToEvent can quickly jump to the point where its reqtime passes.\n+            if (reqtime > m_now) m_events.push(reqtime);\n+        }\n+\n+        // Call TxRequestTracker's implementation.\n+        m_tracker.ReceivedInv(peer, GenTxid{is_wtxid, TXHASHES[txhash]}, preferred, reqtime);\n+    }\n+\n+    void RequestedTx(int peer, int txhash, std::chrono::microseconds exptime)\n+    {\n+        // Apply to naive structure: if a CANDIDATE announcement exists for peer/txhash,\n+        // convert it to REQUESTED, and change any existing REQUESTED announcement for the same txhash to COMPLETED.\n+        if (m_announcements[txhash][peer].m_state == State::CANDIDATE) {\n+            for (int peer2 = 0; peer2 < MAX_PEERS; ++peer2) {\n+                if (m_announcements[txhash][peer2].m_state == State::REQUESTED) {\n+                    m_announcements[txhash][peer2].m_state = State::COMPLETED;\n+                }\n+            }\n+            m_announcements[txhash][peer].m_state = State::REQUESTED;\n+            m_announcements[txhash][peer].m_time = exptime;\n+        }\n+\n+        // Add event so that AdvanceToEvent can quickly jump to the point where its exptime passes.\n+        if (exptime > m_now) m_events.push(exptime);\n+\n+        // Call TxRequestTracker's implementation.\n+        m_tracker.RequestedTx(peer, TXHASHES[txhash], exptime);\n+    }\n+\n+    void ReceivedResponse(int peer, int txhash)\n+    {\n+        // Apply to naive structure: convert anything to COMPLETED.\n+        if (m_announcements[txhash][peer].m_state != State::NOTHING) {\n+            m_announcements[txhash][peer].m_state = State::COMPLETED;\n+            Cleanup(txhash);\n+        }\n+\n+        // Call TxRequestTracker's implementation.\n+        m_tracker.ReceivedResponse(peer, TXHASHES[txhash]);\n+    }\n+\n+    void GetRequestable(int peer)\n+    {\n+        // Implement using naive structure:\n+        std::vector<std::tuple<uint64_t, int, bool>> result; //!< list of (sequence number, txhash, is_wtxid) pairs.\n+        for (int txhash = 0; txhash < MAX_TXHASHES; ++txhash) {\n+            // Mark any expired REQUESTED announcements as COMPLETED.\n+            for (int peer2 = 0; peer2 < MAX_PEERS; ++peer2) {\n+                Announcement& ann2 = m_announcements[txhash][peer2];\n+                if (ann2.m_state == State::REQUESTED && ann2.m_time <= m_now) {\n+                    ann2.m_state = State::COMPLETED;\n+                    break;\n+                }\n+            }\n+            // And delete txids with only COMPLETED announcements left.\n+            Cleanup(txhash);\n+            // CANDIDATEs for which this announcement has the lowest priority get returned.\n+            const Announcement& ann = m_announcements[txhash][peer];\n+            if (ann.m_state == State::CANDIDATE && GetSelected(txhash) == peer) {\n+                result.emplace_back(ann.m_sequence, txhash, ann.m_is_wtxid);\n+            }\n+        }\n+        // Sort the results by sequence number.\n+        std::sort(result.begin(), result.end());\n+\n+        // Compare with TxRequestTracker's implementation.\n+        const auto actual = m_tracker.GetRequestable(peer, m_now);\n+\n+        m_tracker.PostGetRequestableSanityCheck(m_now);\n+        assert(result.size() == actual.size());\n+        for (size_t pos = 0; pos < actual.size(); ++pos) {\n+            assert(TXHASHES[std::get<1>(result[pos])] == actual[pos].GetHash());\n+            assert(std::get<2>(result[pos]) == actual[pos].IsWtxid());\n+        }\n+    }\n+\n+    void Check()\n+    {\n+        // Compare CountTracked and CountLoad with naive structure.\n+        size_t total = 0;\n+        for (int peer = 0; peer < MAX_PEERS; ++peer) {\n+            size_t tracked = 0;\n+            size_t inflight = 0;\n+            size_t candidates = 0;\n+            for (int txhash = 0; txhash < MAX_TXHASHES; ++txhash) {\n+                tracked += m_announcements[txhash][peer].m_state != State::NOTHING;\n+                inflight += m_announcements[txhash][peer].m_state == State::REQUESTED;\n+                candidates += m_announcements[txhash][peer].m_state == State::CANDIDATE;\n+            }\n+            assert(m_tracker.Count(peer) == tracked);\n+            assert(m_tracker.CountInFlight(peer) == inflight);\n+            assert(m_tracker.CountCandidates(peer) == candidates);\n+            total += tracked;\n+        }\n+        // Compare Size.\n+        assert(m_tracker.Size() == total);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499956327",
      "id" : 499956327,
      "in_reply_to_id" : 499943473,
      "line" : 294,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1NjMyNw==",
      "original_commit_id" : "8ef5953e478b820fb5f33ba428c6b207af81d3db",
      "original_line" : 294,
      "original_position" : 294,
      "original_start_line" : null,
      "path" : "src/test/fuzz/txrequest.cpp",
      "position" : 294,
      "pull_request_review_id" : 502523923,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499956327",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499961749"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499961749"
         }
      },
      "author_association" : "MEMBER",
      "body" : "You're right that the description doesn't match the usage in net_processing here, but \"has been evaluation by the mempool\" is perhaps incorrect as well. If it's seen in a block, it can be forgotten as well, for example.\r\n\r\nReally the right criterion is: has it been made AlreadyHaveTx()==true. If we'd delete something that isn't AlreadyHaveTx(), it means we risk fetching it again if it's announced by another peer, despite already having seen it presumably. If we don't delete something that is AlreadyHaveTx(), we're risking fetching something from the same peer despite the same.\r\n\r\nI've adapted the comments a bit and tried to formulate it in a way that doesn't depend on net_processing specifics.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-06T01:46:19Z",
      "diff_hunk" : "@@ -0,0 +1,206 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <net.h> // For NodeId\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or invalid transaction or NOTFOUND was\n+ *   received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction. Note that this only works\n+ *              per txhash, so if the same transaction is announced both through txid and wtxid, we have no means\n+ *              to prevent fetching both (the caller can however mitigate this by delaying one, see further).\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten only:\n+ *   - If a peer goes offline, all its announcements are forgotten.\n+ *   - If a transaction has been successfully received, or is otherwise no longer needed, the caller can call\n+ *     ForgetTxHash, which removes all announcements across all peers with the specified txhash.\n+ *   - If for a given txhash only already-failed announcements remain, they are all forgotten.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening transaction censoring attacks. The flip side is that as long as an attacker manages\n+ *              to prevent us from receiving a transaction, failed announcements (including those from honest peers)\n+ *              will linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a\n+ *              cap on the number of tracked announcements per peer. As failed requests in response to announcements\n+ *              from honest peers should be rare, this almost solely hinders attackers.\n+ *              Transaction censoring attacks can be done by announcing transactions quickly while not answering\n+ *              requests for them. See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more\n+ *              information.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable the calling code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers are more trusted by us, so are less likely to be under attacker control.\n+ *\n+ *   - Pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: random assignments are hard to influence for attackers.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and minimizing\n+ * susceptibility to censorship attacks. An attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one preferred connection).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution). The \"1 +\" is due to the fact that the\n+ *   attacker can be the first to announce through a preferred connection in this scenario, which very likely means\n+ *   they get the first request.\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh>=1\n+ *   are honest, where we assume that the attacker can disconnect and reconnect those connections, the distribution\n+ *   becomes k ~ P + NB(p=1-NP/NPh,r=1) (where NB stands for Negative Binomial distribution), which has mean\n+ *   P-1+NP/NPh.\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of \"announcements\", one for each peer/txhash\n+    // combination:\n+    //\n+    // - CANDIDATE announcements represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED announcements represent transactions that have been requested, and which we're awaiting a\n+    //   response for from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED announcements represent transactions that have been requested from a peer, and a NOTFOUND or a\n+    //   transaction was received in response (valid or not), or they timed out. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED announcements for a given txhash remain (so no CANDIDATE\n+    //   or REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all announcements for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DisconnectedPeer(NodeId peer);\n+\n+    /** Deletes all announcements for a given txhash (both txid and wtxid ones).\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it.\n+     */\n+    void ForgetTxHash(const uint256& txhash);\n+\n+    /** Adds a new CANDIDATE announcement.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that the txid/wtxid property is ignored for determining uniqueness, so if an announcement\n+     * is added for a wtxid H, while one for txid H from the same peer already exists, it will be ignored. This is\n+     * harmless as the txhashes being equal implies it is a non-segwit transaction, so it doesn't matter how it is\n+     * fetched. The new announcement is given the specified preferred and reqtime values, and takes its is_wtxid\n+     * from the specified gtxid.\n+     */\n+    void ReceivedInv(NodeId peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime);\n+\n+    /** Find the txids to request now from peer.\n+     *\n+     * It does the following:\n+     *  - Convert all REQUESTED announcements (for all txhashes/peers) with (expiry <= now) to COMPLETED ones.\n+     *  - Requestable announcements are selected: CANDIDATE announcements from the specified peer with\n+     *    (reqtime <= now) for which no existing REQUESTED announcement with the same txhash exists, and for which\n+     *    the specified peer is the best choice among all (reqtime <= now) CANDIDATE announcements with the same\n+     *    txhash (subject to preferredness rules, and tiebreaking using a deterministic salted hash of peer and\n+     *    txhash).\n+     *  - The selected announcements are converted to GenTxids using their is_wtxid flag, and returned in\n+     *    announcement order (even if multiple were added at the same time, or when the clock went backwards while\n+     *    they were being added).\n+     */\n+    std::vector<GenTxid> GetRequestable(NodeId peer, std::chrono::microseconds now);\n+\n+    /** Marks a transaction as requested, with a specified expiry.\n+     *\n+     * If no CANDIDATE announcement for the provided peer and txhash exists, this call has no effect. Otherwise:\n+     *  - That announcement is converted to REQUESTED.\n+     *  - If any other REQUESTED announcement for the same txhash already existed, it means an unexpected request\n+     *    was made (GetRequestable will never advise doing so). In this case it is converted to COMPLETED, as we're\n+     *    no longer waiting for a response to it.\n+     */\n+    void RequestedTx(NodeId peer, const uint256& txhash, std::chrono::microseconds expiry);\n+\n+    /** Converts any CANDIDATE or REQUESTED announcement to a COMPLETED one, if one exists.\n+     *\n+     * It should be called whenever a transaction or NOTFOUND was received from a peer. When a good transaction is\n+     * received, ForgetTxHash should be called instead of (or in addition to) this operation.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r499961749",
      "id" : 499961749,
      "in_reply_to_id" : 499932949,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk2MTc0OQ==",
      "original_commit_id" : "8ef5953e478b820fb5f33ba428c6b207af81d3db",
      "original_line" : 175,
      "original_position" : 175,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 502530301,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T01:46:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499961749",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@ariard @jnewbery @ajtowns As the size of this PR's page is growing, would you mind going over your older un-\"resolved\" comments and resolve if you feel they've been addressed? For obvious fixes I've been doing that, but in cases where it's not clear to me I've left them open.\r\n\r\n@ariard Nice, I've squashed your test into the relevent commit here (mentioning you in the commit message).",
      "created_at" : "2020-10-06T02:36:14Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#issuecomment-703993017",
      "id" : 703993017,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19988",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwMzk5MzAxNw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-06T02:36:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/703993017",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r500042966"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500042966"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit ee4f89a44b:\r\n\r\nThere is no warning for me. If there is a bug or a false positive warning in an ancient gcc version, we often ignore that instead of \"crippling\" the code.\r\n\r\nMind sharing what kind of warning this is, and what gcc version was used? Maybe even add it to that comment.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-06T06:51:55Z",
      "diff_hunk" : "@@ -0,0 +1,597 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of ByTxHashView relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcements that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE announcement whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED announcement already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority announcement among all CANDIDATE_READY (and _BEST) ones for that\n+     *  txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED announcement. */\n+    REQUESTED,\n+    /** A CANDIDATE announcement that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED announcement. */\n+    COMPLETED,\n+};\n+\n+//! Type alias for sequence numbers.\n+using SequenceNumber = uint64_t;\n+\n+/** An announcement. This is the data we track for each txid or wtxid that is announced to us by each peer. */\n+struct Announcement {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const NodeId m_peer;\n+    /** What sequence number this announcement has. */\n+    const SequenceNumber m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r500042966",
      "id" : 500042966,
      "line" : 71,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA0Mjk2Ng==",
      "original_commit_id" : "ee4f89a44b41a860f2bda98957db2d6871a8e8ea",
      "original_line" : 71,
      "original_position" : 71,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 71,
      "pull_request_review_id" : 500895273,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T14:11:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500042966",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r500063984"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500063984"
         }
      },
      "author_association" : "MEMBER",
      "body" : "in commit ee4f89a44b\r\n\r\nAny reason to have ONE defined in uint256.h, but ZERO here?",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-06T07:33:52Z",
      "diff_hunk" : "@@ -0,0 +1,597 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of ByTxHashView relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcements that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE announcement whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED announcement already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority announcement among all CANDIDATE_READY (and _BEST) ones for that\n+     *  txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED announcement. */\n+    REQUESTED,\n+    /** A CANDIDATE announcement that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED announcement. */\n+    COMPLETED,\n+};\n+\n+//! Type alias for sequence numbers.\n+using SequenceNumber = uint64_t;\n+\n+/** An announcement. This is the data we track for each txid or wtxid that is announced to us by each peer. */\n+struct Announcement {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const NodeId m_peer;\n+    /** What sequence number this announcement has. */\n+    const SequenceNumber m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this announcement is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this announcement is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this announcement can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new announcement from scratch, initially in CANDIDATE_DELAYED state. */\n+    Announcement(const GenTxid& gtxid, NodeId peer, bool preferred, std::chrono::microseconds reqtime,\n+        SequenceNumber sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+//! Type alias for priorities.\n+using Priority = uint64_t;\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    Priority operator()(const uint256& txhash, NodeId peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    Priority operator()(const Announcement& ann) const\n+    {\n+        return operator()(ann.m_txhash, ann.m_peer, ann.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a By*View data type to represent the view of announcement it is sorted\n+// by, and an By*ViewExtractor type to convert an announcement into the By*View type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing announcements by peer/txhash, by checking both (peer, false, txhash) and\n+//   (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST announcements for a given peer in GetRequestable.\n+struct ByPeer {};\n+using ByPeerView = std::tuple<NodeId, bool, const uint256&>;\n+struct ByPeerViewExtractor\n+{\n+    using result_type = ByPeerView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByPeerView{ann.m_peer, ann.GetState() == State::CANDIDATE_BEST, ann.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority).\n+//\n+// Note: priority == 0 whenever state != CANDIDATE_READY.\n+//\n+// Uses:\n+// * Deleting all announcements with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   announcement exists for that txhash.\n+// * Determining when no more non-COMPLETED announcements for a given txhash exist, so the COMPLETED ones can be\n+//   deleted.\n+struct ByTxHash {};\n+using ByTxHashView = std::tuple<const uint256&, State, Priority>;\n+class ByTxHashViewExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    ByTxHashViewExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = ByTxHashView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        const State state = ann.GetState();\n+        const Priority prio = (state == State::CANDIDATE_READY) ? m_computer(ann) : 0;\n+        return ByTxHashView{ann.m_txhash, state, prio};\n+    }\n+};\n+\n+enum class WaitState {\n+    //! Used for announcements that need efficient testing of \"is their timestamp in the future?\".\n+    FUTURE_EVENT,\n+    //! Used for announcements whose timestamp is not relevant.\n+    NO_EVENT,\n+    //! Used for announcements that need efficient testing of \"is their timestamp in the past?\".\n+    PAST_EVENT,\n+};\n+\n+WaitState GetWaitState(const Announcement& ann)\n+{\n+    if (ann.IsWaiting()) return WaitState::FUTURE_EVENT;\n+    if (ann.IsSelectable()) return WaitState::PAST_EVENT;\n+    return WaitState::NO_EVENT;\n+}\n+\n+// The ByTime index is sorted by (wait_state, time).\n+//\n+// All announcements with a timestamp in the future can be found by iterating the index forward from the beginning.\n+// All announcements with a timestamp in the past can be found by iterating the index backwards from the end.\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED announcements whose reqtime has passed, and REQUESTED announcements whose expiry has\n+//   passed.\n+// * Finding CANDIDATE_READY/BEST announcements whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using ByTimeView = std::pair<WaitState, std::chrono::microseconds>;\n+struct ByTimeViewExtractor\n+{\n+    using result_type = ByTimeView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByTimeView{GetWaitState(ann), ann.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Announcement objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Announcement,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, ByPeerViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, ByTxHashViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, ByTimeViewExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of announcements for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED announcements for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED announcements for this peer.\n+};\n+\n+const uint256 UINT256_ZERO;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r500063984",
      "id" : 500063984,
      "line" : 299,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA2Mzk4NA==",
      "original_commit_id" : "ee4f89a44b41a860f2bda98957db2d6871a8e8ea",
      "original_line" : 236,
      "original_position" : 236,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 299,
      "pull_request_review_id" : 500895273,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T14:11:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500063984",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r500129074"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500129074"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yes, seems reasonable. Perhaps at some point in the future we might also want to have a return value from `ReceivedResponse()` so net_processing can know whether the peer is sending spurious notfound entries.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-06T09:19:21Z",
      "diff_hunk" : "@@ -3772,22 +3685,14 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n     if (msg_type == NetMsgType::NOTFOUND) {\n         // Remove the NOTFOUND transactions from the peer\n         LOCK(cs_main);\n-        CNodeState *state = State(pfrom.GetId());\n         std::vector<CInv> vInv;\n         vRecv >> vInv;\n-        if (vInv.size() <= MAX_PEER_TX_IN_FLIGHT + MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+        if (vInv.size() <= MAX_PEER_TX_ANNOUNCEMENTS + MAX_BLOCKS_IN_TRANSIT_PER_PEER) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r500129074",
      "id" : 500129074,
      "in_reply_to_id" : 499511223,
      "line" : 3688,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDEyOTA3NA==",
      "original_commit_id" : "6fa4512fb450d709006fd6b242975fd3ce2f5340",
      "original_line" : 3688,
      "original_position" : 353,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 363,
      "pull_request_review_id" : 502743912,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T09:19:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500129074",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r500130921"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500130921"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Marking as resolved.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-06T09:22:21Z",
      "diff_hunk" : "@@ -0,0 +1,685 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of EntryTxHash relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcemnets that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE entry whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED entry already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED entry. */\n+    REQUESTED,\n+    /** A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED entry. */\n+    COMPLETED,\n+\n+    /** An invalid State value that's larger than all valid ones. */\n+    TOO_LARGE,\n+};\n+\n+/** An announcement entry. This is the data we track for each txid or wtxid that is announced to us. */\n+struct Entry {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const uint64_t m_peer;\n+    /** What sequence number this announcement has. */\n+    const uint64_t m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this entry is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this entry is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this entry can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new entry from scratch, initially in CANDIDATE_DELAYED state. */\n+    Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+        uint64_t sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    uint64_t operator()(const Entry& entry) const\n+    {\n+        return operator()(entry.m_txhash, entry.m_peer, entry.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a Entry* data type to represent the view of Entry it is sorted by,\n+// and an Entry*Extractor type to convert an Entry into the Entry* view type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing entries by peer/txhash, by checking both (peer, false, txhash) and (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST for a given peer in GetRequestable.\n+struct ByPeer {};\n+using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+struct EntryPeerExtractor\n+{\n+    using result_type = EntryPeer;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryPeer{entry.m_peer, entry.GetState() == State::CANDIDATE_BEST, entry.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+//\n+// Uses:\n+// * Deleting all Entrys with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   Entry exists for that txhash.\n+// * Finding the Entry to store per-txhash flags in.\n+// * Determining when no more non-COMPLETED Entrys for a given txhash exist, so the COMPLETED ones can be deleted.\n+struct ByTxHash {};\n+using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+class EntryTxHashExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = EntryTxHash;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        const State state = entry.GetState();\n+        const uint64_t prio = (state == State::CANDIDATE_READY) ? m_computer(entry) : 0;\n+        return EntryTxHash{entry.m_txhash, state, prio};\n+    }\n+};\n+\n+// The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+// 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED entries whose reqtime has passed, and REQUESTED entries whose expiry has passed.\n+// * Finding CANDIDATE_READY/BEST entries whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using EntryTime = std::pair<int, std::chrono::microseconds>;\n+struct EntryTimeExtractor\n+{\n+    using result_type = EntryTime;\n+    result_type operator()(const Entry& entry) const\n+    {\n+        return EntryTime{entry.IsWaiting() ? 0 : entry.IsSelectable() ? 2 : 1, entry.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Entry,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, EntryPeerExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, EntryTxHashExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, EntryTimeExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of entries for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED entries for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED entries for this peer.\n+\n+    /** Compare two PeerInfo objects. Only used for sanity checking. */\n+    friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+    {\n+        return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+               std::tie(b.m_total, b.m_completed, b.m_requested);\n+    }\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED entries for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY entries for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED entries for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+    uint64_t m_priority_candidate_best = 0;\n+    //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+    uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+    //! All peers we have an entry for this txhash for.\n+    std::vector<uint64_t> m_peers;\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<uint64_t, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<uint64_t, PeerInfo> ret;\n+    for (const Entry& entry : index) {\n+        PeerInfo& info = ret[entry.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        info.m_completed += (entry.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Entry& entry : index) {\n+        TxHashInfo& info = ret[entry.m_txhash];\n+        // Classify how many Entrys of each state we have for this txhash.\n+        info.m_candidate_delayed += (entry.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (entry.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (entry.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (entry.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+        if (entry.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(entry);\n+        }\n+        if (entry.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(entry));\n+        }\n+        // Also keep track of which peers this txhash has a Entry for (so we can detect duplicates).\n+        info.m_peers.push_back(entry.m_peer);\n+        // Track preferred/first.\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo entries exist with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+\n+            // Looking up the last ByTxHash entry with the given txhash must return an Entry with that txhash or the\n+            // multi_index is very bad.\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{item.first, State::TOO_LARGE, 0}));\n+            assert(it_last != m_index.get<ByTxHash>().end() && it_last->m_txhash == item.first);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+\n+private:\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txhash that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txhash already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = m_computer(*std::prev(it));\n+            uint64_t priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in\n+            // the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Entry for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED entries.\n+\n+        // If this Entry's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Entry's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txhash, they are\n+     *  deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+     *  CANDIDATE_BEST. Returns whether the Entry still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED entry for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the entry COMPLETED, and select the next best entry (the first CANDIDATE_READY) if needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to EntryTxHashExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(EntryPeerExtractor(), std::less<EntryPeer>()),\n+            boost::make_tuple(EntryTxHashExtractor(m_computer), std::less<EntryTxHash>()),\n+            boost::make_tuple(EntryTimeExtractor(), std::less<EntryTime>())\n+        )) {}\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxHashExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DisconnectedPeer(uint64_t peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+            // CANDIDATE_BEST, or delete all of a txhash's entries if no non-COMPLETED ones are left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(EntryTxHash{txhash, State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST entry for this (txhash, peer) combination. The case where\n+        // there is a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+        // automatically.\n+        if (m_index.get<ByPeer>().count(EntryPeer{peer, true, gtxid.GetHash()})) return;\n+\n+        // Find last entry for this txhash, and extract per-txhash information from it.\n+        Iter<ByTxHash> it_last = m_index.get<ByTxHash>().end();\n+        // First find the first entry past this txhash.\n+        it_last = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0});\n+        if (it_last != m_index.get<ByTxHash>().begin() && std::prev(it_last)->m_txhash == gtxid.GetHash()) {\n+            it_last--;\n+        } else {\n+            // No entry for this txhash exists yet.\n+            it_last = m_index.get<ByTxHash>().end();\n+        }\n+\n+        // Try creating the entry with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST entry already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_sequence);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+    }\n+\n+    //! Find the GenTxids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now)\n+    {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r500130921",
      "id" : 500130921,
      "in_reply_to_id" : 498781706,
      "line" : 579,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDEzMDkyMQ==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 579,
      "original_position" : 561,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 579,
      "pull_request_review_id" : 502746407,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T09:22:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500130921",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r500132563"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500132563"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Agree it doesn't matter at all. It just offends my aesthetic sensibilities. Marking resolved.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-06T09:25:02Z",
      "diff_hunk" : "@@ -2994,9 +2898,7 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n         TxValidationState state;\n \n         for (const GenTxid& gtxid : {GenTxid(false, txid), GenTxid(true, wtxid)}) {\n-            nodestate->m_tx_download.m_tx_announced.erase(gtxid.GetHash());\n-            nodestate->m_tx_download.m_tx_in_flight.erase(gtxid.GetHash());\n-            EraseTxRequest(gtxid);\n+            m_txrequest.ReceivedResponse(pfrom.GetId(), gtxid);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r500132563",
      "id" : 500132563,
      "in_reply_to_id" : 498773268,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDEzMjU2Mw==",
      "original_commit_id" : "9c311d0e20192ccd812eb946470de76b41ae8537",
      "original_line" : 2901,
      "original_position" : 276,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 502748654,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T09:25:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500132563",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> would you mind going over your older un-\"resolved\" comments and resolve if you feel they've been addressed?\r\n\r\nDone all mine. Thanks for being so responsive to review comments!",
      "created_at" : "2020-10-06T09:26:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#issuecomment-704146642",
      "id" : 704146642,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19988",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwNDE0NjY0Mg==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-06T09:26:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/704146642",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r500180971"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500180971"
         }
      },
      "author_association" : "MEMBER",
      "body" : "in commit ee4f89a44b:\r\n\r\nThe comment says \"fail\", the code says \"return false\", this seems inconsistent.\r\n\r\nThis can't happen in normal operation. If this happens, it would be a logic error, so `assert` seems appropriate? Or maybe even remove the dead code?\r\n\r\nEdit: According to the coverage report this *is* hit, so I might have to take another look here.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-06T10:51:10Z",
      "diff_hunk" : "@@ -0,0 +1,597 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of ByTxHashView relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcements that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE announcement whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED announcement already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority announcement among all CANDIDATE_READY (and _BEST) ones for that\n+     *  txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED announcement. */\n+    REQUESTED,\n+    /** A CANDIDATE announcement that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED announcement. */\n+    COMPLETED,\n+};\n+\n+//! Type alias for sequence numbers.\n+using SequenceNumber = uint64_t;\n+\n+/** An announcement. This is the data we track for each txid or wtxid that is announced to us by each peer. */\n+struct Announcement {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const NodeId m_peer;\n+    /** What sequence number this announcement has. */\n+    const SequenceNumber m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this announcement is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this announcement is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this announcement can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new announcement from scratch, initially in CANDIDATE_DELAYED state. */\n+    Announcement(const GenTxid& gtxid, NodeId peer, bool preferred, std::chrono::microseconds reqtime,\n+        SequenceNumber sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+//! Type alias for priorities.\n+using Priority = uint64_t;\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    Priority operator()(const uint256& txhash, NodeId peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    Priority operator()(const Announcement& ann) const\n+    {\n+        return operator()(ann.m_txhash, ann.m_peer, ann.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a By*View data type to represent the view of announcement it is sorted\n+// by, and an By*ViewExtractor type to convert an announcement into the By*View type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing announcements by peer/txhash, by checking both (peer, false, txhash) and\n+//   (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST announcements for a given peer in GetRequestable.\n+struct ByPeer {};\n+using ByPeerView = std::tuple<NodeId, bool, const uint256&>;\n+struct ByPeerViewExtractor\n+{\n+    using result_type = ByPeerView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByPeerView{ann.m_peer, ann.GetState() == State::CANDIDATE_BEST, ann.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority).\n+//\n+// Note: priority == 0 whenever state != CANDIDATE_READY.\n+//\n+// Uses:\n+// * Deleting all announcements with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   announcement exists for that txhash.\n+// * Determining when no more non-COMPLETED announcements for a given txhash exist, so the COMPLETED ones can be\n+//   deleted.\n+struct ByTxHash {};\n+using ByTxHashView = std::tuple<const uint256&, State, Priority>;\n+class ByTxHashViewExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    ByTxHashViewExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = ByTxHashView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        const State state = ann.GetState();\n+        const Priority prio = (state == State::CANDIDATE_READY) ? m_computer(ann) : 0;\n+        return ByTxHashView{ann.m_txhash, state, prio};\n+    }\n+};\n+\n+enum class WaitState {\n+    //! Used for announcements that need efficient testing of \"is their timestamp in the future?\".\n+    FUTURE_EVENT,\n+    //! Used for announcements whose timestamp is not relevant.\n+    NO_EVENT,\n+    //! Used for announcements that need efficient testing of \"is their timestamp in the past?\".\n+    PAST_EVENT,\n+};\n+\n+WaitState GetWaitState(const Announcement& ann)\n+{\n+    if (ann.IsWaiting()) return WaitState::FUTURE_EVENT;\n+    if (ann.IsSelectable()) return WaitState::PAST_EVENT;\n+    return WaitState::NO_EVENT;\n+}\n+\n+// The ByTime index is sorted by (wait_state, time).\n+//\n+// All announcements with a timestamp in the future can be found by iterating the index forward from the beginning.\n+// All announcements with a timestamp in the past can be found by iterating the index backwards from the end.\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED announcements whose reqtime has passed, and REQUESTED announcements whose expiry has\n+//   passed.\n+// * Finding CANDIDATE_READY/BEST announcements whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using ByTimeView = std::pair<WaitState, std::chrono::microseconds>;\n+struct ByTimeViewExtractor\n+{\n+    using result_type = ByTimeView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByTimeView{GetWaitState(ann), ann.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Announcement objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Announcement,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, ByPeerViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, ByTxHashViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, ByTimeViewExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of announcements for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED announcements for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED announcements for this peer.\n+};\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    SequenceNumber m_current_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<NodeId, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED announcement into a CANDIDATE_READY. If this makes it the new best\n+    //! CANDIDATE_READY (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new\n+    //! CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY announcements, the best one (lowest\n+        // priority) comes first. Thus, if an existing _BEST exists for the same txhash that this announcement may\n+        // be preferred over, it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() announcement for this txhash\n+            // already.\n+            Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            Priority priority_old = m_computer(*std::prev(it));\n+            Priority priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST announcement already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an announcement to something non-IsSelected(). If it was IsSelected(), the next best\n+    //! announcement will be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        assert(new_state == State::COMPLETED || new_state == State::CANDIDATE_DELAYED);\n+        assert(it != m_index.get<ByTxHash>().end());\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST\n+            // announcement in the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Announcement& ann){ ann.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only announcement for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED announcements.\n+\n+        // If this announcement's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this announcement's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r500180971",
      "id" : 500180971,
      "line" : 453,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE4MDk3MQ==",
      "original_commit_id" : "ee4f89a44b41a860f2bda98957db2d6871a8e8ea",
      "original_line" : 339,
      "original_position" : 339,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 453,
      "pull_request_review_id" : 500895273,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T14:13:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500180971",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r500217220"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500217220"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This assert seems redundant now that you have the `assert(new_state == State::COMPLETED || new_state == State::CANDIDATE_DELAYED);` at the top. It's not doing any harm, but it seems unnecessary.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-06T11:58:57Z",
      "diff_hunk" : "@@ -0,0 +1,729 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of ByTxHashView relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcements that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE announcement whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED announcement already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority announcement among all CANDIDATE_READY (and _BEST) ones for that\n+     *  txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED announcement. */\n+    REQUESTED,\n+    /** A CANDIDATE announcement that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED announcement. */\n+    COMPLETED,\n+};\n+\n+//! Type alias for sequence numbers.\n+using SequenceNumber = uint64_t;\n+\n+/** An announcement. This is the data we track for each txid or wtxid that is announced to us by each peer. */\n+struct Announcement {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const NodeId m_peer;\n+    /** What sequence number this announcement has. */\n+    const SequenceNumber m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this announcement is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this announcement is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this announcement can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new announcement from scratch, initially in CANDIDATE_DELAYED state. */\n+    Announcement(const GenTxid& gtxid, NodeId peer, bool preferred, std::chrono::microseconds reqtime,\n+        SequenceNumber sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+//! Type alias for priorities.\n+using Priority = uint64_t;\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    Priority operator()(const uint256& txhash, NodeId peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    Priority operator()(const Announcement& ann) const\n+    {\n+        return operator()(ann.m_txhash, ann.m_peer, ann.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a By*View data type to represent the view of announcement it is sorted\n+// by, and an By*ViewExtractor type to convert an announcement into the By*View type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing announcements by peer/txhash, by checking both (peer, false, txhash) and\n+//   (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST announcements for a given peer in GetRequestable.\n+struct ByPeer {};\n+using ByPeerView = std::tuple<NodeId, bool, const uint256&>;\n+struct ByPeerViewExtractor\n+{\n+    using result_type = ByPeerView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByPeerView{ann.m_peer, ann.GetState() == State::CANDIDATE_BEST, ann.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority).\n+//\n+// Note: priority == 0 whenever state != CANDIDATE_READY.\n+//\n+// Uses:\n+// * Deleting all announcements with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   announcement exists for that txhash.\n+// * Determining when no more non-COMPLETED announcements for a given txhash exist, so the COMPLETED ones can be\n+//   deleted.\n+struct ByTxHash {};\n+using ByTxHashView = std::tuple<const uint256&, State, Priority>;\n+class ByTxHashViewExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    ByTxHashViewExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = ByTxHashView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        const State state = ann.GetState();\n+        const Priority prio = (state == State::CANDIDATE_READY) ? m_computer(ann) : 0;\n+        return ByTxHashView{ann.m_txhash, state, prio};\n+    }\n+};\n+\n+enum class WaitState {\n+    //! Used for announcements that need efficient testing of \"is their timestamp in the future?\".\n+    FUTURE_EVENT,\n+    //! Used for announcements whose timestamp is not relevant.\n+    NO_EVENT,\n+    //! Used for announcements that need efficient testing of \"is their timestamp in the past?\".\n+    PAST_EVENT,\n+};\n+\n+WaitState GetWaitState(const Announcement& ann)\n+{\n+    if (ann.IsWaiting()) return WaitState::FUTURE_EVENT;\n+    if (ann.IsSelectable()) return WaitState::PAST_EVENT;\n+    return WaitState::NO_EVENT;\n+}\n+\n+// The ByTime index is sorted by (wait_state, time).\n+//\n+// All announcements with a timestamp in the future can be found by iterating the index forward from the beginning.\n+// All announcements with a timestamp in the past can be found by iterating the index backwards from the end.\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED announcements whose reqtime has passed, and REQUESTED announcements whose expiry has\n+//   passed.\n+// * Finding CANDIDATE_READY/BEST announcements whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using ByTimeView = std::pair<WaitState, std::chrono::microseconds>;\n+struct ByTimeViewExtractor\n+{\n+    using result_type = ByTimeView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByTimeView{GetWaitState(ann), ann.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Announcement objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Announcement,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, ByPeerViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, ByTxHashViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, ByTimeViewExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of announcements for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED announcements for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED announcements for this peer.\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED announcements for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY announcements for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST announcements for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED announcements for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST announcement if one exists, or min() otherwise.\n+    Priority m_priority_candidate_best = std::numeric_limits<Priority>::min();\n+    //! The lowest priority of all CANDIDATE_READY announcements (or max() if none exist).\n+    Priority m_priority_best_candidate_ready = std::numeric_limits<Priority>::max();\n+    //! All peers we have an announcement for this txhash for.\n+    std::vector<NodeId> m_peers;\n+};\n+\n+/** Compare two PeerInfo objects. Only used for sanity checking. */\n+bool operator==(const PeerInfo& a, const PeerInfo& b)\n+{\n+    return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+           std::tie(b.m_total, b.m_completed, b.m_requested);\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<NodeId, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<NodeId, PeerInfo> ret;\n+    for (const Announcement& ann : index) {\n+        PeerInfo& info = ret[ann.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (ann.GetState() == State::REQUESTED);\n+        info.m_completed += (ann.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Announcement& ann : index) {\n+        TxHashInfo& info = ret[ann.m_txhash];\n+        // Classify how many announcements of each state we have for this txhash.\n+        info.m_candidate_delayed += (ann.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (ann.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (ann.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (ann.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST announcements.\n+        if (ann.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(ann);\n+        }\n+        if (ann.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(ann));\n+        }\n+        // Also keep track of which peers this txhash has an announcement for (so we can detect duplicates).\n+        info.m_peers.push_back(ann.m_peer);\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    SequenceNumber m_current_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure. See SanityCheck() for the invariants that apply to it.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<NodeId, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo announcements with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY announcements, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // announcement.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST announcement, the CANDIDATE_BEST one must be\n+            // at least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const Announcement& ann : m_index) {\n+            if (ann.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(ann.m_time > now);\n+            } else if (ann.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(ann.m_time <= now);\n+            }\n+        }\n+    }\n+\n+private:\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED announcement into a CANDIDATE_READY. If this makes it the new best\n+    //! CANDIDATE_READY (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new\n+    //! CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY announcements, the best one (lowest\n+        // priority) comes first. Thus, if an existing _BEST exists for the same txhash that this announcement may\n+        // be preferred over, it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() announcement for this txhash\n+            // already.\n+            Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            Priority priority_old = m_computer(*std::prev(it));\n+            Priority priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST announcement already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an announcement to something non-IsSelected(). If it was IsSelected(), the next best\n+    //! announcement will be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        assert(new_state == State::COMPLETED || new_state == State::CANDIDATE_DELAYED);\n+        assert(it != m_index.get<ByTxHash>().end());\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST\n+            // announcement in the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Announcement& ann){ ann.SetState(new_state); });\n+        assert(!it->IsSelected());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r500217220",
      "id" : 500217220,
      "line" : 439,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDIxNzIyMA==",
      "original_commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "original_line" : 439,
      "original_position" : 439,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 439,
      "pull_request_review_id" : 502861484,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T14:51:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500217220",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r500222894"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500222894"
         }
      },
      "author_association" : "MEMBER",
      "body" : "in commit ee4f89a44b41a860f2bda98957db2d6871a8e8ea:\r\n\r\nThe same peer can't have duplicate hashes, so this can be clarified to say \"different peer\"\r\n\r\n\r\n```suggestion\r\n     *    (reqtime <= now) for which no existing REQUESTED announcement with the same txhash exists from a different peer, and for which\r\n```",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-06T12:09:03Z",
      "diff_hunk" : "@@ -0,0 +1,194 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <net.h> // For NodeId\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not. Which announcements get this flag is determined by the caller, but\n+ *   this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the\n+ *   peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or invalid transaction or NOTFOUND was\n+ *   received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction. Note that this only works\n+ *              per txhash, so if the same transaction is announced both through txid and wtxid, we have no means\n+ *              to prevent fetching both (the caller can however mitigate this by delaying one, see further).\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the announcement was forgotten in\n+ *   between, and re-announced. Announcements are forgotten only:\n+ *   - If a peer goes offline, all its announcements are forgotten.\n+ *   - If a transaction has been successfully received, or is otherwise no longer needed, the caller can call\n+ *     ForgetTxHash, which removes all announcements across all peers with the specified txhash.\n+ *   - If for a given txhash only already-failed announcements remain, they are all forgotten.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening transaction censoring attacks. The flip side is that as long as an attacker manages\n+ *              to prevent us from receiving a transaction, failed announcements (including those from honest peers)\n+ *              will linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a\n+ *              cap on the number of tracked announcements per peer. As failed requests in response to announcements\n+ *              from honest peers should be rare, this almost solely hinders attackers.\n+ *              Transaction censoring attacks can be done by announcing transactions quickly while not answering\n+ *              requests for them. See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for more\n+ *              information.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable the calling code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers are more trusted by us, so are less likely to be under attacker control.\n+ *\n+ *   - Pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: random assignments are hard to influence for attackers.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and minimizing\n+ * susceptibility to censorship attacks. An attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one preferred connection).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution). The \"1 +\" is due to the fact that the\n+ *   attacker can be the first to announce through a preferred connection in this scenario, which very likely means\n+ *   they get the first request.\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh>=1\n+ *   are honest, where we assume that the attacker can disconnect and reconnect those connections, the distribution\n+ *   becomes k ~ P + NB(p=1-NP/NPh,r=1) (where NB stands for Negative Binomial distribution), which has mean\n+ *   P-1+NP/NPh.\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of \"announcements\", one for each peer/txhash\n+    // combination:\n+    //\n+    // - CANDIDATE announcements represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED announcements represent transactions that have been requested, and which we're awaiting a\n+    //   response for from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED announcements represent transactions that have been requested from a peer, and a NOTFOUND or a\n+    //   transaction was received in response (valid or not), or they timed out. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED announcements for a given txhash remain (so no CANDIDATE\n+    //   or REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Adds a new CANDIDATE announcement.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that the txid/wtxid property is ignored for determining uniqueness, so if an announcement\n+     * is added for a wtxid H, while one for txid H from the same peer already exists, it will be ignored. This is\n+     * harmless as the txhashes being equal implies it is a non-segwit transaction, so it doesn't matter how it is\n+     * fetched. The new announcement is given the specified preferred and reqtime values, and takes its is_wtxid\n+     * from the specified gtxid.\n+     */\n+    void ReceivedInv(NodeId peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime);\n+\n+    /** Deletes all announcements for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DisconnectedPeer(NodeId peer);\n+\n+    /** Deletes all announcements for a given txhash (both txid and wtxid ones).\n+     *\n+     * This should be called when a transaction is no longer needed. The caller should ensure that new announcements\n+     * for the same txhash will not trigger new ReceivedInv calls, at least in the short term after this call.\n+     */\n+    void ForgetTxHash(const uint256& txhash);\n+\n+    /** Find the txids to request now from peer.\n+     *\n+     * It does the following:\n+     *  - Convert all REQUESTED announcements (for all txhashes/peers) with (expiry <= now) to COMPLETED ones.\n+     *  - Requestable announcements are selected: CANDIDATE announcements from the specified peer with\n+     *    (reqtime <= now) for which no existing REQUESTED announcement with the same txhash exists, and for which",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r500222894",
      "id" : 500222894,
      "line" : 152,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDIyMjg5NA==",
      "original_commit_id" : "ee4f89a44b41a860f2bda98957db2d6871a8e8ea",
      "original_line" : 152,
      "original_position" : 152,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 152,
      "pull_request_review_id" : 500895273,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T14:11:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500222894",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r500258527"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500258527"
         }
      },
      "author_association" : "MEMBER",
      "body" : "in commit a9a0504f12cb3c301bc56cc5f8f59ca57c1dc433:\r\n\r\nThe default seems to be unused\r\n\r\n```suggestion\r\n    void ReceivedInv(NodeId peer, const GenTxid& gtxid, bool pref, std::chrono::microseconds reqtime)\r\n```",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-06T13:05:03Z",
      "diff_hunk" : "@@ -0,0 +1,587 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds MIN_TIME = std::chrono::microseconds::min();\n+constexpr std::chrono::microseconds MAX_TIME = std::chrono::microseconds::max();\n+constexpr std::chrono::microseconds MICROSECOND = std::chrono::microseconds{1};\n+constexpr std::chrono::microseconds NO_TIME = std::chrono::microseconds{0};\n+\n+/** An Action is a function to call at a particular (simulated) timestamp. */\n+using Action = std::pair<std::chrono::microseconds, std::function<void()>>;\n+\n+/** Object that stores actions from multiple interleaved scenarios, and data shared across them.\n+ *\n+ * The Scenario below is used to fill this.\n+ */\n+struct Runner\n+{\n+    /** The TxRequestTracker being tested. */\n+    TxRequestTracker txrequest;\n+\n+    /** List of actions to be executed (in order of increasing timestamp). */\n+    std::vector<Action> actions;\n+\n+    /** Which node ids have been assigned already (to prevent reuse). */\n+    std::set<NodeId> peerset;\n+\n+    /** Which txhashes have been assigned already (to prevent reuse). */\n+    std::set<uint256> txhashset;\n+};\n+\n+std::chrono::microseconds RandomTime8s() { return std::chrono::microseconds{1 + InsecureRandBits(23)}; }\n+std::chrono::microseconds RandomTime1y() { return std::chrono::microseconds{1 + InsecureRandBits(45)}; }\n+\n+/** A proxy for a Runner that helps build a sequence of consecutive test actions on a TxRequestTracker.\n+ *\n+ * Each Scenario is a proxy through which actions for the (sequential) execution of various tests are added to a\n+ * Runner. The actions from multiple scenarios are then run concurrently, resulting in these tests being performed\n+ * against a TxRequestTracker in parallel. Every test has its own unique txhashes and NodeIds which are not\n+ * reused in other tests, and thus they should be independent from each other. Running them in parallel however\n+ * means that we verify the behavior (w.r.t. one test's txhashes and NodeIds) even when the state of the data\n+ * structure is more complicated due to the presence of other tests.\n+ */\n+class Scenario\n+{\n+    Runner& m_runner;\n+    std::chrono::microseconds m_now;\n+    std::string m_testname;\n+\n+public:\n+    Scenario(Runner& runner, std::chrono::microseconds starttime) : m_runner(runner), m_now(starttime) {}\n+\n+    /** Set a name for the current test, to give more clear error messages. */\n+    void SetTestName(std::string testname)\n+    {\n+        m_testname = std::move(testname);\n+    }\n+\n+    /** Advance this Scenario's time; this affects the timestamps newly scheduled events get. */\n+    void AdvanceTime(std::chrono::microseconds amount)\n+    {\n+        assert(amount.count() >= 0);\n+        m_now += amount;\n+    }\n+\n+    /** Schedule a ForgetTxHash call at the Scheduler's current time. */\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ForgetTxHash(txhash);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    /** Schedule a ReceivedInv call at the Scheduler's current time. */\n+    void ReceivedInv(NodeId peer, const GenTxid& gtxid, bool pref, std::chrono::microseconds reqtime = MIN_TIME)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r500258527",
      "id" : 500258527,
      "line" : 93,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI1ODUyNw==",
      "original_commit_id" : "a9a0504f12cb3c301bc56cc5f8f59ca57c1dc433",
      "original_line" : 93,
      "original_position" : 93,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : 93,
      "pull_request_review_id" : 500895273,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T14:11:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500258527",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r500263942"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500263942"
         }
      },
      "author_association" : "MEMBER",
      "body" : "in commit a9a0504f12cb3c301bc56cc5f8f59ca57c1dc433:\r\n\r\nCan be written shorter\r\n\r\n```suggestion\r\n            scenario.AdvanceTime(GetRandMicros(expiry));\r\n```",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-06T13:12:42Z",
      "diff_hunk" : "@@ -0,0 +1,587 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds MIN_TIME = std::chrono::microseconds::min();\n+constexpr std::chrono::microseconds MAX_TIME = std::chrono::microseconds::max();\n+constexpr std::chrono::microseconds MICROSECOND = std::chrono::microseconds{1};\n+constexpr std::chrono::microseconds NO_TIME = std::chrono::microseconds{0};\n+\n+/** An Action is a function to call at a particular (simulated) timestamp. */\n+using Action = std::pair<std::chrono::microseconds, std::function<void()>>;\n+\n+/** Object that stores actions from multiple interleaved scenarios, and data shared across them.\n+ *\n+ * The Scenario below is used to fill this.\n+ */\n+struct Runner\n+{\n+    /** The TxRequestTracker being tested. */\n+    TxRequestTracker txrequest;\n+\n+    /** List of actions to be executed (in order of increasing timestamp). */\n+    std::vector<Action> actions;\n+\n+    /** Which node ids have been assigned already (to prevent reuse). */\n+    std::set<NodeId> peerset;\n+\n+    /** Which txhashes have been assigned already (to prevent reuse). */\n+    std::set<uint256> txhashset;\n+};\n+\n+std::chrono::microseconds RandomTime8s() { return std::chrono::microseconds{1 + InsecureRandBits(23)}; }\n+std::chrono::microseconds RandomTime1y() { return std::chrono::microseconds{1 + InsecureRandBits(45)}; }\n+\n+/** A proxy for a Runner that helps build a sequence of consecutive test actions on a TxRequestTracker.\n+ *\n+ * Each Scenario is a proxy through which actions for the (sequential) execution of various tests are added to a\n+ * Runner. The actions from multiple scenarios are then run concurrently, resulting in these tests being performed\n+ * against a TxRequestTracker in parallel. Every test has its own unique txhashes and NodeIds which are not\n+ * reused in other tests, and thus they should be independent from each other. Running them in parallel however\n+ * means that we verify the behavior (w.r.t. one test's txhashes and NodeIds) even when the state of the data\n+ * structure is more complicated due to the presence of other tests.\n+ */\n+class Scenario\n+{\n+    Runner& m_runner;\n+    std::chrono::microseconds m_now;\n+    std::string m_testname;\n+\n+public:\n+    Scenario(Runner& runner, std::chrono::microseconds starttime) : m_runner(runner), m_now(starttime) {}\n+\n+    /** Set a name for the current test, to give more clear error messages. */\n+    void SetTestName(std::string testname)\n+    {\n+        m_testname = std::move(testname);\n+    }\n+\n+    /** Advance this Scenario's time; this affects the timestamps newly scheduled events get. */\n+    void AdvanceTime(std::chrono::microseconds amount)\n+    {\n+        assert(amount.count() >= 0);\n+        m_now += amount;\n+    }\n+\n+    /** Schedule a ForgetTxHash call at the Scheduler's current time. */\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ForgetTxHash(txhash);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    /** Schedule a ReceivedInv call at the Scheduler's current time. */\n+    void ReceivedInv(NodeId peer, const GenTxid& gtxid, bool pref, std::chrono::microseconds reqtime = MIN_TIME)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedInv(peer, gtxid, pref, reqtime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    /** Schedule a DisconnectedPeer call at the Scheduler's current time. */\n+    void DisconnectedPeer(NodeId peer)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.DisconnectedPeer(peer);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    /** Schedule a RequestedTx call at the Scheduler's current time. */\n+    void RequestedTx(NodeId peer, const uint256& txhash, std::chrono::microseconds exptime)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.RequestedTx(peer, txhash, exptime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    /** Schedule a ReceivedResponse call at the Scheduler's current time. */\n+    void ReceivedResponse(NodeId peer, const uint256& txhash)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedResponse(peer, txhash);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    /** Schedule calls to verify the TxRequestTracker's state at the Scheduler's current time.\n+     *\n+     * @param peer       The peer whose state will be inspected.\n+     * @param expected   The expected return value for GetRequestable(peer)\n+     * @param candidates The expected return value CountCandidates(peer)\n+     * @param inflight   The expected return value CountInFlight(peer)\n+     * @param completed  The expected return value of Count(peer), minus candidates and inflight.\n+     * @param checkname  An arbitrary string to include in error messages, for test identificatrion.\n+     */\n+    void Check(NodeId peer, const std::vector<GenTxid>& expected, size_t candidates, size_t inflight,\n+        size_t completed, const std::string& checkname = \"\")\n+    {\n+        const auto comment = m_testname + \" \" + checkname;\n+        auto& runner = m_runner;\n+        const auto now = m_now;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            auto ret = runner.txrequest.GetRequestable(peer, now);\n+            runner.txrequest.SanityCheck();\n+            runner.txrequest.PostGetRequestableSanityCheck(now);\n+            size_t total = candidates + inflight + completed;\n+            size_t real_total = runner.txrequest.Count(peer);\n+            size_t real_candidates = runner.txrequest.CountCandidates(peer);\n+            size_t real_inflight = runner.txrequest.CountInFlight(peer);\n+            BOOST_CHECK_MESSAGE(real_total == total, strprintf(\"[\" + comment + \"] total %i (%i expected)\", real_total, total));\n+            BOOST_CHECK_MESSAGE(real_inflight == inflight, strprintf(\"[\" + comment + \"] inflight %i (%i expected)\", real_inflight, inflight));\n+            BOOST_CHECK_MESSAGE(real_candidates == candidates, strprintf(\"[\" + comment + \"] candidates %i (%i expected)\", real_candidates, candidates));\n+            BOOST_CHECK_MESSAGE(ret == expected, \"[\" + comment + \"] mismatching requestables\");\n+        });\n+    }\n+\n+    /** Generate a random txhash, whose priorities for certain peers are constrained.\n+     *\n+     * For example, NewTxHash({{p1,p2,p3},{p2,p4,p5}}) will generate a txhash T such that both:\n+     *  - priority(p1,T) < priority(p2,T) < priority(p3,T)\n+     *  - priority(p2,T) < priority(p4,T) < priority(p5,T)\n+     * where priority is the predicted internal TxRequestTracker's priority, assuming all announcements\n+     * are within the same preferredness class.\n+     */\n+    uint256 NewTxHash(const std::vector<std::vector<NodeId>>& orders = {})\n+    {\n+        uint256 ret;\n+        bool ok;\n+        do {\n+            ret = InsecureRand256();\n+            ok = true;\n+            for (const auto& order : orders) {\n+                for (size_t pos = 1; pos < order.size(); ++pos) {\n+                    uint64_t prio_prev = m_runner.txrequest.ComputePriority(ret, order[pos - 1], true);\n+                    uint64_t prio_cur = m_runner.txrequest.ComputePriority(ret, order[pos], true);\n+                    if (prio_prev >= prio_cur) {\n+                        ok = false;\n+                        break;\n+                    }\n+                }\n+                if (!ok) break;\n+            }\n+            if (ok) {\n+                ok = m_runner.txhashset.insert(ret).second;\n+            }\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    /** Generate a random GenTxid; the txhash follows NewTxHash; the is_wtxid flag is random. */\n+    GenTxid NewGTxid(const std::vector<std::vector<NodeId>>& orders = {})\n+    {\n+        return {InsecureRandBool(), NewTxHash(orders)};\n+    }\n+\n+    /** Generate a new random NodeId to use as peer. The same NodeId is never returned twice\n+     *  (across all Scenarios combined). */\n+    NodeId NewPeer()\n+    {\n+        bool ok;\n+        NodeId ret;\n+        do {\n+            ret = InsecureRandBits(63);\n+            ok = m_runner.peerset.insert(ret).second;\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    std::chrono::microseconds Now() const { return m_now; }\n+};\n+\n+/** Add to scenario a test with a single tx announced by a single peer.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildSingleTest(Scenario& scenario, int config)\n+{\n+    auto peer = scenario.NewPeer();\n+    auto gtxid = scenario.NewGTxid();\n+    bool immediate = config & 1;\n+    bool preferred = config & 2;\n+    auto delay = immediate ? NO_TIME : RandomTime8s();\n+\n+    scenario.SetTestName(strprintf(\"Single(config=%i)\", config));\n+\n+    // Receive an announcement, either immediately requestable or delayed.\n+    scenario.ReceivedInv(peer, gtxid, preferred, immediate ? MIN_TIME : scenario.Now() + delay);\n+    if (immediate) {\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s1\");\n+    } else {\n+        scenario.Check(peer, {}, 1, 0, 0, \"s2\");\n+        scenario.AdvanceTime(delay - MICROSECOND);\n+        scenario.Check(peer, {}, 1, 0, 0, \"s3\");\n+        scenario.AdvanceTime(MICROSECOND);\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s4\");\n+    }\n+\n+    if (config >> 3) { // We'll request the transaction\n+        scenario.AdvanceTime(RandomTime8s());\n+        auto expiry = RandomTime8s();\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s5\");\n+        scenario.RequestedTx(peer, gtxid.GetHash(), scenario.Now() + expiry);\n+        scenario.Check(peer, {}, 0, 1, 0, \"s6\");\n+\n+        if ((config >> 3) == 1) { // The request will time out\n+            scenario.AdvanceTime(expiry - MICROSECOND);\n+            scenario.Check(peer, {}, 0, 1, 0, \"s7\");\n+            scenario.AdvanceTime(MICROSECOND);\n+            scenario.Check(peer, {}, 0, 0, 0, \"s8\");\n+            return;\n+        } else {\n+            scenario.AdvanceTime(std::chrono::microseconds{InsecureRandRange(expiry.count())});",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r500263942",
      "id" : 500263942,
      "line" : 257,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI2Mzk0Mg==",
      "original_commit_id" : "a9a0504f12cb3c301bc56cc5f8f59ca57c1dc433",
      "original_line" : 257,
      "original_position" : 257,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : 257,
      "pull_request_review_id" : 500895273,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T14:11:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500263942",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r500285591"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500285591"
         }
      },
      "author_association" : "MEMBER",
      "body" : "same commit:\r\n\r\n```suggestion\r\n    // Two peers. They will announce in order.\r\n```\r\n\r\nAm I missing something here? There are only two (and a reference to either of them)",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-06T13:39:32Z",
      "diff_hunk" : "@@ -0,0 +1,587 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds MIN_TIME = std::chrono::microseconds::min();\n+constexpr std::chrono::microseconds MAX_TIME = std::chrono::microseconds::max();\n+constexpr std::chrono::microseconds MICROSECOND = std::chrono::microseconds{1};\n+constexpr std::chrono::microseconds NO_TIME = std::chrono::microseconds{0};\n+\n+/** An Action is a function to call at a particular (simulated) timestamp. */\n+using Action = std::pair<std::chrono::microseconds, std::function<void()>>;\n+\n+/** Object that stores actions from multiple interleaved scenarios, and data shared across them.\n+ *\n+ * The Scenario below is used to fill this.\n+ */\n+struct Runner\n+{\n+    /** The TxRequestTracker being tested. */\n+    TxRequestTracker txrequest;\n+\n+    /** List of actions to be executed (in order of increasing timestamp). */\n+    std::vector<Action> actions;\n+\n+    /** Which node ids have been assigned already (to prevent reuse). */\n+    std::set<NodeId> peerset;\n+\n+    /** Which txhashes have been assigned already (to prevent reuse). */\n+    std::set<uint256> txhashset;\n+};\n+\n+std::chrono::microseconds RandomTime8s() { return std::chrono::microseconds{1 + InsecureRandBits(23)}; }\n+std::chrono::microseconds RandomTime1y() { return std::chrono::microseconds{1 + InsecureRandBits(45)}; }\n+\n+/** A proxy for a Runner that helps build a sequence of consecutive test actions on a TxRequestTracker.\n+ *\n+ * Each Scenario is a proxy through which actions for the (sequential) execution of various tests are added to a\n+ * Runner. The actions from multiple scenarios are then run concurrently, resulting in these tests being performed\n+ * against a TxRequestTracker in parallel. Every test has its own unique txhashes and NodeIds which are not\n+ * reused in other tests, and thus they should be independent from each other. Running them in parallel however\n+ * means that we verify the behavior (w.r.t. one test's txhashes and NodeIds) even when the state of the data\n+ * structure is more complicated due to the presence of other tests.\n+ */\n+class Scenario\n+{\n+    Runner& m_runner;\n+    std::chrono::microseconds m_now;\n+    std::string m_testname;\n+\n+public:\n+    Scenario(Runner& runner, std::chrono::microseconds starttime) : m_runner(runner), m_now(starttime) {}\n+\n+    /** Set a name for the current test, to give more clear error messages. */\n+    void SetTestName(std::string testname)\n+    {\n+        m_testname = std::move(testname);\n+    }\n+\n+    /** Advance this Scenario's time; this affects the timestamps newly scheduled events get. */\n+    void AdvanceTime(std::chrono::microseconds amount)\n+    {\n+        assert(amount.count() >= 0);\n+        m_now += amount;\n+    }\n+\n+    /** Schedule a ForgetTxHash call at the Scheduler's current time. */\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ForgetTxHash(txhash);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    /** Schedule a ReceivedInv call at the Scheduler's current time. */\n+    void ReceivedInv(NodeId peer, const GenTxid& gtxid, bool pref, std::chrono::microseconds reqtime = MIN_TIME)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedInv(peer, gtxid, pref, reqtime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    /** Schedule a DisconnectedPeer call at the Scheduler's current time. */\n+    void DisconnectedPeer(NodeId peer)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.DisconnectedPeer(peer);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    /** Schedule a RequestedTx call at the Scheduler's current time. */\n+    void RequestedTx(NodeId peer, const uint256& txhash, std::chrono::microseconds exptime)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.RequestedTx(peer, txhash, exptime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    /** Schedule a ReceivedResponse call at the Scheduler's current time. */\n+    void ReceivedResponse(NodeId peer, const uint256& txhash)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedResponse(peer, txhash);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    /** Schedule calls to verify the TxRequestTracker's state at the Scheduler's current time.\n+     *\n+     * @param peer       The peer whose state will be inspected.\n+     * @param expected   The expected return value for GetRequestable(peer)\n+     * @param candidates The expected return value CountCandidates(peer)\n+     * @param inflight   The expected return value CountInFlight(peer)\n+     * @param completed  The expected return value of Count(peer), minus candidates and inflight.\n+     * @param checkname  An arbitrary string to include in error messages, for test identificatrion.\n+     */\n+    void Check(NodeId peer, const std::vector<GenTxid>& expected, size_t candidates, size_t inflight,\n+        size_t completed, const std::string& checkname = \"\")\n+    {\n+        const auto comment = m_testname + \" \" + checkname;\n+        auto& runner = m_runner;\n+        const auto now = m_now;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            auto ret = runner.txrequest.GetRequestable(peer, now);\n+            runner.txrequest.SanityCheck();\n+            runner.txrequest.PostGetRequestableSanityCheck(now);\n+            size_t total = candidates + inflight + completed;\n+            size_t real_total = runner.txrequest.Count(peer);\n+            size_t real_candidates = runner.txrequest.CountCandidates(peer);\n+            size_t real_inflight = runner.txrequest.CountInFlight(peer);\n+            BOOST_CHECK_MESSAGE(real_total == total, strprintf(\"[\" + comment + \"] total %i (%i expected)\", real_total, total));\n+            BOOST_CHECK_MESSAGE(real_inflight == inflight, strprintf(\"[\" + comment + \"] inflight %i (%i expected)\", real_inflight, inflight));\n+            BOOST_CHECK_MESSAGE(real_candidates == candidates, strprintf(\"[\" + comment + \"] candidates %i (%i expected)\", real_candidates, candidates));\n+            BOOST_CHECK_MESSAGE(ret == expected, \"[\" + comment + \"] mismatching requestables\");\n+        });\n+    }\n+\n+    /** Generate a random txhash, whose priorities for certain peers are constrained.\n+     *\n+     * For example, NewTxHash({{p1,p2,p3},{p2,p4,p5}}) will generate a txhash T such that both:\n+     *  - priority(p1,T) < priority(p2,T) < priority(p3,T)\n+     *  - priority(p2,T) < priority(p4,T) < priority(p5,T)\n+     * where priority is the predicted internal TxRequestTracker's priority, assuming all announcements\n+     * are within the same preferredness class.\n+     */\n+    uint256 NewTxHash(const std::vector<std::vector<NodeId>>& orders = {})\n+    {\n+        uint256 ret;\n+        bool ok;\n+        do {\n+            ret = InsecureRand256();\n+            ok = true;\n+            for (const auto& order : orders) {\n+                for (size_t pos = 1; pos < order.size(); ++pos) {\n+                    uint64_t prio_prev = m_runner.txrequest.ComputePriority(ret, order[pos - 1], true);\n+                    uint64_t prio_cur = m_runner.txrequest.ComputePriority(ret, order[pos], true);\n+                    if (prio_prev >= prio_cur) {\n+                        ok = false;\n+                        break;\n+                    }\n+                }\n+                if (!ok) break;\n+            }\n+            if (ok) {\n+                ok = m_runner.txhashset.insert(ret).second;\n+            }\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    /** Generate a random GenTxid; the txhash follows NewTxHash; the is_wtxid flag is random. */\n+    GenTxid NewGTxid(const std::vector<std::vector<NodeId>>& orders = {})\n+    {\n+        return {InsecureRandBool(), NewTxHash(orders)};\n+    }\n+\n+    /** Generate a new random NodeId to use as peer. The same NodeId is never returned twice\n+     *  (across all Scenarios combined). */\n+    NodeId NewPeer()\n+    {\n+        bool ok;\n+        NodeId ret;\n+        do {\n+            ret = InsecureRandBits(63);\n+            ok = m_runner.peerset.insert(ret).second;\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    std::chrono::microseconds Now() const { return m_now; }\n+};\n+\n+/** Add to scenario a test with a single tx announced by a single peer.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildSingleTest(Scenario& scenario, int config)\n+{\n+    auto peer = scenario.NewPeer();\n+    auto gtxid = scenario.NewGTxid();\n+    bool immediate = config & 1;\n+    bool preferred = config & 2;\n+    auto delay = immediate ? NO_TIME : RandomTime8s();\n+\n+    scenario.SetTestName(strprintf(\"Single(config=%i)\", config));\n+\n+    // Receive an announcement, either immediately requestable or delayed.\n+    scenario.ReceivedInv(peer, gtxid, preferred, immediate ? MIN_TIME : scenario.Now() + delay);\n+    if (immediate) {\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s1\");\n+    } else {\n+        scenario.Check(peer, {}, 1, 0, 0, \"s2\");\n+        scenario.AdvanceTime(delay - MICROSECOND);\n+        scenario.Check(peer, {}, 1, 0, 0, \"s3\");\n+        scenario.AdvanceTime(MICROSECOND);\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s4\");\n+    }\n+\n+    if (config >> 3) { // We'll request the transaction\n+        scenario.AdvanceTime(RandomTime8s());\n+        auto expiry = RandomTime8s();\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s5\");\n+        scenario.RequestedTx(peer, gtxid.GetHash(), scenario.Now() + expiry);\n+        scenario.Check(peer, {}, 0, 1, 0, \"s6\");\n+\n+        if ((config >> 3) == 1) { // The request will time out\n+            scenario.AdvanceTime(expiry - MICROSECOND);\n+            scenario.Check(peer, {}, 0, 1, 0, \"s7\");\n+            scenario.AdvanceTime(MICROSECOND);\n+            scenario.Check(peer, {}, 0, 0, 0, \"s8\");\n+            return;\n+        } else {\n+            scenario.AdvanceTime(std::chrono::microseconds{InsecureRandRange(expiry.count())});\n+            scenario.Check(peer, {}, 0, 1, 0, \"s9\");\n+            if ((config >> 3) == 3) { // A reponse will arrive for the transaction\n+                scenario.ReceivedResponse(peer, gtxid.GetHash());\n+                scenario.Check(peer, {}, 0, 0, 0, \"s10\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime8s());\n+    if (config & 4) { // The peer will go offline\n+        scenario.DisconnectedPeer(peer);\n+    } else { // The transaction is no longer needed\n+        scenario.ForgetTxHash(gtxid.GetHash());\n+    }\n+    scenario.Check(peer, {}, 0, 0, 0, \"s11\");\n+}\n+\n+/** Add to scenario a test with a single tx announced by two peers, to verify the\n+ *  right peer is selected for requests.\n+ *\n+ * config is an integer between 0 and 63, which controls which variant of the test is used.\n+ */\n+void BuildPriorityTest(Scenario& scenario, int config)\n+{\n+    scenario.SetTestName(strprintf(\"Priority(config=%i)\", config));\n+\n+    // Three peers. They will announce in order.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r500285591",
      "id" : 500285591,
      "line" : 285,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI4NTU5MQ==",
      "original_commit_id" : "a9a0504f12cb3c301bc56cc5f8f59ca57c1dc433",
      "original_line" : 285,
      "original_position" : 285,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : 285,
      "pull_request_review_id" : 500895273,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T14:11:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500285591",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r500286203"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500286203"
         }
      },
      "author_association" : "MEMBER",
      "body" : "same commit:\r\n\r\n```suggestion\r\n    NodeId priopeer = stage2_prio ? peer2 : peer1, otherpeer = stage2_prio ? peer1 : peer2;\r\n```",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-06T13:40:11Z",
      "diff_hunk" : "@@ -0,0 +1,587 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <txrequest.h>\n+#include <uint256.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <algorithm>\n+#include <functional>\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(txrequest_tests, BasicTestingSetup)\n+\n+namespace {\n+\n+constexpr std::chrono::microseconds MIN_TIME = std::chrono::microseconds::min();\n+constexpr std::chrono::microseconds MAX_TIME = std::chrono::microseconds::max();\n+constexpr std::chrono::microseconds MICROSECOND = std::chrono::microseconds{1};\n+constexpr std::chrono::microseconds NO_TIME = std::chrono::microseconds{0};\n+\n+/** An Action is a function to call at a particular (simulated) timestamp. */\n+using Action = std::pair<std::chrono::microseconds, std::function<void()>>;\n+\n+/** Object that stores actions from multiple interleaved scenarios, and data shared across them.\n+ *\n+ * The Scenario below is used to fill this.\n+ */\n+struct Runner\n+{\n+    /** The TxRequestTracker being tested. */\n+    TxRequestTracker txrequest;\n+\n+    /** List of actions to be executed (in order of increasing timestamp). */\n+    std::vector<Action> actions;\n+\n+    /** Which node ids have been assigned already (to prevent reuse). */\n+    std::set<NodeId> peerset;\n+\n+    /** Which txhashes have been assigned already (to prevent reuse). */\n+    std::set<uint256> txhashset;\n+};\n+\n+std::chrono::microseconds RandomTime8s() { return std::chrono::microseconds{1 + InsecureRandBits(23)}; }\n+std::chrono::microseconds RandomTime1y() { return std::chrono::microseconds{1 + InsecureRandBits(45)}; }\n+\n+/** A proxy for a Runner that helps build a sequence of consecutive test actions on a TxRequestTracker.\n+ *\n+ * Each Scenario is a proxy through which actions for the (sequential) execution of various tests are added to a\n+ * Runner. The actions from multiple scenarios are then run concurrently, resulting in these tests being performed\n+ * against a TxRequestTracker in parallel. Every test has its own unique txhashes and NodeIds which are not\n+ * reused in other tests, and thus they should be independent from each other. Running them in parallel however\n+ * means that we verify the behavior (w.r.t. one test's txhashes and NodeIds) even when the state of the data\n+ * structure is more complicated due to the presence of other tests.\n+ */\n+class Scenario\n+{\n+    Runner& m_runner;\n+    std::chrono::microseconds m_now;\n+    std::string m_testname;\n+\n+public:\n+    Scenario(Runner& runner, std::chrono::microseconds starttime) : m_runner(runner), m_now(starttime) {}\n+\n+    /** Set a name for the current test, to give more clear error messages. */\n+    void SetTestName(std::string testname)\n+    {\n+        m_testname = std::move(testname);\n+    }\n+\n+    /** Advance this Scenario's time; this affects the timestamps newly scheduled events get. */\n+    void AdvanceTime(std::chrono::microseconds amount)\n+    {\n+        assert(amount.count() >= 0);\n+        m_now += amount;\n+    }\n+\n+    /** Schedule a ForgetTxHash call at the Scheduler's current time. */\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ForgetTxHash(txhash);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    /** Schedule a ReceivedInv call at the Scheduler's current time. */\n+    void ReceivedInv(NodeId peer, const GenTxid& gtxid, bool pref, std::chrono::microseconds reqtime = MIN_TIME)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedInv(peer, gtxid, pref, reqtime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    /** Schedule a DisconnectedPeer call at the Scheduler's current time. */\n+    void DisconnectedPeer(NodeId peer)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.DisconnectedPeer(peer);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    /** Schedule a RequestedTx call at the Scheduler's current time. */\n+    void RequestedTx(NodeId peer, const uint256& txhash, std::chrono::microseconds exptime)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.RequestedTx(peer, txhash, exptime);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    /** Schedule a ReceivedResponse call at the Scheduler's current time. */\n+    void ReceivedResponse(NodeId peer, const uint256& txhash)\n+    {\n+        auto& runner = m_runner;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            runner.txrequest.ReceivedResponse(peer, txhash);\n+            runner.txrequest.SanityCheck();\n+        });\n+    }\n+\n+    /** Schedule calls to verify the TxRequestTracker's state at the Scheduler's current time.\n+     *\n+     * @param peer       The peer whose state will be inspected.\n+     * @param expected   The expected return value for GetRequestable(peer)\n+     * @param candidates The expected return value CountCandidates(peer)\n+     * @param inflight   The expected return value CountInFlight(peer)\n+     * @param completed  The expected return value of Count(peer), minus candidates and inflight.\n+     * @param checkname  An arbitrary string to include in error messages, for test identificatrion.\n+     */\n+    void Check(NodeId peer, const std::vector<GenTxid>& expected, size_t candidates, size_t inflight,\n+        size_t completed, const std::string& checkname = \"\")\n+    {\n+        const auto comment = m_testname + \" \" + checkname;\n+        auto& runner = m_runner;\n+        const auto now = m_now;\n+        runner.actions.emplace_back(m_now, [=,&runner]() {\n+            auto ret = runner.txrequest.GetRequestable(peer, now);\n+            runner.txrequest.SanityCheck();\n+            runner.txrequest.PostGetRequestableSanityCheck(now);\n+            size_t total = candidates + inflight + completed;\n+            size_t real_total = runner.txrequest.Count(peer);\n+            size_t real_candidates = runner.txrequest.CountCandidates(peer);\n+            size_t real_inflight = runner.txrequest.CountInFlight(peer);\n+            BOOST_CHECK_MESSAGE(real_total == total, strprintf(\"[\" + comment + \"] total %i (%i expected)\", real_total, total));\n+            BOOST_CHECK_MESSAGE(real_inflight == inflight, strprintf(\"[\" + comment + \"] inflight %i (%i expected)\", real_inflight, inflight));\n+            BOOST_CHECK_MESSAGE(real_candidates == candidates, strprintf(\"[\" + comment + \"] candidates %i (%i expected)\", real_candidates, candidates));\n+            BOOST_CHECK_MESSAGE(ret == expected, \"[\" + comment + \"] mismatching requestables\");\n+        });\n+    }\n+\n+    /** Generate a random txhash, whose priorities for certain peers are constrained.\n+     *\n+     * For example, NewTxHash({{p1,p2,p3},{p2,p4,p5}}) will generate a txhash T such that both:\n+     *  - priority(p1,T) < priority(p2,T) < priority(p3,T)\n+     *  - priority(p2,T) < priority(p4,T) < priority(p5,T)\n+     * where priority is the predicted internal TxRequestTracker's priority, assuming all announcements\n+     * are within the same preferredness class.\n+     */\n+    uint256 NewTxHash(const std::vector<std::vector<NodeId>>& orders = {})\n+    {\n+        uint256 ret;\n+        bool ok;\n+        do {\n+            ret = InsecureRand256();\n+            ok = true;\n+            for (const auto& order : orders) {\n+                for (size_t pos = 1; pos < order.size(); ++pos) {\n+                    uint64_t prio_prev = m_runner.txrequest.ComputePriority(ret, order[pos - 1], true);\n+                    uint64_t prio_cur = m_runner.txrequest.ComputePriority(ret, order[pos], true);\n+                    if (prio_prev >= prio_cur) {\n+                        ok = false;\n+                        break;\n+                    }\n+                }\n+                if (!ok) break;\n+            }\n+            if (ok) {\n+                ok = m_runner.txhashset.insert(ret).second;\n+            }\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    /** Generate a random GenTxid; the txhash follows NewTxHash; the is_wtxid flag is random. */\n+    GenTxid NewGTxid(const std::vector<std::vector<NodeId>>& orders = {})\n+    {\n+        return {InsecureRandBool(), NewTxHash(orders)};\n+    }\n+\n+    /** Generate a new random NodeId to use as peer. The same NodeId is never returned twice\n+     *  (across all Scenarios combined). */\n+    NodeId NewPeer()\n+    {\n+        bool ok;\n+        NodeId ret;\n+        do {\n+            ret = InsecureRandBits(63);\n+            ok = m_runner.peerset.insert(ret).second;\n+        } while(!ok);\n+        return ret;\n+    }\n+\n+    std::chrono::microseconds Now() const { return m_now; }\n+};\n+\n+/** Add to scenario a test with a single tx announced by a single peer.\n+ *\n+ * config is an integer between 0 and 31, which controls which variant of the test is used.\n+ */\n+void BuildSingleTest(Scenario& scenario, int config)\n+{\n+    auto peer = scenario.NewPeer();\n+    auto gtxid = scenario.NewGTxid();\n+    bool immediate = config & 1;\n+    bool preferred = config & 2;\n+    auto delay = immediate ? NO_TIME : RandomTime8s();\n+\n+    scenario.SetTestName(strprintf(\"Single(config=%i)\", config));\n+\n+    // Receive an announcement, either immediately requestable or delayed.\n+    scenario.ReceivedInv(peer, gtxid, preferred, immediate ? MIN_TIME : scenario.Now() + delay);\n+    if (immediate) {\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s1\");\n+    } else {\n+        scenario.Check(peer, {}, 1, 0, 0, \"s2\");\n+        scenario.AdvanceTime(delay - MICROSECOND);\n+        scenario.Check(peer, {}, 1, 0, 0, \"s3\");\n+        scenario.AdvanceTime(MICROSECOND);\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s4\");\n+    }\n+\n+    if (config >> 3) { // We'll request the transaction\n+        scenario.AdvanceTime(RandomTime8s());\n+        auto expiry = RandomTime8s();\n+        scenario.Check(peer, {gtxid}, 1, 0, 0, \"s5\");\n+        scenario.RequestedTx(peer, gtxid.GetHash(), scenario.Now() + expiry);\n+        scenario.Check(peer, {}, 0, 1, 0, \"s6\");\n+\n+        if ((config >> 3) == 1) { // The request will time out\n+            scenario.AdvanceTime(expiry - MICROSECOND);\n+            scenario.Check(peer, {}, 0, 1, 0, \"s7\");\n+            scenario.AdvanceTime(MICROSECOND);\n+            scenario.Check(peer, {}, 0, 0, 0, \"s8\");\n+            return;\n+        } else {\n+            scenario.AdvanceTime(std::chrono::microseconds{InsecureRandRange(expiry.count())});\n+            scenario.Check(peer, {}, 0, 1, 0, \"s9\");\n+            if ((config >> 3) == 3) { // A reponse will arrive for the transaction\n+                scenario.ReceivedResponse(peer, gtxid.GetHash());\n+                scenario.Check(peer, {}, 0, 0, 0, \"s10\");\n+                return;\n+            }\n+        }\n+    }\n+\n+    if (InsecureRandBool()) scenario.AdvanceTime(RandomTime8s());\n+    if (config & 4) { // The peer will go offline\n+        scenario.DisconnectedPeer(peer);\n+    } else { // The transaction is no longer needed\n+        scenario.ForgetTxHash(gtxid.GetHash());\n+    }\n+    scenario.Check(peer, {}, 0, 0, 0, \"s11\");\n+}\n+\n+/** Add to scenario a test with a single tx announced by two peers, to verify the\n+ *  right peer is selected for requests.\n+ *\n+ * config is an integer between 0 and 63, which controls which variant of the test is used.\n+ */\n+void BuildPriorityTest(Scenario& scenario, int config)\n+{\n+    scenario.SetTestName(strprintf(\"Priority(config=%i)\", config));\n+\n+    // Three peers. They will announce in order.\n+    auto peer1 = scenario.NewPeer(), peer2 = scenario.NewPeer();\n+    // Construct a transaction that under random rules would be preferred by peer2 or peer1,\n+    // depending on configuration.\n+    bool prio1 = config & 1;\n+    auto gtxid = prio1 ? scenario.NewGTxid({{peer1, peer2}}) : scenario.NewGTxid({{peer2, peer1}});\n+    bool pref1 = config & 2, pref2 = config & 4;\n+\n+    scenario.ReceivedInv(peer1, gtxid, pref1, MIN_TIME);\n+    scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p1\");\n+    if (InsecureRandBool()) {\n+        scenario.AdvanceTime(RandomTime8s());\n+        scenario.Check(peer1, {gtxid}, 1, 0, 0, \"p2\");\n+    }\n+\n+    scenario.ReceivedInv(peer2, gtxid, pref2, MIN_TIME);\n+    bool stage2_prio =\n+        // At this point, peer2 will be given priority if:\n+        // - It is preferred and peer1 is not\n+        (pref2 && !pref1) ||\n+        // - They're in the same preference class,\n+        //   and the randomized priority favors peer2 over peer1.\n+        (pref1 == pref2 && !prio1);\n+    uint64_t priopeer = stage2_prio ? peer2 : peer1, otherpeer = stage2_prio ? peer1 : peer2;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r500286203",
      "id" : 500286203,
      "line" : 308,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI4NjIwMw==",
      "original_commit_id" : "a9a0504f12cb3c301bc56cc5f8f59ca57c1dc433",
      "original_line" : 308,
      "original_position" : 308,
      "original_start_line" : null,
      "path" : "src/test/txrequest_tests.cpp",
      "position" : 308,
      "pull_request_review_id" : 500895273,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T14:11:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500286203",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r500336120"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500336120"
         }
      },
      "author_association" : "MEMBER",
      "body" : "'fail' here means 'there exists another announcement for this txhash which isn't COMPLETED'",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-06T14:31:29Z",
      "diff_hunk" : "@@ -0,0 +1,597 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of ByTxHashView relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcements that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE announcement whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED announcement already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority announcement among all CANDIDATE_READY (and _BEST) ones for that\n+     *  txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED announcement. */\n+    REQUESTED,\n+    /** A CANDIDATE announcement that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED announcement. */\n+    COMPLETED,\n+};\n+\n+//! Type alias for sequence numbers.\n+using SequenceNumber = uint64_t;\n+\n+/** An announcement. This is the data we track for each txid or wtxid that is announced to us by each peer. */\n+struct Announcement {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const NodeId m_peer;\n+    /** What sequence number this announcement has. */\n+    const SequenceNumber m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this announcement is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this announcement is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this announcement can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new announcement from scratch, initially in CANDIDATE_DELAYED state. */\n+    Announcement(const GenTxid& gtxid, NodeId peer, bool preferred, std::chrono::microseconds reqtime,\n+        SequenceNumber sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+//! Type alias for priorities.\n+using Priority = uint64_t;\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    Priority operator()(const uint256& txhash, NodeId peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    Priority operator()(const Announcement& ann) const\n+    {\n+        return operator()(ann.m_txhash, ann.m_peer, ann.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a By*View data type to represent the view of announcement it is sorted\n+// by, and an By*ViewExtractor type to convert an announcement into the By*View type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing announcements by peer/txhash, by checking both (peer, false, txhash) and\n+//   (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST announcements for a given peer in GetRequestable.\n+struct ByPeer {};\n+using ByPeerView = std::tuple<NodeId, bool, const uint256&>;\n+struct ByPeerViewExtractor\n+{\n+    using result_type = ByPeerView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByPeerView{ann.m_peer, ann.GetState() == State::CANDIDATE_BEST, ann.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority).\n+//\n+// Note: priority == 0 whenever state != CANDIDATE_READY.\n+//\n+// Uses:\n+// * Deleting all announcements with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   announcement exists for that txhash.\n+// * Determining when no more non-COMPLETED announcements for a given txhash exist, so the COMPLETED ones can be\n+//   deleted.\n+struct ByTxHash {};\n+using ByTxHashView = std::tuple<const uint256&, State, Priority>;\n+class ByTxHashViewExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    ByTxHashViewExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = ByTxHashView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        const State state = ann.GetState();\n+        const Priority prio = (state == State::CANDIDATE_READY) ? m_computer(ann) : 0;\n+        return ByTxHashView{ann.m_txhash, state, prio};\n+    }\n+};\n+\n+enum class WaitState {\n+    //! Used for announcements that need efficient testing of \"is their timestamp in the future?\".\n+    FUTURE_EVENT,\n+    //! Used for announcements whose timestamp is not relevant.\n+    NO_EVENT,\n+    //! Used for announcements that need efficient testing of \"is their timestamp in the past?\".\n+    PAST_EVENT,\n+};\n+\n+WaitState GetWaitState(const Announcement& ann)\n+{\n+    if (ann.IsWaiting()) return WaitState::FUTURE_EVENT;\n+    if (ann.IsSelectable()) return WaitState::PAST_EVENT;\n+    return WaitState::NO_EVENT;\n+}\n+\n+// The ByTime index is sorted by (wait_state, time).\n+//\n+// All announcements with a timestamp in the future can be found by iterating the index forward from the beginning.\n+// All announcements with a timestamp in the past can be found by iterating the index backwards from the end.\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED announcements whose reqtime has passed, and REQUESTED announcements whose expiry has\n+//   passed.\n+// * Finding CANDIDATE_READY/BEST announcements whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using ByTimeView = std::pair<WaitState, std::chrono::microseconds>;\n+struct ByTimeViewExtractor\n+{\n+    using result_type = ByTimeView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByTimeView{GetWaitState(ann), ann.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Announcement objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Announcement,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, ByPeerViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, ByTxHashViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, ByTimeViewExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of announcements for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED announcements for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED announcements for this peer.\n+};\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    SequenceNumber m_current_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<NodeId, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED announcement into a CANDIDATE_READY. If this makes it the new best\n+    //! CANDIDATE_READY (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new\n+    //! CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY announcements, the best one (lowest\n+        // priority) comes first. Thus, if an existing _BEST exists for the same txhash that this announcement may\n+        // be preferred over, it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() announcement for this txhash\n+            // already.\n+            Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            Priority priority_old = m_computer(*std::prev(it));\n+            Priority priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST announcement already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an announcement to something non-IsSelected(). If it was IsSelected(), the next best\n+    //! announcement will be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        assert(new_state == State::COMPLETED || new_state == State::CANDIDATE_DELAYED);\n+        assert(it != m_index.get<ByTxHash>().end());\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST\n+            // announcement in the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Announcement& ann){ ann.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only announcement for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED announcements.\n+\n+        // If this announcement's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this announcement's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r500336120",
      "id" : 500336120,
      "in_reply_to_id" : 500180971,
      "line" : 453,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMzNjEyMA==",
      "original_commit_id" : "ee4f89a44b41a860f2bda98957db2d6871a8e8ea",
      "original_line" : 339,
      "original_position" : 339,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 453,
      "pull_request_review_id" : 502861484,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T14:51:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500336120",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r500355096"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500355096"
         }
      },
      "author_association" : "MEMBER",
      "body" : "We can avoid using an awkward pair here by constructing a vector of pointers and then use a custom comparator function to sort:\r\n\r\n```diff\r\n--- a/src/txrequest.cpp\r\n+++ b/src/txrequest.cpp\r\n@@ -101,6 +101,9 @@ struct Announcement {\r\n         m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\r\n };\r\n \r\n+bool seq_comparator(const Announcement* ann1, const Announcement* ann2) { return ann1->m_sequence < ann2->m_sequence; }\r\n+GenTxid gtxid_extractor(const Announcement* ann) { return GenTxid{ann->m_is_wtxid, ann->m_txhash}; }\r\n+\r\n //! Type alias for priorities.\r\n using Priority = uint64_t;\r\n \r\n@@ -581,21 +584,19 @@ public:\r\n         SetTimePoint(now);\r\n \r\n         // Find all CANDIDATE_BEST announcements for this peer.\r\n-        std::vector<std::pair<SequenceNumber, const Announcement*>> selected;\r\n+        std::vector<const Announcement*> selected;\r\n         auto it_peer = m_index.get<ByPeer>().lower_bound(ByPeerView{peer, true, UINT256_ZERO});\r\n         while (it_peer != m_index.get<ByPeer>().end() && it_peer->m_peer == peer &&\r\n             it_peer->GetState() == State::CANDIDATE_BEST) {\r\n-            selected.emplace_back(it_peer->m_sequence, &*it_peer);\r\n+            selected.emplace_back(&*it_peer);\r\n             ++it_peer;\r\n         }\r\n \r\n         // Return them, sorted by sequence number.\r\n-        std::sort(selected.begin(), selected.end());\r\n+        std::sort(selected.begin(), selected.end(), seq_comparator);\r\n         std::vector<GenTxid> ret;\r\n         ret.reserve(selected.size());\r\n-        for (const auto& item : selected) {\r\n-            ret.emplace_back(item.second->m_is_wtxid, item.second->m_txhash);\r\n-        }\r\n+        std::transform(selected.begin(), selected.end(), std::back_inserter(ret), gtxid_extractor);\r\n         return ret;\r\n     }\r\n\r\n```\r\n\r\nI'm not sure if that's more or less clear code, but thought I'd throw it out there as a suggestion.",
      "commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "created_at" : "2020-10-06T14:51:03Z",
      "diff_hunk" : "@@ -0,0 +1,729 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+namespace {\n+\n+/** The various states a (txhash,peer) pair can be in.\n+ *\n+ * Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient implementation.\n+ * Also note that the sorting order of ByTxHashView relies on the specific order of values in this enum.\n+ *\n+ * Expected behaviour is:\n+ *   - When first announced by a peer, the state is CANDIDATE_DELAYED until reqtime is reached.\n+ *   - Announcements that have reached their reqtime but not been requested will be either CANDIDATE_READY or\n+ *     CANDIDATE_BEST\n+ *   - When requested, an announcement will be in state REQUESTED until expiry is reached.\n+ *   - If expiry is reached, or the peer replies to the request (either with NOTFOUND or the tx), the state becomes\n+ *     COMPLETED\n+ */\n+enum class State : uint8_t {\n+    /** A CANDIDATE announcement whose reqtime is in the future. */\n+    CANDIDATE_DELAYED,\n+    /** The best CANDIDATE for a given txhash; only if there is no REQUESTED announcement already for that txhash.\n+     *  The CANDIDATE_BEST is the lowest-priority announcement among all CANDIDATE_READY (and _BEST) ones for that\n+     *  txhash. */\n+    CANDIDATE_BEST,\n+    /** A REQUESTED announcement. */\n+    REQUESTED,\n+    /** A CANDIDATE announcement that's not CANDIDATE_DELAYED or CANDIDATE_BEST. */\n+    CANDIDATE_READY,\n+    /** A COMPLETED announcement. */\n+    COMPLETED,\n+};\n+\n+//! Type alias for sequence numbers.\n+using SequenceNumber = uint64_t;\n+\n+/** An announcement. This is the data we track for each txid or wtxid that is announced to us by each peer. */\n+struct Announcement {\n+    /** Txid or wtxid that was announced. */\n+    const uint256 m_txhash;\n+    /** For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry. */\n+    std::chrono::microseconds m_time;\n+    /** What peer the request was from. */\n+    const NodeId m_peer;\n+    /** What sequence number this announcement has. */\n+    const SequenceNumber m_sequence : 59;\n+    /** Whether the request is preferred. */\n+    const bool m_preferred : 1;\n+    /** Whether this is a wtxid request. */\n+    const bool m_is_wtxid : 1;\n+\n+    /** What state this announcement is in. This is a uint8_t instead of a State to silence a GCC warning. */\n+    uint8_t m_state : 3;\n+\n+    /** Convert the m_state variable to a State enum. */\n+    State GetState() const { return State(m_state); }\n+    /** Convert a State to a uint8_t and store it in m_state. */\n+    void SetState(State state) { m_state = uint8_t(state); }\n+\n+    /** Whether this announcement is selected. There can be at most 1 selected peer per txhash. */\n+    bool IsSelected() const\n+    {\n+        return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+    }\n+\n+    /** Whether this announcement is waiting for a certain time to pass. */\n+    bool IsWaiting() const\n+    {\n+        return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+    }\n+\n+    /** Whether this announcement can feasibly be selected if the current IsSelected() one disappears. */\n+    bool IsSelectable() const\n+    {\n+        return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+    }\n+\n+    /** Construct a new announcement from scratch, initially in CANDIDATE_DELAYED state. */\n+    Announcement(const GenTxid& gtxid, NodeId peer, bool preferred, std::chrono::microseconds reqtime,\n+        SequenceNumber sequence) :\n+        m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+        m_is_wtxid(gtxid.IsWtxid()), m_state(uint8_t(State::CANDIDATE_DELAYED)) {}\n+};\n+\n+//! Type alias for priorities.\n+using Priority = uint64_t;\n+\n+/** A functor with embedded salt that computes priority of an announcement.\n+ *\n+ * Lower priorities are selected first.\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic) :\n+        m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+        m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+    Priority operator()(const uint256& txhash, NodeId peer, bool preferred) const\n+    {\n+        uint64_t low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+        return low_bits | uint64_t{!preferred} << 63;\n+    }\n+\n+    Priority operator()(const Announcement& ann) const\n+    {\n+        return operator()(ann.m_txhash, ann.m_peer, ann.m_preferred);\n+    }\n+};\n+\n+// Definitions for the 3 indexes used in the main data structure.\n+//\n+// Each index has a By* type to identify it, a By*View data type to represent the view of announcement it is sorted\n+// by, and an By*ViewExtractor type to convert an announcement into the By*View type.\n+// See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+// for more information about the key extraction concept.\n+\n+// The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txhash)\n+//\n+// Uses:\n+// * Looking up existing announcements by peer/txhash, by checking both (peer, false, txhash) and\n+//   (peer, true, txhash).\n+// * Finding all CANDIDATE_BEST announcements for a given peer in GetRequestable.\n+struct ByPeer {};\n+using ByPeerView = std::tuple<NodeId, bool, const uint256&>;\n+struct ByPeerViewExtractor\n+{\n+    using result_type = ByPeerView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByPeerView{ann.m_peer, ann.GetState() == State::CANDIDATE_BEST, ann.m_txhash};\n+    }\n+};\n+\n+// The ByTxHash index is sorted by (txhash, state, priority).\n+//\n+// Note: priority == 0 whenever state != CANDIDATE_READY.\n+//\n+// Uses:\n+// * Deleting all announcements with a given txhash in ForgetTxHash.\n+// * Finding the best CANDIDATE_READY to convert to CANDIDATE_BEST, when no other CANDIDATE_READY or REQUESTED\n+//   announcement exists for that txhash.\n+// * Determining when no more non-COMPLETED announcements for a given txhash exist, so the COMPLETED ones can be\n+//   deleted.\n+struct ByTxHash {};\n+using ByTxHashView = std::tuple<const uint256&, State, Priority>;\n+class ByTxHashViewExtractor {\n+    const PriorityComputer& m_computer;\n+public:\n+    ByTxHashViewExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+    using result_type = ByTxHashView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        const State state = ann.GetState();\n+        const Priority prio = (state == State::CANDIDATE_READY) ? m_computer(ann) : 0;\n+        return ByTxHashView{ann.m_txhash, state, prio};\n+    }\n+};\n+\n+enum class WaitState {\n+    //! Used for announcements that need efficient testing of \"is their timestamp in the future?\".\n+    FUTURE_EVENT,\n+    //! Used for announcements whose timestamp is not relevant.\n+    NO_EVENT,\n+    //! Used for announcements that need efficient testing of \"is their timestamp in the past?\".\n+    PAST_EVENT,\n+};\n+\n+WaitState GetWaitState(const Announcement& ann)\n+{\n+    if (ann.IsWaiting()) return WaitState::FUTURE_EVENT;\n+    if (ann.IsSelectable()) return WaitState::PAST_EVENT;\n+    return WaitState::NO_EVENT;\n+}\n+\n+// The ByTime index is sorted by (wait_state, time).\n+//\n+// All announcements with a timestamp in the future can be found by iterating the index forward from the beginning.\n+// All announcements with a timestamp in the past can be found by iterating the index backwards from the end.\n+//\n+// Uses:\n+// * Finding CANDIDATE_DELAYED announcements whose reqtime has passed, and REQUESTED announcements whose expiry has\n+//   passed.\n+// * Finding CANDIDATE_READY/BEST announcements whose reqtime is in the future (when the clock time went backwards).\n+struct ByTime {};\n+using ByTimeView = std::pair<WaitState, std::chrono::microseconds>;\n+struct ByTimeViewExtractor\n+{\n+    using result_type = ByTimeView;\n+    result_type operator()(const Announcement& ann) const\n+    {\n+        return ByTimeView{GetWaitState(ann), ann.m_time};\n+    }\n+};\n+\n+/** Data type for the main data structure (Announcement objects with ByPeer/ByTxHash/ByTime indexes). */\n+using Index = boost::multi_index_container<\n+    Announcement,\n+    boost::multi_index::indexed_by<\n+        boost::multi_index::ordered_unique<boost::multi_index::tag<ByPeer>, ByPeerViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTxHash>, ByTxHashViewExtractor>,\n+        boost::multi_index::ordered_non_unique<boost::multi_index::tag<ByTime>, ByTimeViewExtractor>\n+    >\n+>;\n+\n+/** Helper type to simplify syntax of iterator types. */\n+template<typename Tag>\n+using Iter = typename Index::index<Tag>::type::iterator;\n+\n+/** Per-peer statistics object. */\n+struct PeerInfo {\n+    size_t m_total = 0; //!< Total number of announcements for this peer.\n+    size_t m_completed = 0; //!< Number of COMPLETED announcements for this peer.\n+    size_t m_requested = 0; //!< Number of REQUESTED announcements for this peer.\n+};\n+\n+/** Per-txhash statistics object. Only used for sanity checking. */\n+struct TxHashInfo\n+{\n+    //! Number of CANDIDATE_DELAYED announcements for this txhash.\n+    size_t m_candidate_delayed = 0;\n+    //! Number of CANDIDATE_READY announcements for this txhash.\n+    size_t m_candidate_ready = 0;\n+    //! Number of CANDIDATE_BEST announcements for this txhash (at most one).\n+    size_t m_candidate_best = 0;\n+    //! Number of REQUESTED announcements for this txhash.\n+    size_t m_requested = 0;\n+    //! The priority of the CANDIDATE_BEST announcement if one exists, or min() otherwise.\n+    Priority m_priority_candidate_best = std::numeric_limits<Priority>::min();\n+    //! The lowest priority of all CANDIDATE_READY announcements (or max() if none exist).\n+    Priority m_priority_best_candidate_ready = std::numeric_limits<Priority>::max();\n+    //! All peers we have an announcement for this txhash for.\n+    std::vector<NodeId> m_peers;\n+};\n+\n+/** Compare two PeerInfo objects. Only used for sanity checking. */\n+bool operator==(const PeerInfo& a, const PeerInfo& b)\n+{\n+    return std::tie(a.m_total, a.m_completed, a.m_requested) ==\n+           std::tie(b.m_total, b.m_completed, b.m_requested);\n+};\n+\n+/** (Re)compute the PeerInfo map from the index. Only used for sanity checking. */\n+std::unordered_map<NodeId, PeerInfo> RecomputePeerInfo(const Index& index)\n+{\n+    std::unordered_map<NodeId, PeerInfo> ret;\n+    for (const Announcement& ann : index) {\n+        PeerInfo& info = ret[ann.m_peer];\n+        ++info.m_total;\n+        info.m_requested += (ann.GetState() == State::REQUESTED);\n+        info.m_completed += (ann.GetState() == State::COMPLETED);\n+    }\n+    return ret;\n+}\n+\n+/** Compute the TxHashInfo map. Only used for sanity checking. */\n+std::map<uint256, TxHashInfo> ComputeTxHashInfo(const Index& index, const PriorityComputer& computer)\n+{\n+    std::map<uint256, TxHashInfo> ret;\n+    for (const Announcement& ann : index) {\n+        TxHashInfo& info = ret[ann.m_txhash];\n+        // Classify how many announcements of each state we have for this txhash.\n+        info.m_candidate_delayed += (ann.GetState() == State::CANDIDATE_DELAYED);\n+        info.m_candidate_ready += (ann.GetState() == State::CANDIDATE_READY);\n+        info.m_candidate_best += (ann.GetState() == State::CANDIDATE_BEST);\n+        info.m_requested += (ann.GetState() == State::REQUESTED);\n+        // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST announcements.\n+        if (ann.GetState() == State::CANDIDATE_BEST) {\n+            info.m_priority_candidate_best = computer(ann);\n+        }\n+        if (ann.GetState() == State::CANDIDATE_READY) {\n+            info.m_priority_best_candidate_ready = std::min(info.m_priority_best_candidate_ready, computer(ann));\n+        }\n+        // Also keep track of which peers this txhash has an announcement for (so we can detect duplicates).\n+        info.m_peers.push_back(ann.m_peer);\n+    }\n+    return ret;\n+}\n+\n+const uint256 UINT256_ZERO;\n+\n+}  // namespace\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The current sequence number. Increases for every announcement. This is used to sort txhashes returned by\n+    //! GetRequestable in announcement order.\n+    SequenceNumber m_current_sequence{0};\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! This tracker's main data structure. See SanityCheck() for the invariants that apply to it.\n+    Index m_index;\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<NodeId, PeerInfo> m_peerinfo;\n+\n+public:\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata from m_index. This verifies the data in it as it should just be caching statistics\n+        // on m_index. It also verifies the invariant that no PeerInfo announcements with m_total==0 exist.\n+        assert(m_peerinfo == RecomputePeerInfo(m_index));\n+\n+        // Calculate per-txhash statistics from m_index, and validate invariants.\n+        for (auto& item : ComputeTxHashInfo(m_index, m_computer)) {\n+            TxHashInfo& info = item.second;\n+\n+            // Cannot have only COMPLETED peer (txhash should have been forgotten already)\n+            assert(info.m_candidate_delayed + info.m_candidate_ready + info.m_candidate_best + info.m_requested > 0);\n+\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(info.m_candidate_best + info.m_requested <= 1);\n+\n+            // If there are any CANDIDATE_READY announcements, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // announcement.\n+            if (info.m_candidate_ready > 0) {\n+                assert(info.m_candidate_best + info.m_requested == 1);\n+            }\n+\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST announcement, the CANDIDATE_BEST one must be\n+            // at least as good (equal or lower priority) as the best CANDIDATE_READY.\n+            if (info.m_candidate_ready && info.m_candidate_best) {\n+                assert(info.m_priority_candidate_best <= info.m_priority_best_candidate_ready);\n+            }\n+\n+            // No txhash can have been announced by the same peer twice.\n+            std::sort(info.m_peers.begin(), info.m_peers.end());\n+            assert(std::adjacent_find(info.m_peers.begin(), info.m_peers.end()) == info.m_peers.end());\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const Announcement& ann : m_index) {\n+            if (ann.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(ann.m_time > now);\n+            } else if (ann.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(ann.m_time <= now);\n+            }\n+        }\n+    }\n+\n+private:\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    Iter<Tag> Erase(Iter<Tag> it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(Iter<Tag> it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_completed -= it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_completed += it->GetState() == State::COMPLETED;\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+    //! Convert a CANDIDATE_DELAYED announcement into a CANDIDATE_READY. If this makes it the new best\n+    //! CANDIDATE_READY (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new\n+    //! CANDIDATE_BEST.\n+    void PromoteCandidateReady(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txhash, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY announcements, the best one (lowest\n+        // priority) comes first. Thus, if an existing _BEST exists for the same txhash that this announcement may\n+        // be preferred over, it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() announcement for this txhash\n+            // already.\n+            Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            Priority priority_old = m_computer(*std::prev(it));\n+            Priority priority_new = m_computer(*it);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST announcement already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an announcement to something non-IsSelected(). If it was IsSelected(), the next best\n+    //! announcement will be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(Iter<ByTxHash> it, State new_state)\n+    {\n+        assert(new_state == State::COMPLETED || new_state == State::CANDIDATE_DELAYED);\n+        assert(it != m_index.get<ByTxHash>().end());\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST\n+            // announcement in the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Announcement& ann){ ann.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Announcement& ann){ ann.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only announcement for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED announcements.\n+\n+        // If this announcement's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this announcement's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    /** Convert any announcement to a COMPLETED one. If there are no non-COMPLETED announcements left for this\n+     *  txhash, they are deleted. If this was a REQUESTED announcement, and there are other CANDIDATEs left, the\n+     *  best one is made CANDIDATE_BEST. Returns whether the announcement still exists. */\n+    bool MakeCompleted(Iter<ByTxHash> it)\n+    {\n+        assert(it != m_index.get<ByTxHash>().end());\n+\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED announcement for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the announcement COMPLETED, and select the next best announcement (the first CANDIDATE_READY) if\n+        // needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED annoucements with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED announcements with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} announcements with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY announcements back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to ByTxHashViewExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(ByPeerViewExtractor(), std::less<ByPeerView>()),\n+            boost::make_tuple(ByTxHashViewExtractor(m_computer), std::less<ByTxHashView>()),\n+            boost::make_tuple(ByTimeViewExtractor(), std::less<ByTimeView>())\n+        )) {}\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful ByTxHashViewExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DisconnectedPeer(NodeId peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(ByPeerView{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the announcement isn't already COMPLETED, first make it COMPLETED (which will mark other\n+            // CANDIDATEs as CANDIDATE_BEST, or delete all of a txhash's announcements if no non-COMPLETED ones are\n+            // left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the announcement (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTxHash(const uint256& txhash)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(ByTxHashView{txhash, State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(NodeId peer, const GenTxid& gtxid, bool preferred,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST announcement for this (txhash, peer) combination. The case\n+        // where there is a non-CANDIDATE_BEST announcement already will be caught by the uniqueness property of the\n+        // ByPeer index when we try to emplace the new object below.\n+        if (m_index.get<ByPeer>().count(ByPeerView{peer, true, gtxid.GetHash()})) return;\n+\n+        // Try creating the announcement with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST announcement already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_current_sequence);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_current_sequence;\n+    }\n+\n+    //! Find the GenTxids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(NodeId peer, std::chrono::microseconds now)\n+    {\n+        // Move time.\n+        SetTimePoint(now);\n+\n+        // Find all CANDIDATE_BEST announcements for this peer.\n+        std::vector<std::pair<SequenceNumber, const Announcement*>> selected;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r500355096",
      "id" : 500355096,
      "line" : 584,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM1NTA5Ng==",
      "original_commit_id" : "ea1c69ac0fe1da837c034a8a21e3a288d3c6daae",
      "original_line" : 584,
      "original_position" : 584,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 584,
      "pull_request_review_id" : 502861484,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-06T14:51:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500355096",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   }
]
