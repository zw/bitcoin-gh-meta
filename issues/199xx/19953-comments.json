[
   {
      "author_association" : "MEMBER",
      "body" : "Here is a categorized list of all the commits:\r\n\r\n### Refactors (https://github.com/sipa/bitcoin/compare/f8c099e220...450d2b2371) [+50 -39]:\r\n * 107b57df9f **scripted-diff: put ECDSA in name of signature functions**: In preparation for adding Schnorr versions of `CheckSig`, `VerifySignature`, and `ComputeEntry`, give them an ECDSA specific name. \r\n * 8bd2b4e784 **refactor: rename scriptPubKey in VerifyWitnessProgram to exec_script**: The old name is confusing, as it doesn't store a scriptPubKey, but the actually executed script. \r\n * 5d62e3a68b **refactor: keep spent outputs in PrecomputedTransactionData**: A BIP-341 signature message may commit to the scriptPubKeys and amounts of all spent outputs (including other ones than the input being signed for spends), so keep them available to signature hashing code. \r\n\r\n### BIP340/341/342 consensus rules (https://github.com/sipa/bitcoin/compare/450d2b2371...865d2c37e2) [+693 -50]:\r\n * 9eb590894f **Add TaggedHash function (BIP 340)**: This adds the TaggedHash function as defined by BIP340 to the hash module, which is used in BIP340 and BIP341 to produce domain-separated hashes. \r\n * 5de246ca81 **Implement Taproot signature hashing (BIP 341)**: This implements the new sighashing scheme from BIP341, with all relevant whole-transaction values precomputed once and cached. \r\n * 0664f5fe1f **Support for Schnorr signatures and integration in SignatureCheckers (BIP 340)**: This enables the schnorrsig module in libsecp256k1, adds the relevant types and functions to src/pubkey, as well as in higher-level `SignatureChecker` classes. The (verification side of the) BIP340 test vectors is also added. \r\n * 8bbed4b7ac **Implement Taproot validation (BIP 341)**: This includes key path spending and script path spending, but not the Tapscript execution implementation (leaf 0xc0 remains unemcumbered in this commit). \r\n * 330de894a9 **Use ScriptExecutionData to pass through annex hash**: Instead of recomputing the annex hash every time a signature is verified, compute it once and cache it in a new ScriptExecutionData structure. \r\n * 72422ce396 **Implement Tapscript script validation rules (BIP 342)**: This adds a new `SigVersion::TAPSCRIPT`, makes the necessary interpreter changes to make it implement BIP342, and uses them for leaf version 0xc0 in Taproot script path spends. \r\n\r\n### Regtest activation and policy (https://github.com/sipa/bitcoin/compare/865d2c37e2...206fb180ec) [+98 -8]:\r\n * e9a021d7e6 **Make Taproot spends standard + policy limits**: This adds a `TxoutType::WITNESS_V1_TAPROOT` for P2TR outputs, and permits spending them in standardness rules. No corresponding `CTxDestination` is added for it, as that isn't needed until we want wallet integration. The taproot validation flags are also enabled for mempool transactions, and standardness rules are added (stack item size limit, no annexes). \r\n * d7ff237f29 **Activate Taproot/Tapscript on regtest (BIP 341, BIP 342)**: Define a versionbits-based activation for the new consensus rules on regtest. No activation or activation mechanism is defined for testnet or mainnet. \r\n\r\n### Tests (https://github.com/sipa/bitcoin/compare/206fb180ec...0e2a5e448f426219a6464b9aaadcc715534114e6) [+2148 -28]:\r\n * 3c226639eb **tests: add BIP340 Schnorr signature support to test framework**: Add a pure Python implementation of BIP340 signing and verification, tested against the BIP's test vectors. \r\n * f06e6d0345 **tests: functional tests for Schnorr/Taproot/Tapscript**: A large functional test is added that automatically generates random transactions which exercise various aspects of the new rules, and verifies they are accepted into the mempool (when appropriate), and correctly accepted/rejected in (Python-constructed) blocks. \r\n * 4567ba034c **tests: add generic qa-asset-based script verification unit test**: This adds a unit test that does generic script verification tests, with positive/negative witnesses/scriptsigs, under various flags. The test data is large (several MB) so it's stored in the qa-assets repo. \r\n * 0e2a5e448f **tests: dumping and minimizing of script assets data**: This adds a --dumptests flag to the feature_taproot.py test, to dump all its generated test cases to files, in a format compatible with the script_assets_test unit test. A fuzzer for said format is added as well, whose primary purpose is coverage-based minimization of those dumps. \r\n\r\n<sub>`PREV=\"$(git rev-parse HEAD)\"; git log --oneline upstream/master..HEAD | while read C L; do if [ \"d${L:0:14}\" == \"d--- [TAPROOT] \" ]; then if [ \"d$PREV\" != \"\" ]; then git diff --shortstat $C..$PREV | (read _ _ _ ADD _ DEL _; echo \"### ${L:14:-4} (https://github.com/sipa/bitcoin/compare/$C...$PREV) [+$ADD -$DEL]:\"); echo; fi; PREV=$C; PREVL=$L; else echo -n \" * $C **${L}**: \"; git show \"$C\" --format=\"%b\" -s | awk '/^$/{exit} 1' | tr $'\\n' ' '; echo; fi; done | tac`</sub>\r\n",
      "created_at" : "2020-09-14T05:15:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-691815830",
      "id" : 691815830,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5MTgxNTgzMA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-13T00:22:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/691815830",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r487713900"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/487713900"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Does it make sense to remove the requirement for the `-enable-experimental` flag to build the schnorrsig module?",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-14T07:44:52Z",
      "diff_hunk" : "@@ -1645,7 +1645,7 @@ if test x$need_bundled_univalue = xyes; then\n   AC_CONFIG_SUBDIRS([src/univalue])\n fi\n \n-ac_configure_args=\"${ac_configure_args} --disable-shared --with-pic --enable-benchmark=no --with-bignum=no --enable-module-recovery\"\n+ac_configure_args=\"${ac_configure_args} --disable-shared --with-pic --enable-benchmark=no --with-bignum=no --enable-module-recovery --enable-module-schnorrsig --enable-experimental\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r487713900",
      "id" : 487713900,
      "line" : 1648,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcxMzkwMA==",
      "original_commit_id" : "111be541b5076e87bf800bc4769685d9b2340aed",
      "original_line" : 1648,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "configure.ac",
      "position" : 5,
      "pull_request_review_id" : 487496838,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/487713900",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r487717197"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/487717197"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This was [discussed in the previous PR](https://github.com/bitcoin/bitcoin/pull/17977/files#r475990462).\r\n\r\nluke-jr\r\n> Should this be non-experimental before merging?\r\n\r\ngmaxwell\r\n> I don't think so: It probably shouldn't be marked non-experimental until after it deployed for activation in Bitcoin because it wouldn't be good to encourage third party users of it while it is still easy to make incompatible changes in Bitcoin (e.g. as was just done. :) )\r\n\r\nsipa\r\n> Or, maybe more likely: the API in libsecp256k1 may change still significantly in the near future (e.g. support for variable-length messages, batch validation, ...) even after we treat the scheme itself final.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-14T07:50:45Z",
      "diff_hunk" : "@@ -1645,7 +1645,7 @@ if test x$need_bundled_univalue = xyes; then\n   AC_CONFIG_SUBDIRS([src/univalue])\n fi\n \n-ac_configure_args=\"${ac_configure_args} --disable-shared --with-pic --enable-benchmark=no --with-bignum=no --enable-module-recovery\"\n+ac_configure_args=\"${ac_configure_args} --disable-shared --with-pic --enable-benchmark=no --with-bignum=no --enable-module-recovery --enable-module-schnorrsig --enable-experimental\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r487717197",
      "id" : 487717197,
      "in_reply_to_id" : 487713900,
      "line" : 1648,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcxNzE5Nw==",
      "original_commit_id" : "111be541b5076e87bf800bc4769685d9b2340aed",
      "original_line" : 1648,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "configure.ac",
      "position" : 5,
      "pull_request_review_id" : 487501076,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/487717197",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@jnewbery There are only two of them. The variable name one is very small, and the ECDSA naming one isn't really a standalone useful change. I think that one could be changed into a scripted-diff though.",
      "created_at" : "2020-09-14T08:34:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-691907545",
      "id" : 691907545,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5MTkwNzU0NQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-14T08:34:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/691907545",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r487880593"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/487880593"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "maybe move that block down into the one below, then you don't have to check `stack.size() >= 2` twice",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-14T12:42:00Z",
      "diff_hunk" : "@@ -237,6 +239,36 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check policy limits for Taproot spends:\n+        // - MAX_STANDARD_TAPSCRIPT_STACK_ITEM_SIZE limit for stack item size\n+        // - No annexes\n+        if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE && !p2sh) {\n+            // Taproot spend (non-P2SH-wrapped, version 1, witness program size 32; see BIP 341)\n+            auto stack = MakeSpan(tx.vin[i].scriptWitness.stack);\n+            if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r487880593",
      "id" : 487880593,
      "line" : 249,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4MDU5Mw==",
      "original_commit_id" : "111be541b5076e87bf800bc4769685d9b2340aed",
      "original_line" : 249,
      "original_position" : 36,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : 36,
      "pull_request_review_id" : 487712003,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/487880593",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/425166?v=4",
         "events_url" : "https://api.github.com/users/flack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/flack/followers",
         "following_url" : "https://api.github.com/users/flack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/flack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/flack",
         "id" : 425166,
         "login" : "flack",
         "node_id" : "MDQ6VXNlcjQyNTE2Ng==",
         "organizations_url" : "https://api.github.com/users/flack/orgs",
         "received_events_url" : "https://api.github.com/users/flack/received_events",
         "repos_url" : "https://api.github.com/users/flack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/flack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/flack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/flack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "concept ACK, just confirming for now this PR is identical to the old PR #17977 at https://github.com/bitcoin/bitcoin/pull/19953/commits/111be541b5076e87bf800bc4769685d9b2340aed",
      "created_at" : "2020-09-14T14:14:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-692080594",
      "id" : 692080594,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5MjA4MDU5NA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-14T14:14:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/692080594",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r488066922"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/488066922"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I would rather not, because if later changes do add supported annexes, it'll need to revert to this flow anyway (where the branch dealing with annexes pops it from the stack, and the next if looks at the stack size after removing it).",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-14T16:30:54Z",
      "diff_hunk" : "@@ -237,6 +239,36 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check policy limits for Taproot spends:\n+        // - MAX_STANDARD_TAPSCRIPT_STACK_ITEM_SIZE limit for stack item size\n+        // - No annexes\n+        if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE && !p2sh) {\n+            // Taproot spend (non-P2SH-wrapped, version 1, witness program size 32; see BIP 341)\n+            auto stack = MakeSpan(tx.vin[i].scriptWitness.stack);\n+            if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r488066922",
      "id" : 488066922,
      "in_reply_to_id" : 487880593,
      "line" : 249,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA2NjkyMg==",
      "original_commit_id" : "111be541b5076e87bf800bc4769685d9b2340aed",
      "original_line" : 249,
      "original_position" : 36,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : 36,
      "pull_request_review_id" : 487947905,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/488066922",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Reordered commits a bit, replaced the ECDSA naming one with a scripted diff, and organized the commits in sections. The end state is identical to what it was before.",
      "created_at" : "2020-09-14T18:42:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-692240577",
      "id" : 692240577,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5MjI0MDU3Nw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-14T18:57:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/692240577",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Could the first 2 commits be done as separate PRs? That should slightly reduce the size of this one",
      "created_at" : "2020-09-14T20:37:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-692300062",
      "id" : 692300062,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5MjMwMDA2Mg==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-14T20:37:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/692300062",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/15256660?v=4",
         "events_url" : "https://api.github.com/users/benthecarman/events{/privacy}",
         "followers_url" : "https://api.github.com/users/benthecarman/followers",
         "following_url" : "https://api.github.com/users/benthecarman/following{/other_user}",
         "gists_url" : "https://api.github.com/users/benthecarman/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/benthecarman",
         "id" : 15256660,
         "login" : "benthecarman",
         "node_id" : "MDQ6VXNlcjE1MjU2NjYw",
         "organizations_url" : "https://api.github.com/users/benthecarman/orgs",
         "received_events_url" : "https://api.github.com/users/benthecarman/received_events",
         "repos_url" : "https://api.github.com/users/benthecarman/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/benthecarman/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/benthecarman/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/benthecarman"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@benthecarman That was suggested earlier by @jnewbery. I think splitting off 28 trivial lines of refactors from a 2500-line PR (though 1700 are tests) isn't going to change much. The refactors that were nontrivial and useful as standalone improvements have been split off already and merged (see history of the previous PR).",
      "created_at" : "2020-09-14T20:39:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-692301083",
      "id" : 692301083,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5MjMwMTA4Mw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-16T16:23:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/692301083",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I added a unit test too now, with test vectors that were extracted from 20000 runs of the feature_taproot.py test (with the largest tests removed, and larger groups of inputs per transaction), minimized using libfuzzer's coverage tracking to 105.\r\n\r\nThe code for doing so is in https://github.com/sipa/bitcoin/commits/taproot-test-creation. I'll clean that code up a bit and integrate some parts of it in the normal Python test, so it's easier to recreate these vectors if improvements to the Python test are made.",
      "created_at" : "2020-09-16T04:08:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-693157316",
      "id" : 693157316,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5MzE1NzMxNg==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-16T04:10:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/693157316",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I was surprised to learn that this was a 2500-line PR. By directory:\r\n\r\n- `/test/functional` - 1790 lines\r\n- `/src/test` - 134 lines\r\n- `/src` (exc `test`) - 817 lines\r\n\r\nSo the majority of code in this PR is tests (which is a good thing!)\r\n\r\nI agree with sipa that it's not necessary to split off the first two commits (especially now that they're separated to the top of the branch). Equally no harm in doing so if that'd reduce the workload.",
      "created_at" : "2020-09-16T08:52:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-693269062",
      "id" : 693269062,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5MzI2OTA2Mg==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-16T08:52:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/693269062",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "No code changes aside from unit test commit https://github.com/bitcoin/bitcoin/pull/19953/commits/9673fd9999a7fef4bfc5b074fa1861938042df10",
      "created_at" : "2020-09-16T11:35:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-693347931",
      "id" : 693347931,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5MzM0NzkzMQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-16T11:35:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/693347931",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #20121 (configure: Allow users to explicitly enable libsecp256k1's GMP bignum support by luke-jr)\n* #20100 (Script: split policy/error consensus codes for CLEANSTACK, MINIMALIF by sanket1729)\n* #20035 (signet: Fix uninitialized read in validation by MarcoFalke)\n* #19935 (Move SaltedHashers to separate file and add some new ones by achow101)\n* #19792 (rpc: Add dumpcoinstats by fjahr)\n* #19602 (wallet: Migrate legacy wallets to descriptor wallets by achow101)\n* #19521 (Coinstats Index (without UTXO set hash) by fjahr)\n* #19438 (Introduce deploymentstatus by ajtowns)\n* #18788 (tests: Update more tests to work with descriptor wallets by achow101)\n* #16546 (External signer support - Wallet Box edition by Sjors)\n* #13533 ([tests] Reduced number of validations in tx_validationcache_tests by lucash-dev)\n* #13062 (Make script interpreter independent from storage type CScript by sipa)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2020-09-19T13:34:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-695214236",
      "id" : 695214236,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5NTIxNDIzNg==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-13T04:55:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/695214236",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r491588125"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491588125"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`VerifySchnorr` has `assert(sigbytes.size() == 64);` so false won't be returned. Should either change this comment or change the assertion to `if (sigbytes.size() != 64) return false;`",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-19T22:57:31Z",
      "diff_hunk" : "@@ -206,6 +207,24 @@ class CPubKey\n     bool Derive(CPubKey& pubkeyChild, ChainCode &ccChild, unsigned int nChild, const ChainCode& cc) const;\n };\n \n+class XOnlyPubKey {\n+private:\n+    uint256 m_keydata;\n+\n+public:\n+    /** Construct an x-only pubkey from exactly 32 bytes. */\n+    XOnlyPubKey(Span<const unsigned char> input);\n+\n+    /** Verify a 64-byte Schnorr signature.\n+     *\n+     * If the signature is not exactly 64 bytes, false is returned.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r491588125",
      "id" : 491588125,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTU4ODEyNQ==",
      "original_commit_id" : "beed0764df14791e33f60636fff06d50f067ea9d",
      "original_line" : 220,
      "original_position" : 22,
      "original_start_line" : null,
      "path" : "src/pubkey.h",
      "position" : null,
      "pull_request_review_id" : 492160493,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491588125",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/15256660?v=4",
         "events_url" : "https://api.github.com/users/benthecarman/events{/privacy}",
         "followers_url" : "https://api.github.com/users/benthecarman/followers",
         "following_url" : "https://api.github.com/users/benthecarman/following{/other_user}",
         "gists_url" : "https://api.github.com/users/benthecarman/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/benthecarman",
         "id" : 15256660,
         "login" : "benthecarman",
         "node_id" : "MDQ6VXNlcjE1MjU2NjYw",
         "organizations_url" : "https://api.github.com/users/benthecarman/orgs",
         "received_events_url" : "https://api.github.com/users/benthecarman/received_events",
         "repos_url" : "https://api.github.com/users/benthecarman/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/benthecarman/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/benthecarman/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/benthecarman"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r491638161"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491638161"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: would be easier for people to check if this was correct if they were ordered the same as the BIP",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-20T01:08:55Z",
      "diff_hunk" : "@@ -328,3 +331,11 @@ bool GetScriptOp(CScriptBase::const_iterator& pc, CScriptBase::const_iterator en\n     opcodeRet = static_cast<opcodetype>(opcode);\n     return true;\n }\n+\n+bool IsOpSuccess(const opcodetype& opcode)\n+{\n+    return (opcode == 0x50 || opcode == 0x62 || opcode == 0x89 ||\n+            opcode == 0x8a || opcode == 0x8d || opcode == 0x8e ||\n+            (opcode >= 0x7e && opcode <= 0x81) || (opcode >= 0x83 && opcode <= 0x86) ||\n+            (opcode >= 0x95 && opcode <= 0x99) || (opcode >= 0xbb && opcode <= 0xfe));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r491638161",
      "id" : 491638161,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTYzODE2MQ==",
      "original_commit_id" : "94844a655f12f598596ca7a35b878349de640e7b",
      "original_line" : 340,
      "original_position" : 20,
      "original_start_line" : 337,
      "path" : "src/script/script.cpp",
      "position" : null,
      "pull_request_review_id" : 492164684,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491638161",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/15256660?v=4",
         "events_url" : "https://api.github.com/users/benthecarman/events{/privacy}",
         "followers_url" : "https://api.github.com/users/benthecarman/followers",
         "following_url" : "https://api.github.com/users/benthecarman/following{/other_user}",
         "gists_url" : "https://api.github.com/users/benthecarman/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/benthecarman",
         "id" : 15256660,
         "login" : "benthecarman",
         "node_id" : "MDQ6VXNlcjE1MjU2NjYw",
         "organizations_url" : "https://api.github.com/users/benthecarman/orgs",
         "received_events_url" : "https://api.github.com/users/benthecarman/received_events",
         "repos_url" : "https://api.github.com/users/benthecarman/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/benthecarman/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/benthecarman/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/benthecarman"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r491638297"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491638297"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: when referring to other op codes in the error messages they are normally prefixed with `OP_`, to be consistent this could be changed to `OP_SUCCESSx reserved for...`",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-20T01:10:59Z",
      "diff_hunk" : "@@ -75,6 +75,10 @@ std::string ScriptErrorString(const ScriptError serror)\n             return \"Witness version reserved for soft-fork upgrades\";\n         case SCRIPT_ERR_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION:\n             return \"Taproot version reserved for soft-fork upgrades\";\n+        case SCRIPT_ERR_DISCOURAGE_OP_SUCCESS:\n+            return \"SUCCESSx reserved for soft-fork upgrades\";",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r491638297",
      "id" : 491638297,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTYzODI5Nw==",
      "original_commit_id" : "94844a655f12f598596ca7a35b878349de640e7b",
      "original_line" : 79,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/script/script_error.cpp",
      "position" : null,
      "pull_request_review_id" : 492164684,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/491638297",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/15256660?v=4",
         "events_url" : "https://api.github.com/users/benthecarman/events{/privacy}",
         "followers_url" : "https://api.github.com/users/benthecarman/followers",
         "following_url" : "https://api.github.com/users/benthecarman/following{/other_user}",
         "gists_url" : "https://api.github.com/users/benthecarman/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/benthecarman",
         "id" : 15256660,
         "login" : "benthecarman",
         "node_id" : "MDQ6VXNlcjE1MjU2NjYw",
         "organizations_url" : "https://api.github.com/users/benthecarman/orgs",
         "received_events_url" : "https://api.github.com/users/benthecarman/received_events",
         "repos_url" : "https://api.github.com/users/benthecarman/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/benthecarman/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/benthecarman/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/benthecarman"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "#### My expectation was to do a code review for taproot, but unfortunately, I cannot ACK the concept or the approach of this PR at this time. \r\n\r\nAfter initial research and deep dive, I ask the following:  \r\n1. Will a majority of bitcoin users benefit from this PR?  \r\n_for consensus changes this answer should be a 'YES'_\r\n2. Does this PR create new security concerns or attack vectors for the typical bitcoin user?\r\n_for consensus changes this answer should be a 'NO'_\r\n\r\n**Below are my concerns with questions regarding this PR, answers and clarifications will hopefully bring me around.**\r\n\r\n### Background \r\nOriginal motivation to review this PR came from a tweet with a bounty. I am honored to help bitcoin, and am reviewing this PR independant of monetary expectations.  \r\n\r\nFollowing documents have been read and reviewed in detail specifically for this review, skipping some code and proofs.\r\n- [x] [PR Review Club for 17977](https://bitcoincore.reviews/17977-3)\r\n- [x] [[bitcoin-dev] Taproot](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-January/015614.html)\r\n- [x] [Homomorphic Payment Addresses and the Pay-to-Contract Protocol](https://arxiv.org/pdf/1212.3257.pdf)\r\n- [x] [BIP340](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki), [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki), [BIP342](https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki)\r\n- [x] [Simple Schnorr Multi-Signatures with Applications to Bitcoin](https://eprint.iacr.org/2018/068.pdf)\r\n- [x] [Impact of Taproot and Schnorr on Address Clustering Analysis of Bitcoin](http://blockchain.cs.ucl.ac.uk/wp-content/uploads/2020/04/UCL_CBT_DiscussionPaper_Q12020_Anania_2020.pdf) \r\n\r\nReason for not a simple \"concept NACK\" is because of the known information gap on my end. Specifically, I have not read most of bitcoin bips since early segwit. \r\n* My knowledge and use of bitcoin has been almost exclusively with P2PKH, including custom coded raw transactions on the utxo level. \r\n* Have not yet personally implemented BIP32 - Hierarchical Deterministic Wallets, nor SegWit \r\n\r\n### Questions\r\nsome of these are leading some of these are clarifying \r\n1. Are my current ECDSA private/public key pairs compatible with Schnorr?\r\n2. Where are the specific steps of transforming keys to Schnorr public/private key pairs? \r\n3. is there any difference in key management between ECDSA pairs and Schnorr pairs?\r\n4. is Schnorr compatible with BIP32? \r\n5. If we define _complexity risk_ as a measure of required knowledge in relation to security expectations, does this PR add complexity risk? \r\n6. Can we measure the _complexity risk_ delta of this PR?\r\n7. Would an expert ECDSA pk pair security manager need more knowledge to become an expert Schnorr pk pair manager? \r\n8. Would a future expert Schnorr pk pair manger already be an expert ECDSA pk pair manager? \r\n9. If we define a _hard-knowledge-fork_ as needing more knowledge and a _soft-knowledge-fork_ as needing less knowledge to use bitcoin, is this Taproot PR a _hard-knowledge-fork_ or _soft-knowledge-fork_? \r\n10. Can Taproot be implemented with ECDSA? [Technical: Pay-to-contract and Sign-to-contract](https://www.reddit.com/r/Bitcoin/comments/d3lffo/technical_paytocontract_and_signtocontract/)?\r\n11. Is Taproot available for ECDSA in this PR? \r\n\r\n### Concerns\r\n**MultiSig**\r\nIm concerned that we are explicitly promoting MultiSig as a net positive for securing users private keys, and as far as i can tell, the consensus is that multisig comes down to a single leader in practice. \r\n\r\n[poll: Is the use of multisig on a bitcoin transaction, a security feature or a false sense of security? ](https://twitter.com/jaybny/status/1308297471735418882)\r\n\r\n**Key Reuse** \r\nIm concerned that we are implicitly assuming that key reuse is wrong, but as far as i can tell, the consensus is that code reuse is fine for most cases.  \r\n\r\n**Highest concern is if the efficiency improvements, like removal of double sha256 hashing and others, are assuming no key reuse, creating a new vector for user error, since a majority of bitcoin users reuse their keys.**\r\n\r\n\r\nsimilar sentiments:\r\n> \"While the key holders are expected not to reuse key pair, little could be done to stop payers to reuse an address. Unfortunately, key-pair reuse has been a social and technical norm since the creation of Bitcoin (the first tx made in block 170 reused the previous public key). I dont see any hope to change this norm any time soon, if possible at all.\" [bitcoin-dev](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-December/016549.html)\r\n\r\n> > Overall, we are left with concerns both about the merit of doing Taproot\r\n> > versus alternatives, as well as the process through which we got to be here.\r\n> > 1) Is Taproot actually more private than bare MAST and Schnorr separately? What\r\n> > are the actual anonymity set benefits compared to doing the separately?\r\n> \r\n> Yes, presuming single-pubkey-single-signature remains a common authorisation pattern. \r\n[bitcoin-dev](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017622.html)\r\n\r\nand fud: \r\n> [Similarly, the SIGHASH_SINGLE bug for example would have been disastrous for this scheme. In general, the Blockchain this is used in must not allow spending more than one output with a single \r\n> signature.](https://github.com/ElementsProject/scriptless-scripts/blob/master/md/partially-blind-swap.md)\r\n\r\nred flags:\r\n> [Homomorphic Payment Addresses and the Pay-to-Contract Protocol](https://arxiv.org/pdf/1212.3257.pdf)\r\n> * Customer public key a\" in the tx cannot be used twice for same Public-Key of merchant \r\n> * signaling variation? address(a,c) vs address(P,c) - \r\n>     * (a,c) becomes a private key \r\n\r\nother:\r\nDISCOURAGE_FLAG - why the need for this flag? cant we say - ON_POLICY_CHANGE(Transform the mempool)?  \r\n\r\nflagged for followup:\r\n[BIP340](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki)\r\n> This complicates the implementation of secure signing protocols in scenarios in which a group of mutually distrusting signers work together to produce a single joint signature \r\n\r\n> Using the first option would be slightly more efficient for verification (around 10%), but we prioritize compactness, and therefore choose option 3.\r\nbatch verification\r\n\r\n> breaking an X only key - at most a small constant faster\r\n\r\n> nonce - leaking secret\r\n\r\n> every public key - has two corresponding secret keys\r\n\r\n> not using the same private key - across different signing schemes - signatures can leak secret key through nonce reuse\r\n\r\n> open up new nonce attack vectors\r\n\r\n> However, if this optimization is used and additionally the signature verification at the end of the signing algorithm is dropped for increased efficiency, signers must ensure the public key is correctly calculated and not taken from untrusted sources.\r\n\r\n> While recent academic papers claim that they are also possible with ECDSA, consensus support for Schnorr signature verification would significantly simplify the constructions.\r\n\r\n[BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki)\r\n> Combining all these ideas in a single proposal would be an extensive change, be hard to review, and likely miss new discoveries that otherwise could have been made along the way.\r\n\r\n> Just like other existing output types, taproot outputs should never reuse keys, for privacy reasons. This does not only apply to the particular leaf that was used to spend an output but to all leaves committed to in the output. If leaves were reused, it could happen that spending a different output would reuse the same Merkle branches in the Merkle proof. \r\n\r\n> fixes the verification capabilities of offline signing devices by including amount and scriptPubKey in the signature message, avoids unnecessary hashing\r\n\r\n> Hashes that go into the signature message and the message itself are now computed with a single SHA256 invocation instead of double SHA256. There is no expected security improvement by doubling SHA256 because this only protects against length-extension attacks against SHA256 which are not a concern for signature messages because there is no secret data. Therefore doubling SHA256 is a waste of resources.\r\n\r\n> The public key is directly included in the output in contrast to typical earlier constructions which store a hash of the public key or script in the output. This has the same cost for senders and is more space efficient overall if the key-based spending path is taken. [2]\r\n\r\n\r\n[BIP342](https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki)\r\n> The inefficient OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY opcodes are disabled. Instead, a new opcode OP_CHECKSIGADD is introduced to allow creating the same multisignature policies in a batch-verifiable way. \r\n\r\n> Disabled script opcodes The following script opcodes are disabled in tapscript: OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY[2]. The disabled opcodes behave in the same way as OP_RETURN, by failing and terminating the script immediately when executed, and being ignored when found in unexecuted branch of the script.\r\n\r\n> This way, new SIGHASH modes can be added, as well as NOINPUT-tagged public keys and a public key constant which is replaced by the taproot internal key for signature validation.\r\n\r\n> Why is a limit on script size no longer needed? Since there is no scriptCode directly included in the signature hash (only indirectly through a precomputable tapleaf hash), the CPU time spent on a signature check is no longer proportional to the size of the script being executed.\r\n\r\n### PR Purpose\r\nas stated \r\n\r\n> privacy, efficiency, and flexibility of Bitcoin's scripting capabilities\r\n\r\n> This proposal aims to improve privacy, efficiency, and flexibility of Bitcoin's scripting capabilities without adding new security assumptions[1]. Specifically, it seeks to minimize how much information about the spendability conditions of a transaction output is revealed on chain at creation or spending time and to add a number of upgrade mechanisms, while fixing a few minor but long-standing issues\r\n\r\nTaproot is an optional feature, and P2PKH key reusers, not concerned with privacy, do not need to us it. Yet, they still get the benefits of smaller multisig transactions.  \r\n\r\n**Is this [chart](https://eprint.iacr.org/2018/068.pdf) the only benefits of this PR for the majority of users? Is it worth consensus soft-fork? What are the risks?** \r\n![image](https://user-images.githubusercontent.com/777326/93874364-19fd3d80-fc88-11ea-8f65-c478398f0108.png)\r\n## Taproot ##\r\n> Taproot's advantages become apparent under the assumption that most applications involve outputs that could be spent by all parties agreeing \r\n\r\nThis use of practical reality built into the bitcoin protocol is exactly what we need more off! Maybe this abstraction can one day be made between alice and bob, because many times alice is really bob in a dress, and bob has no double spend risk on the tx from bob to bob.  \r\n\r\n**defaut spending path**\r\nfrom what i understand, since in practice over 85% of bitcoin transaction are single key, the default path will be basically p2pkh (or the Segwit + Schnorr equivalent)   \r\n\r\n**user story**\r\nIf Taproot tree path spending is not for the 85% of bitcoin users, then who is it for? actual user stories will go a long way here. \r\n",
      "created_at" : "2020-09-22T11:02:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-696650924",
      "id" : 696650924,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5NjY1MDkyNA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-22T11:02:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/696650924",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/777326?v=4",
         "events_url" : "https://api.github.com/users/jaybny/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jaybny/followers",
         "following_url" : "https://api.github.com/users/jaybny/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jaybny/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jaybny",
         "id" : 777326,
         "login" : "jaybny",
         "node_id" : "MDQ6VXNlcjc3NzMyNg==",
         "organizations_url" : "https://api.github.com/users/jaybny/orgs",
         "received_events_url" : "https://api.github.com/users/jaybny/received_events",
         "repos_url" : "https://api.github.com/users/jaybny/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jaybny/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jaybny/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jaybny"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@jaybny All of those questions are about the BIPs themselves, and not about the code changes to implement them, and thus out of scope here. I suggest you discuss them on the bitcoin-dev mailing list, https://bitcoin.stackexchange.com, or other media.\n\nI'll give my answers for your list of short questions, but if you have follow up discussion, please take it elsewhere. It would be distracting to code reviewers here.\n\n1. Yes, intentionally. This is explained in BIP340.\n2. You remove the first byte of a 33-byte compressed pubkey to obtain a 32-byte x-only pubkey.\n3. No.\n4. Yes.\n5. BIP341/342 increase the functionality of the scripting language, which also implies there are more ways someone can screw up when doing nontrivial things. On the other hand, certain weaknesses that used to exist in legacy scripts and segwit scripts are fixed.\n6. That sounds subjective.\n7. No.\n8. Not sure what you mean.\n9. That sounds subjective.\n10. In theory yes, but doing most interesting things with it requires a way to have a single tweaked key that can be spent using consent of multiple parties. This is a *lot* harder with ECDSA than with Schnorr.\n11. This PR implements the BIP341 and BIP342 consensus rules. If those BIPs would have specified support for Taproot with ECDSA, then this PR would have needed to comply with that. BIP341 uses Schnorr signatures in its key spending path, and BIP342 explicitly specifies that all opcodes involving signatures use Schnorr signatures (OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD) or are disables (OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY).",
      "created_at" : "2020-09-22T12:42:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-696695513",
      "id" : 696695513,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5NjY5NTUxMw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-22T12:51:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/696695513",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r492941551"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492941551"
         }
      },
      "author_association" : "NONE",
      "body" : "inconsistent capitalization and hyphenation",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-22T18:19:07Z",
      "diff_hunk" : "@@ -86,13 +105,13 @@ def is_x_coord(self, x):\n         return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n \n     def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point.\"\"\"\n+        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the y-coordinate is even.\"\"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r492941551",
      "id" : 492941551,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk0MTU1MQ==",
      "original_commit_id" : "9673fd9999a7fef4bfc5b074fa1861938042df10",
      "original_line" : 108,
      "original_position" : 48,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 493729595,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492941551",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/284023?v=4",
         "events_url" : "https://api.github.com/users/ysangkok/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ysangkok/followers",
         "following_url" : "https://api.github.com/users/ysangkok/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ysangkok/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ysangkok",
         "id" : 284023,
         "login" : "ysangkok",
         "node_id" : "MDQ6VXNlcjI4NDAyMw==",
         "organizations_url" : "https://api.github.com/users/ysangkok/orgs",
         "received_events_url" : "https://api.github.com/users/ysangkok/received_events",
         "repos_url" : "https://api.github.com/users/ysangkok/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ysangkok/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ysangkok/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ysangkok"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r492942832"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492942832"
         }
      },
      "author_association" : "NONE",
      "body" : "unclear whether it will be negated again if it is already negated, or if it will be negated if it is not already negated",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-22T18:21:15Z",
      "diff_hunk" : "@@ -369,3 +393,161 @@ def sign_ecdsa(self, msg, low_s=True):\n         rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')\n         sb = s.to_bytes((s.bit_length() + 8) // 8, 'big')\n         return b'\\x30' + bytes([4 + len(rb) + len(sb), 2, len(rb)]) + rb + bytes([2, len(sb)]) + sb\n+\n+def compute_xonly_pubkey(key):\n+    \"\"\"Compute an x-only (32 byte) public key from a (32 byte) private key.\n+\n+    This also returns whether the resulting public key was negated.\n+    \"\"\"\n+\n+    assert(len(key) == 32)\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return (None, None)\n+    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, x)]))\n+    return (P[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(P))\n+\n+def tweak_add_privkey(key, tweak, negated=False):\n+    \"\"\"Tweak a private key (after optionally negating it).\"\"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r492942832",
      "id" : 492942832,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk0MjgzMg==",
      "original_commit_id" : "9673fd9999a7fef4bfc5b074fa1861938042df10",
      "original_line" : 411,
      "original_position" : 117,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 493729595,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492942832",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/284023?v=4",
         "events_url" : "https://api.github.com/users/ysangkok/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ysangkok/followers",
         "following_url" : "https://api.github.com/users/ysangkok/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ysangkok/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ysangkok",
         "id" : 284023,
         "login" : "ysangkok",
         "node_id" : "MDQ6VXNlcjI4NDAyMw==",
         "organizations_url" : "https://api.github.com/users/ysangkok/orgs",
         "received_events_url" : "https://api.github.com/users/ysangkok/received_events",
         "repos_url" : "https://api.github.com/users/ysangkok/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ysangkok/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ysangkok/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ysangkok"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r492944176"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492944176"
         }
      },
      "author_association" : "NONE",
      "body" : "simpler to just use `bytes(32)`. python wouldn't let you have uninitialized memory.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-22T18:23:22Z",
      "diff_hunk" : "@@ -369,3 +393,161 @@ def sign_ecdsa(self, msg, low_s=True):\n         rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')\n         sb = s.to_bytes((s.bit_length() + 8) // 8, 'big')\n         return b'\\x30' + bytes([4 + len(rb) + len(sb), 2, len(rb)]) + rb + bytes([2, len(sb)]) + sb\n+\n+def compute_xonly_pubkey(key):\n+    \"\"\"Compute an x-only (32 byte) public key from a (32 byte) private key.\n+\n+    This also returns whether the resulting public key was negated.\n+    \"\"\"\n+\n+    assert(len(key) == 32)\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return (None, None)\n+    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, x)]))\n+    return (P[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(P))\n+\n+def tweak_add_privkey(key, tweak, negated=False):\n+    \"\"\"Tweak a private key (after optionally negating it).\"\"\"\n+\n+    assert(len(key) == 32)\n+    assert(len(tweak) == 32)\n+\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return None\n+    if negated:\n+       x = SECP256K1_ORDER - x\n+    t = int.from_bytes(tweak, 'big')\n+    if t >= SECP256K1_ORDER:\n+        return None\n+    x = (x + t) % SECP256K1_ORDER\n+    if x == 0:\n+        return None\n+    return x.to_bytes(32, 'big')\n+\n+def tweak_add_pubkey(key, tweak):\n+    \"\"\"Tweak a public key and return whether the result was negated.\"\"\"\n+\n+    assert(len(key) == 32)\n+    assert(len(tweak) == 32)\n+\n+    x_coord = int.from_bytes(key, 'big')\n+    if x_coord >= SECP256K1_FIELD_SIZE:\n+        return None\n+    P = SECP256K1.lift_x(x_coord)\n+    if P is None:\n+        return None\n+    t = int.from_bytes(tweak, 'big')\n+    if t >= SECP256K1_ORDER:\n+        return None\n+    Q = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, t), (P, 1)]))\n+    if Q is None:\n+        return None\n+    return (Q[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(Q))\n+\n+def verify_schnorr(key, sig, msg):\n+    \"\"\"Verify a Schnorr signature (see BIP 340).\n+\n+    - key is a 32-byte xonly pubkey (computed using compute_xonly_pubkey).\n+    - sig is a 64-byte Schnorr signature\n+    - msg is a 32-byte message\n+    \"\"\"\n+    assert(len(key) == 32)\n+    assert(len(msg) == 32)\n+    assert(len(sig) == 64)\n+\n+    x_coord = int.from_bytes(key, 'big')\n+    if x_coord == 0 or x_coord >= SECP256K1_FIELD_SIZE:\n+        return False\n+    P = SECP256K1.lift_x(x_coord)\n+    if P is None:\n+        return False\n+    r = int.from_bytes(sig[0:32], 'big')\n+    if r >= SECP256K1_FIELD_SIZE:\n+        return False\n+    s = int.from_bytes(sig[32:64], 'big')\n+    if s >= SECP256K1_ORDER:\n+        return False\n+    e = int.from_bytes(TaggedHash(\"BIP0340/challenge\", sig[0:32] + key + msg), 'big') % SECP256K1_ORDER\n+    R = SECP256K1.mul([(SECP256K1_G, s), (P, SECP256K1_ORDER - e)])\n+    if not SECP256K1.has_even_y(R):\n+        return False\n+    if ((r * R[2] * R[2]) % SECP256K1_FIELD_SIZE) != R[0]:\n+        return False\n+    return True\n+\n+def sign_schnorr(key, msg, aux=None, flip_p=False, flip_r=False):\n+    \"\"\"Create a Schnorr signature (see BIP 340).\"\"\"\n+\n+    if aux is None:\n+        aux = bytes(0 for _ in range(32))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r492944176",
      "id" : 492944176,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk0NDE3Ng==",
      "original_commit_id" : "9673fd9999a7fef4bfc5b074fa1861938042df10",
      "original_line" : 484,
      "original_position" : 190,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 493729595,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492944176",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/284023?v=4",
         "events_url" : "https://api.github.com/users/ysangkok/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ysangkok/followers",
         "following_url" : "https://api.github.com/users/ysangkok/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ysangkok/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ysangkok",
         "id" : 284023,
         "login" : "ysangkok",
         "node_id" : "MDQ6VXNlcjI4NDAyMw==",
         "organizations_url" : "https://api.github.com/users/ysangkok/orgs",
         "received_events_url" : "https://api.github.com/users/ysangkok/received_events",
         "repos_url" : "https://api.github.com/users/ysangkok/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ysangkok/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ysangkok/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ysangkok"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r492944523"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492944523"
         }
      },
      "author_association" : "NONE",
      "body" : "why call magic methods directly when you can use `next(reader)`? arguably more readable.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-22T18:23:55Z",
      "diff_hunk" : "@@ -369,3 +393,161 @@ def sign_ecdsa(self, msg, low_s=True):\n         rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')\n         sb = s.to_bytes((s.bit_length() + 8) // 8, 'big')\n         return b'\\x30' + bytes([4 + len(rb) + len(sb), 2, len(rb)]) + rb + bytes([2, len(sb)]) + sb\n+\n+def compute_xonly_pubkey(key):\n+    \"\"\"Compute an x-only (32 byte) public key from a (32 byte) private key.\n+\n+    This also returns whether the resulting public key was negated.\n+    \"\"\"\n+\n+    assert(len(key) == 32)\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return (None, None)\n+    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, x)]))\n+    return (P[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(P))\n+\n+def tweak_add_privkey(key, tweak, negated=False):\n+    \"\"\"Tweak a private key (after optionally negating it).\"\"\"\n+\n+    assert(len(key) == 32)\n+    assert(len(tweak) == 32)\n+\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return None\n+    if negated:\n+       x = SECP256K1_ORDER - x\n+    t = int.from_bytes(tweak, 'big')\n+    if t >= SECP256K1_ORDER:\n+        return None\n+    x = (x + t) % SECP256K1_ORDER\n+    if x == 0:\n+        return None\n+    return x.to_bytes(32, 'big')\n+\n+def tweak_add_pubkey(key, tweak):\n+    \"\"\"Tweak a public key and return whether the result was negated.\"\"\"\n+\n+    assert(len(key) == 32)\n+    assert(len(tweak) == 32)\n+\n+    x_coord = int.from_bytes(key, 'big')\n+    if x_coord >= SECP256K1_FIELD_SIZE:\n+        return None\n+    P = SECP256K1.lift_x(x_coord)\n+    if P is None:\n+        return None\n+    t = int.from_bytes(tweak, 'big')\n+    if t >= SECP256K1_ORDER:\n+        return None\n+    Q = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, t), (P, 1)]))\n+    if Q is None:\n+        return None\n+    return (Q[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(Q))\n+\n+def verify_schnorr(key, sig, msg):\n+    \"\"\"Verify a Schnorr signature (see BIP 340).\n+\n+    - key is a 32-byte xonly pubkey (computed using compute_xonly_pubkey).\n+    - sig is a 64-byte Schnorr signature\n+    - msg is a 32-byte message\n+    \"\"\"\n+    assert(len(key) == 32)\n+    assert(len(msg) == 32)\n+    assert(len(sig) == 64)\n+\n+    x_coord = int.from_bytes(key, 'big')\n+    if x_coord == 0 or x_coord >= SECP256K1_FIELD_SIZE:\n+        return False\n+    P = SECP256K1.lift_x(x_coord)\n+    if P is None:\n+        return False\n+    r = int.from_bytes(sig[0:32], 'big')\n+    if r >= SECP256K1_FIELD_SIZE:\n+        return False\n+    s = int.from_bytes(sig[32:64], 'big')\n+    if s >= SECP256K1_ORDER:\n+        return False\n+    e = int.from_bytes(TaggedHash(\"BIP0340/challenge\", sig[0:32] + key + msg), 'big') % SECP256K1_ORDER\n+    R = SECP256K1.mul([(SECP256K1_G, s), (P, SECP256K1_ORDER - e)])\n+    if not SECP256K1.has_even_y(R):\n+        return False\n+    if ((r * R[2] * R[2]) % SECP256K1_FIELD_SIZE) != R[0]:\n+        return False\n+    return True\n+\n+def sign_schnorr(key, msg, aux=None, flip_p=False, flip_r=False):\n+    \"\"\"Create a Schnorr signature (see BIP 340).\"\"\"\n+\n+    if aux is None:\n+        aux = bytes(0 for _ in range(32))\n+\n+    assert(len(key) == 32)\n+    assert(len(msg) == 32)\n+    assert(len(aux) == 32)\n+\n+    sec = int.from_bytes(key, 'big')\n+    if sec == 0 or sec >= SECP256K1_ORDER:\n+        return None\n+    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, sec)]))\n+    if SECP256K1.has_even_y(P) == flip_p:\n+        sec = SECP256K1_ORDER - sec\n+    t = (sec ^ int.from_bytes(TaggedHash(\"BIP0340/aux\", aux), 'big')).to_bytes(32, 'big')\n+    kp = int.from_bytes(TaggedHash(\"BIP0340/nonce\", t + P[0].to_bytes(32, 'big') + msg), 'big') % SECP256K1_ORDER\n+    assert(kp != 0)\n+    R = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, kp)]))\n+    k = kp if SECP256K1.has_even_y(R) != flip_r else SECP256K1_ORDER - kp\n+    e = int.from_bytes(TaggedHash(\"BIP0340/challenge\", R[0].to_bytes(32, 'big') + P[0].to_bytes(32, 'big') + msg), 'big') % SECP256K1_ORDER\n+    return R[0].to_bytes(32, 'big') + ((k + e * sec) % SECP256K1_ORDER).to_bytes(32, 'big')\n+\n+class TestFrameworkKey(unittest.TestCase):\n+    def test_schnorr(self):\n+        \"\"\"Test the Python Schnorr implementation.\"\"\"\n+        byte_arrays = [generate_privkey() for _ in range(3)] + [v.to_bytes(32, 'big') for v in [0, SECP256K1_ORDER - 1, SECP256K1_ORDER, 2**256 - 1]]\n+        keys = {}\n+        for privkey in byte_arrays:  # build array of key/pubkey pairs\n+            pubkey, _ = compute_xonly_pubkey(privkey)\n+            if pubkey is not None:\n+                keys[privkey] = pubkey\n+        for msg in byte_arrays:  # test every combination of message, signing key, verification key\n+            for sign_privkey, sign_pubkey in keys.items():\n+                sig = sign_schnorr(sign_privkey, msg)\n+                for verify_privkey, verify_pubkey in keys.items():\n+                    if verify_privkey == sign_privkey:\n+                        self.assertTrue(verify_schnorr(verify_pubkey, sig, msg))\n+                        sig = list(sig)\n+                        sig[random.randrange(64)] ^= (1 << (random.randrange(8)))  # damaging signature should break things\n+                        sig = bytes(sig)\n+                    self.assertFalse(verify_schnorr(verify_pubkey, sig, msg))\n+\n+    def test_schnorr_testvectors(self):\n+        \"\"\"Implement the BIP340 test vectors (read from bip340_test_vectors.csv).\"\"\"\n+        num_tests = 0\n+        with open(os.path.join(sys.path[0], 'test_framework', 'bip340_test_vectors.csv'), newline='', encoding='utf8') as csvfile:\n+            reader = csv.reader(csvfile)\n+            reader.__next__()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r492944523",
      "id" : 492944523,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk0NDUyMw==",
      "original_commit_id" : "9673fd9999a7fef4bfc5b074fa1861938042df10",
      "original_line" : 529,
      "original_position" : 235,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 493729595,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492944523",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/284023?v=4",
         "events_url" : "https://api.github.com/users/ysangkok/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ysangkok/followers",
         "following_url" : "https://api.github.com/users/ysangkok/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ysangkok/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ysangkok",
         "id" : 284023,
         "login" : "ysangkok",
         "node_id" : "MDQ6VXNlcjI4NDAyMw==",
         "organizations_url" : "https://api.github.com/users/ysangkok/orgs",
         "received_events_url" : "https://api.github.com/users/ysangkok/received_events",
         "repos_url" : "https://api.github.com/users/ysangkok/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ysangkok/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ysangkok/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ysangkok"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r492948353"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492948353"
         }
      },
      "author_association" : "NONE",
      "body" : "parens unnecessary",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-22T18:29:46Z",
      "diff_hunk" : "@@ -369,3 +393,161 @@ def sign_ecdsa(self, msg, low_s=True):\n         rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')\n         sb = s.to_bytes((s.bit_length() + 8) // 8, 'big')\n         return b'\\x30' + bytes([4 + len(rb) + len(sb), 2, len(rb)]) + rb + bytes([2, len(sb)]) + sb\n+\n+def compute_xonly_pubkey(key):\n+    \"\"\"Compute an x-only (32 byte) public key from a (32 byte) private key.\n+\n+    This also returns whether the resulting public key was negated.\n+    \"\"\"\n+\n+    assert(len(key) == 32)\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return (None, None)\n+    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, x)]))\n+    return (P[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(P))\n+\n+def tweak_add_privkey(key, tweak, negated=False):\n+    \"\"\"Tweak a private key (after optionally negating it).\"\"\"\n+\n+    assert(len(key) == 32)\n+    assert(len(tweak) == 32)\n+\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return None\n+    if negated:\n+       x = SECP256K1_ORDER - x\n+    t = int.from_bytes(tweak, 'big')\n+    if t >= SECP256K1_ORDER:\n+        return None\n+    x = (x + t) % SECP256K1_ORDER\n+    if x == 0:\n+        return None\n+    return x.to_bytes(32, 'big')\n+\n+def tweak_add_pubkey(key, tweak):\n+    \"\"\"Tweak a public key and return whether the result was negated.\"\"\"\n+\n+    assert(len(key) == 32)\n+    assert(len(tweak) == 32)\n+\n+    x_coord = int.from_bytes(key, 'big')\n+    if x_coord >= SECP256K1_FIELD_SIZE:\n+        return None\n+    P = SECP256K1.lift_x(x_coord)\n+    if P is None:\n+        return None\n+    t = int.from_bytes(tweak, 'big')\n+    if t >= SECP256K1_ORDER:\n+        return None\n+    Q = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, t), (P, 1)]))\n+    if Q is None:\n+        return None\n+    return (Q[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(Q))\n+\n+def verify_schnorr(key, sig, msg):\n+    \"\"\"Verify a Schnorr signature (see BIP 340).\n+\n+    - key is a 32-byte xonly pubkey (computed using compute_xonly_pubkey).\n+    - sig is a 64-byte Schnorr signature\n+    - msg is a 32-byte message\n+    \"\"\"\n+    assert(len(key) == 32)\n+    assert(len(msg) == 32)\n+    assert(len(sig) == 64)\n+\n+    x_coord = int.from_bytes(key, 'big')\n+    if x_coord == 0 or x_coord >= SECP256K1_FIELD_SIZE:\n+        return False\n+    P = SECP256K1.lift_x(x_coord)\n+    if P is None:\n+        return False\n+    r = int.from_bytes(sig[0:32], 'big')\n+    if r >= SECP256K1_FIELD_SIZE:\n+        return False\n+    s = int.from_bytes(sig[32:64], 'big')\n+    if s >= SECP256K1_ORDER:\n+        return False\n+    e = int.from_bytes(TaggedHash(\"BIP0340/challenge\", sig[0:32] + key + msg), 'big') % SECP256K1_ORDER\n+    R = SECP256K1.mul([(SECP256K1_G, s), (P, SECP256K1_ORDER - e)])\n+    if not SECP256K1.has_even_y(R):\n+        return False\n+    if ((r * R[2] * R[2]) % SECP256K1_FIELD_SIZE) != R[0]:\n+        return False\n+    return True\n+\n+def sign_schnorr(key, msg, aux=None, flip_p=False, flip_r=False):\n+    \"\"\"Create a Schnorr signature (see BIP 340).\"\"\"\n+\n+    if aux is None:\n+        aux = bytes(0 for _ in range(32))\n+\n+    assert(len(key) == 32)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r492948353",
      "id" : 492948353,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk0ODM1Mw==",
      "original_commit_id" : "9673fd9999a7fef4bfc5b074fa1861938042df10",
      "original_line" : 486,
      "original_position" : 192,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 493729595,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492948353",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/284023?v=4",
         "events_url" : "https://api.github.com/users/ysangkok/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ysangkok/followers",
         "following_url" : "https://api.github.com/users/ysangkok/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ysangkok/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ysangkok",
         "id" : 284023,
         "login" : "ysangkok",
         "node_id" : "MDQ6VXNlcjI4NDAyMw==",
         "organizations_url" : "https://api.github.com/users/ysangkok/orgs",
         "received_events_url" : "https://api.github.com/users/ysangkok/received_events",
         "repos_url" : "https://api.github.com/users/ysangkok/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ysangkok/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ysangkok/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ysangkok"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r492948800"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492948800"
         }
      },
      "author_association" : "NONE",
      "body" : "parens unnecessary",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-22T18:30:25Z",
      "diff_hunk" : "@@ -369,3 +393,161 @@ def sign_ecdsa(self, msg, low_s=True):\n         rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')\n         sb = s.to_bytes((s.bit_length() + 8) // 8, 'big')\n         return b'\\x30' + bytes([4 + len(rb) + len(sb), 2, len(rb)]) + rb + bytes([2, len(sb)]) + sb\n+\n+def compute_xonly_pubkey(key):\n+    \"\"\"Compute an x-only (32 byte) public key from a (32 byte) private key.\n+\n+    This also returns whether the resulting public key was negated.\n+    \"\"\"\n+\n+    assert(len(key) == 32)\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return (None, None)\n+    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, x)]))\n+    return (P[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(P))\n+\n+def tweak_add_privkey(key, tweak, negated=False):\n+    \"\"\"Tweak a private key (after optionally negating it).\"\"\"\n+\n+    assert(len(key) == 32)\n+    assert(len(tweak) == 32)\n+\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return None\n+    if negated:\n+       x = SECP256K1_ORDER - x\n+    t = int.from_bytes(tweak, 'big')\n+    if t >= SECP256K1_ORDER:\n+        return None\n+    x = (x + t) % SECP256K1_ORDER\n+    if x == 0:\n+        return None\n+    return x.to_bytes(32, 'big')\n+\n+def tweak_add_pubkey(key, tweak):\n+    \"\"\"Tweak a public key and return whether the result was negated.\"\"\"\n+\n+    assert(len(key) == 32)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r492948800",
      "id" : 492948800,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk0ODgwMA==",
      "original_commit_id" : "9673fd9999a7fef4bfc5b074fa1861938042df10",
      "original_line" : 432,
      "original_position" : 138,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 493729595,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492948800",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/284023?v=4",
         "events_url" : "https://api.github.com/users/ysangkok/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ysangkok/followers",
         "following_url" : "https://api.github.com/users/ysangkok/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ysangkok/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ysangkok",
         "id" : 284023,
         "login" : "ysangkok",
         "node_id" : "MDQ6VXNlcjI4NDAyMw==",
         "organizations_url" : "https://api.github.com/users/ysangkok/orgs",
         "received_events_url" : "https://api.github.com/users/ysangkok/received_events",
         "repos_url" : "https://api.github.com/users/ysangkok/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ysangkok/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ysangkok/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ysangkok"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493064062"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493064062"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-22T22:15:28Z",
      "diff_hunk" : "@@ -206,6 +207,24 @@ class CPubKey\n     bool Derive(CPubKey& pubkeyChild, ChainCode &ccChild, unsigned int nChild, const ChainCode& cc) const;\n };\n \n+class XOnlyPubKey {\n+private:\n+    uint256 m_keydata;\n+\n+public:\n+    /** Construct an x-only pubkey from exactly 32 bytes. */\n+    XOnlyPubKey(Span<const unsigned char> input);\n+\n+    /** Verify a 64-byte Schnorr signature.\n+     *\n+     * If the signature is not exactly 64 bytes, false is returned.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493064062",
      "id" : 493064062,
      "in_reply_to_id" : 491588125,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2NDA2Mg==",
      "original_commit_id" : "beed0764df14791e33f60636fff06d50f067ea9d",
      "original_line" : 220,
      "original_position" : 22,
      "original_start_line" : null,
      "path" : "src/pubkey.h",
      "position" : null,
      "pull_request_review_id" : 493883968,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493064062",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493064438"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493064438"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done. I intentionally didn't change the implementation in test_framework, as this provides weak additional evidence that the semantics didn't change compared to the older code.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-22T22:16:30Z",
      "diff_hunk" : "@@ -328,3 +331,11 @@ bool GetScriptOp(CScriptBase::const_iterator& pc, CScriptBase::const_iterator en\n     opcodeRet = static_cast<opcodetype>(opcode);\n     return true;\n }\n+\n+bool IsOpSuccess(const opcodetype& opcode)\n+{\n+    return (opcode == 0x50 || opcode == 0x62 || opcode == 0x89 ||\n+            opcode == 0x8a || opcode == 0x8d || opcode == 0x8e ||\n+            (opcode >= 0x7e && opcode <= 0x81) || (opcode >= 0x83 && opcode <= 0x86) ||\n+            (opcode >= 0x95 && opcode <= 0x99) || (opcode >= 0xbb && opcode <= 0xfe));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493064438",
      "id" : 493064438,
      "in_reply_to_id" : 491638161,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2NDQzOA==",
      "original_commit_id" : "94844a655f12f598596ca7a35b878349de640e7b",
      "original_line" : 340,
      "original_position" : 20,
      "original_start_line" : 337,
      "path" : "src/script/script.cpp",
      "position" : null,
      "pull_request_review_id" : 493884379,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493064438",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493064475"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493064475"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-22T22:16:38Z",
      "diff_hunk" : "@@ -75,6 +75,10 @@ std::string ScriptErrorString(const ScriptError serror)\n             return \"Witness version reserved for soft-fork upgrades\";\n         case SCRIPT_ERR_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION:\n             return \"Taproot version reserved for soft-fork upgrades\";\n+        case SCRIPT_ERR_DISCOURAGE_OP_SUCCESS:\n+            return \"SUCCESSx reserved for soft-fork upgrades\";",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493064475",
      "id" : 493064475,
      "in_reply_to_id" : 491638297,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2NDQ3NQ==",
      "original_commit_id" : "94844a655f12f598596ca7a35b878349de640e7b",
      "original_line" : 79,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/script/script_error.cpp",
      "position" : null,
      "pull_request_review_id" : 493884422,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493064475",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493064570"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493064570"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-22T22:16:51Z",
      "diff_hunk" : "@@ -86,13 +105,13 @@ def is_x_coord(self, x):\n         return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n \n     def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point.\"\"\"\n+        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the y-coordinate is even.\"\"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493064570",
      "id" : 493064570,
      "in_reply_to_id" : 492941551,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2NDU3MA==",
      "original_commit_id" : "9673fd9999a7fef4bfc5b074fa1861938042df10",
      "original_line" : 108,
      "original_position" : 48,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 493884516,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493064570",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493064790"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493064790"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Changed the interface to not take a negated argument, but infer it from the key. This should be cleaner and simpler.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-22T22:17:20Z",
      "diff_hunk" : "@@ -369,3 +393,161 @@ def sign_ecdsa(self, msg, low_s=True):\n         rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')\n         sb = s.to_bytes((s.bit_length() + 8) // 8, 'big')\n         return b'\\x30' + bytes([4 + len(rb) + len(sb), 2, len(rb)]) + rb + bytes([2, len(sb)]) + sb\n+\n+def compute_xonly_pubkey(key):\n+    \"\"\"Compute an x-only (32 byte) public key from a (32 byte) private key.\n+\n+    This also returns whether the resulting public key was negated.\n+    \"\"\"\n+\n+    assert(len(key) == 32)\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return (None, None)\n+    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, x)]))\n+    return (P[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(P))\n+\n+def tweak_add_privkey(key, tweak, negated=False):\n+    \"\"\"Tweak a private key (after optionally negating it).\"\"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493064790",
      "id" : 493064790,
      "in_reply_to_id" : 492942832,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2NDc5MA==",
      "original_commit_id" : "9673fd9999a7fef4bfc5b074fa1861938042df10",
      "original_line" : 411,
      "original_position" : 117,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 493884761,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493064790",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493064821"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493064821"
         }
      },
      "author_association" : "MEMBER",
      "body" : "TIL. Done.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-22T22:17:28Z",
      "diff_hunk" : "@@ -369,3 +393,161 @@ def sign_ecdsa(self, msg, low_s=True):\n         rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')\n         sb = s.to_bytes((s.bit_length() + 8) // 8, 'big')\n         return b'\\x30' + bytes([4 + len(rb) + len(sb), 2, len(rb)]) + rb + bytes([2, len(sb)]) + sb\n+\n+def compute_xonly_pubkey(key):\n+    \"\"\"Compute an x-only (32 byte) public key from a (32 byte) private key.\n+\n+    This also returns whether the resulting public key was negated.\n+    \"\"\"\n+\n+    assert(len(key) == 32)\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return (None, None)\n+    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, x)]))\n+    return (P[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(P))\n+\n+def tweak_add_privkey(key, tweak, negated=False):\n+    \"\"\"Tweak a private key (after optionally negating it).\"\"\"\n+\n+    assert(len(key) == 32)\n+    assert(len(tweak) == 32)\n+\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return None\n+    if negated:\n+       x = SECP256K1_ORDER - x\n+    t = int.from_bytes(tweak, 'big')\n+    if t >= SECP256K1_ORDER:\n+        return None\n+    x = (x + t) % SECP256K1_ORDER\n+    if x == 0:\n+        return None\n+    return x.to_bytes(32, 'big')\n+\n+def tweak_add_pubkey(key, tweak):\n+    \"\"\"Tweak a public key and return whether the result was negated.\"\"\"\n+\n+    assert(len(key) == 32)\n+    assert(len(tweak) == 32)\n+\n+    x_coord = int.from_bytes(key, 'big')\n+    if x_coord >= SECP256K1_FIELD_SIZE:\n+        return None\n+    P = SECP256K1.lift_x(x_coord)\n+    if P is None:\n+        return None\n+    t = int.from_bytes(tweak, 'big')\n+    if t >= SECP256K1_ORDER:\n+        return None\n+    Q = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, t), (P, 1)]))\n+    if Q is None:\n+        return None\n+    return (Q[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(Q))\n+\n+def verify_schnorr(key, sig, msg):\n+    \"\"\"Verify a Schnorr signature (see BIP 340).\n+\n+    - key is a 32-byte xonly pubkey (computed using compute_xonly_pubkey).\n+    - sig is a 64-byte Schnorr signature\n+    - msg is a 32-byte message\n+    \"\"\"\n+    assert(len(key) == 32)\n+    assert(len(msg) == 32)\n+    assert(len(sig) == 64)\n+\n+    x_coord = int.from_bytes(key, 'big')\n+    if x_coord == 0 or x_coord >= SECP256K1_FIELD_SIZE:\n+        return False\n+    P = SECP256K1.lift_x(x_coord)\n+    if P is None:\n+        return False\n+    r = int.from_bytes(sig[0:32], 'big')\n+    if r >= SECP256K1_FIELD_SIZE:\n+        return False\n+    s = int.from_bytes(sig[32:64], 'big')\n+    if s >= SECP256K1_ORDER:\n+        return False\n+    e = int.from_bytes(TaggedHash(\"BIP0340/challenge\", sig[0:32] + key + msg), 'big') % SECP256K1_ORDER\n+    R = SECP256K1.mul([(SECP256K1_G, s), (P, SECP256K1_ORDER - e)])\n+    if not SECP256K1.has_even_y(R):\n+        return False\n+    if ((r * R[2] * R[2]) % SECP256K1_FIELD_SIZE) != R[0]:\n+        return False\n+    return True\n+\n+def sign_schnorr(key, msg, aux=None, flip_p=False, flip_r=False):\n+    \"\"\"Create a Schnorr signature (see BIP 340).\"\"\"\n+\n+    if aux is None:\n+        aux = bytes(0 for _ in range(32))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493064821",
      "id" : 493064821,
      "in_reply_to_id" : 492944176,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2NDgyMQ==",
      "original_commit_id" : "9673fd9999a7fef4bfc5b074fa1861938042df10",
      "original_line" : 484,
      "original_position" : 190,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 493884805,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493064821",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493064966"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493064966"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This was copied from the BIP340 reference code. You may want to update it there too.\r\n\r\nDone.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-22T22:17:51Z",
      "diff_hunk" : "@@ -369,3 +393,161 @@ def sign_ecdsa(self, msg, low_s=True):\n         rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')\n         sb = s.to_bytes((s.bit_length() + 8) // 8, 'big')\n         return b'\\x30' + bytes([4 + len(rb) + len(sb), 2, len(rb)]) + rb + bytes([2, len(sb)]) + sb\n+\n+def compute_xonly_pubkey(key):\n+    \"\"\"Compute an x-only (32 byte) public key from a (32 byte) private key.\n+\n+    This also returns whether the resulting public key was negated.\n+    \"\"\"\n+\n+    assert(len(key) == 32)\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return (None, None)\n+    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, x)]))\n+    return (P[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(P))\n+\n+def tweak_add_privkey(key, tweak, negated=False):\n+    \"\"\"Tweak a private key (after optionally negating it).\"\"\"\n+\n+    assert(len(key) == 32)\n+    assert(len(tweak) == 32)\n+\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return None\n+    if negated:\n+       x = SECP256K1_ORDER - x\n+    t = int.from_bytes(tweak, 'big')\n+    if t >= SECP256K1_ORDER:\n+        return None\n+    x = (x + t) % SECP256K1_ORDER\n+    if x == 0:\n+        return None\n+    return x.to_bytes(32, 'big')\n+\n+def tweak_add_pubkey(key, tweak):\n+    \"\"\"Tweak a public key and return whether the result was negated.\"\"\"\n+\n+    assert(len(key) == 32)\n+    assert(len(tweak) == 32)\n+\n+    x_coord = int.from_bytes(key, 'big')\n+    if x_coord >= SECP256K1_FIELD_SIZE:\n+        return None\n+    P = SECP256K1.lift_x(x_coord)\n+    if P is None:\n+        return None\n+    t = int.from_bytes(tweak, 'big')\n+    if t >= SECP256K1_ORDER:\n+        return None\n+    Q = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, t), (P, 1)]))\n+    if Q is None:\n+        return None\n+    return (Q[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(Q))\n+\n+def verify_schnorr(key, sig, msg):\n+    \"\"\"Verify a Schnorr signature (see BIP 340).\n+\n+    - key is a 32-byte xonly pubkey (computed using compute_xonly_pubkey).\n+    - sig is a 64-byte Schnorr signature\n+    - msg is a 32-byte message\n+    \"\"\"\n+    assert(len(key) == 32)\n+    assert(len(msg) == 32)\n+    assert(len(sig) == 64)\n+\n+    x_coord = int.from_bytes(key, 'big')\n+    if x_coord == 0 or x_coord >= SECP256K1_FIELD_SIZE:\n+        return False\n+    P = SECP256K1.lift_x(x_coord)\n+    if P is None:\n+        return False\n+    r = int.from_bytes(sig[0:32], 'big')\n+    if r >= SECP256K1_FIELD_SIZE:\n+        return False\n+    s = int.from_bytes(sig[32:64], 'big')\n+    if s >= SECP256K1_ORDER:\n+        return False\n+    e = int.from_bytes(TaggedHash(\"BIP0340/challenge\", sig[0:32] + key + msg), 'big') % SECP256K1_ORDER\n+    R = SECP256K1.mul([(SECP256K1_G, s), (P, SECP256K1_ORDER - e)])\n+    if not SECP256K1.has_even_y(R):\n+        return False\n+    if ((r * R[2] * R[2]) % SECP256K1_FIELD_SIZE) != R[0]:\n+        return False\n+    return True\n+\n+def sign_schnorr(key, msg, aux=None, flip_p=False, flip_r=False):\n+    \"\"\"Create a Schnorr signature (see BIP 340).\"\"\"\n+\n+    if aux is None:\n+        aux = bytes(0 for _ in range(32))\n+\n+    assert(len(key) == 32)\n+    assert(len(msg) == 32)\n+    assert(len(aux) == 32)\n+\n+    sec = int.from_bytes(key, 'big')\n+    if sec == 0 or sec >= SECP256K1_ORDER:\n+        return None\n+    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, sec)]))\n+    if SECP256K1.has_even_y(P) == flip_p:\n+        sec = SECP256K1_ORDER - sec\n+    t = (sec ^ int.from_bytes(TaggedHash(\"BIP0340/aux\", aux), 'big')).to_bytes(32, 'big')\n+    kp = int.from_bytes(TaggedHash(\"BIP0340/nonce\", t + P[0].to_bytes(32, 'big') + msg), 'big') % SECP256K1_ORDER\n+    assert(kp != 0)\n+    R = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, kp)]))\n+    k = kp if SECP256K1.has_even_y(R) != flip_r else SECP256K1_ORDER - kp\n+    e = int.from_bytes(TaggedHash(\"BIP0340/challenge\", R[0].to_bytes(32, 'big') + P[0].to_bytes(32, 'big') + msg), 'big') % SECP256K1_ORDER\n+    return R[0].to_bytes(32, 'big') + ((k + e * sec) % SECP256K1_ORDER).to_bytes(32, 'big')\n+\n+class TestFrameworkKey(unittest.TestCase):\n+    def test_schnorr(self):\n+        \"\"\"Test the Python Schnorr implementation.\"\"\"\n+        byte_arrays = [generate_privkey() for _ in range(3)] + [v.to_bytes(32, 'big') for v in [0, SECP256K1_ORDER - 1, SECP256K1_ORDER, 2**256 - 1]]\n+        keys = {}\n+        for privkey in byte_arrays:  # build array of key/pubkey pairs\n+            pubkey, _ = compute_xonly_pubkey(privkey)\n+            if pubkey is not None:\n+                keys[privkey] = pubkey\n+        for msg in byte_arrays:  # test every combination of message, signing key, verification key\n+            for sign_privkey, sign_pubkey in keys.items():\n+                sig = sign_schnorr(sign_privkey, msg)\n+                for verify_privkey, verify_pubkey in keys.items():\n+                    if verify_privkey == sign_privkey:\n+                        self.assertTrue(verify_schnorr(verify_pubkey, sig, msg))\n+                        sig = list(sig)\n+                        sig[random.randrange(64)] ^= (1 << (random.randrange(8)))  # damaging signature should break things\n+                        sig = bytes(sig)\n+                    self.assertFalse(verify_schnorr(verify_pubkey, sig, msg))\n+\n+    def test_schnorr_testvectors(self):\n+        \"\"\"Implement the BIP340 test vectors (read from bip340_test_vectors.csv).\"\"\"\n+        num_tests = 0\n+        with open(os.path.join(sys.path[0], 'test_framework', 'bip340_test_vectors.csv'), newline='', encoding='utf8') as csvfile:\n+            reader = csv.reader(csvfile)\n+            reader.__next__()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493064966",
      "id" : 493064966,
      "in_reply_to_id" : 492944523,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2NDk2Ng==",
      "original_commit_id" : "9673fd9999a7fef4bfc5b074fa1861938042df10",
      "original_line" : 529,
      "original_position" : 235,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 493884982,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493064966",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493065018"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493065018"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done, in many places.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-22T22:18:01Z",
      "diff_hunk" : "@@ -369,3 +393,161 @@ def sign_ecdsa(self, msg, low_s=True):\n         rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')\n         sb = s.to_bytes((s.bit_length() + 8) // 8, 'big')\n         return b'\\x30' + bytes([4 + len(rb) + len(sb), 2, len(rb)]) + rb + bytes([2, len(sb)]) + sb\n+\n+def compute_xonly_pubkey(key):\n+    \"\"\"Compute an x-only (32 byte) public key from a (32 byte) private key.\n+\n+    This also returns whether the resulting public key was negated.\n+    \"\"\"\n+\n+    assert(len(key) == 32)\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return (None, None)\n+    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, x)]))\n+    return (P[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(P))\n+\n+def tweak_add_privkey(key, tweak, negated=False):\n+    \"\"\"Tweak a private key (after optionally negating it).\"\"\"\n+\n+    assert(len(key) == 32)\n+    assert(len(tweak) == 32)\n+\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return None\n+    if negated:\n+       x = SECP256K1_ORDER - x\n+    t = int.from_bytes(tweak, 'big')\n+    if t >= SECP256K1_ORDER:\n+        return None\n+    x = (x + t) % SECP256K1_ORDER\n+    if x == 0:\n+        return None\n+    return x.to_bytes(32, 'big')\n+\n+def tweak_add_pubkey(key, tweak):\n+    \"\"\"Tweak a public key and return whether the result was negated.\"\"\"\n+\n+    assert(len(key) == 32)\n+    assert(len(tweak) == 32)\n+\n+    x_coord = int.from_bytes(key, 'big')\n+    if x_coord >= SECP256K1_FIELD_SIZE:\n+        return None\n+    P = SECP256K1.lift_x(x_coord)\n+    if P is None:\n+        return None\n+    t = int.from_bytes(tweak, 'big')\n+    if t >= SECP256K1_ORDER:\n+        return None\n+    Q = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, t), (P, 1)]))\n+    if Q is None:\n+        return None\n+    return (Q[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(Q))\n+\n+def verify_schnorr(key, sig, msg):\n+    \"\"\"Verify a Schnorr signature (see BIP 340).\n+\n+    - key is a 32-byte xonly pubkey (computed using compute_xonly_pubkey).\n+    - sig is a 64-byte Schnorr signature\n+    - msg is a 32-byte message\n+    \"\"\"\n+    assert(len(key) == 32)\n+    assert(len(msg) == 32)\n+    assert(len(sig) == 64)\n+\n+    x_coord = int.from_bytes(key, 'big')\n+    if x_coord == 0 or x_coord >= SECP256K1_FIELD_SIZE:\n+        return False\n+    P = SECP256K1.lift_x(x_coord)\n+    if P is None:\n+        return False\n+    r = int.from_bytes(sig[0:32], 'big')\n+    if r >= SECP256K1_FIELD_SIZE:\n+        return False\n+    s = int.from_bytes(sig[32:64], 'big')\n+    if s >= SECP256K1_ORDER:\n+        return False\n+    e = int.from_bytes(TaggedHash(\"BIP0340/challenge\", sig[0:32] + key + msg), 'big') % SECP256K1_ORDER\n+    R = SECP256K1.mul([(SECP256K1_G, s), (P, SECP256K1_ORDER - e)])\n+    if not SECP256K1.has_even_y(R):\n+        return False\n+    if ((r * R[2] * R[2]) % SECP256K1_FIELD_SIZE) != R[0]:\n+        return False\n+    return True\n+\n+def sign_schnorr(key, msg, aux=None, flip_p=False, flip_r=False):\n+    \"\"\"Create a Schnorr signature (see BIP 340).\"\"\"\n+\n+    if aux is None:\n+        aux = bytes(0 for _ in range(32))\n+\n+    assert(len(key) == 32)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493065018",
      "id" : 493065018,
      "in_reply_to_id" : 492948353,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2NTAxOA==",
      "original_commit_id" : "9673fd9999a7fef4bfc5b074fa1861938042df10",
      "original_line" : 486,
      "original_position" : 192,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 493885056,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493065018",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493065062"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493065062"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done in many places.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-22T22:18:09Z",
      "diff_hunk" : "@@ -369,3 +393,161 @@ def sign_ecdsa(self, msg, low_s=True):\n         rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')\n         sb = s.to_bytes((s.bit_length() + 8) // 8, 'big')\n         return b'\\x30' + bytes([4 + len(rb) + len(sb), 2, len(rb)]) + rb + bytes([2, len(sb)]) + sb\n+\n+def compute_xonly_pubkey(key):\n+    \"\"\"Compute an x-only (32 byte) public key from a (32 byte) private key.\n+\n+    This also returns whether the resulting public key was negated.\n+    \"\"\"\n+\n+    assert(len(key) == 32)\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return (None, None)\n+    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, x)]))\n+    return (P[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(P))\n+\n+def tweak_add_privkey(key, tweak, negated=False):\n+    \"\"\"Tweak a private key (after optionally negating it).\"\"\"\n+\n+    assert(len(key) == 32)\n+    assert(len(tweak) == 32)\n+\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return None\n+    if negated:\n+       x = SECP256K1_ORDER - x\n+    t = int.from_bytes(tweak, 'big')\n+    if t >= SECP256K1_ORDER:\n+        return None\n+    x = (x + t) % SECP256K1_ORDER\n+    if x == 0:\n+        return None\n+    return x.to_bytes(32, 'big')\n+\n+def tweak_add_pubkey(key, tweak):\n+    \"\"\"Tweak a public key and return whether the result was negated.\"\"\"\n+\n+    assert(len(key) == 32)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493065062",
      "id" : 493065062,
      "in_reply_to_id" : 492948800,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2NTA2Mg==",
      "original_commit_id" : "9673fd9999a7fef4bfc5b074fa1861938042df10",
      "original_line" : 432,
      "original_position" : 138,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 493885119,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493065062",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I addressed comments by @benthecarman and @ysangkok. See \"Updates 2020-09-22\" in the new PR #19997 for the changes that were applied.\r\n\r\nI also moved the \"keep spent outputs in PrecomputedTransactionData\" to the refactors section, as it contains no semantics changes, and didn't depend on any earlier commits.",
      "created_at" : "2020-09-22T22:21:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-697013149",
      "id" : 697013149,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5NzAxMzE0OQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-22T22:43:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/697013149",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "reviewed updates to https://github.com/bitcoin/bitcoin/pull/19953/commits/fe5cf2ed6adbf2271553f97c61de4d59bee20c05\r\n\r\n`IsOpSuccess` was compared against the BIP directly rather than previous iteration, which I had hand-calculated painstakingly. It matches the BIP.",
      "created_at" : "2020-09-23T14:10:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-697415762",
      "id" : 697415762,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5NzQxNTc2Mg==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-23T14:10:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/697415762",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493822427"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493822427"
         }
      },
      "author_association" : "MEMBER",
      "body" : "pico-nit: This is only one output. This probably belongs https://github.com/bitcoin/bitcoin/pull/19953/commits/34da2198264cf90a7ae7f50a912a599f6fd66291#diff-be2905e2f5218ecdbe4e55637dac75f3R1415",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-23T18:55:22Z",
      "diff_hunk" : "@@ -1322,6 +1375,75 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData* cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache != nullptr && cache->m_bip341_taproot_ready && cache->m_spent_outputs_ready);\n+\n+    CHashWriter ss = HASHER_TAPSIGHASH;\n+\n+    // Epoch\n+    static constexpr uint8_t EPOCH = 0;\n+    ss << EPOCH;\n+\n+    // Hash type\n+    const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n+    const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;\n+    if (!(hash_type <= 0x03 || (hash_type >= 0x81 && hash_type <= 0x83))) return false;\n+    ss << hash_type;\n+\n+    // Transaction level data\n+    ss << tx_to.nVersion;\n+    ss << tx_to.nLockTime;\n+    if (input_type != SIGHASH_ANYONECANPAY) {\n+        ss << cache->m_prevouts_single_hash;\n+        ss << cache->m_spent_amounts_single_hash;\n+        ss << cache->m_spent_scripts_single_hash;\n+        ss << cache->m_sequences_single_hash;\n+    }\n+    if (output_type == SIGHASH_ALL) {\n+        ss << cache->m_outputs_single_hash;\n+    }\n+\n+    // Data about the input/prevout being spent\n+    const auto* witstack = &tx_to.vin[in_pos].scriptWitness.stack;\n+    bool have_annex = witstack->size() > 1 && witstack->back().size() > 0 && witstack->back()[0] == ANNEX_TAG;\n+    const uint8_t spend_type = (ext_flag << 1) + (have_annex ? 1 : 0); // The low bit indicates whether an annex is present.\n+    ss << spend_type;\n+    if (input_type == SIGHASH_ANYONECANPAY) {\n+        ss << tx_to.vin[in_pos].prevout;\n+        ss << cache->m_spent_outputs[in_pos];\n+        ss << tx_to.vin[in_pos].nSequence;\n+    } else {\n+        ss << in_pos;\n+    }\n+    if (have_annex) {\n+        ss << (CHashWriter(SER_GETHASH, 0) << witstack->back()).GetSHA256();\n+    }\n+\n+    // Data about the output(s)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493822427",
      "id" : 493822427,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgyMjQyNw==",
      "original_commit_id" : "34da2198264cf90a7ae7f50a912a599f6fd66291",
      "original_line" : 1435,
      "original_position" : 145,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 494958421,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493822427",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493833809"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493833809"
         }
      },
      "author_association" : "MEMBER",
      "body" : "pico-nit: why not just `assert(sigversion != SigVersion:: TAPROOT)`?",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-23T19:11:39Z",
      "diff_hunk" : "@@ -381,6 +439,9 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n     // static const valtype vchZero(0);\n     static const valtype vchTrue(1, 1);\n \n+    // sigversion cannot be TAPROOT here, as it admits no script execution.\n+    assert(sigversion == SigVersion::BASE || sigversion == SigVersion::WITNESS_V0 || sigversion == SigVersion::TAPSCRIPT);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493833809",
      "id" : 493833809,
      "line" : 442,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgzMzgwOQ==",
      "original_commit_id" : "390252cd5bc562a40ab193c044ded32126c3ffbd",
      "original_line" : 442,
      "original_position" : 90,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 100,
      "pull_request_review_id" : 494958421,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493833809",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493838107"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493838107"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n    if (!SignatureHashSchnorr(sighash, execdata, *txTo, nIn, hashtype, sigversion, 0x00 /* key_version */, this->txdata)) return false;\r\n```",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-23T19:19:47Z",
      "diff_hunk" : "@@ -1565,7 +1675,7 @@ bool GenericTransactionSignatureChecker<T>::CheckSchnorrSignature(Span<const uns\n         if (hashtype == SIGHASH_DEFAULT) return false;\n     }\n     uint256 sighash;\n-    if (!SignatureHashSchnorr(sighash, execdata, *txTo, nIn, hashtype, sigversion, this->txdata)) return false;\n+    if (!SignatureHashSchnorr(sighash, execdata, *txTo, nIn, hashtype, sigversion, 0x00, this->txdata)) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493838107",
      "id" : 493838107,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgzODEwNw==",
      "original_commit_id" : "390252cd5bc562a40ab193c044ded32126c3ffbd",
      "original_line" : 1678,
      "original_position" : 249,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 494958421,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493838107",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493865077"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493865077"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Why no `MINIMALIF`?",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-23T20:09:15Z",
      "diff_hunk" : "@@ -1610,5 +1640,50 @@ BOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_invalid_flags)\n     BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_INVALID_FLAGS);\n }\n \n+BOOST_AUTO_TEST_CASE(script_taproot)\n+{\n+    UniValue tests = read_json(std::string(std::begin(json_tests::script_taproot_tests), std::end(json_tests::script_taproot_tests)));\n+\n+    static constexpr unsigned int VERIFY_FLAGS =\n+        SCRIPT_VERIFY_P2SH |\n+        SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY |\n+        SCRIPT_VERIFY_CHECKSEQUENCEVERIFY |\n+        SCRIPT_VERIFY_WITNESS |\n+        SCRIPT_VERIFY_NULLFAIL |\n+        SCRIPT_VERIFY_TAPROOT;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493865077",
      "id" : 493865077,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg2NTA3Nw==",
      "original_commit_id" : "fe5cf2ed6adbf2271553f97c61de4d59bee20c05",
      "original_line" : 1653,
      "original_position" : 75,
      "original_start_line" : null,
      "path" : "src/test/script_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 494958421,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493865077",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493869440"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493869440"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "If a new sig version is added in the future, we probably want it to fail here.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-23T20:17:27Z",
      "diff_hunk" : "@@ -381,6 +439,9 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n     // static const valtype vchZero(0);\n     static const valtype vchTrue(1, 1);\n \n+    // sigversion cannot be TAPROOT here, as it admits no script execution.\n+    assert(sigversion == SigVersion::BASE || sigversion == SigVersion::WITNESS_V0 || sigversion == SigVersion::TAPSCRIPT);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493869440",
      "id" : 493869440,
      "in_reply_to_id" : 493833809,
      "line" : 442,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg2OTQ0MA==",
      "original_commit_id" : "390252cd5bc562a40ab193c044ded32126c3ffbd",
      "original_line" : 442,
      "original_position" : 90,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 100,
      "pull_request_review_id" : 495015539,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493869440",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/15256660?v=4",
         "events_url" : "https://api.github.com/users/benthecarman/events{/privacy}",
         "followers_url" : "https://api.github.com/users/benthecarman/followers",
         "following_url" : "https://api.github.com/users/benthecarman/following{/other_user}",
         "gists_url" : "https://api.github.com/users/benthecarman/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/benthecarman",
         "id" : 15256660,
         "login" : "benthecarman",
         "node_id" : "MDQ6VXNlcjE1MjU2NjYw",
         "organizations_url" : "https://api.github.com/users/benthecarman/orgs",
         "received_events_url" : "https://api.github.com/users/benthecarman/received_events",
         "repos_url" : "https://api.github.com/users/benthecarman/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/benthecarman/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/benthecarman/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/benthecarman"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493870676"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493870676"
         }
      },
      "author_association" : "MEMBER",
      "body" : "eh ok, guess crashing would be best in this case",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-23T20:19:51Z",
      "diff_hunk" : "@@ -381,6 +439,9 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n     // static const valtype vchZero(0);\n     static const valtype vchTrue(1, 1);\n \n+    // sigversion cannot be TAPROOT here, as it admits no script execution.\n+    assert(sigversion == SigVersion::BASE || sigversion == SigVersion::WITNESS_V0 || sigversion == SigVersion::TAPSCRIPT);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493870676",
      "id" : 493870676,
      "in_reply_to_id" : 493833809,
      "line" : 442,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg3MDY3Ng==",
      "original_commit_id" : "390252cd5bc562a40ab193c044ded32126c3ffbd",
      "original_line" : 442,
      "original_position" : 90,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 100,
      "pull_request_review_id" : 495017161,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493870676",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493871166"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493871166"
         }
      },
      "author_association" : "MEMBER",
      "body" : "... because it's not used for consensus, along with CLEANSTACK et al. Right.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-23T20:20:43Z",
      "diff_hunk" : "@@ -1610,5 +1640,50 @@ BOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_invalid_flags)\n     BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_INVALID_FLAGS);\n }\n \n+BOOST_AUTO_TEST_CASE(script_taproot)\n+{\n+    UniValue tests = read_json(std::string(std::begin(json_tests::script_taproot_tests), std::end(json_tests::script_taproot_tests)));\n+\n+    static constexpr unsigned int VERIFY_FLAGS =\n+        SCRIPT_VERIFY_P2SH |\n+        SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY |\n+        SCRIPT_VERIFY_CHECKSEQUENCEVERIFY |\n+        SCRIPT_VERIFY_WITNESS |\n+        SCRIPT_VERIFY_NULLFAIL |\n+        SCRIPT_VERIFY_TAPROOT;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493871166",
      "id" : 493871166,
      "in_reply_to_id" : 493865077,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg3MTE2Ng==",
      "original_commit_id" : "fe5cf2ed6adbf2271553f97c61de4d59bee20c05",
      "original_line" : 1653,
      "original_position" : 75,
      "original_start_line" : null,
      "path" : "src/test/script_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 495017759,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493871166",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493871451"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493871451"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yeah, I'm intentionally only using equality checks with sigversion (all over interpreter.cpp), so that there are no surprises when a new one is added.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-23T20:21:15Z",
      "diff_hunk" : "@@ -381,6 +439,9 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n     // static const valtype vchZero(0);\n     static const valtype vchTrue(1, 1);\n \n+    // sigversion cannot be TAPROOT here, as it admits no script execution.\n+    assert(sigversion == SigVersion::BASE || sigversion == SigVersion::WITNESS_V0 || sigversion == SigVersion::TAPSCRIPT);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493871451",
      "id" : 493871451,
      "in_reply_to_id" : 493833809,
      "line" : 442,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg3MTQ1MQ==",
      "original_commit_id" : "390252cd5bc562a40ab193c044ded32126c3ffbd",
      "original_line" : 442,
      "original_position" : 90,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 100,
      "pull_request_review_id" : 495018135,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493871451",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493885215"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493885215"
         }
      },
      "author_association" : "MEMBER",
      "body" : "34da2198264cf90a7ae7f50a912a599f6fd66291\r\n\r\nNo need to be exhaustive?\r\n```cpp\r\nuses_bip341_taproot = true;\r\nif (uses_bip143_segwit) break;\r\n```",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-23T20:47:12Z",
      "diff_hunk" : "@@ -1291,23 +1291,76 @@ uint256 GetOutputsSHA256(const T& txTo)\n     return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n \n     m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n+    }\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = SHA256Uint256(GetPrevoutsSHA256(txTo));\n-        hashSequence = SHA256Uint256(GetSequencesSHA256(txTo));\n-        hashOutputs = SHA256Uint256(GetOutputsSHA256(txTo));\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143_segwit = false;\n+    bool uses_bip341_taproot = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every native witness v1 spend as a Taproot spend. This only works if spent_outputs was\n+                // provided as well, but if it wasn't, actual validation will fail anyway.\n+                uses_bip341_taproot = true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493885215",
      "id" : 493885215,
      "line" : 1444,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4NTIxNQ==",
      "original_commit_id" : "34da2198264cf90a7ae7f50a912a599f6fd66291",
      "original_line" : 1444,
      "original_position" : 53,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 288,
      "pull_request_review_id" : 495035585,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493885215",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493888647"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493888647"
         }
      },
      "author_association" : "MEMBER",
      "body" : "34da2198264cf90a7ae7f50a912a599f6fd66291\r\n\r\nThen change to `const PrecomputedTransactionData& cache` instead?",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-23T20:53:38Z",
      "diff_hunk" : "@@ -1322,6 +1375,75 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData* cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache != nullptr && cache->m_bip341_taproot_ready && cache->m_spent_outputs_ready);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493888647",
      "id" : 493888647,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4ODY0Nw==",
      "original_commit_id" : "34da2198264cf90a7ae7f50a912a599f6fd66291",
      "original_line" : 1491,
      "original_position" : 102,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 495035585,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493888647",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493901353"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493901353"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-23T21:18:39Z",
      "diff_hunk" : "@@ -1322,6 +1375,75 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData* cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache != nullptr && cache->m_bip341_taproot_ready && cache->m_spent_outputs_ready);\n+\n+    CHashWriter ss = HASHER_TAPSIGHASH;\n+\n+    // Epoch\n+    static constexpr uint8_t EPOCH = 0;\n+    ss << EPOCH;\n+\n+    // Hash type\n+    const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n+    const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;\n+    if (!(hash_type <= 0x03 || (hash_type >= 0x81 && hash_type <= 0x83))) return false;\n+    ss << hash_type;\n+\n+    // Transaction level data\n+    ss << tx_to.nVersion;\n+    ss << tx_to.nLockTime;\n+    if (input_type != SIGHASH_ANYONECANPAY) {\n+        ss << cache->m_prevouts_single_hash;\n+        ss << cache->m_spent_amounts_single_hash;\n+        ss << cache->m_spent_scripts_single_hash;\n+        ss << cache->m_sequences_single_hash;\n+    }\n+    if (output_type == SIGHASH_ALL) {\n+        ss << cache->m_outputs_single_hash;\n+    }\n+\n+    // Data about the input/prevout being spent\n+    const auto* witstack = &tx_to.vin[in_pos].scriptWitness.stack;\n+    bool have_annex = witstack->size() > 1 && witstack->back().size() > 0 && witstack->back()[0] == ANNEX_TAG;\n+    const uint8_t spend_type = (ext_flag << 1) + (have_annex ? 1 : 0); // The low bit indicates whether an annex is present.\n+    ss << spend_type;\n+    if (input_type == SIGHASH_ANYONECANPAY) {\n+        ss << tx_to.vin[in_pos].prevout;\n+        ss << cache->m_spent_outputs[in_pos];\n+        ss << tx_to.vin[in_pos].nSequence;\n+    } else {\n+        ss << in_pos;\n+    }\n+    if (have_annex) {\n+        ss << (CHashWriter(SER_GETHASH, 0) << witstack->back()).GetSHA256();\n+    }\n+\n+    // Data about the output(s)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493901353",
      "id" : 493901353,
      "in_reply_to_id" : 493822427,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkwMTM1Mw==",
      "original_commit_id" : "34da2198264cf90a7ae7f50a912a599f6fd66291",
      "original_line" : 1435,
      "original_position" : 145,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 495056275,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493901353",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493901411"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493901411"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-23T21:18:46Z",
      "diff_hunk" : "@@ -1565,7 +1675,7 @@ bool GenericTransactionSignatureChecker<T>::CheckSchnorrSignature(Span<const uns\n         if (hashtype == SIGHASH_DEFAULT) return false;\n     }\n     uint256 sighash;\n-    if (!SignatureHashSchnorr(sighash, execdata, *txTo, nIn, hashtype, sigversion, this->txdata)) return false;\n+    if (!SignatureHashSchnorr(sighash, execdata, *txTo, nIn, hashtype, sigversion, 0x00, this->txdata)) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493901411",
      "id" : 493901411,
      "in_reply_to_id" : 493838107,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkwMTQxMQ==",
      "original_commit_id" : "390252cd5bc562a40ab193c044ded32126c3ffbd",
      "original_line" : 1678,
      "original_position" : 249,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 495056352,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493901411",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493901512"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493901512"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Added a comment in script/interpreter.h.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-23T21:18:59Z",
      "diff_hunk" : "@@ -1610,5 +1640,50 @@ BOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_invalid_flags)\n     BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_INVALID_FLAGS);\n }\n \n+BOOST_AUTO_TEST_CASE(script_taproot)\n+{\n+    UniValue tests = read_json(std::string(std::begin(json_tests::script_taproot_tests), std::end(json_tests::script_taproot_tests)));\n+\n+    static constexpr unsigned int VERIFY_FLAGS =\n+        SCRIPT_VERIFY_P2SH |\n+        SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY |\n+        SCRIPT_VERIFY_CHECKSEQUENCEVERIFY |\n+        SCRIPT_VERIFY_WITNESS |\n+        SCRIPT_VERIFY_NULLFAIL |\n+        SCRIPT_VERIFY_TAPROOT;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493901512",
      "id" : 493901512,
      "in_reply_to_id" : 493865077,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkwMTUxMg==",
      "original_commit_id" : "fe5cf2ed6adbf2271553f97c61de4d59bee20c05",
      "original_line" : 1653,
      "original_position" : 75,
      "original_start_line" : null,
      "path" : "src/test/script_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 495056479,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493901512",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I addressed comments by @instagibbs, and made the unit test vectors test more and generic and made it qa-assets based (see corresponding PR https://github.com/bitcoin-core/qa-assets/pull/27). Changes are in two new sections in #19997.\r\n\r\nI'm still working on polishing up the tooling used to create script_assets_test.json. At this point they don't test anything that (many iterations of) feature_taproot.py doesn't test, so I think review should be focused on that.",
      "created_at" : "2020-09-23T21:25:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-697981325",
      "id" : 697981325,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5Nzk4MTMyNQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-23T21:28:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/697981325",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493906842"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493906842"
         }
      },
      "author_association" : "MEMBER",
      "body" : "No, one input can be segwit and another can be taproot.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-23T21:30:34Z",
      "diff_hunk" : "@@ -1291,23 +1291,76 @@ uint256 GetOutputsSHA256(const T& txTo)\n     return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n \n     m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n+    }\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = SHA256Uint256(GetPrevoutsSHA256(txTo));\n-        hashSequence = SHA256Uint256(GetSequencesSHA256(txTo));\n-        hashOutputs = SHA256Uint256(GetOutputsSHA256(txTo));\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143_segwit = false;\n+    bool uses_bip341_taproot = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every native witness v1 spend as a Taproot spend. This only works if spent_outputs was\n+                // provided as well, but if it wasn't, actual validation will fail anyway.\n+                uses_bip341_taproot = true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493906842",
      "id" : 493906842,
      "in_reply_to_id" : 493885215,
      "line" : 1444,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkwNjg0Mg==",
      "original_commit_id" : "34da2198264cf90a7ae7f50a912a599f6fd66291",
      "original_line" : 1444,
      "original_position" : 53,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 288,
      "pull_request_review_id" : 495063019,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493906842",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493911557"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493911557"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This should just be an optimization, ie if there are 100 inputs and the first is segwit v0 and the second is segwit v1, with @promag's suggestion it would then stop checking with both `uses_bip341_taproot` and `uses_bip143_segwit` set correctly, vs with the current implementation it would continue and check the remaining 98 inputs.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-23T21:41:19Z",
      "diff_hunk" : "@@ -1291,23 +1291,76 @@ uint256 GetOutputsSHA256(const T& txTo)\n     return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n \n     m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n+    }\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = SHA256Uint256(GetPrevoutsSHA256(txTo));\n-        hashSequence = SHA256Uint256(GetSequencesSHA256(txTo));\n-        hashOutputs = SHA256Uint256(GetOutputsSHA256(txTo));\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143_segwit = false;\n+    bool uses_bip341_taproot = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every native witness v1 spend as a Taproot spend. This only works if spent_outputs was\n+                // provided as well, but if it wasn't, actual validation will fail anyway.\n+                uses_bip341_taproot = true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493911557",
      "id" : 493911557,
      "in_reply_to_id" : 493885215,
      "line" : 1444,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxMTU1Nw==",
      "original_commit_id" : "34da2198264cf90a7ae7f50a912a599f6fd66291",
      "original_line" : 1444,
      "original_position" : 53,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 288,
      "pull_request_review_id" : 495068952,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493911557",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/15256660?v=4",
         "events_url" : "https://api.github.com/users/benthecarman/events{/privacy}",
         "followers_url" : "https://api.github.com/users/benthecarman/followers",
         "following_url" : "https://api.github.com/users/benthecarman/following{/other_user}",
         "gists_url" : "https://api.github.com/users/benthecarman/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/benthecarman",
         "id" : 15256660,
         "login" : "benthecarman",
         "node_id" : "MDQ6VXNlcjE1MjU2NjYw",
         "organizations_url" : "https://api.github.com/users/benthecarman/orgs",
         "received_events_url" : "https://api.github.com/users/benthecarman/received_events",
         "repos_url" : "https://api.github.com/users/benthecarman/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/benthecarman/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/benthecarman/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/benthecarman"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493913215"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493913215"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Oh, I misread. Indeed, that's a potentially useful and simple optimization. I'll implement it when I make further changes.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-23T21:44:56Z",
      "diff_hunk" : "@@ -1291,23 +1291,76 @@ uint256 GetOutputsSHA256(const T& txTo)\n     return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n \n     m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n+    }\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = SHA256Uint256(GetPrevoutsSHA256(txTo));\n-        hashSequence = SHA256Uint256(GetSequencesSHA256(txTo));\n-        hashOutputs = SHA256Uint256(GetOutputsSHA256(txTo));\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143_segwit = false;\n+    bool uses_bip341_taproot = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every native witness v1 spend as a Taproot spend. This only works if spent_outputs was\n+                // provided as well, but if it wasn't, actual validation will fail anyway.\n+                uses_bip341_taproot = true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r493913215",
      "id" : 493913215,
      "in_reply_to_id" : 493885215,
      "line" : 1444,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxMzIxNQ==",
      "original_commit_id" : "34da2198264cf90a7ae7f50a912a599f6fd66291",
      "original_line" : 1444,
      "original_position" : 53,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 288,
      "pull_request_review_id" : 495070960,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493913215",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "re-ACK https://github.com/bitcoin/bitcoin/pull/19953/commits/528ed883558b0bdac97fa64ada560906c322d021\r\n\r\n",
      "created_at" : "2020-09-24T13:43:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-698352605",
      "id" : 698352605,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5ODM1MjYwNQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-24T13:43:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/698352605",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r494730343"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494730343"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-25T03:43:44Z",
      "diff_hunk" : "@@ -1291,23 +1291,76 @@ uint256 GetOutputsSHA256(const T& txTo)\n     return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n \n     m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n+    }\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = SHA256Uint256(GetPrevoutsSHA256(txTo));\n-        hashSequence = SHA256Uint256(GetSequencesSHA256(txTo));\n-        hashOutputs = SHA256Uint256(GetOutputsSHA256(txTo));\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143_segwit = false;\n+    bool uses_bip341_taproot = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every native witness v1 spend as a Taproot spend. This only works if spent_outputs was\n+                // provided as well, but if it wasn't, actual validation will fail anyway.\n+                uses_bip341_taproot = true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r494730343",
      "id" : 494730343,
      "in_reply_to_id" : 493885215,
      "line" : 1444,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDczMDM0Mw==",
      "original_commit_id" : "34da2198264cf90a7ae7f50a912a599f6fd66291",
      "original_line" : 1444,
      "original_position" : 53,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 288,
      "pull_request_review_id" : 496091133,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494730343",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r494730380"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494730380"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-25T03:43:56Z",
      "diff_hunk" : "@@ -1322,6 +1375,75 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData* cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache != nullptr && cache->m_bip341_taproot_ready && cache->m_spent_outputs_ready);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r494730380",
      "id" : 494730380,
      "in_reply_to_id" : 493888647,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDczMDM4MA==",
      "original_commit_id" : "34da2198264cf90a7ae7f50a912a599f6fd66291",
      "original_line" : 1491,
      "original_position" : 102,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 496091175,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494730380",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I addressed comments by @promag, added a functional test to verify CLEANSTACK is consensus-enforced in tapscript, and gave tapscript's MINIMALIF a separate error code (effectively addressing #20009 to the extent it affects this PR).",
      "created_at" : "2020-09-25T03:45:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-698703640",
      "id" : 698703640,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5ODcwMzY0MA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-25T03:45:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/698703640",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "reACK https://github.com/bitcoin/bitcoin/pull/19953/commits/80efcba5e7ad84f68f5cd59c05fc87134fc9fb69",
      "created_at" : "2020-09-25T12:11:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-698893603",
      "id" : 698893603,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5ODg5MzYwMw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-25T12:11:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/698893603",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r496155450"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/496155450"
         }
      },
      "author_association" : "NONE",
      "body" : "This line is very compact.\r\n\r\nLooks like those numeric literals are based on SIGHASH_INPUT_MASK. If they are, could they not be constructed from it? It is weird to have logic based partly on the enum, and partly on hard coded numeric literals.\r\n\r\nI think this could be split up into two if's, each returning false. Then, each of those branches could be explaining the situation and the reason for rejection.\r\n\r\nEvery time I see a negation of a boolean operator, I do de-morgan in my head. Either way, if you prefer this with or without the outer negation, I think splitting it up would really be preferable, it would be readable for all kinds of brains.\r\n\r\nThis is not complicated logic, and it is easy to avoid having it look complex. Just my two cents :)",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-28T18:37:15Z",
      "diff_hunk" : "@@ -1291,35 +1389,176 @@ uint256 GetOutputsSHA256(const T& txTo)\n     return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n+\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n+    }\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = SHA256Uint256(GetPrevoutsSHA256(txTo));\n-        hashSequence = SHA256Uint256(GetSequencesSHA256(txTo));\n-        hashOutputs = SHA256Uint256(GetOutputsSHA256(txTo));\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143_segwit = false;\n+    bool uses_bip341_taproot = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every native witness v1 spend as a Taproot spend. This only works if spent_outputs was\n+                // provided as well, but if it wasn't, actual validation will fail anyway.\n+                uses_bip341_taproot = true;\n+            } else {\n+                // Treat every spend that's not known to native witness v1 as a Witness v0 spend. This branch may\n+                // also be taken for unknown witness versions, but it is harmless, and being precise would require\n+                // P2SH evaluation to find the redeemScript.\n+                uses_bip143_segwit = true;\n+            }\n+        }\n+        if (uses_bip341_taproot && uses_bip143_segwit) break; // No need to scan further if we already need all.\n     }\n \n-    m_ready = true;\n+    if (uses_bip143_segwit || uses_bip341_taproot) {\n+        // Computations shared between both sighash schemes.\n+        m_prevouts_single_hash = GetPrevoutsSHA256(txTo);\n+        m_sequences_single_hash = GetSequencesSHA256(txTo);\n+        m_outputs_single_hash = GetOutputsSHA256(txTo);\n+    }\n+    if (uses_bip143_segwit) {\n+        hashPrevouts = SHA256Uint256(m_prevouts_single_hash);\n+        hashSequence = SHA256Uint256(m_sequences_single_hash);\n+        hashOutputs = SHA256Uint256(m_outputs_single_hash);\n+        m_bip143_segwit_ready = true;\n+    }\n+    if (uses_bip341_taproot) {\n+        m_spent_amounts_single_hash = GetSpentAmountsSHA256(m_spent_outputs);\n+        m_spent_scripts_single_hash = GetSpentScriptsSHA256(m_spent_outputs);\n+        m_bip341_taproot_ready = true;\n+    }\n }\n \n template <class T>\n PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n {\n-    Init(txTo);\n+    Init(txTo, {});\n }\n \n // explicit instantiation\n-template void PrecomputedTransactionData::Init(const CTransaction& txTo);\n-template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo);\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+static const CHashWriter HASHER_TAPLEAF = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HASHER_TAPBRANCH = TaggedHash(\"TapBranch\");\n+static const CHashWriter HASHER_TAPTWEAK = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const uint8_t key_version, const PrecomputedTransactionData& cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    case SigVersion::TAPSCRIPT:\n+        ext_flag = 1;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache.m_bip341_taproot_ready && cache.m_spent_outputs_ready);\n+\n+    CHashWriter ss = HASHER_TAPSIGHASH;\n+\n+    // Epoch\n+    static constexpr uint8_t EPOCH = 0;\n+    ss << EPOCH;\n+\n+    // Hash type\n+    const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n+    const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;\n+    if (!(hash_type <= 0x03 || (hash_type >= 0x81 && hash_type <= 0x83))) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r496155450",
      "id" : 496155450,
      "line" : 1523,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE1NTQ1MA==",
      "original_commit_id" : "80efcba5e7ad84f68f5cd59c05fc87134fc9fb69",
      "original_line" : 1523,
      "original_position" : 348,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 370,
      "pull_request_review_id" : 497796796,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/496155450",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/284023?v=4",
         "events_url" : "https://api.github.com/users/ysangkok/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ysangkok/followers",
         "following_url" : "https://api.github.com/users/ysangkok/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ysangkok/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ysangkok",
         "id" : 284023,
         "login" : "ysangkok",
         "node_id" : "MDQ6VXNlcjI4NDAyMw==",
         "organizations_url" : "https://api.github.com/users/ysangkok/orgs",
         "received_events_url" : "https://api.github.com/users/ysangkok/received_events",
         "repos_url" : "https://api.github.com/users/ysangkok/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ysangkok/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ysangkok/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ysangkok"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r496159580"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/496159580"
         }
      },
      "author_association" : "MEMBER",
      "body" : "That would be incorrect.\r\n\r\nde-morganing it gives you `!(hash_type <= 0x03) && !(hash_type >= 0x81 && hash_type <= 0x83)`, which is a conjunction at the top level. Splitting that up into two separate `if`s would make it a disjunction.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-09-28T18:44:59Z",
      "diff_hunk" : "@@ -1291,35 +1389,176 @@ uint256 GetOutputsSHA256(const T& txTo)\n     return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n+\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n+    }\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = SHA256Uint256(GetPrevoutsSHA256(txTo));\n-        hashSequence = SHA256Uint256(GetSequencesSHA256(txTo));\n-        hashOutputs = SHA256Uint256(GetOutputsSHA256(txTo));\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143_segwit = false;\n+    bool uses_bip341_taproot = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every native witness v1 spend as a Taproot spend. This only works if spent_outputs was\n+                // provided as well, but if it wasn't, actual validation will fail anyway.\n+                uses_bip341_taproot = true;\n+            } else {\n+                // Treat every spend that's not known to native witness v1 as a Witness v0 spend. This branch may\n+                // also be taken for unknown witness versions, but it is harmless, and being precise would require\n+                // P2SH evaluation to find the redeemScript.\n+                uses_bip143_segwit = true;\n+            }\n+        }\n+        if (uses_bip341_taproot && uses_bip143_segwit) break; // No need to scan further if we already need all.\n     }\n \n-    m_ready = true;\n+    if (uses_bip143_segwit || uses_bip341_taproot) {\n+        // Computations shared between both sighash schemes.\n+        m_prevouts_single_hash = GetPrevoutsSHA256(txTo);\n+        m_sequences_single_hash = GetSequencesSHA256(txTo);\n+        m_outputs_single_hash = GetOutputsSHA256(txTo);\n+    }\n+    if (uses_bip143_segwit) {\n+        hashPrevouts = SHA256Uint256(m_prevouts_single_hash);\n+        hashSequence = SHA256Uint256(m_sequences_single_hash);\n+        hashOutputs = SHA256Uint256(m_outputs_single_hash);\n+        m_bip143_segwit_ready = true;\n+    }\n+    if (uses_bip341_taproot) {\n+        m_spent_amounts_single_hash = GetSpentAmountsSHA256(m_spent_outputs);\n+        m_spent_scripts_single_hash = GetSpentScriptsSHA256(m_spent_outputs);\n+        m_bip341_taproot_ready = true;\n+    }\n }\n \n template <class T>\n PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n {\n-    Init(txTo);\n+    Init(txTo, {});\n }\n \n // explicit instantiation\n-template void PrecomputedTransactionData::Init(const CTransaction& txTo);\n-template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo);\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+static const CHashWriter HASHER_TAPLEAF = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HASHER_TAPBRANCH = TaggedHash(\"TapBranch\");\n+static const CHashWriter HASHER_TAPTWEAK = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const uint8_t key_version, const PrecomputedTransactionData& cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    case SigVersion::TAPSCRIPT:\n+        ext_flag = 1;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache.m_bip341_taproot_ready && cache.m_spent_outputs_ready);\n+\n+    CHashWriter ss = HASHER_TAPSIGHASH;\n+\n+    // Epoch\n+    static constexpr uint8_t EPOCH = 0;\n+    ss << EPOCH;\n+\n+    // Hash type\n+    const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n+    const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;\n+    if (!(hash_type <= 0x03 || (hash_type >= 0x81 && hash_type <= 0x83))) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r496159580",
      "id" : 496159580,
      "in_reply_to_id" : 496155450,
      "line" : 1523,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE1OTU4MA==",
      "original_commit_id" : "80efcba5e7ad84f68f5cd59c05fc87134fc9fb69",
      "original_line" : 1523,
      "original_position" : 348,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 370,
      "pull_request_review_id" : 497802044,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/496159580",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "A few updates (see https://github.com/bitcoin/bitcoin/pull/19997 for detailed history):\r\n* Fixed/clarified a few code comments addressing anonymous review\r\n* A few generic improvements to the functional test (include ECDSA tests with uncompressed pubkeys, cache witnesses)\r\n* Added support to the functional test to dump its generated tests in json format compatible with the unit test, and a fuzz \"test\" to help minimize it (it actually works as a fuzz test itself now too, though probably not a very good one)\r\n* Rebased on master to adapt the test for #20006.",
      "created_at" : "2020-10-02T08:23:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-702595992",
      "id" : 702595992,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwMjU5NTk5Mg==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-02T08:23:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/702595992",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r498710487"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498710487"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "just curious, why January 1, 2008?",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-02T09:20:16Z",
      "diff_hunk" : "@@ -86,6 +86,11 @@ class CMainParams : public CChainParams {\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999; // December 31, 2008\n \n+        // Deployment of Taproot (BIPs 340-342)\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].bit = 2;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nStartTime = 1199145601; // January 1, 2008",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r498710487",
      "id" : 498710487,
      "line" : 91,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcxMDQ4Nw==",
      "original_commit_id" : "c849dae8ce05ef5c92df6ec1bb77b9ea2e38240a",
      "original_line" : 91,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "src/chainparams.cpp",
      "position" : 6,
      "pull_request_review_id" : 500982998,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498710487",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/60179867?v=4",
         "events_url" : "https://api.github.com/users/decryp2kanon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/decryp2kanon/followers",
         "following_url" : "https://api.github.com/users/decryp2kanon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/decryp2kanon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/decryp2kanon",
         "id" : 60179867,
         "login" : "decryp2kanon",
         "node_id" : "MDQ6VXNlcjYwMTc5ODY3",
         "organizations_url" : "https://api.github.com/users/decryp2kanon/orgs",
         "received_events_url" : "https://api.github.com/users/decryp2kanon/received_events",
         "repos_url" : "https://api.github.com/users/decryp2kanon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/decryp2kanon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/decryp2kanon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/decryp2kanon"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "reACK `c849dae`",
      "created_at" : "2020-10-02T12:09:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-702698495",
      "id" : 702698495,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwMjY5ODQ5NQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-02T12:09:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/702698495",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/15256660?v=4",
         "events_url" : "https://api.github.com/users/benthecarman/events{/privacy}",
         "followers_url" : "https://api.github.com/users/benthecarman/followers",
         "following_url" : "https://api.github.com/users/benthecarman/following{/other_user}",
         "gists_url" : "https://api.github.com/users/benthecarman/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/benthecarman",
         "id" : 15256660,
         "login" : "benthecarman",
         "node_id" : "MDQ6VXNlcjE1MjU2NjYw",
         "organizations_url" : "https://api.github.com/users/benthecarman/orgs",
         "received_events_url" : "https://api.github.com/users/benthecarman/received_events",
         "repos_url" : "https://api.github.com/users/benthecarman/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/benthecarman/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/benthecarman/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/benthecarman"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r498849526"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498849526"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Copying `DEPLOYMENT_TESTDUMMY` I suspect",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-02T14:16:27Z",
      "diff_hunk" : "@@ -86,6 +86,11 @@ class CMainParams : public CChainParams {\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999; // December 31, 2008\n \n+        // Deployment of Taproot (BIPs 340-342)\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].bit = 2;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nStartTime = 1199145601; // January 1, 2008",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r498849526",
      "id" : 498849526,
      "in_reply_to_id" : 498710487,
      "line" : 91,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg0OTUyNg==",
      "original_commit_id" : "c849dae8ce05ef5c92df6ec1bb77b9ea2e38240a",
      "original_line" : 91,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "src/chainparams.cpp",
      "position" : 6,
      "pull_request_review_id" : 501174738,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498849526",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "reACK https://github.com/bitcoin/bitcoin/pull/19953/commits/c849dae8ce05ef5c92df6ec1bb77b9ea2e38240a",
      "created_at" : "2020-10-02T14:16:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-702759759",
      "id" : 702759759,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwMjc1OTc1OQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-02T14:16:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/702759759",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "Ack https://github.com/bitcoin/bitcoin/pull/19953/commits/c849dae8ce05ef5c92df6ec1bb77b9ea2e38240a",
      "created_at" : "2020-10-02T14:25:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-702764639",
      "id" : 702764639,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwMjc2NDYzOQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-02T14:25:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/702764639",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/11212268?v=4",
         "events_url" : "https://api.github.com/users/gruve-p/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gruve-p/followers",
         "following_url" : "https://api.github.com/users/gruve-p/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gruve-p/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gruve-p",
         "id" : 11212268,
         "login" : "gruve-p",
         "node_id" : "MDQ6VXNlcjExMjEyMjY4",
         "organizations_url" : "https://api.github.com/users/gruve-p/orgs",
         "received_events_url" : "https://api.github.com/users/gruve-p/received_events",
         "repos_url" : "https://api.github.com/users/gruve-p/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gruve-p/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gruve-p/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gruve-p"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r498921722"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498921722"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Indeed, just whatever time sufficiently in the past.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-02T16:21:31Z",
      "diff_hunk" : "@@ -86,6 +86,11 @@ class CMainParams : public CChainParams {\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999; // December 31, 2008\n \n+        // Deployment of Taproot (BIPs 340-342)\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].bit = 2;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nStartTime = 1199145601; // January 1, 2008",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r498921722",
      "id" : 498921722,
      "in_reply_to_id" : 498710487,
      "line" : 91,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMTcyMg==",
      "original_commit_id" : "c849dae8ce05ef5c92df6ec1bb77b9ea2e38240a",
      "original_line" : 91,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "src/chainparams.cpp",
      "position" : 6,
      "pull_request_review_id" : 501274808,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/498921722",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r499133023"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499133023"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: a new line?",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-03T09:39:29Z",
      "diff_hunk" : "@@ -1470,6 +1500,7 @@ BOOST_AUTO_TEST_CASE(script_HasValidOps)\n     BOOST_CHECK(!script.HasValidOps());\n }\n \n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r499133023",
      "id" : 499133023,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEzMzAyMw==",
      "original_commit_id" : "c849dae8ce05ef5c92df6ec1bb77b9ea2e38240a",
      "original_line" : 1503,
      "original_position" : 62,
      "original_start_line" : null,
      "path" : "src/test/script_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 501534261,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499133023",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/60179867?v=4",
         "events_url" : "https://api.github.com/users/decryp2kanon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/decryp2kanon/followers",
         "following_url" : "https://api.github.com/users/decryp2kanon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/decryp2kanon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/decryp2kanon",
         "id" : 60179867,
         "login" : "decryp2kanon",
         "node_id" : "MDQ6VXNlcjYwMTc5ODY3",
         "organizations_url" : "https://api.github.com/users/decryp2kanon/orgs",
         "received_events_url" : "https://api.github.com/users/decryp2kanon/received_events",
         "repos_url" : "https://api.github.com/users/decryp2kanon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/decryp2kanon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/decryp2kanon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/decryp2kanon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r499133297"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499133297"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: new line?",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-03T09:43:16Z",
      "diff_hunk" : "@@ -1,15 +1,30 @@\n-# Copyright (c) 2019 Pieter Wuille\n+# Copyright (c) 2019-2020 Pieter Wuille\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r499133297",
      "id" : 499133297,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEzMzI5Nw==",
      "original_commit_id" : "c849dae8ce05ef5c92df6ec1bb77b9ea2e38240a",
      "original_line" : 2,
      "original_position" : 3,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 501534499,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499133297",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/60179867?v=4",
         "events_url" : "https://api.github.com/users/decryp2kanon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/decryp2kanon/followers",
         "following_url" : "https://api.github.com/users/decryp2kanon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/decryp2kanon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/decryp2kanon",
         "id" : 60179867,
         "login" : "decryp2kanon",
         "node_id" : "MDQ6VXNlcjYwMTc5ODY3",
         "organizations_url" : "https://api.github.com/users/decryp2kanon/orgs",
         "received_events_url" : "https://api.github.com/users/decryp2kanon/received_events",
         "repos_url" : "https://api.github.com/users/decryp2kanon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/decryp2kanon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/decryp2kanon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/decryp2kanon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r499844996"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499844996"
         }
      },
      "author_association" : "MEMBER",
      "body" : "6577f465f3dad2460b2bee02ca662c7ebbe72e4c\r\nnit, avoids copying `ScriptExecutionData` and error is still the last one.\r\n```cpp\r\nbool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, const ScriptExecutionData& execdata, ScriptError* error = nullptr);\r\nbool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* error = nullptr)\r\n{\r\n    ScriptExecutionData execdata;\r\n    EvalScript(stack, script, flags, checker, sigversion, execdata, error);\r\n}\r\n",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-05T20:12:35Z",
      "diff_hunk" : "@@ -227,15 +237,15 @@ class GenericTransactionSignatureChecker : public BaseSignatureChecker\n     GenericTransactionSignatureChecker(const T* txToIn, unsigned int nInIn, const CAmount& amountIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(nullptr) {}\n     GenericTransactionSignatureChecker(const T* txToIn, unsigned int nInIn, const CAmount& amountIn, const PrecomputedTransactionData& txdataIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(&txdataIn) {}\n     bool CheckECDSASignature(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override;\n-    bool CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey, SigVersion sigversion) const override;\n+    bool CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey, SigVersion sigversion, const ScriptExecutionData& execdata) const override;\n     bool CheckLockTime(const CScriptNum& nLockTime) const override;\n     bool CheckSequence(const CScriptNum& nSequence) const override;\n };\n \n using TransactionSignatureChecker = GenericTransactionSignatureChecker<CTransaction>;\n using MutableTransactionSignatureChecker = GenericTransactionSignatureChecker<CMutableTransaction>;\n \n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* error = nullptr);\n+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* error = nullptr, ScriptExecutionData execdata = {});",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r499844996",
      "id" : 499844996,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg0NDk5Ng==",
      "original_commit_id" : "6577f465f3dad2460b2bee02ca662c7ebbe72e4c",
      "original_line" : 248,
      "original_position" : 40,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 502385340,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499844996",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r499865869"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499865869"
         }
      },
      "author_association" : "MEMBER",
      "body" : "That won't work, `EvalScript` needs a mutable `ScriptExecutionData` object.\r\n\r\nIt would be slightly cleaner to split the execdata into a fixed-at-VerifyScript-time part and a changed-during-execution part, but that'd be a even more annoying interface change.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-05T20:53:07Z",
      "diff_hunk" : "@@ -227,15 +237,15 @@ class GenericTransactionSignatureChecker : public BaseSignatureChecker\n     GenericTransactionSignatureChecker(const T* txToIn, unsigned int nInIn, const CAmount& amountIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(nullptr) {}\n     GenericTransactionSignatureChecker(const T* txToIn, unsigned int nInIn, const CAmount& amountIn, const PrecomputedTransactionData& txdataIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(&txdataIn) {}\n     bool CheckECDSASignature(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override;\n-    bool CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey, SigVersion sigversion) const override;\n+    bool CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey, SigVersion sigversion, const ScriptExecutionData& execdata) const override;\n     bool CheckLockTime(const CScriptNum& nLockTime) const override;\n     bool CheckSequence(const CScriptNum& nSequence) const override;\n };\n \n using TransactionSignatureChecker = GenericTransactionSignatureChecker<CTransaction>;\n using MutableTransactionSignatureChecker = GenericTransactionSignatureChecker<CMutableTransaction>;\n \n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* error = nullptr);\n+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* error = nullptr, ScriptExecutionData execdata = {});",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r499865869",
      "id" : 499865869,
      "in_reply_to_id" : 499844996,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg2NTg2OQ==",
      "original_commit_id" : "6577f465f3dad2460b2bee02ca662c7ebbe72e4c",
      "original_line" : 248,
      "original_position" : 40,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 502412021,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/499865869",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r500552248"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500552248"
         }
      },
      "author_association" : "MEMBER",
      "body" : "1ef50ed -nit\r\n```suggestion\r\n            const COutPoint& prevout = txin.prevout;\r\n```",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-06T19:43:52Z",
      "diff_hunk" : "@@ -1538,14 +1538,20 @@ bool CheckInputScripts(const CTransaction& tx, TxValidationState &state, const C\n         return true;\n     }\n \n-    if (!txdata.m_ready) {\n-        txdata.Init(tx);\n+    if (!txdata.m_spent_outputs_ready) {\n+        std::vector<CTxOut> spent_outputs;\n+        spent_outputs.reserve(tx.vin.size());\n+\n+        for (const auto& txin : tx.vin) {\n+            const COutPoint &prevout = txin.prevout;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r500552248",
      "id" : 500552248,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU1MjI0OA==",
      "original_commit_id" : "c849dae8ce05ef5c92df6ec1bb77b9ea2e38240a",
      "original_line" : 1546,
      "original_position" : 11,
      "original_start_line" : null,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 503301437,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500552248",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r500554420"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500554420"
         }
      },
      "author_association" : "MEMBER",
      "body" : "1ef50ed perhaps, per https://github.com/bitcoin/bitcoin/pull/19953#discussion_r500578940\r\n```suggestion\r\nvoid PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut>&& spent_outputs)\r\n```",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-06T19:48:03Z",
      "diff_hunk" : "@@ -1291,35 +1389,178 @@ uint256 GetOutputsSHA256(const T& txTo)\n     return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r500554420",
      "id" : 500554420,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU1NDQyMA==",
      "original_commit_id" : "c849dae8ce05ef5c92df6ec1bb77b9ea2e38240a",
      "original_line" : 1421,
      "original_position" : 246,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 503301437,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500554420",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r500571274"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500571274"
         }
      },
      "author_association" : "MEMBER",
      "body" : "31c322a perhaps use constexpr\r\n```suggestion\r\nstatic constexpr unsigned int ANNEX_TAG = 0x50;\r\n```",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-06T20:19:25Z",
      "diff_hunk" : "@@ -44,6 +44,17 @@ static const unsigned int LOCKTIME_THRESHOLD = 500000000; // Tue Nov  5 00:53:20\n // SEQUENCE_FINAL).\n static const uint32_t LOCKTIME_MAX = 0xFFFFFFFFU;\n \n+// Tag for input annex. If there are at least two witness elements for a transaction input,\n+// and the first byte of the last element is 0x50, this last element is called annex, and\n+// has meanings independent of the script\n+static const unsigned int ANNEX_TAG = 0x50;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r500571274",
      "id" : 500571274,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU3MTI3NA==",
      "original_commit_id" : "c849dae8ce05ef5c92df6ec1bb77b9ea2e38240a",
      "original_line" : 50,
      "original_position" : 7,
      "original_start_line" : null,
      "path" : "src/script/script.h",
      "position" : null,
      "pull_request_review_id" : 503301437,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500571274",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r500576577"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500576577"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commits 31c322a (`in_pos, hash_type, sigversion`) and 332dc13bdc (`key_version`) perhaps remove constness for by-value arguments, e.g. per discussion at https://github.com/bitcoin/bitcoin/pull/19845#discussion_r489776345\r\n```suggestion\r\nbool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, uint32_t in_pos, uint8_t hash_type, SigVersion sigversion, uint8_t key_version, const PrecomputedTransactionData& cache)\r\n```",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-06T20:29:29Z",
      "diff_hunk" : "@@ -1291,35 +1389,178 @@ uint256 GetOutputsSHA256(const T& txTo)\n     return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n+\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n+    }\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = SHA256Uint256(GetPrevoutsSHA256(txTo));\n-        hashSequence = SHA256Uint256(GetSequencesSHA256(txTo));\n-        hashOutputs = SHA256Uint256(GetOutputsSHA256(txTo));\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143_segwit = false;\n+    bool uses_bip341_taproot = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every witness-bearing spend with 34-byte scriptPubKey that starts with OP_1 as a Taproot\n+                // spend. This only works if spent_outputs was provided as well, but if it wasn't, actual validation\n+                // will fail anyway. Note that this branch may trigger for scriptPubKeys that aren't actually segwit\n+                // but in that case validation will fail as SCRIPT_ERR_WITNESS_UNEXPECTED anyway.\n+                uses_bip341_taproot = true;\n+            } else {\n+                // Treat every spend that's not known to native witness v1 as a Witness v0 spend. This branch may\n+                // also be taken for unknown witness versions, but it is harmless, and being precise would require\n+                // P2SH evaluation to find the redeemScript.\n+                uses_bip143_segwit = true;\n+            }\n+        }\n+        if (uses_bip341_taproot && uses_bip143_segwit) break; // No need to scan further if we already need all.\n     }\n \n-    m_ready = true;\n+    if (uses_bip143_segwit || uses_bip341_taproot) {\n+        // Computations shared between both sighash schemes.\n+        m_prevouts_single_hash = GetPrevoutsSHA256(txTo);\n+        m_sequences_single_hash = GetSequencesSHA256(txTo);\n+        m_outputs_single_hash = GetOutputsSHA256(txTo);\n+    }\n+    if (uses_bip143_segwit) {\n+        hashPrevouts = SHA256Uint256(m_prevouts_single_hash);\n+        hashSequence = SHA256Uint256(m_sequences_single_hash);\n+        hashOutputs = SHA256Uint256(m_outputs_single_hash);\n+        m_bip143_segwit_ready = true;\n+    }\n+    if (uses_bip341_taproot) {\n+        m_spent_amounts_single_hash = GetSpentAmountsSHA256(m_spent_outputs);\n+        m_spent_scripts_single_hash = GetSpentScriptsSHA256(m_spent_outputs);\n+        m_bip341_taproot_ready = true;\n+    }\n }\n \n template <class T>\n PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n {\n-    Init(txTo);\n+    Init(txTo, {});\n }\n \n // explicit instantiation\n-template void PrecomputedTransactionData::Init(const CTransaction& txTo);\n-template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo);\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+static const CHashWriter HASHER_TAPLEAF = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HASHER_TAPBRANCH = TaggedHash(\"TapBranch\");\n+static const CHashWriter HASHER_TAPTWEAK = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const uint8_t key_version, const PrecomputedTransactionData& cache)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r500576577",
      "id" : 500576577,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU3NjU3Nw==",
      "original_commit_id" : "c849dae8ce05ef5c92df6ec1bb77b9ea2e38240a",
      "original_line" : 1490,
      "original_position" : 325,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 503301437,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500576577",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r500578719"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500578719"
         }
      },
      "author_association" : "MEMBER",
      "body" : "1ef50ed perhaps, per https://github.com/bitcoin/bitcoin/pull/19953#discussion_r500578940\r\n```diff\r\n-template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\r\n-template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\r\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut>&& spent_outputs);\r\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut>&& spent_outputs);\r\n```",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-06T20:33:33Z",
      "diff_hunk" : "@@ -1291,35 +1389,178 @@ uint256 GetOutputsSHA256(const T& txTo)\n     return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n+\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n+    }\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = SHA256Uint256(GetPrevoutsSHA256(txTo));\n-        hashSequence = SHA256Uint256(GetSequencesSHA256(txTo));\n-        hashOutputs = SHA256Uint256(GetOutputsSHA256(txTo));\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143_segwit = false;\n+    bool uses_bip341_taproot = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every witness-bearing spend with 34-byte scriptPubKey that starts with OP_1 as a Taproot\n+                // spend. This only works if spent_outputs was provided as well, but if it wasn't, actual validation\n+                // will fail anyway. Note that this branch may trigger for scriptPubKeys that aren't actually segwit\n+                // but in that case validation will fail as SCRIPT_ERR_WITNESS_UNEXPECTED anyway.\n+                uses_bip341_taproot = true;\n+            } else {\n+                // Treat every spend that's not known to native witness v1 as a Witness v0 spend. This branch may\n+                // also be taken for unknown witness versions, but it is harmless, and being precise would require\n+                // P2SH evaluation to find the redeemScript.\n+                uses_bip143_segwit = true;\n+            }\n+        }\n+        if (uses_bip341_taproot && uses_bip143_segwit) break; // No need to scan further if we already need all.\n     }\n \n-    m_ready = true;\n+    if (uses_bip143_segwit || uses_bip341_taproot) {\n+        // Computations shared between both sighash schemes.\n+        m_prevouts_single_hash = GetPrevoutsSHA256(txTo);\n+        m_sequences_single_hash = GetSequencesSHA256(txTo);\n+        m_outputs_single_hash = GetOutputsSHA256(txTo);\n+    }\n+    if (uses_bip143_segwit) {\n+        hashPrevouts = SHA256Uint256(m_prevouts_single_hash);\n+        hashSequence = SHA256Uint256(m_sequences_single_hash);\n+        hashOutputs = SHA256Uint256(m_outputs_single_hash);\n+        m_bip143_segwit_ready = true;\n+    }\n+    if (uses_bip341_taproot) {\n+        m_spent_amounts_single_hash = GetSpentAmountsSHA256(m_spent_outputs);\n+        m_spent_scripts_single_hash = GetSpentScriptsSHA256(m_spent_outputs);\n+        m_bip341_taproot_ready = true;\n+    }\n }\n \n template <class T>\n PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n {\n-    Init(txTo);\n+    Init(txTo, {});\n }\n \n // explicit instantiation\n-template void PrecomputedTransactionData::Init(const CTransaction& txTo);\n-template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo);\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r500578719",
      "id" : 500578719,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU3ODcxOQ==",
      "original_commit_id" : "c849dae8ce05ef5c92df6ec1bb77b9ea2e38240a",
      "original_line" : 1480,
      "original_position" : 315,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 503301437,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500578719",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r500578940"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500578940"
         }
      },
      "author_association" : "MEMBER",
      "body" : "1ef50ed perhaps, as the caller is `txdata.Init(tx, std::move(spent_outputs));`, if we want to force callers to move it\r\n\r\n```suggestion\r\n    void Init(const T& tx, std::vector<CTxOut>&& spent_outputs);\r\n```\r\n",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-06T20:34:03Z",
      "diff_hunk" : "@@ -114,41 +125,111 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 19),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 20),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    // BIP341 precomputed data.\n+    // These are single-SHA256, see https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-15.\n+    uint256 m_prevouts_single_hash;\n+    uint256 m_sequences_single_hash;\n+    uint256 m_outputs_single_hash;\n+    uint256 m_spent_amounts_single_hash;\n+    uint256 m_spent_scripts_single_hash;\n+    //! Whether the 5 fields above are initialized.\n+    bool m_bip341_taproot_ready = false;\n+\n+    // BIP143 precomputed data (double-SHA256).\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n-    bool m_ready = false;\n+    //! Whether the 3 fields above are initialized.\n+    bool m_bip143_segwit_ready = false;\n+\n+    std::vector<CTxOut> m_spent_outputs;\n+    //! Whether m_spent_outputs is initialized.\n+    bool m_spent_outputs_ready = false;\n \n     PrecomputedTransactionData() = default;\n \n     template <class T>\n-    void Init(const T& tx);\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r500578940",
      "id" : 500578940,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU3ODk0MA==",
      "original_commit_id" : "c849dae8ce05ef5c92df6ec1bb77b9ea2e38240a",
      "original_line" : 170,
      "original_position" : 95,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 503301437,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500578940",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r500588835"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500588835"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Actually, it's possible to avoid the copy still by just making it mutable, and using your idea of a wrapper to provide a default:\r\n\r\nhttps://github.com/sipa/bitcoin/commit/09b24d503a7b9baace0be3f51e53f2a095cf160b\r\n\r\n```patch\r\ndiff --git a/src/script/interpreter.cpp b/src/script/interpreter.cpp\r\nindex 9d25ec156a..f4cf24fee5 100644\r\n--- a/src/script/interpreter.cpp\r\n+++ b/src/script/interpreter.cpp\r\n@@ -428,8 +428,7 @@ static bool EvalChecksig(const valtype& sig, const valtype& pubkey, CScript::con\r\n     assert(false);\r\n }\r\n \r\n-\r\n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, ScriptExecutionData execdata)\r\n+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptExecutionData& execdata, ScriptError* serror)\r\n {\r\n     static const CScriptNum bnZero(0);\r\n     static const CScriptNum bnOne(1);\r\n@@ -1257,6 +1256,12 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\r\n     return set_success(serror);\r\n }\r\n \r\n+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)\r\n+{\r\n+    ScriptExecutionData execdata;\r\n+    return EvalScript(stack, script, flags, checker, sigversion, execdata, serror);\r\n+}\r\n+\r\n namespace {\r\n \r\n /**\r\n@@ -1776,7 +1781,7 @@ bool GenericTransactionSignatureChecker<T>::CheckSequence(const CScriptNum& nSeq\r\n template class GenericTransactionSignatureChecker<CTransaction>;\r\n template class GenericTransactionSignatureChecker<CMutableTransaction>;\r\n \r\n-static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, const ScriptExecutionData& execdata, ScriptError* serror)\r\n+static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, ScriptExecutionData& execdata, ScriptError* serror)\r\n {\r\n     std::vector<valtype> stack{stack_span.begin(), stack_span.end()};\r\n \r\n@@ -1810,7 +1815,7 @@ static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CS\r\n     }\r\n \r\n     // Run the script interpreter.\r\n-    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, serror, execdata)) return false;\r\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, execdata, serror)) return false;\r\n \r\n     // Scripts inside witness implicitly require cleanstack behaviour\r\n     if (stack.size() != 1) return set_error(serror, SCRIPT_ERR_CLEANSTACK);\r\ndiff --git a/src/script/interpreter.h b/src/script/interpreter.h\r\nindex c71a125e73..1050ed1550 100644\r\n--- a/src/script/interpreter.h\r\n+++ b/src/script/interpreter.h\r\n@@ -272,7 +272,8 @@ public:\r\n using TransactionSignatureChecker = GenericTransactionSignatureChecker<CTransaction>;\r\n using MutableTransactionSignatureChecker = GenericTransactionSignatureChecker<CMutableTransaction>;\r\n \r\n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* error = nullptr, ScriptExecutionData execdata = {});\r\n+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptExecutionData& execdata, ScriptError* error = nullptr);\r\n+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* error = nullptr);\r\n bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CScriptWitness* witness, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror = nullptr);\r\n \r\n size_t CountWitnessSigOps(const CScript& scriptSig, const CScript& scriptPubKey, const CScriptWitness* witness, unsigned int flags);\r\n```",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-06T20:52:59Z",
      "diff_hunk" : "@@ -227,15 +237,15 @@ class GenericTransactionSignatureChecker : public BaseSignatureChecker\n     GenericTransactionSignatureChecker(const T* txToIn, unsigned int nInIn, const CAmount& amountIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(nullptr) {}\n     GenericTransactionSignatureChecker(const T* txToIn, unsigned int nInIn, const CAmount& amountIn, const PrecomputedTransactionData& txdataIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(&txdataIn) {}\n     bool CheckECDSASignature(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override;\n-    bool CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey, SigVersion sigversion) const override;\n+    bool CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey, SigVersion sigversion, const ScriptExecutionData& execdata) const override;\n     bool CheckLockTime(const CScriptNum& nLockTime) const override;\n     bool CheckSequence(const CScriptNum& nSequence) const override;\n };\n \n using TransactionSignatureChecker = GenericTransactionSignatureChecker<CTransaction>;\n using MutableTransactionSignatureChecker = GenericTransactionSignatureChecker<CMutableTransaction>;\n \n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* error = nullptr);\n+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* error = nullptr, ScriptExecutionData execdata = {});",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r500588835",
      "id" : 500588835,
      "in_reply_to_id" : 499844996,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU4ODgzNQ==",
      "original_commit_id" : "6577f465f3dad2460b2bee02ca662c7ebbe72e4c",
      "original_line" : 248,
      "original_position" : 40,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 503349722,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500588835",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r500620335"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500620335"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-06T21:59:29Z",
      "diff_hunk" : "@@ -1470,6 +1500,7 @@ BOOST_AUTO_TEST_CASE(script_HasValidOps)\n     BOOST_CHECK(!script.HasValidOps());\n }\n \n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r500620335",
      "id" : 500620335,
      "in_reply_to_id" : 499133023,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYyMDMzNQ==",
      "original_commit_id" : "c849dae8ce05ef5c92df6ec1bb77b9ea2e38240a",
      "original_line" : 1503,
      "original_position" : 62,
      "original_start_line" : null,
      "path" : "src/test/script_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 503389650,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500620335",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r500620389"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500620389"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-06T21:59:36Z",
      "diff_hunk" : "@@ -1,15 +1,30 @@\n-# Copyright (c) 2019 Pieter Wuille\n+# Copyright (c) 2019-2020 Pieter Wuille\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r500620389",
      "id" : 500620389,
      "in_reply_to_id" : 499133297,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYyMDM4OQ==",
      "original_commit_id" : "c849dae8ce05ef5c92df6ec1bb77b9ea2e38240a",
      "original_line" : 2,
      "original_position" : 3,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 503389720,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500620389",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r500621654"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500621654"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've incorporated this patch, as I think it conceptually makes sense: `ScriptExecutionData`'s contents has a linear history, so there is no need to pass it as `const`.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-06T22:02:40Z",
      "diff_hunk" : "@@ -227,15 +237,15 @@ class GenericTransactionSignatureChecker : public BaseSignatureChecker\n     GenericTransactionSignatureChecker(const T* txToIn, unsigned int nInIn, const CAmount& amountIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(nullptr) {}\n     GenericTransactionSignatureChecker(const T* txToIn, unsigned int nInIn, const CAmount& amountIn, const PrecomputedTransactionData& txdataIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(&txdataIn) {}\n     bool CheckECDSASignature(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override;\n-    bool CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey, SigVersion sigversion) const override;\n+    bool CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey, SigVersion sigversion, const ScriptExecutionData& execdata) const override;\n     bool CheckLockTime(const CScriptNum& nLockTime) const override;\n     bool CheckSequence(const CScriptNum& nSequence) const override;\n };\n \n using TransactionSignatureChecker = GenericTransactionSignatureChecker<CTransaction>;\n using MutableTransactionSignatureChecker = GenericTransactionSignatureChecker<CMutableTransaction>;\n \n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* error = nullptr);\n+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* error = nullptr, ScriptExecutionData execdata = {});",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r500621654",
      "id" : 500621654,
      "in_reply_to_id" : 499844996,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYyMTY1NA==",
      "original_commit_id" : "6577f465f3dad2460b2bee02ca662c7ebbe72e4c",
      "original_line" : 248,
      "original_position" : 40,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 503391324,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500621654",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Addressed comments by @decryp2kanon and @promag. See detailed history in #19997.",
      "created_at" : "2020-10-06T22:04:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-704577840",
      "id" : 704577840,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwNDU3Nzg0MA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-06T22:07:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/704577840",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "reACK https://github.com/bitcoin/bitcoin/pull/19953/commits/7dfb7239773e7974bdb61f648bf8351a808a63a5",
      "created_at" : "2020-10-07T01:52:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-704645268",
      "id" : 704645268,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwNDY0NTI2OA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-07T01:52:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/704645268",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "reACK 7dfb723",
      "created_at" : "2020-10-07T04:35:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-704685630",
      "id" : 704685630,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwNDY4NTYzMA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-07T04:35:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/704685630",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/15256660?v=4",
         "events_url" : "https://api.github.com/users/benthecarman/events{/privacy}",
         "followers_url" : "https://api.github.com/users/benthecarman/followers",
         "following_url" : "https://api.github.com/users/benthecarman/following{/other_user}",
         "gists_url" : "https://api.github.com/users/benthecarman/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/benthecarman",
         "id" : 15256660,
         "login" : "benthecarman",
         "node_id" : "MDQ6VXNlcjE1MjU2NjYw",
         "organizations_url" : "https://api.github.com/users/benthecarman/orgs",
         "received_events_url" : "https://api.github.com/users/benthecarman/received_events",
         "repos_url" : "https://api.github.com/users/benthecarman/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/benthecarman/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/benthecarman/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/benthecarman"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r500883991"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500883991"
         }
      },
      "author_association" : "MEMBER",
      "body" : "c018355 perhaps use the same param name in the definition `XOnlyPubKey::XOnlyPubKey(Span<const unsigned char> in)` as in the declaration\r\n",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-07T09:52:26Z",
      "diff_hunk" : "@@ -206,6 +207,26 @@ class CPubKey\n     bool Derive(CPubKey& pubkeyChild, ChainCode &ccChild, unsigned int nChild, const ChainCode& cc) const;\n };\n \n+class XOnlyPubKey {\n+private:\n+    uint256 m_keydata;\n+\n+public:\n+    /** Construct an x-only pubkey from exactly 32 bytes. */\n+    XOnlyPubKey(Span<const unsigned char> input);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r500883991",
      "id" : 500883991,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDg4Mzk5MQ==",
      "original_commit_id" : "7dfb7239773e7974bdb61f648bf8351a808a63a5",
      "original_line" : 216,
      "original_position" : 27,
      "original_start_line" : null,
      "path" : "src/pubkey.h",
      "position" : null,
      "pull_request_review_id" : 503301437,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500883991",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r500887241"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500887241"
         }
      },
      "author_association" : "MEMBER",
      "body" : "c018355 perhaps use `constexpr` for these two declarations",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-07T09:57:40Z",
      "diff_hunk" : "@@ -34,18 +35,30 @@ class CSignatureCache\n         uint256 nonce = GetRandHash();\n         // We want the nonce to be 64 bytes long to force the hasher to process\n         // this chunk, which makes later hash computations more efficient. We\n-        // just write our 32-byte entropy twice to fill the 64 bytes.\n-        m_salted_hasher.Write(nonce.begin(), 32);\n-        m_salted_hasher.Write(nonce.begin(), 32);\n+        // just write our 32-byte entropy, and then pad with 'E' for ECDSA and\n+        // 'S' for Schnorr (followed by 0 bytes).\n+        static const unsigned char PADDING_ECDSA[32] = {'E'};\n+        static const unsigned char PADDING_SCHNORR[32] = {'S'};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r500887241",
      "id" : 500887241,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDg4NzI0MQ==",
      "original_commit_id" : "7dfb7239773e7974bdb61f648bf8351a808a63a5",
      "original_line" : 41,
      "original_position" : 22,
      "original_start_line" : null,
      "path" : "src/script/sigcache.cpp",
      "position" : null,
      "pull_request_review_id" : 503301437,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500887241",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r500900420"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500900420"
         }
      },
      "author_association" : "MEMBER",
      "body" : "3c2d549 constness not present in the declaration on by-value argument\r\n```suggestion\r\nbool XOnlyPubKey::CheckPayToContract(const XOnlyPubKey& base, const uint256& hash, bool parity) const\r\n```",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-07T10:19:58Z",
      "diff_hunk" : "@@ -166,6 +167,26 @@ int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_\n     return 1;\n }\n \n+XOnlyPubKey::XOnlyPubKey(Span<const unsigned char> in)\n+{\n+    assert(in.size() == 32);\n+    std::copy(in.begin(), in.end(), m_keydata.begin());\n+}\n+\n+bool XOnlyPubKey::VerifySchnorr(const uint256& msg, Span<const unsigned char> sigbytes) const {\n+    assert(sigbytes.size() == 64);\n+    secp256k1_xonly_pubkey pubkey;\n+    if (!secp256k1_xonly_pubkey_parse(secp256k1_context_verify, &pubkey, m_keydata.data())) return false;\n+    return secp256k1_schnorrsig_verify(secp256k1_context_verify, sigbytes.data(), msg.begin(), &pubkey);\n+}\n+\n+bool XOnlyPubKey::CheckPayToContract(const XOnlyPubKey& base, const uint256& hash, const bool parity) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r500900420",
      "id" : 500900420,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDkwMDQyMA==",
      "original_commit_id" : "7dfb7239773e7974bdb61f648bf8351a808a63a5",
      "original_line" : 183,
      "original_position" : 25,
      "original_start_line" : null,
      "path" : "src/pubkey.cpp",
      "position" : null,
      "pull_request_review_id" : 503301437,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/500900420",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501071063"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501071063"
         }
      },
      "author_association" : "MEMBER",
      "body" : "332dc13b perhaps use same doc style as other members of this struct, and also per `doc/developer-notes.md` \"To describe a member or variable\"\r\n```diff\r\n-    /** Whether m_validation_weight_left is initialized. */\r\n+    //! Whether m_validation_weight_left is initialized.\r\n     bool m_validation_weight_left_init = false;\r\n-    /** How much validation weight is left (decremented for every successful non-empty signature check). */\r\n+    //! How much validation weight is left (decremented for every successful non-empty signature check).\r\n```",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-07T14:44:02Z",
      "diff_hunk" : "@@ -114,41 +125,111 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 19),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 20),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    // BIP341 precomputed data.\n+    // These are single-SHA256, see https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-15.\n+    uint256 m_prevouts_single_hash;\n+    uint256 m_sequences_single_hash;\n+    uint256 m_outputs_single_hash;\n+    uint256 m_spent_amounts_single_hash;\n+    uint256 m_spent_scripts_single_hash;\n+    //! Whether the 5 fields above are initialized.\n+    bool m_bip341_taproot_ready = false;\n+\n+    // BIP143 precomputed data (double-SHA256).\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n-    bool m_ready = false;\n+    //! Whether the 3 fields above are initialized.\n+    bool m_bip143_segwit_ready = false;\n+\n+    std::vector<CTxOut> m_spent_outputs;\n+    //! Whether m_spent_outputs is initialized.\n+    bool m_spent_outputs_ready = false;\n \n     PrecomputedTransactionData() = default;\n \n     template <class T>\n-    void Init(const T& tx);\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and BIP16 P2SH-wrapped redeemscripts\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with 32-byte program, not BIP16 P2SH-wrapped, key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with 32-byte program, not BIP16 P2SH-wrapped, script path spending, leaf version 0xc0; see BIP 342\n+};\n+\n+struct ScriptExecutionData\n+{\n+    //! Whether m_tapleaf_hash is initialized.\n+    bool m_tapleaf_hash_init = false;\n+    //! The tapleaf hash.\n+    uint256 m_tapleaf_hash;\n+\n+    //! Whether m_codeseparator_pos is initialized.\n+    bool m_codeseparator_pos_init = false;\n+    //! Opcode position of the last executed OP_CODESEPARATOR (or 0xFFFFFFFF if none executed).\n+    uint32_t m_codeseparator_pos;\n+\n+    //! Whether m_annex_present and (when needed) m_annex_hash are initialized.\n+    bool m_annex_init = false;\n+    //! Whether an annex is present.\n+    bool m_annex_present;\n+    //! Hash of the annex data.\n+    uint256 m_annex_hash;\n+\n+    /** Whether m_validation_weight_left is initialized. */\n+    bool m_validation_weight_left_init = false;\n+    /** How much validation weight is left (decremented for every successful non-empty signature check). */\n+    int64_t m_validation_weight_left;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501071063",
      "id" : 501071063,
      "line" : 206,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA3MTA2Mw==",
      "original_commit_id" : "7dfb7239773e7974bdb61f648bf8351a808a63a5",
      "original_line" : 206,
      "original_position" : 133,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : 133,
      "pull_request_review_id" : 503958243,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501071063",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501113435"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501113435"
         }
      },
      "author_association" : "MEMBER",
      "body" : "332dc13bd 4 instances of `sigversion == SigVersion::BASE || sigversion == SigVersion::WITNESS_V0` in `EvalScript()`, could (very optionally) factor out to a const bool localvar",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-07T15:38:35Z",
      "diff_hunk" : "@@ -381,6 +438,9 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n     // static const valtype vchZero(0);\n     static const valtype vchTrue(1, 1);\n \n+    // sigversion cannot be TAPROOT here, as it admits no script execution.\n+    assert(sigversion == SigVersion::BASE || sigversion == SigVersion::WITNESS_V0 || sigversion == SigVersion::TAPSCRIPT);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501113435",
      "id" : 501113435,
      "line" : 442,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTExMzQzNQ==",
      "original_commit_id" : "7dfb7239773e7974bdb61f648bf8351a808a63a5",
      "original_line" : 442,
      "original_position" : 100,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 100,
      "pull_request_review_id" : 503958243,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501113435",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501127015"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501127015"
         }
      },
      "author_association" : "MEMBER",
      "body" : "332dc13b currently low-risk here, but perhaps avoid future possibility of use before set\r\n```suggestion\r\n    uint8_t ext_flag{0};\r\n```",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-07T15:57:10Z",
      "diff_hunk" : "@@ -1291,35 +1394,178 @@ uint256 GetOutputsSHA256(const T& txTo)\n     return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = SHA256Uint256(GetPrevoutsSHA256(txTo));\n-        hashSequence = SHA256Uint256(GetSequencesSHA256(txTo));\n-        hashOutputs = SHA256Uint256(GetOutputsSHA256(txTo));\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n     }\n \n-    m_ready = true;\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143_segwit = false;\n+    bool uses_bip341_taproot = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every witness-bearing spend with 34-byte scriptPubKey that starts with OP_1 as a Taproot\n+                // spend. This only works if spent_outputs was provided as well, but if it wasn't, actual validation\n+                // will fail anyway. Note that this branch may trigger for scriptPubKeys that aren't actually segwit\n+                // but in that case validation will fail as SCRIPT_ERR_WITNESS_UNEXPECTED anyway.\n+                uses_bip341_taproot = true;\n+            } else {\n+                // Treat every spend that's not known to native witness v1 as a Witness v0 spend. This branch may\n+                // also be taken for unknown witness versions, but it is harmless, and being precise would require\n+                // P2SH evaluation to find the redeemScript.\n+                uses_bip143_segwit = true;\n+            }\n+        }\n+        if (uses_bip341_taproot && uses_bip143_segwit) break; // No need to scan further if we already need all.\n+    }\n+\n+    if (uses_bip143_segwit || uses_bip341_taproot) {\n+        // Computations shared between both sighash schemes.\n+        m_prevouts_single_hash = GetPrevoutsSHA256(txTo);\n+        m_sequences_single_hash = GetSequencesSHA256(txTo);\n+        m_outputs_single_hash = GetOutputsSHA256(txTo);\n+    }\n+    if (uses_bip143_segwit) {\n+        hashPrevouts = SHA256Uint256(m_prevouts_single_hash);\n+        hashSequence = SHA256Uint256(m_sequences_single_hash);\n+        hashOutputs = SHA256Uint256(m_outputs_single_hash);\n+        m_bip143_segwit_ready = true;\n+    }\n+    if (uses_bip341_taproot) {\n+        m_spent_amounts_single_hash = GetSpentAmountsSHA256(m_spent_outputs);\n+        m_spent_scripts_single_hash = GetSpentScriptsSHA256(m_spent_outputs);\n+        m_bip341_taproot_ready = true;\n+    }\n }\n \n template <class T>\n PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n {\n-    Init(txTo);\n+    Init(txTo, {});\n }\n \n // explicit instantiation\n-template void PrecomputedTransactionData::Init(const CTransaction& txTo);\n-template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo);\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+static const CHashWriter HASHER_TAPLEAF = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HASHER_TAPBRANCH = TaggedHash(\"TapBranch\");\n+static const CHashWriter HASHER_TAPTWEAK = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const uint8_t key_version, const PrecomputedTransactionData& cache)\n+{\n+    uint8_t ext_flag;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501127015",
      "id" : 501127015,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEyNzAxNQ==",
      "original_commit_id" : "7dfb7239773e7974bdb61f648bf8351a808a63a5",
      "original_line" : 1494,
      "original_position" : 339,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 503958243,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501127015",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501152092"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501152092"
         }
      },
      "author_association" : "MEMBER",
      "body" : "332dc13bdc perhaps add this additional code documentation from BIP342 to clarify the intention of the code\r\n```diff\r\n                         // Tapscript requires minimal IF/NOTIF inputs as a consensus rule.\r\n                         if (sigversion == SigVersion::TAPSCRIPT) {\r\n+                            // The input argument to the OP_IF and OP_NOTIF opcodes must be either\r\n+                            // exactly 0 (the empty vector) or exactly 1 (the one-byte vector with value 1).\r\n                             if (vch.size() > 1 || (vch.size() == 1 && vch[0] != 1)) {\r\n```\r\n",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-07T16:33:01Z",
      "diff_hunk" : "@@ -568,6 +634,13 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                         if (stack.size() < 1)\n                             return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);\n                         valtype& vch = stacktop(-1);\n+                        // Tapscript requires minimal IF/NOTIF inputs as a consensus rule.\n+                        if (sigversion == SigVersion::TAPSCRIPT) {\n+                            if (vch.size() > 1 || (vch.size() == 1 && vch[0] != 1)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501152092",
      "id" : 501152092,
      "line" : 641,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE1MjA5Mg==",
      "original_commit_id" : "7dfb7239773e7974bdb61f648bf8351a808a63a5",
      "original_line" : 641,
      "original_position" : 149,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 151,
      "pull_request_review_id" : 503958243,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501152092",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501159080"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501159080"
         }
      },
      "author_association" : "MEMBER",
      "body" : "332dc13bdc perhaps add this additional info from BIP 342\r\n```diff\r\n-        assert(key_version == 0); // key_version must be 0 for now\r\n+        // key_version must be 0 for now, representing the current version of\r\n+        // public keys in the tapscript signature opcode execution.\r\n+        assert(key_version == 0);\r\n\r\n```\r\n",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-07T16:44:00Z",
      "diff_hunk" : "@@ -1291,35 +1394,178 @@ uint256 GetOutputsSHA256(const T& txTo)\n     return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = SHA256Uint256(GetPrevoutsSHA256(txTo));\n-        hashSequence = SHA256Uint256(GetSequencesSHA256(txTo));\n-        hashOutputs = SHA256Uint256(GetOutputsSHA256(txTo));\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n     }\n \n-    m_ready = true;\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143_segwit = false;\n+    bool uses_bip341_taproot = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every witness-bearing spend with 34-byte scriptPubKey that starts with OP_1 as a Taproot\n+                // spend. This only works if spent_outputs was provided as well, but if it wasn't, actual validation\n+                // will fail anyway. Note that this branch may trigger for scriptPubKeys that aren't actually segwit\n+                // but in that case validation will fail as SCRIPT_ERR_WITNESS_UNEXPECTED anyway.\n+                uses_bip341_taproot = true;\n+            } else {\n+                // Treat every spend that's not known to native witness v1 as a Witness v0 spend. This branch may\n+                // also be taken for unknown witness versions, but it is harmless, and being precise would require\n+                // P2SH evaluation to find the redeemScript.\n+                uses_bip143_segwit = true;\n+            }\n+        }\n+        if (uses_bip341_taproot && uses_bip143_segwit) break; // No need to scan further if we already need all.\n+    }\n+\n+    if (uses_bip143_segwit || uses_bip341_taproot) {\n+        // Computations shared between both sighash schemes.\n+        m_prevouts_single_hash = GetPrevoutsSHA256(txTo);\n+        m_sequences_single_hash = GetSequencesSHA256(txTo);\n+        m_outputs_single_hash = GetOutputsSHA256(txTo);\n+    }\n+    if (uses_bip143_segwit) {\n+        hashPrevouts = SHA256Uint256(m_prevouts_single_hash);\n+        hashSequence = SHA256Uint256(m_sequences_single_hash);\n+        hashOutputs = SHA256Uint256(m_outputs_single_hash);\n+        m_bip143_segwit_ready = true;\n+    }\n+    if (uses_bip341_taproot) {\n+        m_spent_amounts_single_hash = GetSpentAmountsSHA256(m_spent_outputs);\n+        m_spent_scripts_single_hash = GetSpentScriptsSHA256(m_spent_outputs);\n+        m_bip341_taproot_ready = true;\n+    }\n }\n \n template <class T>\n PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n {\n-    Init(txTo);\n+    Init(txTo, {});\n }\n \n // explicit instantiation\n-template void PrecomputedTransactionData::Init(const CTransaction& txTo);\n-template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo);\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+static const CHashWriter HASHER_TAPLEAF = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HASHER_TAPBRANCH = TaggedHash(\"TapBranch\");\n+static const CHashWriter HASHER_TAPTWEAK = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const uint8_t key_version, const PrecomputedTransactionData& cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    case SigVersion::TAPSCRIPT:\n+        ext_flag = 1;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache.m_bip341_taproot_ready && cache.m_spent_outputs_ready);\n+\n+    CHashWriter ss = HASHER_TAPSIGHASH;\n+\n+    // Epoch\n+    static constexpr uint8_t EPOCH = 0;\n+    ss << EPOCH;\n+\n+    // Hash type\n+    const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n+    const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;\n+    if (!(hash_type <= 0x03 || (hash_type >= 0x81 && hash_type <= 0x83))) return false;\n+    ss << hash_type;\n+\n+    // Transaction level data\n+    ss << tx_to.nVersion;\n+    ss << tx_to.nLockTime;\n+    if (input_type != SIGHASH_ANYONECANPAY) {\n+        ss << cache.m_prevouts_single_hash;\n+        ss << cache.m_spent_amounts_single_hash;\n+        ss << cache.m_spent_scripts_single_hash;\n+        ss << cache.m_sequences_single_hash;\n+    }\n+    if (output_type == SIGHASH_ALL) {\n+        ss << cache.m_outputs_single_hash;\n+    }\n+\n+    // Data about the input/prevout being spent\n+    assert(execdata.m_annex_init);\n+    const bool have_annex = execdata.m_annex_present;\n+    const uint8_t spend_type = (ext_flag << 1) + (have_annex ? 1 : 0); // The low bit indicates whether an annex is present.\n+    ss << spend_type;\n+    if (input_type == SIGHASH_ANYONECANPAY) {\n+        ss << tx_to.vin[in_pos].prevout;\n+        ss << cache.m_spent_outputs[in_pos];\n+        ss << tx_to.vin[in_pos].nSequence;\n+    } else {\n+        ss << in_pos;\n+    }\n+    if (have_annex) {\n+        ss << execdata.m_annex_hash;\n+    }\n+\n+    // Data about the output (if only one).\n+    if (output_type == SIGHASH_SINGLE) {\n+        if (in_pos >= tx_to.vout.size()) return false;\n+        CHashWriter sha_single_output(SER_GETHASH, 0);\n+        sha_single_output << tx_to.vout[in_pos];\n+        ss << sha_single_output.GetSHA256();\n+    }\n+\n+    // Additional data for BIP 342 signatures\n+    if (sigversion == SigVersion::TAPSCRIPT) {\n+        assert(execdata.m_tapleaf_hash_init);\n+        ss << execdata.m_tapleaf_hash;\n+        assert(key_version == 0); // key_version must be 0 for now",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501159080",
      "id" : 501159080,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE1OTA4MA==",
      "original_commit_id" : "7dfb7239773e7974bdb61f648bf8351a808a63a5",
      "original_line" : 1559,
      "original_position" : 406,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 503958243,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501159080",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501185979"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501185979"
         }
      },
      "author_association" : "MEMBER",
      "body" : "332dc13b maybe simplify\r\n```diff\r\n     return opcode == 80 || opcode == 98 || (opcode >= 126 && opcode <= 129) ||\r\n-           (opcode >= 131 && opcode <= 134) || (opcode >= 137 && opcode <= 138) ||\r\n-           (opcode >= 141 && opcode <= 142) || (opcode >= 149 && opcode <= 153) ||\r\n+           (opcode >= 131 && opcode <= 134) || opcode == 137 || opcode == 138 ||\r\n+           opcode == 141 || opcode == 142 || (opcode >= 149 && opcode <= 153) ||\r\n            (opcode >= 187 && opcode <= 254);\r\n```\r\n",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-07T17:26:53Z",
      "diff_hunk" : "@@ -328,3 +331,11 @@ bool GetScriptOp(CScriptBase::const_iterator& pc, CScriptBase::const_iterator en\n     opcodeRet = static_cast<opcodetype>(opcode);\n     return true;\n }\n+\n+bool IsOpSuccess(const opcodetype& opcode)\n+{\n+    return opcode == 80 || opcode == 98 || (opcode >= 126 && opcode <= 129) ||\n+           (opcode >= 131 && opcode <= 134) || (opcode >= 137 && opcode <= 138) ||\n+           (opcode >= 141 && opcode <= 142) || (opcode >= 149 && opcode <= 153) ||\n+           (opcode >= 187 && opcode <= 254);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501185979",
      "id" : 501185979,
      "line" : 340,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE4NTk3OQ==",
      "original_commit_id" : "7dfb7239773e7974bdb61f648bf8351a808a63a5",
      "original_line" : 340,
      "original_position" : 20,
      "original_start_line" : null,
      "path" : "src/script/script.cpp",
      "position" : 20,
      "pull_request_review_id" : 503958243,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501185979",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501215517"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501215517"
         }
      },
      "author_association" : "MEMBER",
      "body" : "IIRC the text as-is completely \"matches\" the BIP text, meaning if it gives a range here, it gives a range in the BIP text. I think as-is is easier to pattern match.\r\n\r\n> 80, 98, 126-129, 131-134, 137-138, 141-142, 149-153, 187-254",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-07T18:15:58Z",
      "diff_hunk" : "@@ -328,3 +331,11 @@ bool GetScriptOp(CScriptBase::const_iterator& pc, CScriptBase::const_iterator en\n     opcodeRet = static_cast<opcodetype>(opcode);\n     return true;\n }\n+\n+bool IsOpSuccess(const opcodetype& opcode)\n+{\n+    return opcode == 80 || opcode == 98 || (opcode >= 126 && opcode <= 129) ||\n+           (opcode >= 131 && opcode <= 134) || (opcode >= 137 && opcode <= 138) ||\n+           (opcode >= 141 && opcode <= 142) || (opcode >= 149 && opcode <= 153) ||\n+           (opcode >= 187 && opcode <= 254);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501215517",
      "id" : 501215517,
      "in_reply_to_id" : 501185979,
      "line" : 340,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIxNTUxNw==",
      "original_commit_id" : "7dfb7239773e7974bdb61f648bf8351a808a63a5",
      "original_line" : 340,
      "original_position" : 20,
      "original_start_line" : null,
      "path" : "src/script/script.cpp",
      "position" : 20,
      "pull_request_review_id" : 504146948,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501215517",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501221893"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501221893"
         }
      },
      "author_association" : "MEMBER",
      "body" : "True, though the BIP prose here is inconsistent (see the first 2 elements) and could be updated. The code could opt for the simpler version. Not a biggie though--I hesitated to comment on it.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-07T18:23:22Z",
      "diff_hunk" : "@@ -328,3 +331,11 @@ bool GetScriptOp(CScriptBase::const_iterator& pc, CScriptBase::const_iterator en\n     opcodeRet = static_cast<opcodetype>(opcode);\n     return true;\n }\n+\n+bool IsOpSuccess(const opcodetype& opcode)\n+{\n+    return opcode == 80 || opcode == 98 || (opcode >= 126 && opcode <= 129) ||\n+           (opcode >= 131 && opcode <= 134) || (opcode >= 137 && opcode <= 138) ||\n+           (opcode >= 141 && opcode <= 142) || (opcode >= 149 && opcode <= 153) ||\n+           (opcode >= 187 && opcode <= 254);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501221893",
      "id" : 501221893,
      "in_reply_to_id" : 501185979,
      "line" : 340,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIyMTg5Mw==",
      "original_commit_id" : "7dfb7239773e7974bdb61f648bf8351a808a63a5",
      "original_line" : 340,
      "original_position" : 20,
      "original_start_line" : null,
      "path" : "src/script/script.cpp",
      "position" : 20,
      "pull_request_review_id" : 504153623,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501221893",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501242957"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501242957"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'd rather be explicit in every calling site about which sigversions are affected.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-07T19:00:50Z",
      "diff_hunk" : "@@ -381,6 +438,9 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n     // static const valtype vchZero(0);\n     static const valtype vchTrue(1, 1);\n \n+    // sigversion cannot be TAPROOT here, as it admits no script execution.\n+    assert(sigversion == SigVersion::BASE || sigversion == SigVersion::WITNESS_V0 || sigversion == SigVersion::TAPSCRIPT);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501242957",
      "id" : 501242957,
      "in_reply_to_id" : 501113435,
      "line" : 442,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI0Mjk1Nw==",
      "original_commit_id" : "7dfb7239773e7974bdb61f648bf8351a808a63a5",
      "original_line" : 442,
      "original_position" : 100,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 100,
      "pull_request_review_id" : 504180859,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501242957",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501244312"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501244312"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I believe that not initializing a variable is better than initializing it incorrectly. The former lets you use tooling (ubsan, valgrind) to detect invalid usage, instead of creating a potentially very hard to discover bug (I don't think it matters much here, as it's a very simple case, but as a matter of principle I dislike initialization of variables just to avoid a risk of them being uninitialized).",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-07T19:03:08Z",
      "diff_hunk" : "@@ -1291,35 +1394,178 @@ uint256 GetOutputsSHA256(const T& txTo)\n     return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = SHA256Uint256(GetPrevoutsSHA256(txTo));\n-        hashSequence = SHA256Uint256(GetSequencesSHA256(txTo));\n-        hashOutputs = SHA256Uint256(GetOutputsSHA256(txTo));\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n     }\n \n-    m_ready = true;\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143_segwit = false;\n+    bool uses_bip341_taproot = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every witness-bearing spend with 34-byte scriptPubKey that starts with OP_1 as a Taproot\n+                // spend. This only works if spent_outputs was provided as well, but if it wasn't, actual validation\n+                // will fail anyway. Note that this branch may trigger for scriptPubKeys that aren't actually segwit\n+                // but in that case validation will fail as SCRIPT_ERR_WITNESS_UNEXPECTED anyway.\n+                uses_bip341_taproot = true;\n+            } else {\n+                // Treat every spend that's not known to native witness v1 as a Witness v0 spend. This branch may\n+                // also be taken for unknown witness versions, but it is harmless, and being precise would require\n+                // P2SH evaluation to find the redeemScript.\n+                uses_bip143_segwit = true;\n+            }\n+        }\n+        if (uses_bip341_taproot && uses_bip143_segwit) break; // No need to scan further if we already need all.\n+    }\n+\n+    if (uses_bip143_segwit || uses_bip341_taproot) {\n+        // Computations shared between both sighash schemes.\n+        m_prevouts_single_hash = GetPrevoutsSHA256(txTo);\n+        m_sequences_single_hash = GetSequencesSHA256(txTo);\n+        m_outputs_single_hash = GetOutputsSHA256(txTo);\n+    }\n+    if (uses_bip143_segwit) {\n+        hashPrevouts = SHA256Uint256(m_prevouts_single_hash);\n+        hashSequence = SHA256Uint256(m_sequences_single_hash);\n+        hashOutputs = SHA256Uint256(m_outputs_single_hash);\n+        m_bip143_segwit_ready = true;\n+    }\n+    if (uses_bip341_taproot) {\n+        m_spent_amounts_single_hash = GetSpentAmountsSHA256(m_spent_outputs);\n+        m_spent_scripts_single_hash = GetSpentScriptsSHA256(m_spent_outputs);\n+        m_bip341_taproot_ready = true;\n+    }\n }\n \n template <class T>\n PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n {\n-    Init(txTo);\n+    Init(txTo, {});\n }\n \n // explicit instantiation\n-template void PrecomputedTransactionData::Init(const CTransaction& txTo);\n-template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo);\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+static const CHashWriter HASHER_TAPLEAF = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HASHER_TAPBRANCH = TaggedHash(\"TapBranch\");\n+static const CHashWriter HASHER_TAPTWEAK = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const uint8_t key_version, const PrecomputedTransactionData& cache)\n+{\n+    uint8_t ext_flag;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501244312",
      "id" : 501244312,
      "in_reply_to_id" : 501127015,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI0NDMxMg==",
      "original_commit_id" : "7dfb7239773e7974bdb61f648bf8351a808a63a5",
      "original_line" : 1494,
      "original_position" : 339,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 504182605,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501244312",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501258827"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501258827"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I prefer to keep it exactly as in the BIP for now, but no reason the BIP can't be updated to be more clear.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-07T19:30:22Z",
      "diff_hunk" : "@@ -328,3 +331,11 @@ bool GetScriptOp(CScriptBase::const_iterator& pc, CScriptBase::const_iterator en\n     opcodeRet = static_cast<opcodetype>(opcode);\n     return true;\n }\n+\n+bool IsOpSuccess(const opcodetype& opcode)\n+{\n+    return opcode == 80 || opcode == 98 || (opcode >= 126 && opcode <= 129) ||\n+           (opcode >= 131 && opcode <= 134) || (opcode >= 137 && opcode <= 138) ||\n+           (opcode >= 141 && opcode <= 142) || (opcode >= 149 && opcode <= 153) ||\n+           (opcode >= 187 && opcode <= 254);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501258827",
      "id" : 501258827,
      "in_reply_to_id" : 501185979,
      "line" : 340,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI1ODgyNw==",
      "original_commit_id" : "7dfb7239773e7974bdb61f648bf8351a808a63a5",
      "original_line" : 340,
      "original_position" : 20,
      "original_start_line" : null,
      "path" : "src/script/script.cpp",
      "position" : 20,
      "pull_request_review_id" : 504201403,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501258827",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501260989"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501260989"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-07T19:34:14Z",
      "diff_hunk" : "@@ -1538,14 +1538,20 @@ bool CheckInputScripts(const CTransaction& tx, TxValidationState &state, const C\n         return true;\n     }\n \n-    if (!txdata.m_ready) {\n-        txdata.Init(tx);\n+    if (!txdata.m_spent_outputs_ready) {\n+        std::vector<CTxOut> spent_outputs;\n+        spent_outputs.reserve(tx.vin.size());\n+\n+        for (const auto& txin : tx.vin) {\n+            const COutPoint &prevout = txin.prevout;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501260989",
      "id" : 501260989,
      "in_reply_to_id" : 500552248,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2MDk4OQ==",
      "original_commit_id" : "c849dae8ce05ef5c92df6ec1bb77b9ea2e38240a",
      "original_line" : 1546,
      "original_position" : 11,
      "original_start_line" : null,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 504204158,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501260989",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501261053"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501261053"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-07T19:34:21Z",
      "diff_hunk" : "@@ -1291,35 +1389,178 @@ uint256 GetOutputsSHA256(const T& txTo)\n     return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501261053",
      "id" : 501261053,
      "in_reply_to_id" : 500554420,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2MTA1Mw==",
      "original_commit_id" : "c849dae8ce05ef5c92df6ec1bb77b9ea2e38240a",
      "original_line" : 1421,
      "original_position" : 246,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 504204236,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501261053",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501261091"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501261091"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-07T19:34:27Z",
      "diff_hunk" : "@@ -44,6 +44,17 @@ static const unsigned int LOCKTIME_THRESHOLD = 500000000; // Tue Nov  5 00:53:20\n // SEQUENCE_FINAL).\n static const uint32_t LOCKTIME_MAX = 0xFFFFFFFFU;\n \n+// Tag for input annex. If there are at least two witness elements for a transaction input,\n+// and the first byte of the last element is 0x50, this last element is called annex, and\n+// has meanings independent of the script\n+static const unsigned int ANNEX_TAG = 0x50;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501261091",
      "id" : 501261091,
      "in_reply_to_id" : 500571274,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2MTA5MQ==",
      "original_commit_id" : "c849dae8ce05ef5c92df6ec1bb77b9ea2e38240a",
      "original_line" : 50,
      "original_position" : 7,
      "original_start_line" : null,
      "path" : "src/script/script.h",
      "position" : null,
      "pull_request_review_id" : 504204298,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501261091",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501261184"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501261184"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-07T19:34:36Z",
      "diff_hunk" : "@@ -1291,35 +1389,178 @@ uint256 GetOutputsSHA256(const T& txTo)\n     return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n+\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n+    }\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = SHA256Uint256(GetPrevoutsSHA256(txTo));\n-        hashSequence = SHA256Uint256(GetSequencesSHA256(txTo));\n-        hashOutputs = SHA256Uint256(GetOutputsSHA256(txTo));\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143_segwit = false;\n+    bool uses_bip341_taproot = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every witness-bearing spend with 34-byte scriptPubKey that starts with OP_1 as a Taproot\n+                // spend. This only works if spent_outputs was provided as well, but if it wasn't, actual validation\n+                // will fail anyway. Note that this branch may trigger for scriptPubKeys that aren't actually segwit\n+                // but in that case validation will fail as SCRIPT_ERR_WITNESS_UNEXPECTED anyway.\n+                uses_bip341_taproot = true;\n+            } else {\n+                // Treat every spend that's not known to native witness v1 as a Witness v0 spend. This branch may\n+                // also be taken for unknown witness versions, but it is harmless, and being precise would require\n+                // P2SH evaluation to find the redeemScript.\n+                uses_bip143_segwit = true;\n+            }\n+        }\n+        if (uses_bip341_taproot && uses_bip143_segwit) break; // No need to scan further if we already need all.\n     }\n \n-    m_ready = true;\n+    if (uses_bip143_segwit || uses_bip341_taproot) {\n+        // Computations shared between both sighash schemes.\n+        m_prevouts_single_hash = GetPrevoutsSHA256(txTo);\n+        m_sequences_single_hash = GetSequencesSHA256(txTo);\n+        m_outputs_single_hash = GetOutputsSHA256(txTo);\n+    }\n+    if (uses_bip143_segwit) {\n+        hashPrevouts = SHA256Uint256(m_prevouts_single_hash);\n+        hashSequence = SHA256Uint256(m_sequences_single_hash);\n+        hashOutputs = SHA256Uint256(m_outputs_single_hash);\n+        m_bip143_segwit_ready = true;\n+    }\n+    if (uses_bip341_taproot) {\n+        m_spent_amounts_single_hash = GetSpentAmountsSHA256(m_spent_outputs);\n+        m_spent_scripts_single_hash = GetSpentScriptsSHA256(m_spent_outputs);\n+        m_bip341_taproot_ready = true;\n+    }\n }\n \n template <class T>\n PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n {\n-    Init(txTo);\n+    Init(txTo, {});\n }\n \n // explicit instantiation\n-template void PrecomputedTransactionData::Init(const CTransaction& txTo);\n-template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo);\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+static const CHashWriter HASHER_TAPLEAF = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HASHER_TAPBRANCH = TaggedHash(\"TapBranch\");\n+static const CHashWriter HASHER_TAPTWEAK = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const uint8_t key_version, const PrecomputedTransactionData& cache)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501261184",
      "id" : 501261184,
      "in_reply_to_id" : 500576577,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2MTE4NA==",
      "original_commit_id" : "c849dae8ce05ef5c92df6ec1bb77b9ea2e38240a",
      "original_line" : 1490,
      "original_position" : 325,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 504204416,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501261184",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501261274"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501261274"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-07T19:34:43Z",
      "diff_hunk" : "@@ -1291,35 +1389,178 @@ uint256 GetOutputsSHA256(const T& txTo)\n     return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n+\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n+    }\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = SHA256Uint256(GetPrevoutsSHA256(txTo));\n-        hashSequence = SHA256Uint256(GetSequencesSHA256(txTo));\n-        hashOutputs = SHA256Uint256(GetOutputsSHA256(txTo));\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143_segwit = false;\n+    bool uses_bip341_taproot = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every witness-bearing spend with 34-byte scriptPubKey that starts with OP_1 as a Taproot\n+                // spend. This only works if spent_outputs was provided as well, but if it wasn't, actual validation\n+                // will fail anyway. Note that this branch may trigger for scriptPubKeys that aren't actually segwit\n+                // but in that case validation will fail as SCRIPT_ERR_WITNESS_UNEXPECTED anyway.\n+                uses_bip341_taproot = true;\n+            } else {\n+                // Treat every spend that's not known to native witness v1 as a Witness v0 spend. This branch may\n+                // also be taken for unknown witness versions, but it is harmless, and being precise would require\n+                // P2SH evaluation to find the redeemScript.\n+                uses_bip143_segwit = true;\n+            }\n+        }\n+        if (uses_bip341_taproot && uses_bip143_segwit) break; // No need to scan further if we already need all.\n     }\n \n-    m_ready = true;\n+    if (uses_bip143_segwit || uses_bip341_taproot) {\n+        // Computations shared between both sighash schemes.\n+        m_prevouts_single_hash = GetPrevoutsSHA256(txTo);\n+        m_sequences_single_hash = GetSequencesSHA256(txTo);\n+        m_outputs_single_hash = GetOutputsSHA256(txTo);\n+    }\n+    if (uses_bip143_segwit) {\n+        hashPrevouts = SHA256Uint256(m_prevouts_single_hash);\n+        hashSequence = SHA256Uint256(m_sequences_single_hash);\n+        hashOutputs = SHA256Uint256(m_outputs_single_hash);\n+        m_bip143_segwit_ready = true;\n+    }\n+    if (uses_bip341_taproot) {\n+        m_spent_amounts_single_hash = GetSpentAmountsSHA256(m_spent_outputs);\n+        m_spent_scripts_single_hash = GetSpentScriptsSHA256(m_spent_outputs);\n+        m_bip341_taproot_ready = true;\n+    }\n }\n \n template <class T>\n PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n {\n-    Init(txTo);\n+    Init(txTo, {});\n }\n \n // explicit instantiation\n-template void PrecomputedTransactionData::Init(const CTransaction& txTo);\n-template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo);\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501261274",
      "id" : 501261274,
      "in_reply_to_id" : 500578719,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2MTI3NA==",
      "original_commit_id" : "c849dae8ce05ef5c92df6ec1bb77b9ea2e38240a",
      "original_line" : 1480,
      "original_position" : 315,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 504204519,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501261274",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501261337"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501261337"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-07T19:34:50Z",
      "diff_hunk" : "@@ -114,41 +125,111 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 19),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 20),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    // BIP341 precomputed data.\n+    // These are single-SHA256, see https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-15.\n+    uint256 m_prevouts_single_hash;\n+    uint256 m_sequences_single_hash;\n+    uint256 m_outputs_single_hash;\n+    uint256 m_spent_amounts_single_hash;\n+    uint256 m_spent_scripts_single_hash;\n+    //! Whether the 5 fields above are initialized.\n+    bool m_bip341_taproot_ready = false;\n+\n+    // BIP143 precomputed data (double-SHA256).\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n-    bool m_ready = false;\n+    //! Whether the 3 fields above are initialized.\n+    bool m_bip143_segwit_ready = false;\n+\n+    std::vector<CTxOut> m_spent_outputs;\n+    //! Whether m_spent_outputs is initialized.\n+    bool m_spent_outputs_ready = false;\n \n     PrecomputedTransactionData() = default;\n \n     template <class T>\n-    void Init(const T& tx);\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501261337",
      "id" : 501261337,
      "in_reply_to_id" : 500578940,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2MTMzNw==",
      "original_commit_id" : "c849dae8ce05ef5c92df6ec1bb77b9ea2e38240a",
      "original_line" : 170,
      "original_position" : 95,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 504204608,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501261337",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501261435"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501261435"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Renamed them both to `bytes`.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-07T19:35:01Z",
      "diff_hunk" : "@@ -206,6 +207,26 @@ class CPubKey\n     bool Derive(CPubKey& pubkeyChild, ChainCode &ccChild, unsigned int nChild, const ChainCode& cc) const;\n };\n \n+class XOnlyPubKey {\n+private:\n+    uint256 m_keydata;\n+\n+public:\n+    /** Construct an x-only pubkey from exactly 32 bytes. */\n+    XOnlyPubKey(Span<const unsigned char> input);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501261435",
      "id" : 501261435,
      "in_reply_to_id" : 500883991,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2MTQzNQ==",
      "original_commit_id" : "7dfb7239773e7974bdb61f648bf8351a808a63a5",
      "original_line" : 216,
      "original_position" : 27,
      "original_start_line" : null,
      "path" : "src/pubkey.h",
      "position" : null,
      "pull_request_review_id" : 504204747,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501261435",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501261517"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501261517"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-07T19:35:09Z",
      "diff_hunk" : "@@ -34,18 +35,30 @@ class CSignatureCache\n         uint256 nonce = GetRandHash();\n         // We want the nonce to be 64 bytes long to force the hasher to process\n         // this chunk, which makes later hash computations more efficient. We\n-        // just write our 32-byte entropy twice to fill the 64 bytes.\n-        m_salted_hasher.Write(nonce.begin(), 32);\n-        m_salted_hasher.Write(nonce.begin(), 32);\n+        // just write our 32-byte entropy, and then pad with 'E' for ECDSA and\n+        // 'S' for Schnorr (followed by 0 bytes).\n+        static const unsigned char PADDING_ECDSA[32] = {'E'};\n+        static const unsigned char PADDING_SCHNORR[32] = {'S'};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501261517",
      "id" : 501261517,
      "in_reply_to_id" : 500887241,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2MTUxNw==",
      "original_commit_id" : "7dfb7239773e7974bdb61f648bf8351a808a63a5",
      "original_line" : 41,
      "original_position" : 22,
      "original_start_line" : null,
      "path" : "src/script/sigcache.cpp",
      "position" : null,
      "pull_request_review_id" : 504204822,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501261517",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501261574"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501261574"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-07T19:35:16Z",
      "diff_hunk" : "@@ -166,6 +167,26 @@ int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_\n     return 1;\n }\n \n+XOnlyPubKey::XOnlyPubKey(Span<const unsigned char> in)\n+{\n+    assert(in.size() == 32);\n+    std::copy(in.begin(), in.end(), m_keydata.begin());\n+}\n+\n+bool XOnlyPubKey::VerifySchnorr(const uint256& msg, Span<const unsigned char> sigbytes) const {\n+    assert(sigbytes.size() == 64);\n+    secp256k1_xonly_pubkey pubkey;\n+    if (!secp256k1_xonly_pubkey_parse(secp256k1_context_verify, &pubkey, m_keydata.data())) return false;\n+    return secp256k1_schnorrsig_verify(secp256k1_context_verify, sigbytes.data(), msg.begin(), &pubkey);\n+}\n+\n+bool XOnlyPubKey::CheckPayToContract(const XOnlyPubKey& base, const uint256& hash, const bool parity) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501261574",
      "id" : 501261574,
      "in_reply_to_id" : 500900420,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2MTU3NA==",
      "original_commit_id" : "7dfb7239773e7974bdb61f648bf8351a808a63a5",
      "original_line" : 183,
      "original_position" : 25,
      "original_start_line" : null,
      "path" : "src/pubkey.cpp",
      "position" : null,
      "pull_request_review_id" : 504204901,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501261574",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501261663"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501261663"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-07T19:35:25Z",
      "diff_hunk" : "@@ -114,41 +125,111 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 19),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 20),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    // BIP341 precomputed data.\n+    // These are single-SHA256, see https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-15.\n+    uint256 m_prevouts_single_hash;\n+    uint256 m_sequences_single_hash;\n+    uint256 m_outputs_single_hash;\n+    uint256 m_spent_amounts_single_hash;\n+    uint256 m_spent_scripts_single_hash;\n+    //! Whether the 5 fields above are initialized.\n+    bool m_bip341_taproot_ready = false;\n+\n+    // BIP143 precomputed data (double-SHA256).\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n-    bool m_ready = false;\n+    //! Whether the 3 fields above are initialized.\n+    bool m_bip143_segwit_ready = false;\n+\n+    std::vector<CTxOut> m_spent_outputs;\n+    //! Whether m_spent_outputs is initialized.\n+    bool m_spent_outputs_ready = false;\n \n     PrecomputedTransactionData() = default;\n \n     template <class T>\n-    void Init(const T& tx);\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and BIP16 P2SH-wrapped redeemscripts\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with 32-byte program, not BIP16 P2SH-wrapped, key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with 32-byte program, not BIP16 P2SH-wrapped, script path spending, leaf version 0xc0; see BIP 342\n+};\n+\n+struct ScriptExecutionData\n+{\n+    //! Whether m_tapleaf_hash is initialized.\n+    bool m_tapleaf_hash_init = false;\n+    //! The tapleaf hash.\n+    uint256 m_tapleaf_hash;\n+\n+    //! Whether m_codeseparator_pos is initialized.\n+    bool m_codeseparator_pos_init = false;\n+    //! Opcode position of the last executed OP_CODESEPARATOR (or 0xFFFFFFFF if none executed).\n+    uint32_t m_codeseparator_pos;\n+\n+    //! Whether m_annex_present and (when needed) m_annex_hash are initialized.\n+    bool m_annex_init = false;\n+    //! Whether an annex is present.\n+    bool m_annex_present;\n+    //! Hash of the annex data.\n+    uint256 m_annex_hash;\n+\n+    /** Whether m_validation_weight_left is initialized. */\n+    bool m_validation_weight_left_init = false;\n+    /** How much validation weight is left (decremented for every successful non-empty signature check). */\n+    int64_t m_validation_weight_left;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501261663",
      "id" : 501261663,
      "in_reply_to_id" : 501071063,
      "line" : 206,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2MTY2Mw==",
      "original_commit_id" : "7dfb7239773e7974bdb61f648bf8351a808a63a5",
      "original_line" : 206,
      "original_position" : 133,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : 133,
      "pull_request_review_id" : 504205006,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501261663",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501261750"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501261750"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-07T19:35:36Z",
      "diff_hunk" : "@@ -568,6 +634,13 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                         if (stack.size() < 1)\n                             return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);\n                         valtype& vch = stacktop(-1);\n+                        // Tapscript requires minimal IF/NOTIF inputs as a consensus rule.\n+                        if (sigversion == SigVersion::TAPSCRIPT) {\n+                            if (vch.size() > 1 || (vch.size() == 1 && vch[0] != 1)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501261750",
      "id" : 501261750,
      "in_reply_to_id" : 501152092,
      "line" : 641,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2MTc1MA==",
      "original_commit_id" : "7dfb7239773e7974bdb61f648bf8351a808a63a5",
      "original_line" : 641,
      "original_position" : 149,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 151,
      "pull_request_review_id" : 504205124,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501261750",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501261833"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501261833"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-07T19:35:45Z",
      "diff_hunk" : "@@ -1291,35 +1394,178 @@ uint256 GetOutputsSHA256(const T& txTo)\n     return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = SHA256Uint256(GetPrevoutsSHA256(txTo));\n-        hashSequence = SHA256Uint256(GetSequencesSHA256(txTo));\n-        hashOutputs = SHA256Uint256(GetOutputsSHA256(txTo));\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n     }\n \n-    m_ready = true;\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143_segwit = false;\n+    bool uses_bip341_taproot = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every witness-bearing spend with 34-byte scriptPubKey that starts with OP_1 as a Taproot\n+                // spend. This only works if spent_outputs was provided as well, but if it wasn't, actual validation\n+                // will fail anyway. Note that this branch may trigger for scriptPubKeys that aren't actually segwit\n+                // but in that case validation will fail as SCRIPT_ERR_WITNESS_UNEXPECTED anyway.\n+                uses_bip341_taproot = true;\n+            } else {\n+                // Treat every spend that's not known to native witness v1 as a Witness v0 spend. This branch may\n+                // also be taken for unknown witness versions, but it is harmless, and being precise would require\n+                // P2SH evaluation to find the redeemScript.\n+                uses_bip143_segwit = true;\n+            }\n+        }\n+        if (uses_bip341_taproot && uses_bip143_segwit) break; // No need to scan further if we already need all.\n+    }\n+\n+    if (uses_bip143_segwit || uses_bip341_taproot) {\n+        // Computations shared between both sighash schemes.\n+        m_prevouts_single_hash = GetPrevoutsSHA256(txTo);\n+        m_sequences_single_hash = GetSequencesSHA256(txTo);\n+        m_outputs_single_hash = GetOutputsSHA256(txTo);\n+    }\n+    if (uses_bip143_segwit) {\n+        hashPrevouts = SHA256Uint256(m_prevouts_single_hash);\n+        hashSequence = SHA256Uint256(m_sequences_single_hash);\n+        hashOutputs = SHA256Uint256(m_outputs_single_hash);\n+        m_bip143_segwit_ready = true;\n+    }\n+    if (uses_bip341_taproot) {\n+        m_spent_amounts_single_hash = GetSpentAmountsSHA256(m_spent_outputs);\n+        m_spent_scripts_single_hash = GetSpentScriptsSHA256(m_spent_outputs);\n+        m_bip341_taproot_ready = true;\n+    }\n }\n \n template <class T>\n PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n {\n-    Init(txTo);\n+    Init(txTo, {});\n }\n \n // explicit instantiation\n-template void PrecomputedTransactionData::Init(const CTransaction& txTo);\n-template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo);\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+static const CHashWriter HASHER_TAPLEAF = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HASHER_TAPBRANCH = TaggedHash(\"TapBranch\");\n+static const CHashWriter HASHER_TAPTWEAK = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const uint8_t key_version, const PrecomputedTransactionData& cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    case SigVersion::TAPSCRIPT:\n+        ext_flag = 1;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache.m_bip341_taproot_ready && cache.m_spent_outputs_ready);\n+\n+    CHashWriter ss = HASHER_TAPSIGHASH;\n+\n+    // Epoch\n+    static constexpr uint8_t EPOCH = 0;\n+    ss << EPOCH;\n+\n+    // Hash type\n+    const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n+    const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;\n+    if (!(hash_type <= 0x03 || (hash_type >= 0x81 && hash_type <= 0x83))) return false;\n+    ss << hash_type;\n+\n+    // Transaction level data\n+    ss << tx_to.nVersion;\n+    ss << tx_to.nLockTime;\n+    if (input_type != SIGHASH_ANYONECANPAY) {\n+        ss << cache.m_prevouts_single_hash;\n+        ss << cache.m_spent_amounts_single_hash;\n+        ss << cache.m_spent_scripts_single_hash;\n+        ss << cache.m_sequences_single_hash;\n+    }\n+    if (output_type == SIGHASH_ALL) {\n+        ss << cache.m_outputs_single_hash;\n+    }\n+\n+    // Data about the input/prevout being spent\n+    assert(execdata.m_annex_init);\n+    const bool have_annex = execdata.m_annex_present;\n+    const uint8_t spend_type = (ext_flag << 1) + (have_annex ? 1 : 0); // The low bit indicates whether an annex is present.\n+    ss << spend_type;\n+    if (input_type == SIGHASH_ANYONECANPAY) {\n+        ss << tx_to.vin[in_pos].prevout;\n+        ss << cache.m_spent_outputs[in_pos];\n+        ss << tx_to.vin[in_pos].nSequence;\n+    } else {\n+        ss << in_pos;\n+    }\n+    if (have_annex) {\n+        ss << execdata.m_annex_hash;\n+    }\n+\n+    // Data about the output (if only one).\n+    if (output_type == SIGHASH_SINGLE) {\n+        if (in_pos >= tx_to.vout.size()) return false;\n+        CHashWriter sha_single_output(SER_GETHASH, 0);\n+        sha_single_output << tx_to.vout[in_pos];\n+        ss << sha_single_output.GetSHA256();\n+    }\n+\n+    // Additional data for BIP 342 signatures\n+    if (sigversion == SigVersion::TAPSCRIPT) {\n+        assert(execdata.m_tapleaf_hash_init);\n+        ss << execdata.m_tapleaf_hash;\n+        assert(key_version == 0); // key_version must be 0 for now",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r501261833",
      "id" : 501261833,
      "in_reply_to_id" : 501159080,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2MTgzMw==",
      "original_commit_id" : "7dfb7239773e7974bdb61f648bf8351a808a63a5",
      "original_line" : 1559,
      "original_position" : 406,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 504205210,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/501261833",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I addressed comments by @jonatack. See detailed history in #19997.",
      "created_at" : "2020-10-07T19:36:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-705150707",
      "id" : 705150707,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwNTE1MDcwNw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-07T19:36:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/705150707",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "reACK 07dd29e ",
      "created_at" : "2020-10-08T07:47:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-705394994",
      "id" : 705394994,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwNTM5NDk5NA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-08T07:47:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/705394994",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/15256660?v=4",
         "events_url" : "https://api.github.com/users/benthecarman/events{/privacy}",
         "followers_url" : "https://api.github.com/users/benthecarman/followers",
         "following_url" : "https://api.github.com/users/benthecarman/following{/other_user}",
         "gists_url" : "https://api.github.com/users/benthecarman/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/benthecarman",
         "id" : 15256660,
         "login" : "benthecarman",
         "node_id" : "MDQ6VXNlcjE1MjU2NjYw",
         "organizations_url" : "https://api.github.com/users/benthecarman/orgs",
         "received_events_url" : "https://api.github.com/users/benthecarman/received_events",
         "repos_url" : "https://api.github.com/users/benthecarman/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/benthecarman/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/benthecarman/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/benthecarman"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "reACK https://github.com/bitcoin/bitcoin/pull/19953/commits/07dd29e1b50b8fcba91c36386ed5267a2e60c240",
      "created_at" : "2020-10-08T11:21:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-705504394",
      "id" : 705504394,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwNTUwNDM5NA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-08T11:21:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/705504394",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I made a few more changes related to signature checking:\r\n\r\n* The `key_version` (currently always 0) is no longer passed as an argument into `SignatureHashSchnorr`, because if a new one was introduced, it would need a new SigVersion as well. So instead use the latter to derive the `key_version`. @ariard This partially reverts an earlier comment you had, but I think the comments make it clearer still.\r\n* Introduce distinct script validation errors for the various ways Schnorr signatures (in Taproot/Tapscript) can fail (invalid length, invalid sighash type, or actual Schnorr validation failure). This allows more accurate testing in feature_taproot.py, but did require passing down `ScriptError` in a few more places.\r\n\r\nAs always, details of the changes are in #19997.",
      "created_at" : "2020-10-09T01:38:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-705917051",
      "id" : 705917051,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwNTkxNzA1MQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-09T03:08:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/705917051",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "reACK 4a7e017",
      "created_at" : "2020-10-09T08:47:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-706055597",
      "id" : 706055597,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwNjA1NTU5Nw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-09T08:47:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/706055597",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/15256660?v=4",
         "events_url" : "https://api.github.com/users/benthecarman/events{/privacy}",
         "followers_url" : "https://api.github.com/users/benthecarman/followers",
         "following_url" : "https://api.github.com/users/benthecarman/following{/other_user}",
         "gists_url" : "https://api.github.com/users/benthecarman/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/benthecarman",
         "id" : 15256660,
         "login" : "benthecarman",
         "node_id" : "MDQ6VXNlcjE1MjU2NjYw",
         "organizations_url" : "https://api.github.com/users/benthecarman/orgs",
         "received_events_url" : "https://api.github.com/users/benthecarman/received_events",
         "repos_url" : "https://api.github.com/users/benthecarman/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/benthecarman/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/benthecarman/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/benthecarman"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "reACK https://github.com/bitcoin/bitcoin/pull/19953/commits/4a7e0171c0eec437c5de2b0eb316c5088e5b07b0",
      "created_at" : "2020-10-09T12:32:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-706153809",
      "id" : 706153809,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwNjE1MzgwOQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-09T12:32:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/706153809",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "reACK https://github.com/bitcoin/bitcoin/pull/19953/commits/4a7e0171c0eec437c5de2b0eb316c5088e5b07b0",
      "created_at" : "2020-10-09T12:38:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-706156185",
      "id" : 706156185,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwNjE1NjE4NQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-09T12:38:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/706156185",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/11212268?v=4",
         "events_url" : "https://api.github.com/users/gruve-p/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gruve-p/followers",
         "following_url" : "https://api.github.com/users/gruve-p/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gruve-p/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gruve-p",
         "id" : 11212268,
         "login" : "gruve-p",
         "node_id" : "MDQ6VXNlcjExMjEyMjY4",
         "organizations_url" : "https://api.github.com/users/gruve-p/orgs",
         "received_events_url" : "https://api.github.com/users/gruve-p/received_events",
         "repos_url" : "https://api.github.com/users/gruve-p/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gruve-p/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gruve-p/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gruve-p"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r502483744"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/502483744"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Why is `tapleaf_hash` passed as a pointer with a non-null check? This function is always called with a non-null `tapleaf_hash`, so it'd make more sense to pass by reference.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-09T14:50:35Z",
      "diff_hunk" : "@@ -1504,58 +1791,146 @@ bool GenericTransactionSignatureChecker<T>::CheckSequence(const CScriptNum& nSeq\n template class GenericTransactionSignatureChecker<CTransaction>;\n template class GenericTransactionSignatureChecker<CMutableTransaction>;\n \n-static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, ScriptExecutionData& execdata, ScriptError* serror)\n {\n     std::vector<valtype> stack{stack_span.begin(), stack_span.end()};\n \n+    if (sigversion == SigVersion::TAPSCRIPT) {\n+        // OP_SUCCESSx processing overrides everything, including stack element size limits\n+        CScript::const_iterator pc = scriptPubKey.begin();\n+        while (pc < scriptPubKey.end()) {\n+            opcodetype opcode;\n+            if (!scriptPubKey.GetOp(pc, opcode)) {\n+                // Note how this condition would not be reached if an unknown OP_SUCCESSx was found\n+                return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n+            }\n+            // New opcodes will be listed here. May use a different sigversion to modify existing opcodes.\n+            if (IsOpSuccess(opcode)) {\n+                if (flags & SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS) {\n+                    return set_error(serror, SCRIPT_ERR_DISCOURAGE_OP_SUCCESS);\n+                }\n+                return set_success(serror);\n+            }\n+        }\n+\n+        // Tapscript enforces initial stack size limits (altstack is empty here)\n+        if (stack.size() > MAX_STACK_SIZE) {\n+            return set_error(serror, SCRIPT_ERR_STACK_SIZE);\n+        }\n+    }\n+\n     // Disallow stack item size > MAX_SCRIPT_ELEMENT_SIZE in witness stack\n     for (const valtype& elem : stack) {\n         if (elem.size() > MAX_SCRIPT_ELEMENT_SIZE) return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n     }\n \n     // Run the script interpreter.\n-    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, serror)) return false;\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, execdata, serror)) return false;\n \n     // Scripts inside witness implicitly require cleanstack behaviour\n     if (stack.size() != 1) return set_error(serror, SCRIPT_ERR_CLEANSTACK);\n     if (!CastToBool(stack.back())) return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n     return true;\n }\n \n-static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, const std::vector<unsigned char>& program, const CScript& script, uint256* tapleaf_hash)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r502483744",
      "id" : 502483744,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ4Mzc0NA==",
      "original_commit_id" : "4a7e0171c0eec437c5de2b0eb316c5088e5b07b0",
      "original_line" : 1834,
      "original_position" : 548,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 505746659,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/502483744",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r502840625"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/502840625"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "in 6b0f2a4320aebe1b802763a559cbaf3c348c2ffc:\r\n\r\nNot sure if it's needed but could add an assert for extra caution:\r\n```\r\nassert(txdata.m_spent_outputs.size() == tx.vin.size());\r\n```",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-10T22:48:12Z",
      "diff_hunk" : "@@ -1539,13 +1539,19 @@ bool CheckInputScripts(const CTransaction& tx, TxValidationState &state, const C\n     }\n \n     if (!txdata.m_ready) {\n-        txdata.Init(tx);\n+        std::vector<CTxOut> spent_outputs;\n+        spent_outputs.reserve(tx.vin.size());\n+\n+        for (const auto& txin : tx.vin) {\n+            const COutPoint& prevout = txin.prevout;\n+            const Coin& coin = inputs.AccessCoin(prevout);\n+            assert(!coin.IsSpent());\n+            spent_outputs.emplace_back(coin.out);\n+        }\n+        txdata.Init(tx, std::move(spent_outputs));\n     }\n \n     for (unsigned int i = 0; i < tx.vin.size(); i++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r502840625",
      "id" : 502840625,
      "line" : 1555,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg0MDYyNQ==",
      "original_commit_id" : "6b0f2a4320aebe1b802763a559cbaf3c348c2ffc",
      "original_line" : 1555,
      "original_position" : 17,
      "original_start_line" : null,
      "path" : "src/validation.cpp",
      "position" : 20,
      "pull_request_review_id" : 506131025,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/502840625",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1322187?v=4",
         "events_url" : "https://api.github.com/users/fjahr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fjahr/followers",
         "following_url" : "https://api.github.com/users/fjahr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fjahr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fjahr",
         "id" : 1322187,
         "login" : "fjahr",
         "node_id" : "MDQ6VXNlcjEzMjIxODc=",
         "organizations_url" : "https://api.github.com/users/fjahr/orgs",
         "received_events_url" : "https://api.github.com/users/fjahr/received_events",
         "repos_url" : "https://api.github.com/users/fjahr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fjahr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fjahr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fjahr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r502885312"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/502885312"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "in 68f87cb0da326bcaa2570ed6299a7ee1c6d7b5f6:\r\n\r\nnit: this could be at the beginning of the else block I think",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-11T08:42:34Z",
      "diff_hunk" : "@@ -1708,11 +1731,41 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n         } else {\n             return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH);\n         }\n+    } else if (witversion == 1 && program.size() == WITNESS_V1_TAPROOT_SIZE && !is_p2sh) {\n+        // BIP341 Taproot: 32-byte non-P2SH witness v1 program (which encodes a P2C-tweaked pubkey)\n+        if (!(flags & SCRIPT_VERIFY_TAPROOT)) return set_success(serror);\n+        if (stack.size() == 0) return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);\n+        if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {\n+            // Drop annex (this is non-standard; see IsWitnessStandard)\n+            SpanPopBack(stack);\n+        }\n+        if (stack.size() == 1) {\n+            // Key path spending (stack size is 1 after removing optional annex)\n+            if (!checker.CheckSchnorrSignature(stack.front(), program, SigVersion::TAPROOT, serror)) {\n+                return false;\n+            }\n+            return set_success(serror);\n+        } else {\n+            // Script path spending (stack size is >1 after removing optional annex)\n+            const valtype& control = SpanPopBack(stack);\n+            const valtype& script_bytes = SpanPopBack(stack);\n+            exec_script = CScript(script_bytes.begin(), script_bytes.end());\n+            if (control.size() < TAPROOT_CONTROL_BASE_SIZE || control.size() > TAPROOT_CONTROL_MAX_SIZE || ((control.size() - TAPROOT_CONTROL_BASE_SIZE) % TAPROOT_CONTROL_NODE_SIZE) != 0) {\n+                return set_error(serror, SCRIPT_ERR_TAPROOT_WRONG_CONTROL_SIZE);\n+            }\n+            if (!VerifyTaprootCommitment(control, program, exec_script)) {\n+                return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);\n+            }\n+            if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r502885312",
      "id" : 502885312,
      "line" : 1922,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg4NTMxMg==",
      "original_commit_id" : "68f87cb0da326bcaa2570ed6299a7ee1c6d7b5f6",
      "original_line" : 1922,
      "original_position" : 86,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 644,
      "pull_request_review_id" : 506131025,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/502885312",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1322187?v=4",
         "events_url" : "https://api.github.com/users/fjahr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fjahr/followers",
         "following_url" : "https://api.github.com/users/fjahr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fjahr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fjahr",
         "id" : 1322187,
         "login" : "fjahr",
         "node_id" : "MDQ6VXNlcjEzMjIxODc=",
         "organizations_url" : "https://api.github.com/users/fjahr/orgs",
         "received_events_url" : "https://api.github.com/users/fjahr/received_events",
         "repos_url" : "https://api.github.com/users/fjahr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fjahr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fjahr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fjahr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r502955684"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/502955684"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "in c3825c1bc41815d9b27d9a5dc36e46165b2f5861:\r\n\r\n```suggestion\r\n * success variable indicates whether the signature check itself succeeded.\r\n```",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-11T19:26:46Z",
      "diff_hunk" : "@@ -371,6 +368,66 @@ static bool EvalChecksig(const valtype& vchSig, const valtype& vchPubKey, CScrip\n     return true;\n }\n \n+static bool EvalChecksigTapscript(const valtype& sig, const valtype& pubkey, ScriptExecutionData& execdata, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& success)\n+{\n+    assert(sigversion == SigVersion::TAPSCRIPT);\n+\n+    /*\n+     *  The following validation sequence is consensus critical. Please note how --\n+     *    upgradable public key versions precede other rules;\n+     *    the script execution fails when using empty signature with invalid public key;\n+     *    the script execution fails when using non-empty invalid signature.\n+     */\n+    success = !sig.empty();\n+    if (success) {\n+        // Implement the sigops/witnesssize ratio test.\n+        // Passing with an upgradable public key version is also counted.\n+        assert(execdata.m_validation_weight_left_init);\n+        execdata.m_validation_weight_left -= VALIDATION_WEIGHT_PER_SIGOP_PASSED;\n+        if (execdata.m_validation_weight_left < 0) {\n+            return set_error(serror, SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT);\n+        }\n+    }\n+    if (pubkey.size() == 0) {\n+        return set_error(serror, SCRIPT_ERR_PUBKEYTYPE);\n+    } else if (pubkey.size() == 32) {\n+        if (success && !checker.CheckSchnorrSignature(sig, pubkey, sigversion, execdata, serror)) {\n+            return false;\n+        }\n+    } else {\n+        /*\n+         *  New public key version softforks should be defined before this `else` block.\n+         *  Generally, the new code should not do anything but failing the script execution. To avoid\n+         *  consensus bugs, it should not modify any existing values (including success).\n+         */\n+        if ((flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE) != 0) {\n+            return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE);\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+/** Helper for OP_CHECKSIG, OP_CHECKSIGVERIFY, and (in Tapscript) OP_CHECKSIGADD.\n+ *\n+ * A return value of false means the script fails entirely. When true is returned, the\n+ * fSuccess variable indicates whether the signature check itself succeeded.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r502955684",
      "id" : 502955684,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk1NTY4NA==",
      "original_commit_id" : "c3825c1bc41815d9b27d9a5dc36e46165b2f5861",
      "original_line" : 414,
      "original_position" : 64,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 506131025,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/502955684",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1322187?v=4",
         "events_url" : "https://api.github.com/users/fjahr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fjahr/followers",
         "following_url" : "https://api.github.com/users/fjahr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fjahr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fjahr",
         "id" : 1322187,
         "login" : "fjahr",
         "node_id" : "MDQ6VXNlcjEzMjIxODc=",
         "organizations_url" : "https://api.github.com/users/fjahr/orgs",
         "received_events_url" : "https://api.github.com/users/fjahr/received_events",
         "repos_url" : "https://api.github.com/users/fjahr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fjahr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fjahr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fjahr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r502963706"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/502963706"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "in 58c90569f75221bc4652cbde5cad4dbae543a1ca:\r\n\r\nnit\r\n```suggestion\r\n# The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\r\n```",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-11T20:45:03Z",
      "diff_hunk" : "@@ -0,0 +1,1403 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r502963706",
      "id" : 502963706,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk2MzcwNg==",
      "original_commit_id" : "58c90569f75221bc4652cbde5cad4dbae543a1ca",
      "original_line" : 100,
      "original_position" : 100,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 506131025,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/502963706",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1322187?v=4",
         "events_url" : "https://api.github.com/users/fjahr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fjahr/followers",
         "following_url" : "https://api.github.com/users/fjahr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fjahr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fjahr",
         "id" : 1322187,
         "login" : "fjahr",
         "node_id" : "MDQ6VXNlcjEzMjIxODc=",
         "organizations_url" : "https://api.github.com/users/fjahr/orgs",
         "received_events_url" : "https://api.github.com/users/fjahr/received_events",
         "repos_url" : "https://api.github.com/users/fjahr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fjahr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fjahr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fjahr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r502965296"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/502965296"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "in 58c90569f75221bc4652cbde5cad4dbae543a1ca:\r\n\r\nThere are already some 101 blocks mined on the taproot node to fund it earlier and then funds are transferred to the non-taproot node to fund it. I guess this generate can be removed and the blocks could be mined earlier?",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-11T21:00:45Z",
      "diff_hunk" : "@@ -0,0 +1,1403 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expression for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        return tweak_add_privkey(key, tweak)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    scriptsig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    witness_stack = flatten(get(ctx, \"witness\"))\n+    return (scriptsig, witness_stack)\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda returning (scriptsig, witness_stack), taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+# - Whether this test demands being placed in a txin with no corresponding txout (for testing SIGHASH_SINGLE behavior)\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail,need_vin_vout_mismatch\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, need_vin_vout_mismatch=False, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert tap is None\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert script is None\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert script is None\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert script is None\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            return spend(tx, idx, utxos, **conf)\n+        else:\n+            assert failure is not None\n+            return spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None, need_vin_vout_mismatch=need_vin_vout_mismatch)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    return bytes(CScript([pubkey, OP_CHECKSIG]))\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+def zero_appender(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a zero added.\"\"\"\n+    return lambda ctx: deep_eval(ctx, expr) + b\"\\x00\"\n+\n+def byte_popper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with its last byte removed.\"\"\"\n+    return lambda ctx: deep_eval(ctx, expr)[:-1]\n+\n+# Expected error strings\n+\n+ERR_KEYPATH_INVALID_SIG = {\"err_msg\": \"Invalid signature for Taproot key path spending\"}\n+ERR_SCRIPTPATH_INVALID_SIG = {\"err_msg\": \"Signature must be zero for failed CHECK(MULTI)SIG operation\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_TAPSCRIPT_CHECKMULTISIG = {\"err_msg\": \"OP_CHECKMULTISIG(VERIFY) is not available in tapscript\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal in tapscript\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Stack size must be exactly one after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+ERR_CHECKSIGVERIFY = {\"err_msg\": \"Script failed an OP_CHECKSIGVERIFY operation\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+VALID_SIGHASHES_TAPROOT_SINGLE = [\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT_NO_SINGLE = [h for h in VALID_SIGHASHES_TAPROOT if h not in VALID_SIGHASHES_TAPROOT_SINGLE]\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SIG_POP_BYTE = {\"failure\": {\"sign\": byte_popper(default_sign)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+SIG_ADD_ZERO = {\"failure\": {\"sign\": zero_appender(default_sign)}}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 50000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    secs = [generate_privkey() for _ in range(8)]\n+    pubs = [compute_xonly_pubkey(sec)[0] for sec in secs]\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    tap = taproot_construct(pubs[0])\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=secs[0], failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=secs[0], failure={\"sighash\": bitflipper(default_sighash)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=secs[0], failure={\"flag_flip_r\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=secs[0], failure={\"flag_flip_p\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=secs[0], failure={\"signature\": bitflipper(default_signature)}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pubs[0])\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pubs[1])))]\n+            tap = taproot_construct(pubs[0], scripts)\n+            add_spender(spenders, \"sighash/keypath_hashtype_%x\" % hashtype, tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath_hashtype_%x\" % hashtype, tap=tap, leaf=\"s0\", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+            # Test SIGHASH_SINGLE behavior in combination with mismatching outputs\n+            if hashtype in VALID_SIGHASHES_TAPROOT_SINGLE:\n+                add_spender(spenders, \"sighash/keypath_hashtype_mis_%x\" % hashtype, tap=tap, key=secs[0], annex=annex, standard=no_annex, hashtype_actual=random.choice(VALID_SIGHASHES_TAPROOT_NO_SINGLE), failure={\"hashtype_actual\": hashtype}, **ERR_KEYPATH_INVALID_SIG, need_vin_vout_mismatch=True)\n+                add_spender(spenders, \"sighash/scriptpath_hashtype_mis_%x\" % hashtype, tap=tap, leaf=\"s0\", key=secs[1], annex=annex, standard=no_annex, hashtype_actual=random.choice(VALID_SIGHASHES_TAPROOT_NO_SINGLE), **SINGLE_SIG, failure={\"hashtype_actual\": hashtype}, **ERR_SCRIPTPATH_INVALID_SIG, need_vin_vout_mismatch=True)\n+\n+        # Test OP_CODESEPARATOR impact on sighashing.\n+        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+        common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+        scripts = [\n+            (\"pk_codesep\", CScript(random_checksig_style(pubs[1]) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig\n+            (\"codesep_pk\", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pubs[1]))),  # codesep before checksig\n+            (\"branched_codesep\", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pubs[0], OP_ELSE, OP_CODESEPARATOR, pubs[1], OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"sighash/pk_codesep\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/codesep_pk\", tap=tap, leaf=\"codesep_pk\", key=secs[1], codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/left\", tap=tap, leaf=\"branched_codesep\", key=secs[0], codeseppos=3, **common, inputs=[getter(\"sign\"), b'\\x01'], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/right\", tap=tap, leaf=\"branched_codesep\", key=secs[1], codeseppos=6, **common, inputs=[getter(\"sign\"), b''], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Reusing the scripts above, test that various features affect the sighash.\n+    add_spender(spenders, \"sighash/annex\", tap=tap, leaf=\"pk_codesep\", key=secs[1], hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={\"sighash\": override(default_sighash, annex=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/script\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, script_taproot=tap.leaves[\"codesep_pk\"].script)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/leafver\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leafversion=random.choice([x & 0xFE for x in range(0x100) if x & 0xFE != 0xC0]))}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leaf=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/keypath\", tap=tap, key=secs[0], **common, failure={\"sighash\": override(default_sighash, leaf=\"pk_codesep\")}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # Test that invalid hashtypes don't work, both in key path and script path spends\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for invalid_hashtype in [x for x in range(0x100) if x not in VALID_SIGHASHES_TAPROOT]:\n+        add_spender(spenders, \"sighash/keypath_unk_hashtype_%x\" % invalid_hashtype, tap=tap, key=secs[0], hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_KEYPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/scriptpath_unk_hashtype_%x\" % invalid_hashtype, tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Test that hashtype 0 cannot have a hashtype byte, and 1 must have one.\n+    add_spender(spenders, \"sighash/hashtype0_byte_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    # Test that hashtype 0 and hashtype 1 cannot be transmuted into each other.\n+    add_spender(spenders, \"sighash/hashtype0to1_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0to1_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Test aspects of signatures with unusual lengths\n+    for hashtype in [SIGHASH_DEFAULT, random.choice(VALID_SIGHASHES_TAPROOT)]:\n+        scripts = [\n+            (\"csv\", CScript([pubs[2], OP_CHECKSIGVERIFY, OP_1])),\n+            (\"cs_pos\", CScript([pubs[2], OP_CHECKSIG])),\n+            (\"csa_pos\", CScript([OP_0, pubs[2], OP_CHECKSIGADD, OP_1, OP_EQUAL])),\n+            (\"cs_neg\", CScript([pubs[2], OP_CHECKSIG, OP_NOT])),\n+            (\"csa_neg\", CScript([OP_2, pubs[2], OP_CHECKSIGADD, OP_2, OP_EQUAL]))\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[3], scripts)\n+        # Empty signatures\n+        add_spender(spenders, \"siglen/empty_keypath\", tap=tap, key=secs[3], hashtype=hashtype, failure={\"sign\": b\"\"}, **ERR_KEYPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/empty_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_CHECKSIGVERIFY)\n+        add_spender(spenders, \"siglen/empty_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_NO_SUCCESS)\n+        add_spender(spenders, \"siglen/empty_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_NO_SUCCESS)\n+        add_spender(spenders, \"siglen/empty_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": lambda _: random_bytes(random.randrange(1, 100))}, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/empty_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": lambda _: random_bytes(random.randrange(1, 100))}, **ERR_SCRIPTPATH_INVALID_SIG)\n+        # Appending a zero byte to signatures invalidates them\n+        add_spender(spenders, \"siglen/padzero_keypath\", tap=tap, key=secs[3], hashtype=hashtype, **SIG_ADD_ZERO, **ERR_KEYPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/padzero_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/padzero_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/padzero_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/padzero_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_ADD_ZERO, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/padzero_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_ADD_ZERO, **ERR_SCRIPTPATH_INVALID_SIG)\n+        # Removing the last byte from signatures invalidates them\n+        add_spender(spenders, \"siglen/popbyte_keypath\", tap=tap, key=secs[3], hashtype=hashtype, **SIG_POP_BYTE, **ERR_KEYPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/popbyte_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/popbyte_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/popbyte_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/popbyte_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_POP_BYTE, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/popbyte_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_POP_BYTE, **ERR_SCRIPTPATH_INVALID_SIG)\n+        # Verify that an invalid signature is not allowed, not even when the CHECKSIG* is expected to fail.\n+        add_spender(spenders, \"siglen/invalid_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": default_sign, \"sighash\": bitflipper(default_sighash)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/invalid_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": default_sign, \"sighash\": bitflipper(default_sighash)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # == Test that BIP341 spending only applies to witness version 1, program length 32, no P2SH ==\n+\n+    for p2sh in [False, True]:\n+        for witver in range(1, 17):\n+            for witlen in [20, 31, 32, 33]:\n+                def mutate(spk):\n+                    prog = spk[2:]\n+                    assert len(prog) == 32\n+                    if witlen < 32:\n+                        prog = prog[0:witlen]\n+                    elif witlen > 32:\n+                        prog += bytes([0 for _ in range(witlen - 32)])\n+                    return CScript([CScriptOp.encode_op_n(witver), prog])\n+                scripts = [(\"s0\", CScript([pubs[0], OP_CHECKSIG])), (\"dummy\", CScript([OP_RETURN]))]\n+                tap = taproot_construct(pubs[1], scripts)\n+                if not p2sh and witver == 1 and witlen == 32:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, failure={\"leaf\": \"dummy\"}, **ERR_OP_RETURN)\n+                else:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], standard=False)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, standard=False)\n+\n+    # == Test various aspects of BIP341 spending paths ==\n+\n+    # A set of functions that compute the hashing partner in a Merkle tree, designed to exercise\n+    # edge cases. This relies on the taproot_construct feature that a lambda can be passed in\n+    # instead of a subtree, to compute the partner to be hashed with.\n+    PARTNER_MERKLE_FN = [\n+        # Combine with itself\n+        lambda h: h,\n+        # Combine with hash 0\n+        lambda h: bytes([0 for _ in range(32)]),\n+        # Combine with hash 2^256-1\n+        lambda h: bytes([0xff for _ in range(32)]),\n+        # Combine with itself-1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') + 1).to_bytes(32, 'big'),\n+        # Combine with itself-1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') + 1).to_bytes(32, 'little'),\n+        # Combine with random bitflipped version of self.\n+        lambda h: (int.from_bytes(h, 'little') ^ (1 << random.randrange(256))).to_bytes(32, 'little')\n+    ]\n+    # Start with a tree of that has depth 1 for \"128deep\" and depth 2 for \"129deep\".\n+    scripts = [(\"128deep\", CScript([pubs[0], OP_CHECKSIG])), [(\"129deep\", CScript([pubs[0], OP_CHECKSIG])), random.choice(PARTNER_MERKLE_FN)]]\n+    # Add 127 nodes on top of that tree, so that \"128deep\" and \"129deep\" end up at their designated depths.\n+    for _ in range(127):\n+        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+    tap = taproot_construct(pubs[0], scripts)\n+    # Test that spends with a depth of 128 work, but 129 doesn't (even with a tree with weird Merkle branches in it).\n+    add_spender(spenders, \"spendpath/merklelimit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"leaf\": \"129deep\"}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that flipping the negation bit invalidates spends.\n+    add_spender(spenders, \"spendpath/negflag\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"negflag\": lambda ctx: 1 - default_negflag(ctx)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the Merkle branch invalidate it.\n+    add_spender(spenders, \"spendpath/bitflipmerkle\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"merklebranch\": bitflipper(default_merklebranch)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the inner pubkey invalidate it.\n+    add_spender(spenders, \"spendpath/bitflippubkey\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"pubkey_inner\": bitflipper(default_pubkey_inner)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that empty witnesses are invalid.\n+    add_spender(spenders, \"spendpath/emptywit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"witness\": []}, **ERR_EMPTY_WITNESS)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padlongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/trunclongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    scripts = [(\"s\", CScript([pubs[0], OP_CHECKSIG]))]\n+    tap = taproot_construct(pubs[1], scripts)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/truncshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block to 1 byte (\"-1 Merkle length\") invalidates it\n+    add_spender(spenders, \"spendpath/trunc1shortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:1]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    # == Test BIP342 edge cases ==\n+\n+    csa_low_val = random.randrange(0, 17) # Within range for OP_n\n+    csa_low_result = csa_low_val + 1\n+\n+    csa_high_val = random.randrange(17, 100) if random.getrandbits(1) else random.randrange(-100, -1) # Outside OP_n range\n+    csa_high_result = csa_high_val + 1\n+\n+    OVERSIZE_NUMBER = 2**31\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER))), 6)\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER-1))), 5)\n+\n+    big_choices = []\n+    big_scriptops = []\n+    for i in range(1000):\n+        r = random.randrange(len(pubs))\n+        big_choices.append(r)\n+        big_scriptops += [pubs[r], OP_CHECKSIGVERIFY]\n+\n+\n+    def big_spend_inputs(ctx):\n+        \"\"\"Helper function to construct the script input for t33/t34 below.\"\"\"\n+        # Instead of signing 999 times, precompute signatures for every (key, hashtype) combination\n+        sigs = {}\n+        for ht in VALID_SIGHASHES_TAPROOT:\n+            for k in range(len(pubs)):\n+                sigs[(k, ht)] = override(default_sign, hashtype=ht, key=secs[k])(ctx)\n+        num = get(ctx, \"num\")\n+        return [sigs[(big_choices[i], random.choice(VALID_SIGHASHES_TAPROOT))] for i in range(num - 1, -1, -1)]\n+\n+    # Various BIP342 features\n+    scripts = [\n+        # 0) drop stack element and OP_CHECKSIG\n+        (\"t0\", CScript([OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 1) normal OP_CHECKSIG\n+        (\"t1\", CScript([pubs[1], OP_CHECKSIG])),\n+        # 2) normal OP_CHECKSIGVERIFY\n+        (\"t2\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1])),\n+        # 3) Hypothetical OP_CHECKMULTISIG script that takes a single sig as input\n+        (\"t3\", CScript([OP_0, OP_SWAP, OP_1, pubs[1], OP_1, OP_CHECKMULTISIG])),\n+        # 4) Hypothetical OP_CHECKMULTISIGVERIFY script that takes a single sig as input\n+        (\"t4\", CScript([OP_0, OP_SWAP, OP_1, pubs[1], OP_1, OP_CHECKMULTISIGVERIFY, OP_1])),\n+        # 5) OP_IF script that needs a true input\n+        (\"t5\", CScript([OP_IF, pubs[1], OP_CHECKSIG, OP_ELSE, OP_RETURN, OP_ENDIF])),\n+        # 6) OP_NOTIF script that needs a true input\n+        (\"t6\", CScript([OP_NOTIF, OP_RETURN, OP_ELSE, pubs[1], OP_CHECKSIG, OP_ENDIF])),\n+        # 7) OP_CHECKSIG with an empty key\n+        (\"t7\", CScript([OP_0, OP_CHECKSIG])),\n+        # 8) OP_CHECKSIGVERIFY with an empty key\n+        (\"t8\", CScript([OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 9) normal OP_CHECKSIGADD that also ensures return value is correct\n+        (\"t9\", CScript([csa_low_val, pubs[1], OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 10) OP_CHECKSIGADD with empty key\n+        (\"t10\", CScript([csa_low_val, OP_0, OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 11) OP_CHECKSIGADD with missing counter stack element\n+        (\"t11\", CScript([pubs[1], OP_CHECKSIGADD, OP_1, OP_EQUAL])),\n+        # 12) OP_CHECKSIG that needs invalid signature\n+        (\"t12\", CScript([pubs[1], OP_CHECKSIGVERIFY, pubs[0], OP_CHECKSIG, OP_NOT])),\n+        # 13) OP_CHECKSIG with empty key that needs invalid signature\n+        (\"t13\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_CHECKSIG, OP_NOT])),\n+        # 14) OP_CHECKSIGADD that needs invalid signature\n+        (\"t14\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, pubs[0], OP_CHECKSIGADD, OP_NOT])),\n+        # 15) OP_CHECKSIGADD with empty key that needs invalid signature\n+        (\"t15\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGADD, OP_NOT])),\n+        # 16) OP_CHECKSIG with unknown pubkey type\n+        (\"t16\", CScript([OP_1, OP_CHECKSIG])),\n+        # 17) OP_CHECKSIGADD with unknown pubkey type\n+        (\"t17\", CScript([OP_0, OP_1, OP_CHECKSIGADD])),\n+        # 18) OP_CHECKSIGVERIFY with unknown pubkey type\n+        (\"t18\", CScript([OP_1, OP_CHECKSIGVERIFY, OP_1])),\n+        # 19) script longer than 10000 bytes and over 201 non-push opcodes\n+        (\"t19\", CScript([OP_0, OP_0, OP_2DROP] * 10001 + [pubs[1], OP_CHECKSIG])),\n+        # 20) OP_CHECKSIGVERIFY with empty key\n+        (\"t20\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 21) Script that grows the stack to 1000 elements\n+        (\"t21\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 999 + [OP_DROP] * 999)),\n+        # 22) Script that grows the stack to 1001 elements\n+        (\"t22\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 1000 + [OP_DROP] * 1000)),\n+        # 23) Script that expects an input stack of 1000 elements\n+        (\"t23\", CScript([OP_DROP] * 999 + [pubs[1], OP_CHECKSIG])),\n+        # 24) Script that expects an input stack of 1001 elements\n+        (\"t24\", CScript([OP_DROP] * 1000 + [pubs[1], OP_CHECKSIG])),\n+        # 25) Script that pushes a MAX_SCRIPT_ELEMENT_SIZE-bytes element\n+        (\"t25\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE), OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 26) Script that pushes a (MAX_SCRIPT_ELEMENT_SIZE+1)-bytes element\n+        (\"t26\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 27) CHECKSIGADD that must fail because numeric argument number is >4 bytes\n+        (\"t27\", CScript([CScriptNum(OVERSIZE_NUMBER), pubs[1], OP_CHECKSIGADD])),\n+        # 28) Pushes random CScriptNum value, checks OP_CHECKSIGADD result\n+        (\"t28\", CScript([csa_high_val, pubs[1], OP_CHECKSIGADD, csa_high_result, OP_EQUAL])),\n+        # 29) CHECKSIGADD that succeeds with proper sig because numeric argument number is <=4 bytes\n+        (\"t29\", CScript([CScriptNum(OVERSIZE_NUMBER-1), pubs[1], OP_CHECKSIGADD])),\n+        # 30) Variant of t1 with \"normal\" 33-byte pubkey\n+        (\"t30\", CScript([b'\\x03' + pubs[1], OP_CHECKSIG])),\n+        # 31) Variant of t2 with \"normal\" 33-byte pubkey\n+        (\"t31\", CScript([b'\\x02' + pubs[1], OP_CHECKSIGVERIFY, OP_1])),\n+        # 32) Variant of t28 with \"normal\" 33-byte pubkey\n+        (\"t32\", CScript([csa_high_val, b'\\x03' + pubs[1], OP_CHECKSIGADD, csa_high_result, OP_EQUAL])),\n+        # 33) 999-of-999 multisig\n+        (\"t33\", CScript(big_scriptops[:1998] + [OP_1])),\n+        # 34) 1000-of-1000 multisig\n+        (\"t34\", CScript(big_scriptops[:2000] + [OP_1])),\n+        # 35) Variant of t9 that uses a non-minimally encoded input arg\n+        (\"t35\", CScript([bytes([csa_low_val]), pubs[1], OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 36) Empty script\n+        (\"t36\", CScript([])),\n+    ]\n+    # Add many dummies to test huge trees\n+    for j in range(100000):\n+        scripts.append((None, CScript([OP_RETURN, random.randrange(100000)])))\n+    random.shuffle(scripts)\n+    tap = taproot_construct(pubs[0], scripts)\n+    common = {\n+        \"hashtype\": hashtype,\n+        \"key\": secs[1],\n+        \"tap\": tap,\n+    }\n+    # Test that MAX_SCRIPT_ELEMENT_SIZE byte stack element inputs are valid, but not one more (and 80 bytes is standard but 81 is not).\n+    add_spender(spenders, \"tapscript/inputmaxlimit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE)], failure={\"inputs\": [getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1)]}, **ERR_PUSH_LIMIT)\n+    add_spender(spenders, \"tapscript/input80limit\", leaf=\"t0\", **common, inputs=[getter(\"sign\"), random_bytes(80)])\n+    add_spender(spenders, \"tapscript/input81limit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(81)])\n+    # Test that OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY cause failure, but OP_CHECKSIG and OP_CHECKSIGVERIFY work.\n+    add_spender(spenders, \"tapscript/disabled_checkmultisig\", leaf=\"t1\", **common, **SINGLE_SIG, failure={\"leaf\": \"t3\"}, **ERR_TAPSCRIPT_CHECKMULTISIG)\n+    add_spender(spenders, \"tapscript/disabled_checkmultisigverify\", leaf=\"t2\", **common, **SINGLE_SIG, failure={\"leaf\": \"t4\"}, **ERR_TAPSCRIPT_CHECKMULTISIG)\n+    # Test that OP_IF and OP_NOTIF do not accept non-0x01 as truth value (the MINIMALIF rule is consensus in Tapscript)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x02']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x03']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0001']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0100']}, **ERR_MINIMALIF)\n+    # Test that 1-byte public keys (which are unknown) are acceptable but nonstandard with unrelated signatures, but 0-byte public keys are not valid.\n+    add_spender(spenders, \"tapscript/unkpk/checksig\", leaf=\"t16\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigadd\", leaf=\"t17\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigverify\", leaf=\"t18\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that 33-byte public keys (which are unknown) are acceptable but nonstandard with valid signatures, but normal pubkeys are not valid in that case.\n+    add_spender(spenders, \"tapscript/oldpk/checksig\", leaf=\"t30\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t1\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"tapscript/oldpk/checksigadd\", leaf=\"t31\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t2\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"tapscript/oldpk/checksigverify\", leaf=\"t32\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t28\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    # Test that 0-byte public keys are not acceptable.\n+    add_spender(spenders, \"tapscript/emptypk/checksig\", leaf=\"t1\", **SINGLE_SIG, **common, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigverify\", leaf=\"t2\", **SINGLE_SIG, **common, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigadd\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigadd\", leaf=\"t35\", standard=False, **SINGLE_SIG, **common, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that OP_CHECKSIGADD results are as expected\n+    add_spender(spenders, \"tapscript/checksigaddresults\", leaf=\"t28\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    add_spender(spenders, \"tapscript/checksigaddoversize\", leaf=\"t29\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    # Test that OP_CHECKSIGADD requires 3 stack elements.\n+    add_spender(spenders, \"tapscript/checksigadd3args\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t11\"}, **ERR_STACK_EMPTY)\n+    # Test that empty signatures do not cause script failure in OP_CHECKSIG and OP_CHECKSIGADD (but do fail with empty pubkey, and do fail OP_CHECKSIGVERIFY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksig\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t13\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/nochecksigverify\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t20\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksigadd\", leaf=\"t14\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t15\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that scripts over 10000 bytes (and over 201 non-push ops) are acceptable.\n+    add_spender(spenders, \"tapscript/no10000limit\", leaf=\"t19\", **SINGLE_SIG, **common)\n+    # Test that a stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000stack\", leaf=\"t21\", **SINGLE_SIG, **common, failure={\"leaf\": \"t22\"}, **ERR_STACK_SIZE)\n+    # Test that an input stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000inputs\", leaf=\"t23\", **common, inputs=[getter(\"sign\")] + [b'' for _ in range(999)], failure={\"leaf\": \"t24\", \"inputs\": [getter(\"sign\")] + [b'' for _ in range(1000)]}, **ERR_STACK_SIZE)\n+    # Test that pushing a MAX_SCRIPT_ELEMENT_SIZE byte stack element is valid, but one longer is not.\n+    add_spender(spenders, \"tapscript/pushmaxlimit\", leaf=\"t25\", **common, **SINGLE_SIG, failure={\"leaf\": \"t26\"}, **ERR_PUSH_LIMIT)\n+    # Test that 999-of-999 multisig works (but 1000-of-1000 triggers stack size limits)\n+    add_spender(spenders, \"tapscript/bigmulti\", leaf=\"t33\", **common, inputs=big_spend_inputs, num=999, failure={\"leaf\": \"t34\", \"num\": 1000}, **ERR_STACK_SIZE)\n+    # Test that the CLEANSTACK rule is consensus critical in tapscript\n+    add_spender(spenders, \"tapscript/cleanstack\", leaf=\"t36\", tap=tap, inputs=[b'\\x01'], failure={\"inputs\": [b'\\x01', b'\\x01']}, **ERR_CLEANSTACK)\n+\n+    # == Test for sigops ratio limit ==\n+\n+    # Given a number n, and a public key pk, functions that produce a (CScript, sigops). Each script takes as\n+    # input a valid signature with the passed pk followed by a dummy push of bytes that are to be dropped, and\n+    # will execute sigops signature checks.\n+    SIGOPS_RATIO_SCRIPTS = [\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIG.\n+        lambda n, pk: (CScript([OP_DROP, pk] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGVERIFY.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_0, OP_IF, OP_2DUP, OP_CHECKSIGVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_2, OP_SWAP, OP_CHECKSIGADD, OP_3, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIG.\n+        lambda n, pk: (CScript([random_bytes(220), OP_2DROP, pk, OP_1, OP_NOTIF, OP_2DUP, OP_CHECKSIG, OP_VERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_4, OP_SWAP, OP_CHECKSIGADD, OP_5, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGADD.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_1, OP_IF, OP_ELSE, OP_2DUP, OP_6, OP_SWAP, OP_CHECKSIGADD, OP_7, OP_EQUALVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_8, OP_SWAP, OP_CHECKSIGADD, OP_9, OP_EQUAL]), n + 1),\n+        # n+1 OP_CHECKSIGs, but also one OP_CHECKSIG with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, pk, OP_CHECKSIG, OP_NOT, OP_VERIFY, pk] + [OP_2DUP, OP_CHECKSIG, OP_VERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGADDs and 1 OP_CHECKSIG, but also an OP_CHECKSIGADD with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, OP_10, pk, OP_CHECKSIGADD, OP_10, OP_EQUALVERIFY, pk] + [OP_2DUP, OP_16, OP_SWAP, OP_CHECKSIGADD, b'\\x11', OP_EQUALVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+    ]\n+    for annex in [None, bytes([ANNEX_TAG]) + random_bytes(random.randrange(1000))]:\n+        for hashtype in [SIGHASH_DEFAULT, SIGHASH_ALL]:\n+            for pubkey in [pubs[1], random_bytes(random.choice([x for x in range(2, 81) if x != 32]))]:\n+                for fn_num, fn in enumerate(SIGOPS_RATIO_SCRIPTS):\n+                    merkledepth = random.randrange(129)\n+\n+\n+                    def predict_sigops_ratio(n, dummy_size):\n+                        \"\"\"Predict whether spending fn(n, pubkey) with dummy_size will pass the ratio test.\"\"\"\n+                        script, sigops = fn(n, pubkey)\n+                        # Predict the size of the witness for a given choice of n\n+                        stacklen_size = 1\n+                        sig_size = 64 + (hashtype != SIGHASH_DEFAULT)\n+                        siglen_size = 1\n+                        dummylen_size = 1 + 2 * (dummy_size >= 253)\n+                        script_size = len(script)\n+                        scriptlen_size = 1 + 2 * (script_size >= 253)\n+                        control_size = 33 + 32 * merkledepth\n+                        controllen_size = 1 + 2 * (control_size >= 253)\n+                        annex_size = 0 if annex is None else len(annex)\n+                        annexlen_size = 0 if annex is None else 1 + 2 * (annex_size >= 253)\n+                        witsize = stacklen_size + sig_size + siglen_size + dummy_size + dummylen_size + script_size + scriptlen_size + control_size + controllen_size + annex_size + annexlen_size\n+                        # sigops ratio test\n+                        return witsize + 50 >= 50 * sigops\n+                    # Make sure n is high enough that with empty dummy, the script is not valid\n+                    n = 0\n+                    while predict_sigops_ratio(n, 0):\n+                        n += 1\n+                    # But allow picking a bit higher still\n+                    n += random.randrange(5)\n+                    # Now pick dummy size *just* large enough that the overall construction passes\n+                    dummylen = 0\n+                    while not predict_sigops_ratio(n, dummylen):\n+                        dummylen += 1\n+                    scripts = [(\"s\", fn(n, pubkey)[0])]\n+                    for _ in range(merkledepth):\n+                        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+                    tap = taproot_construct(pubs[0], scripts)\n+                    standard = annex is None and dummylen <= 80 and len(pubkey) == 32\n+                    add_spender(spenders, \"tapscript/sigopsratio_%i\" % fn_num, tap=tap, leaf=\"s\", annex=annex, hashtype=hashtype, key=secs[1], inputs=[getter(\"sign\"), random_bytes(dummylen)], standard=standard, failure={\"inputs\": [getter(\"sign\"), random_bytes(dummylen - 1)]}, **ERR_SIGOPS_RATIO)\n+\n+    # Future leaf versions\n+    for leafver in range(0, 0x100, 2):\n+        if leafver == LEAF_VERSION_TAPSCRIPT or leafver == ANNEX_TAG:\n+            # Skip the defined LEAF_VERSION_TAPSCRIPT, and the ANNEX_TAG which is not usable as leaf version\n+            continue\n+        scripts = [\n+            (\"bare_c0\", CScript([OP_NOP])),\n+            (\"bare_unkver\", CScript([OP_NOP]), leafver),\n+            (\"return_c0\", CScript([OP_RETURN])),\n+            (\"return_unkver\", CScript([OP_RETURN]), leafver),\n+            (\"undecodable_c0\", CScript([OP_PUSHDATA1])),\n+            (\"undecodable_unkver\", CScript([OP_PUSHDATA1]), leafver),\n+            (\"bigpush_c0\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP])),\n+            (\"bigpush_unkver\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP]), leafver),\n+            (\"1001push_c0\", CScript([OP_0] * 1001)),\n+            (\"1001push_unkver\", CScript([OP_0] * 1001), leafver),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"unkver/bare\", standard=False, tap=tap, leaf=\"bare_unkver\", failure={\"leaf\": \"bare_c0\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"unkver/return\", standard=False, tap=tap, leaf=\"return_unkver\", failure={\"leaf\": \"return_c0\"}, **ERR_OP_RETURN)\n+        add_spender(spenders, \"unkver/undecodable\", standard=False, tap=tap, leaf=\"undecodable_unkver\", failure={\"leaf\": \"undecodable_c0\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"unkver/bigpush\", standard=False, tap=tap, leaf=\"bigpush_unkver\", failure={\"leaf\": \"bigpush_c0\"}, **ERR_PUSH_LIMIT)\n+        add_spender(spenders, \"unkver/1001push\", standard=False, tap=tap, leaf=\"1001push_unkver\", failure={\"leaf\": \"1001push_c0\"}, **ERR_STACK_SIZE)\n+        add_spender(spenders, \"unkver/1001inputs\", standard=False, tap=tap, leaf=\"bare_unkver\", inputs=[b'']*1001, failure={\"leaf\": \"bare_c0\"}, **ERR_STACK_SIZE)\n+\n+    # OP_SUCCESSx tests.\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for opval in range(76, 0x100):\n+        opcode = CScriptOp(opval)\n+        if not is_op_success(opcode):\n+            continue\n+        scripts = [\n+            (\"bare_success\", CScript([opcode])),\n+            (\"bare_nop\", CScript([OP_NOP])),\n+            (\"unexecif_success\", CScript([OP_0, OP_IF, opcode, OP_ENDIF])),\n+            (\"unexecif_nop\", CScript([OP_0, OP_IF, OP_NOP, OP_ENDIF])),\n+            (\"return_success\", CScript([OP_RETURN, opcode])),\n+            (\"return_nop\", CScript([OP_RETURN, OP_NOP])),\n+            (\"undecodable_success\", CScript([opcode, OP_PUSHDATA1])),\n+            (\"undecodable_nop\", CScript([OP_NOP, OP_PUSHDATA1])),\n+            (\"undecodable_bypassed_success\", CScript([OP_PUSHDATA1, OP_2, opcode])),\n+            (\"bigpush_success\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, opcode])),\n+            (\"bigpush_nop\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, OP_NOP])),\n+            (\"1001push_success\", CScript([OP_0] * 1001 + [opcode])),\n+            (\"1001push_nop\", CScript([OP_0] * 1001 + [OP_NOP])),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"opsuccess/bare\", standard=False, tap=tap, leaf=\"bare_success\", failure={\"leaf\": \"bare_nop\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"opsuccess/exexecif\", standard=False, tap=tap, leaf=\"unexecif_success\", failure={\"leaf\": \"unexecif_nop\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"opsuccess/return\", standard=False, tap=tap, leaf=\"return_success\", failure={\"leaf\": \"return_nop\"}, **ERR_OP_RETURN)\n+        add_spender(spenders, \"opsuccess/undecodable\", standard=False, tap=tap, leaf=\"undecodable_success\", failure={\"leaf\": \"undecodable_nop\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"opsuccess/undecodable_bypass\", standard=False, tap=tap, leaf=\"undecodable_success\", failure={\"leaf\": \"undecodable_bypassed_success\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"opsuccess/bigpush\", standard=False, tap=tap, leaf=\"bigpush_success\", failure={\"leaf\": \"bigpush_nop\"}, **ERR_PUSH_LIMIT)\n+        add_spender(spenders, \"opsuccess/1001push\", standard=False, tap=tap, leaf=\"1001push_success\", failure={\"leaf\": \"1001push_nop\"}, **ERR_STACK_SIZE)\n+        add_spender(spenders, \"opsuccess/1001inputs\", standard=False, tap=tap, leaf=\"bare_success\", inputs=[b'']*1001, failure={\"leaf\": \"bare_nop\"}, **ERR_STACK_SIZE)\n+\n+    # Non-OP_SUCCESSx (verify that those aren't accidentally treated as OP_SUCCESSx)\n+    for opval in range(0, 0x100):\n+        opcode = CScriptOp(opval)\n+        if is_op_success(opcode):\n+            continue\n+        scripts = [\n+            (\"normal\", CScript([OP_RETURN, opcode] + [OP_NOP] * 75)),\n+            (\"op_success\", CScript([OP_RETURN, CScriptOp(0x50)]))\n+        ]\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"alwaysvalid/notsuccessx\", tap=tap, leaf=\"op_success\", inputs=[], standard=False, failure={\"leaf\": \"normal\"}) # err_msg differs based on opcode\n+\n+    # == Legacy tests ==\n+\n+    # Also add a few legacy spends into the mix, so that transactions which combine taproot and pre-taproot spends get tested too.\n+    for compressed in [False, True]:\n+        eckey1 = ECKey()\n+        eckey1.set(generate_privkey(), compressed)\n+        pubkey1 = eckey1.get_pubkey().get_bytes()\n+        eckey2 = ECKey()\n+        eckey2.set(generate_privkey(), compressed)\n+        for p2sh in [False, True]:\n+            for witv0 in [False, True]:\n+                for hashtype in VALID_SIGHASHES_ECDSA + [random.randrange(0x04, 0x80), random.randrange(0x84, 0x100)]:\n+                    standard = (hashtype in VALID_SIGHASHES_ECDSA) and (compressed or not witv0)\n+                    add_spender(spenders, \"legacy/pk-wrongkey\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, script=CScript([pubkey1, OP_CHECKSIG]), **SINGLE_SIG, key=eckey1, failure={\"key\": eckey2}, sigops_weight=4-3*witv0, **ERR_NO_SUCCESS)\n+                    add_spender(spenders, \"legacy/pkh-sighashflip\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, pkh=pubkey1, key=eckey1, **SIGHASH_BITFLIP, sigops_weight=4-3*witv0, **ERR_NO_SUCCESS)\n+\n+    # Verify that OP_CHECKSIGADD wasn't accidentally added to pre-taproot validation logic.\n+    for p2sh in [False, True]:\n+        for witv0 in [False, True]:\n+            for hashtype in VALID_SIGHASHES_ECDSA + [random.randrange(0x04, 0x80), random.randrange(0x84, 0x100)]:\n+                standard = hashtype in VALID_SIGHASHES_ECDSA and (p2sh or witv0)\n+                add_spender(spenders, \"compat/nocsa\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, script=CScript([OP_IF, OP_11, pubkey1, OP_CHECKSIGADD, OP_12, OP_EQUAL, OP_ELSE, pubkey1, OP_CHECKSIG, OP_ENDIF]), key=eckey1, sigops_weight=4-3*witv0, inputs=[getter(\"sign\"), b''], failure={\"inputs\": [getter(\"sign\"), b'\\x01']}, **ERR_UNDECODABLE)\n+\n+    return spenders\n+\n+def spenders_taproot_inactive():\n+    \"\"\"Spenders for testing that pre-activation Taproot rules don't apply.\"\"\"\n+\n+    spenders = []\n+\n+    sec = generate_privkey()\n+    pub, _ = compute_xonly_pubkey(sec)\n+    scripts = [\n+        (\"pk\", CScript([pub, OP_CHECKSIG])),\n+        (\"future_leaf\", CScript([pub, OP_CHECKSIG]), 0xc2),\n+        (\"op_success\", CScript([pub, OP_CHECKSIG, OP_0, OP_IF, CScriptOp(0x50), OP_ENDIF])),\n+    ]\n+    tap = taproot_construct(pub, scripts)\n+\n+    # Test that keypath spending is valid & standard if compliant, but valid and nonstandard otherwise.\n+    add_spender(spenders, \"inactive/keypath_valid\", key=sec, tap=tap)\n+    add_spender(spenders, \"inactive/keypath_invalidsig\", key=sec, tap=tap, standard=False, sighash=bitflipper(default_sighash))\n+    add_spender(spenders, \"inactive/keypath_empty\", key=sec, tap=tap, standard=False, witness=[])\n+\n+    # Same for scriptpath spending (but using future features like annex, leaf versions, or OP_SUCCESS is nonstandard).\n+    add_spender(spenders, \"inactive/scriptpath_valid\", key=sec, tap=tap, leaf=\"pk\", inputs=[getter(\"sign\")])\n+    add_spender(spenders, \"inactive/scriptpath_invalidsig\", key=sec, tap=tap, leaf=\"pk\", standard=False, inputs=[getter(\"sign\")], sighash=bitflipper(default_sighash))\n+    add_spender(spenders, \"inactive/scriptpath_invalidcb\", key=sec, tap=tap, leaf=\"pk\", standard=False, inputs=[getter(\"sign\")], controlblock=bitflipper(default_controlblock))\n+    add_spender(spenders, \"inactive/scriptpath_valid_unkleaf\", key=sec, tap=tap, leaf=\"future_leaf\", standard=False, inputs=[getter(\"sign\")])\n+    add_spender(spenders, \"inactive/scriptpath_invalid_unkleaf\", key=sec, tap=tap, leaf=\"future_leaf\", standard=False, inputs=[getter(\"sign\")], sighash=bitflipper(default_sighash))\n+    add_spender(spenders, \"inactive/scriptpath_valid_opsuccess\", key=sec, tap=tap, leaf=\"op_success\", standard=False, inputs=[getter(\"sign\")])\n+    add_spender(spenders, \"inactive/scriptpath_valid_opsuccess\", key=sec, tap=tap, leaf=\"op_success\", standard=False, inputs=[getter(\"sign\")], sighash=bitflipper(default_sighash))\n+\n+    return spenders\n+\n+# Data type to keep track of UTXOs, where they were created, and how to spend them.\n+UTXOData = namedtuple('UTXOData', 'outpoint,output,spender')\n+\n+class TaprootTest(BitcoinTestFramework):\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.setup_clean_chain = True\n+        # Node 0 has Taproot inactive, Node 1 active.\n+        self.extra_args = [[\"-whitelist=127.0.0.1\", \"-par=1\", \"-vbparams=taproot:1:1\"], [\"-whitelist=127.0.0.1\", \"-par=1\"]]\n+\n+    def block_submit(self, node, txs, msg, err_msg, cb_pubkey=None, fees=0, sigops_weight=0, witness=False, accept=False):\n+\n+        # Deplete block of any non-tapscript sigops using a single additional 0-value coinbase output.\n+        # It is not impossible to fit enough tapscript sigops to hit the old 80k limit without\n+        # busting txin-level limits. We simply have to account for the p2pk outputs in all\n+        # transactions.\n+        extra_output_script = CScript([OP_CHECKSIG]*((MAX_BLOCK_SIGOPS_WEIGHT - sigops_weight) // WITNESS_SCALE_FACTOR))\n+\n+        block = create_block(self.tip, create_coinbase(self.lastblockheight + 1, pubkey=cb_pubkey, extra_output_script=extra_output_script, fees=fees), self.lastblocktime + 1)\n+        block.nVersion = 4\n+        for tx in txs:\n+            tx.rehash()\n+            block.vtx.append(tx)\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        witness and add_witness_commitment(block)\n+        block.rehash()\n+        block.solve()\n+        block_response = node.submitblock(block.serialize(True).hex())\n+        if err_msg is not None:\n+            assert block_response is not None and err_msg in block_response, \"Missing error message '%s' from block response '%s': %s\" % (err_msg, \"(None)\" if block_response is None else block_response, msg)\n+        if (accept):\n+            assert node.getbestblockhash() == block.hash, \"Failed to accept: %s (response: %s)\" % (msg, block_response)\n+            self.tip = block.sha256\n+            self.lastblockhash = block.hash\n+            self.lastblocktime += 1\n+            self.lastblockheight += 1\n+        else:\n+            assert node.getbestblockhash() == self.lastblockhash, \"Failed to reject: \" + msg\n+\n+    def test_spenders(self, node, spenders, input_counts):\n+        \"\"\"Run randomized tests with a number of \"spenders\".\n+\n+        Steps:\n+            1) Generate an appropriate UTXO for each spender to test spend conditions\n+            2) Generate 100 random addresses of all wallet types: pkh/sh_wpkh/wpkh\n+            3) Select random number of inputs from (1)\n+            4) Select random number of addresses from (2) as outputs\n+\n+        Each spender embodies a test; in a large randomized test, it is verified\n+        that toggling the valid argument to each lambda toggles the validity of\n+        the transaction. This is accomplished by constructing transactions consisting\n+        of all valid inputs, except one invalid one.\n+        \"\"\"\n+\n+        # Generate some coins to fund the wallet.\n+        node.generate(10)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r502965296",
      "id" : 502965296,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk2NTI5Ng==",
      "original_commit_id" : "58c90569f75221bc4652cbde5cad4dbae543a1ca",
      "original_line" : 1203,
      "original_position" : 1203,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 506131025,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/502965296",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1322187?v=4",
         "events_url" : "https://api.github.com/users/fjahr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fjahr/followers",
         "following_url" : "https://api.github.com/users/fjahr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fjahr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fjahr",
         "id" : 1322187,
         "login" : "fjahr",
         "node_id" : "MDQ6VXNlcjEzMjIxODc=",
         "organizations_url" : "https://api.github.com/users/fjahr/orgs",
         "received_events_url" : "https://api.github.com/users/fjahr/received_events",
         "repos_url" : "https://api.github.com/users/fjahr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fjahr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fjahr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fjahr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r502966921"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/502966921"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "in 58c90569f75221bc4652cbde5cad4dbae543a1ca:\r\n\r\n```suggestion\r\n            unspents.sort(key=lambda x: int(x[\"amount\"] * 100000000), reverse=True)\r\n```",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-11T21:16:36Z",
      "diff_hunk" : "@@ -0,0 +1,1403 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expression for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        return tweak_add_privkey(key, tweak)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    scriptsig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    witness_stack = flatten(get(ctx, \"witness\"))\n+    return (scriptsig, witness_stack)\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda returning (scriptsig, witness_stack), taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+# - Whether this test demands being placed in a txin with no corresponding txout (for testing SIGHASH_SINGLE behavior)\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail,need_vin_vout_mismatch\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, need_vin_vout_mismatch=False, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert tap is None\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert script is None\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert script is None\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert script is None\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            return spend(tx, idx, utxos, **conf)\n+        else:\n+            assert failure is not None\n+            return spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None, need_vin_vout_mismatch=need_vin_vout_mismatch)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    return bytes(CScript([pubkey, OP_CHECKSIG]))\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+def zero_appender(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a zero added.\"\"\"\n+    return lambda ctx: deep_eval(ctx, expr) + b\"\\x00\"\n+\n+def byte_popper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with its last byte removed.\"\"\"\n+    return lambda ctx: deep_eval(ctx, expr)[:-1]\n+\n+# Expected error strings\n+\n+ERR_KEYPATH_INVALID_SIG = {\"err_msg\": \"Invalid signature for Taproot key path spending\"}\n+ERR_SCRIPTPATH_INVALID_SIG = {\"err_msg\": \"Signature must be zero for failed CHECK(MULTI)SIG operation\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_TAPSCRIPT_CHECKMULTISIG = {\"err_msg\": \"OP_CHECKMULTISIG(VERIFY) is not available in tapscript\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal in tapscript\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Stack size must be exactly one after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+ERR_CHECKSIGVERIFY = {\"err_msg\": \"Script failed an OP_CHECKSIGVERIFY operation\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+VALID_SIGHASHES_TAPROOT_SINGLE = [\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT_NO_SINGLE = [h for h in VALID_SIGHASHES_TAPROOT if h not in VALID_SIGHASHES_TAPROOT_SINGLE]\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SIG_POP_BYTE = {\"failure\": {\"sign\": byte_popper(default_sign)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+SIG_ADD_ZERO = {\"failure\": {\"sign\": zero_appender(default_sign)}}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 50000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    secs = [generate_privkey() for _ in range(8)]\n+    pubs = [compute_xonly_pubkey(sec)[0] for sec in secs]\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    tap = taproot_construct(pubs[0])\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=secs[0], failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=secs[0], failure={\"sighash\": bitflipper(default_sighash)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=secs[0], failure={\"flag_flip_r\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=secs[0], failure={\"flag_flip_p\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=secs[0], failure={\"signature\": bitflipper(default_signature)}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pubs[0])\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pubs[1])))]\n+            tap = taproot_construct(pubs[0], scripts)\n+            add_spender(spenders, \"sighash/keypath_hashtype_%x\" % hashtype, tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath_hashtype_%x\" % hashtype, tap=tap, leaf=\"s0\", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+            # Test SIGHASH_SINGLE behavior in combination with mismatching outputs\n+            if hashtype in VALID_SIGHASHES_TAPROOT_SINGLE:\n+                add_spender(spenders, \"sighash/keypath_hashtype_mis_%x\" % hashtype, tap=tap, key=secs[0], annex=annex, standard=no_annex, hashtype_actual=random.choice(VALID_SIGHASHES_TAPROOT_NO_SINGLE), failure={\"hashtype_actual\": hashtype}, **ERR_KEYPATH_INVALID_SIG, need_vin_vout_mismatch=True)\n+                add_spender(spenders, \"sighash/scriptpath_hashtype_mis_%x\" % hashtype, tap=tap, leaf=\"s0\", key=secs[1], annex=annex, standard=no_annex, hashtype_actual=random.choice(VALID_SIGHASHES_TAPROOT_NO_SINGLE), **SINGLE_SIG, failure={\"hashtype_actual\": hashtype}, **ERR_SCRIPTPATH_INVALID_SIG, need_vin_vout_mismatch=True)\n+\n+        # Test OP_CODESEPARATOR impact on sighashing.\n+        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+        common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+        scripts = [\n+            (\"pk_codesep\", CScript(random_checksig_style(pubs[1]) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig\n+            (\"codesep_pk\", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pubs[1]))),  # codesep before checksig\n+            (\"branched_codesep\", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pubs[0], OP_ELSE, OP_CODESEPARATOR, pubs[1], OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"sighash/pk_codesep\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/codesep_pk\", tap=tap, leaf=\"codesep_pk\", key=secs[1], codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/left\", tap=tap, leaf=\"branched_codesep\", key=secs[0], codeseppos=3, **common, inputs=[getter(\"sign\"), b'\\x01'], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/right\", tap=tap, leaf=\"branched_codesep\", key=secs[1], codeseppos=6, **common, inputs=[getter(\"sign\"), b''], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Reusing the scripts above, test that various features affect the sighash.\n+    add_spender(spenders, \"sighash/annex\", tap=tap, leaf=\"pk_codesep\", key=secs[1], hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={\"sighash\": override(default_sighash, annex=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/script\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, script_taproot=tap.leaves[\"codesep_pk\"].script)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/leafver\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leafversion=random.choice([x & 0xFE for x in range(0x100) if x & 0xFE != 0xC0]))}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leaf=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/keypath\", tap=tap, key=secs[0], **common, failure={\"sighash\": override(default_sighash, leaf=\"pk_codesep\")}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # Test that invalid hashtypes don't work, both in key path and script path spends\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for invalid_hashtype in [x for x in range(0x100) if x not in VALID_SIGHASHES_TAPROOT]:\n+        add_spender(spenders, \"sighash/keypath_unk_hashtype_%x\" % invalid_hashtype, tap=tap, key=secs[0], hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_KEYPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/scriptpath_unk_hashtype_%x\" % invalid_hashtype, tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Test that hashtype 0 cannot have a hashtype byte, and 1 must have one.\n+    add_spender(spenders, \"sighash/hashtype0_byte_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    # Test that hashtype 0 and hashtype 1 cannot be transmuted into each other.\n+    add_spender(spenders, \"sighash/hashtype0to1_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0to1_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Test aspects of signatures with unusual lengths\n+    for hashtype in [SIGHASH_DEFAULT, random.choice(VALID_SIGHASHES_TAPROOT)]:\n+        scripts = [\n+            (\"csv\", CScript([pubs[2], OP_CHECKSIGVERIFY, OP_1])),\n+            (\"cs_pos\", CScript([pubs[2], OP_CHECKSIG])),\n+            (\"csa_pos\", CScript([OP_0, pubs[2], OP_CHECKSIGADD, OP_1, OP_EQUAL])),\n+            (\"cs_neg\", CScript([pubs[2], OP_CHECKSIG, OP_NOT])),\n+            (\"csa_neg\", CScript([OP_2, pubs[2], OP_CHECKSIGADD, OP_2, OP_EQUAL]))\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[3], scripts)\n+        # Empty signatures\n+        add_spender(spenders, \"siglen/empty_keypath\", tap=tap, key=secs[3], hashtype=hashtype, failure={\"sign\": b\"\"}, **ERR_KEYPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/empty_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_CHECKSIGVERIFY)\n+        add_spender(spenders, \"siglen/empty_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_NO_SUCCESS)\n+        add_spender(spenders, \"siglen/empty_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_NO_SUCCESS)\n+        add_spender(spenders, \"siglen/empty_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": lambda _: random_bytes(random.randrange(1, 100))}, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/empty_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": lambda _: random_bytes(random.randrange(1, 100))}, **ERR_SCRIPTPATH_INVALID_SIG)\n+        # Appending a zero byte to signatures invalidates them\n+        add_spender(spenders, \"siglen/padzero_keypath\", tap=tap, key=secs[3], hashtype=hashtype, **SIG_ADD_ZERO, **ERR_KEYPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/padzero_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/padzero_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/padzero_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/padzero_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_ADD_ZERO, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/padzero_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_ADD_ZERO, **ERR_SCRIPTPATH_INVALID_SIG)\n+        # Removing the last byte from signatures invalidates them\n+        add_spender(spenders, \"siglen/popbyte_keypath\", tap=tap, key=secs[3], hashtype=hashtype, **SIG_POP_BYTE, **ERR_KEYPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/popbyte_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/popbyte_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/popbyte_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/popbyte_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_POP_BYTE, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/popbyte_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_POP_BYTE, **ERR_SCRIPTPATH_INVALID_SIG)\n+        # Verify that an invalid signature is not allowed, not even when the CHECKSIG* is expected to fail.\n+        add_spender(spenders, \"siglen/invalid_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": default_sign, \"sighash\": bitflipper(default_sighash)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/invalid_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": default_sign, \"sighash\": bitflipper(default_sighash)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # == Test that BIP341 spending only applies to witness version 1, program length 32, no P2SH ==\n+\n+    for p2sh in [False, True]:\n+        for witver in range(1, 17):\n+            for witlen in [20, 31, 32, 33]:\n+                def mutate(spk):\n+                    prog = spk[2:]\n+                    assert len(prog) == 32\n+                    if witlen < 32:\n+                        prog = prog[0:witlen]\n+                    elif witlen > 32:\n+                        prog += bytes([0 for _ in range(witlen - 32)])\n+                    return CScript([CScriptOp.encode_op_n(witver), prog])\n+                scripts = [(\"s0\", CScript([pubs[0], OP_CHECKSIG])), (\"dummy\", CScript([OP_RETURN]))]\n+                tap = taproot_construct(pubs[1], scripts)\n+                if not p2sh and witver == 1 and witlen == 32:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, failure={\"leaf\": \"dummy\"}, **ERR_OP_RETURN)\n+                else:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], standard=False)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, standard=False)\n+\n+    # == Test various aspects of BIP341 spending paths ==\n+\n+    # A set of functions that compute the hashing partner in a Merkle tree, designed to exercise\n+    # edge cases. This relies on the taproot_construct feature that a lambda can be passed in\n+    # instead of a subtree, to compute the partner to be hashed with.\n+    PARTNER_MERKLE_FN = [\n+        # Combine with itself\n+        lambda h: h,\n+        # Combine with hash 0\n+        lambda h: bytes([0 for _ in range(32)]),\n+        # Combine with hash 2^256-1\n+        lambda h: bytes([0xff for _ in range(32)]),\n+        # Combine with itself-1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') + 1).to_bytes(32, 'big'),\n+        # Combine with itself-1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') + 1).to_bytes(32, 'little'),\n+        # Combine with random bitflipped version of self.\n+        lambda h: (int.from_bytes(h, 'little') ^ (1 << random.randrange(256))).to_bytes(32, 'little')\n+    ]\n+    # Start with a tree of that has depth 1 for \"128deep\" and depth 2 for \"129deep\".\n+    scripts = [(\"128deep\", CScript([pubs[0], OP_CHECKSIG])), [(\"129deep\", CScript([pubs[0], OP_CHECKSIG])), random.choice(PARTNER_MERKLE_FN)]]\n+    # Add 127 nodes on top of that tree, so that \"128deep\" and \"129deep\" end up at their designated depths.\n+    for _ in range(127):\n+        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+    tap = taproot_construct(pubs[0], scripts)\n+    # Test that spends with a depth of 128 work, but 129 doesn't (even with a tree with weird Merkle branches in it).\n+    add_spender(spenders, \"spendpath/merklelimit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"leaf\": \"129deep\"}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that flipping the negation bit invalidates spends.\n+    add_spender(spenders, \"spendpath/negflag\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"negflag\": lambda ctx: 1 - default_negflag(ctx)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the Merkle branch invalidate it.\n+    add_spender(spenders, \"spendpath/bitflipmerkle\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"merklebranch\": bitflipper(default_merklebranch)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the inner pubkey invalidate it.\n+    add_spender(spenders, \"spendpath/bitflippubkey\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"pubkey_inner\": bitflipper(default_pubkey_inner)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that empty witnesses are invalid.\n+    add_spender(spenders, \"spendpath/emptywit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"witness\": []}, **ERR_EMPTY_WITNESS)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padlongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/trunclongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    scripts = [(\"s\", CScript([pubs[0], OP_CHECKSIG]))]\n+    tap = taproot_construct(pubs[1], scripts)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/truncshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block to 1 byte (\"-1 Merkle length\") invalidates it\n+    add_spender(spenders, \"spendpath/trunc1shortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:1]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    # == Test BIP342 edge cases ==\n+\n+    csa_low_val = random.randrange(0, 17) # Within range for OP_n\n+    csa_low_result = csa_low_val + 1\n+\n+    csa_high_val = random.randrange(17, 100) if random.getrandbits(1) else random.randrange(-100, -1) # Outside OP_n range\n+    csa_high_result = csa_high_val + 1\n+\n+    OVERSIZE_NUMBER = 2**31\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER))), 6)\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER-1))), 5)\n+\n+    big_choices = []\n+    big_scriptops = []\n+    for i in range(1000):\n+        r = random.randrange(len(pubs))\n+        big_choices.append(r)\n+        big_scriptops += [pubs[r], OP_CHECKSIGVERIFY]\n+\n+\n+    def big_spend_inputs(ctx):\n+        \"\"\"Helper function to construct the script input for t33/t34 below.\"\"\"\n+        # Instead of signing 999 times, precompute signatures for every (key, hashtype) combination\n+        sigs = {}\n+        for ht in VALID_SIGHASHES_TAPROOT:\n+            for k in range(len(pubs)):\n+                sigs[(k, ht)] = override(default_sign, hashtype=ht, key=secs[k])(ctx)\n+        num = get(ctx, \"num\")\n+        return [sigs[(big_choices[i], random.choice(VALID_SIGHASHES_TAPROOT))] for i in range(num - 1, -1, -1)]\n+\n+    # Various BIP342 features\n+    scripts = [\n+        # 0) drop stack element and OP_CHECKSIG\n+        (\"t0\", CScript([OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 1) normal OP_CHECKSIG\n+        (\"t1\", CScript([pubs[1], OP_CHECKSIG])),\n+        # 2) normal OP_CHECKSIGVERIFY\n+        (\"t2\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1])),\n+        # 3) Hypothetical OP_CHECKMULTISIG script that takes a single sig as input\n+        (\"t3\", CScript([OP_0, OP_SWAP, OP_1, pubs[1], OP_1, OP_CHECKMULTISIG])),\n+        # 4) Hypothetical OP_CHECKMULTISIGVERIFY script that takes a single sig as input\n+        (\"t4\", CScript([OP_0, OP_SWAP, OP_1, pubs[1], OP_1, OP_CHECKMULTISIGVERIFY, OP_1])),\n+        # 5) OP_IF script that needs a true input\n+        (\"t5\", CScript([OP_IF, pubs[1], OP_CHECKSIG, OP_ELSE, OP_RETURN, OP_ENDIF])),\n+        # 6) OP_NOTIF script that needs a true input\n+        (\"t6\", CScript([OP_NOTIF, OP_RETURN, OP_ELSE, pubs[1], OP_CHECKSIG, OP_ENDIF])),\n+        # 7) OP_CHECKSIG with an empty key\n+        (\"t7\", CScript([OP_0, OP_CHECKSIG])),\n+        # 8) OP_CHECKSIGVERIFY with an empty key\n+        (\"t8\", CScript([OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 9) normal OP_CHECKSIGADD that also ensures return value is correct\n+        (\"t9\", CScript([csa_low_val, pubs[1], OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 10) OP_CHECKSIGADD with empty key\n+        (\"t10\", CScript([csa_low_val, OP_0, OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 11) OP_CHECKSIGADD with missing counter stack element\n+        (\"t11\", CScript([pubs[1], OP_CHECKSIGADD, OP_1, OP_EQUAL])),\n+        # 12) OP_CHECKSIG that needs invalid signature\n+        (\"t12\", CScript([pubs[1], OP_CHECKSIGVERIFY, pubs[0], OP_CHECKSIG, OP_NOT])),\n+        # 13) OP_CHECKSIG with empty key that needs invalid signature\n+        (\"t13\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_CHECKSIG, OP_NOT])),\n+        # 14) OP_CHECKSIGADD that needs invalid signature\n+        (\"t14\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, pubs[0], OP_CHECKSIGADD, OP_NOT])),\n+        # 15) OP_CHECKSIGADD with empty key that needs invalid signature\n+        (\"t15\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGADD, OP_NOT])),\n+        # 16) OP_CHECKSIG with unknown pubkey type\n+        (\"t16\", CScript([OP_1, OP_CHECKSIG])),\n+        # 17) OP_CHECKSIGADD with unknown pubkey type\n+        (\"t17\", CScript([OP_0, OP_1, OP_CHECKSIGADD])),\n+        # 18) OP_CHECKSIGVERIFY with unknown pubkey type\n+        (\"t18\", CScript([OP_1, OP_CHECKSIGVERIFY, OP_1])),\n+        # 19) script longer than 10000 bytes and over 201 non-push opcodes\n+        (\"t19\", CScript([OP_0, OP_0, OP_2DROP] * 10001 + [pubs[1], OP_CHECKSIG])),\n+        # 20) OP_CHECKSIGVERIFY with empty key\n+        (\"t20\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 21) Script that grows the stack to 1000 elements\n+        (\"t21\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 999 + [OP_DROP] * 999)),\n+        # 22) Script that grows the stack to 1001 elements\n+        (\"t22\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 1000 + [OP_DROP] * 1000)),\n+        # 23) Script that expects an input stack of 1000 elements\n+        (\"t23\", CScript([OP_DROP] * 999 + [pubs[1], OP_CHECKSIG])),\n+        # 24) Script that expects an input stack of 1001 elements\n+        (\"t24\", CScript([OP_DROP] * 1000 + [pubs[1], OP_CHECKSIG])),\n+        # 25) Script that pushes a MAX_SCRIPT_ELEMENT_SIZE-bytes element\n+        (\"t25\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE), OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 26) Script that pushes a (MAX_SCRIPT_ELEMENT_SIZE+1)-bytes element\n+        (\"t26\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 27) CHECKSIGADD that must fail because numeric argument number is >4 bytes\n+        (\"t27\", CScript([CScriptNum(OVERSIZE_NUMBER), pubs[1], OP_CHECKSIGADD])),\n+        # 28) Pushes random CScriptNum value, checks OP_CHECKSIGADD result\n+        (\"t28\", CScript([csa_high_val, pubs[1], OP_CHECKSIGADD, csa_high_result, OP_EQUAL])),\n+        # 29) CHECKSIGADD that succeeds with proper sig because numeric argument number is <=4 bytes\n+        (\"t29\", CScript([CScriptNum(OVERSIZE_NUMBER-1), pubs[1], OP_CHECKSIGADD])),\n+        # 30) Variant of t1 with \"normal\" 33-byte pubkey\n+        (\"t30\", CScript([b'\\x03' + pubs[1], OP_CHECKSIG])),\n+        # 31) Variant of t2 with \"normal\" 33-byte pubkey\n+        (\"t31\", CScript([b'\\x02' + pubs[1], OP_CHECKSIGVERIFY, OP_1])),\n+        # 32) Variant of t28 with \"normal\" 33-byte pubkey\n+        (\"t32\", CScript([csa_high_val, b'\\x03' + pubs[1], OP_CHECKSIGADD, csa_high_result, OP_EQUAL])),\n+        # 33) 999-of-999 multisig\n+        (\"t33\", CScript(big_scriptops[:1998] + [OP_1])),\n+        # 34) 1000-of-1000 multisig\n+        (\"t34\", CScript(big_scriptops[:2000] + [OP_1])),\n+        # 35) Variant of t9 that uses a non-minimally encoded input arg\n+        (\"t35\", CScript([bytes([csa_low_val]), pubs[1], OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 36) Empty script\n+        (\"t36\", CScript([])),\n+    ]\n+    # Add many dummies to test huge trees\n+    for j in range(100000):\n+        scripts.append((None, CScript([OP_RETURN, random.randrange(100000)])))\n+    random.shuffle(scripts)\n+    tap = taproot_construct(pubs[0], scripts)\n+    common = {\n+        \"hashtype\": hashtype,\n+        \"key\": secs[1],\n+        \"tap\": tap,\n+    }\n+    # Test that MAX_SCRIPT_ELEMENT_SIZE byte stack element inputs are valid, but not one more (and 80 bytes is standard but 81 is not).\n+    add_spender(spenders, \"tapscript/inputmaxlimit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE)], failure={\"inputs\": [getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1)]}, **ERR_PUSH_LIMIT)\n+    add_spender(spenders, \"tapscript/input80limit\", leaf=\"t0\", **common, inputs=[getter(\"sign\"), random_bytes(80)])\n+    add_spender(spenders, \"tapscript/input81limit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(81)])\n+    # Test that OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY cause failure, but OP_CHECKSIG and OP_CHECKSIGVERIFY work.\n+    add_spender(spenders, \"tapscript/disabled_checkmultisig\", leaf=\"t1\", **common, **SINGLE_SIG, failure={\"leaf\": \"t3\"}, **ERR_TAPSCRIPT_CHECKMULTISIG)\n+    add_spender(spenders, \"tapscript/disabled_checkmultisigverify\", leaf=\"t2\", **common, **SINGLE_SIG, failure={\"leaf\": \"t4\"}, **ERR_TAPSCRIPT_CHECKMULTISIG)\n+    # Test that OP_IF and OP_NOTIF do not accept non-0x01 as truth value (the MINIMALIF rule is consensus in Tapscript)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x02']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x03']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0001']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0100']}, **ERR_MINIMALIF)\n+    # Test that 1-byte public keys (which are unknown) are acceptable but nonstandard with unrelated signatures, but 0-byte public keys are not valid.\n+    add_spender(spenders, \"tapscript/unkpk/checksig\", leaf=\"t16\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigadd\", leaf=\"t17\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigverify\", leaf=\"t18\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that 33-byte public keys (which are unknown) are acceptable but nonstandard with valid signatures, but normal pubkeys are not valid in that case.\n+    add_spender(spenders, \"tapscript/oldpk/checksig\", leaf=\"t30\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t1\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"tapscript/oldpk/checksigadd\", leaf=\"t31\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t2\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"tapscript/oldpk/checksigverify\", leaf=\"t32\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t28\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    # Test that 0-byte public keys are not acceptable.\n+    add_spender(spenders, \"tapscript/emptypk/checksig\", leaf=\"t1\", **SINGLE_SIG, **common, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigverify\", leaf=\"t2\", **SINGLE_SIG, **common, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigadd\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigadd\", leaf=\"t35\", standard=False, **SINGLE_SIG, **common, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that OP_CHECKSIGADD results are as expected\n+    add_spender(spenders, \"tapscript/checksigaddresults\", leaf=\"t28\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    add_spender(spenders, \"tapscript/checksigaddoversize\", leaf=\"t29\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    # Test that OP_CHECKSIGADD requires 3 stack elements.\n+    add_spender(spenders, \"tapscript/checksigadd3args\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t11\"}, **ERR_STACK_EMPTY)\n+    # Test that empty signatures do not cause script failure in OP_CHECKSIG and OP_CHECKSIGADD (but do fail with empty pubkey, and do fail OP_CHECKSIGVERIFY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksig\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t13\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/nochecksigverify\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t20\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksigadd\", leaf=\"t14\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t15\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that scripts over 10000 bytes (and over 201 non-push ops) are acceptable.\n+    add_spender(spenders, \"tapscript/no10000limit\", leaf=\"t19\", **SINGLE_SIG, **common)\n+    # Test that a stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000stack\", leaf=\"t21\", **SINGLE_SIG, **common, failure={\"leaf\": \"t22\"}, **ERR_STACK_SIZE)\n+    # Test that an input stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000inputs\", leaf=\"t23\", **common, inputs=[getter(\"sign\")] + [b'' for _ in range(999)], failure={\"leaf\": \"t24\", \"inputs\": [getter(\"sign\")] + [b'' for _ in range(1000)]}, **ERR_STACK_SIZE)\n+    # Test that pushing a MAX_SCRIPT_ELEMENT_SIZE byte stack element is valid, but one longer is not.\n+    add_spender(spenders, \"tapscript/pushmaxlimit\", leaf=\"t25\", **common, **SINGLE_SIG, failure={\"leaf\": \"t26\"}, **ERR_PUSH_LIMIT)\n+    # Test that 999-of-999 multisig works (but 1000-of-1000 triggers stack size limits)\n+    add_spender(spenders, \"tapscript/bigmulti\", leaf=\"t33\", **common, inputs=big_spend_inputs, num=999, failure={\"leaf\": \"t34\", \"num\": 1000}, **ERR_STACK_SIZE)\n+    # Test that the CLEANSTACK rule is consensus critical in tapscript\n+    add_spender(spenders, \"tapscript/cleanstack\", leaf=\"t36\", tap=tap, inputs=[b'\\x01'], failure={\"inputs\": [b'\\x01', b'\\x01']}, **ERR_CLEANSTACK)\n+\n+    # == Test for sigops ratio limit ==\n+\n+    # Given a number n, and a public key pk, functions that produce a (CScript, sigops). Each script takes as\n+    # input a valid signature with the passed pk followed by a dummy push of bytes that are to be dropped, and\n+    # will execute sigops signature checks.\n+    SIGOPS_RATIO_SCRIPTS = [\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIG.\n+        lambda n, pk: (CScript([OP_DROP, pk] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGVERIFY.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_0, OP_IF, OP_2DUP, OP_CHECKSIGVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_2, OP_SWAP, OP_CHECKSIGADD, OP_3, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIG.\n+        lambda n, pk: (CScript([random_bytes(220), OP_2DROP, pk, OP_1, OP_NOTIF, OP_2DUP, OP_CHECKSIG, OP_VERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_4, OP_SWAP, OP_CHECKSIGADD, OP_5, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGADD.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_1, OP_IF, OP_ELSE, OP_2DUP, OP_6, OP_SWAP, OP_CHECKSIGADD, OP_7, OP_EQUALVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_8, OP_SWAP, OP_CHECKSIGADD, OP_9, OP_EQUAL]), n + 1),\n+        # n+1 OP_CHECKSIGs, but also one OP_CHECKSIG with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, pk, OP_CHECKSIG, OP_NOT, OP_VERIFY, pk] + [OP_2DUP, OP_CHECKSIG, OP_VERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGADDs and 1 OP_CHECKSIG, but also an OP_CHECKSIGADD with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, OP_10, pk, OP_CHECKSIGADD, OP_10, OP_EQUALVERIFY, pk] + [OP_2DUP, OP_16, OP_SWAP, OP_CHECKSIGADD, b'\\x11', OP_EQUALVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+    ]\n+    for annex in [None, bytes([ANNEX_TAG]) + random_bytes(random.randrange(1000))]:\n+        for hashtype in [SIGHASH_DEFAULT, SIGHASH_ALL]:\n+            for pubkey in [pubs[1], random_bytes(random.choice([x for x in range(2, 81) if x != 32]))]:\n+                for fn_num, fn in enumerate(SIGOPS_RATIO_SCRIPTS):\n+                    merkledepth = random.randrange(129)\n+\n+\n+                    def predict_sigops_ratio(n, dummy_size):\n+                        \"\"\"Predict whether spending fn(n, pubkey) with dummy_size will pass the ratio test.\"\"\"\n+                        script, sigops = fn(n, pubkey)\n+                        # Predict the size of the witness for a given choice of n\n+                        stacklen_size = 1\n+                        sig_size = 64 + (hashtype != SIGHASH_DEFAULT)\n+                        siglen_size = 1\n+                        dummylen_size = 1 + 2 * (dummy_size >= 253)\n+                        script_size = len(script)\n+                        scriptlen_size = 1 + 2 * (script_size >= 253)\n+                        control_size = 33 + 32 * merkledepth\n+                        controllen_size = 1 + 2 * (control_size >= 253)\n+                        annex_size = 0 if annex is None else len(annex)\n+                        annexlen_size = 0 if annex is None else 1 + 2 * (annex_size >= 253)\n+                        witsize = stacklen_size + sig_size + siglen_size + dummy_size + dummylen_size + script_size + scriptlen_size + control_size + controllen_size + annex_size + annexlen_size\n+                        # sigops ratio test\n+                        return witsize + 50 >= 50 * sigops\n+                    # Make sure n is high enough that with empty dummy, the script is not valid\n+                    n = 0\n+                    while predict_sigops_ratio(n, 0):\n+                        n += 1\n+                    # But allow picking a bit higher still\n+                    n += random.randrange(5)\n+                    # Now pick dummy size *just* large enough that the overall construction passes\n+                    dummylen = 0\n+                    while not predict_sigops_ratio(n, dummylen):\n+                        dummylen += 1\n+                    scripts = [(\"s\", fn(n, pubkey)[0])]\n+                    for _ in range(merkledepth):\n+                        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+                    tap = taproot_construct(pubs[0], scripts)\n+                    standard = annex is None and dummylen <= 80 and len(pubkey) == 32\n+                    add_spender(spenders, \"tapscript/sigopsratio_%i\" % fn_num, tap=tap, leaf=\"s\", annex=annex, hashtype=hashtype, key=secs[1], inputs=[getter(\"sign\"), random_bytes(dummylen)], standard=standard, failure={\"inputs\": [getter(\"sign\"), random_bytes(dummylen - 1)]}, **ERR_SIGOPS_RATIO)\n+\n+    # Future leaf versions\n+    for leafver in range(0, 0x100, 2):\n+        if leafver == LEAF_VERSION_TAPSCRIPT or leafver == ANNEX_TAG:\n+            # Skip the defined LEAF_VERSION_TAPSCRIPT, and the ANNEX_TAG which is not usable as leaf version\n+            continue\n+        scripts = [\n+            (\"bare_c0\", CScript([OP_NOP])),\n+            (\"bare_unkver\", CScript([OP_NOP]), leafver),\n+            (\"return_c0\", CScript([OP_RETURN])),\n+            (\"return_unkver\", CScript([OP_RETURN]), leafver),\n+            (\"undecodable_c0\", CScript([OP_PUSHDATA1])),\n+            (\"undecodable_unkver\", CScript([OP_PUSHDATA1]), leafver),\n+            (\"bigpush_c0\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP])),\n+            (\"bigpush_unkver\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP]), leafver),\n+            (\"1001push_c0\", CScript([OP_0] * 1001)),\n+            (\"1001push_unkver\", CScript([OP_0] * 1001), leafver),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"unkver/bare\", standard=False, tap=tap, leaf=\"bare_unkver\", failure={\"leaf\": \"bare_c0\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"unkver/return\", standard=False, tap=tap, leaf=\"return_unkver\", failure={\"leaf\": \"return_c0\"}, **ERR_OP_RETURN)\n+        add_spender(spenders, \"unkver/undecodable\", standard=False, tap=tap, leaf=\"undecodable_unkver\", failure={\"leaf\": \"undecodable_c0\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"unkver/bigpush\", standard=False, tap=tap, leaf=\"bigpush_unkver\", failure={\"leaf\": \"bigpush_c0\"}, **ERR_PUSH_LIMIT)\n+        add_spender(spenders, \"unkver/1001push\", standard=False, tap=tap, leaf=\"1001push_unkver\", failure={\"leaf\": \"1001push_c0\"}, **ERR_STACK_SIZE)\n+        add_spender(spenders, \"unkver/1001inputs\", standard=False, tap=tap, leaf=\"bare_unkver\", inputs=[b'']*1001, failure={\"leaf\": \"bare_c0\"}, **ERR_STACK_SIZE)\n+\n+    # OP_SUCCESSx tests.\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for opval in range(76, 0x100):\n+        opcode = CScriptOp(opval)\n+        if not is_op_success(opcode):\n+            continue\n+        scripts = [\n+            (\"bare_success\", CScript([opcode])),\n+            (\"bare_nop\", CScript([OP_NOP])),\n+            (\"unexecif_success\", CScript([OP_0, OP_IF, opcode, OP_ENDIF])),\n+            (\"unexecif_nop\", CScript([OP_0, OP_IF, OP_NOP, OP_ENDIF])),\n+            (\"return_success\", CScript([OP_RETURN, opcode])),\n+            (\"return_nop\", CScript([OP_RETURN, OP_NOP])),\n+            (\"undecodable_success\", CScript([opcode, OP_PUSHDATA1])),\n+            (\"undecodable_nop\", CScript([OP_NOP, OP_PUSHDATA1])),\n+            (\"undecodable_bypassed_success\", CScript([OP_PUSHDATA1, OP_2, opcode])),\n+            (\"bigpush_success\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, opcode])),\n+            (\"bigpush_nop\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, OP_NOP])),\n+            (\"1001push_success\", CScript([OP_0] * 1001 + [opcode])),\n+            (\"1001push_nop\", CScript([OP_0] * 1001 + [OP_NOP])),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"opsuccess/bare\", standard=False, tap=tap, leaf=\"bare_success\", failure={\"leaf\": \"bare_nop\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"opsuccess/exexecif\", standard=False, tap=tap, leaf=\"unexecif_success\", failure={\"leaf\": \"unexecif_nop\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"opsuccess/return\", standard=False, tap=tap, leaf=\"return_success\", failure={\"leaf\": \"return_nop\"}, **ERR_OP_RETURN)\n+        add_spender(spenders, \"opsuccess/undecodable\", standard=False, tap=tap, leaf=\"undecodable_success\", failure={\"leaf\": \"undecodable_nop\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"opsuccess/undecodable_bypass\", standard=False, tap=tap, leaf=\"undecodable_success\", failure={\"leaf\": \"undecodable_bypassed_success\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"opsuccess/bigpush\", standard=False, tap=tap, leaf=\"bigpush_success\", failure={\"leaf\": \"bigpush_nop\"}, **ERR_PUSH_LIMIT)\n+        add_spender(spenders, \"opsuccess/1001push\", standard=False, tap=tap, leaf=\"1001push_success\", failure={\"leaf\": \"1001push_nop\"}, **ERR_STACK_SIZE)\n+        add_spender(spenders, \"opsuccess/1001inputs\", standard=False, tap=tap, leaf=\"bare_success\", inputs=[b'']*1001, failure={\"leaf\": \"bare_nop\"}, **ERR_STACK_SIZE)\n+\n+    # Non-OP_SUCCESSx (verify that those aren't accidentally treated as OP_SUCCESSx)\n+    for opval in range(0, 0x100):\n+        opcode = CScriptOp(opval)\n+        if is_op_success(opcode):\n+            continue\n+        scripts = [\n+            (\"normal\", CScript([OP_RETURN, opcode] + [OP_NOP] * 75)),\n+            (\"op_success\", CScript([OP_RETURN, CScriptOp(0x50)]))\n+        ]\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"alwaysvalid/notsuccessx\", tap=tap, leaf=\"op_success\", inputs=[], standard=False, failure={\"leaf\": \"normal\"}) # err_msg differs based on opcode\n+\n+    # == Legacy tests ==\n+\n+    # Also add a few legacy spends into the mix, so that transactions which combine taproot and pre-taproot spends get tested too.\n+    for compressed in [False, True]:\n+        eckey1 = ECKey()\n+        eckey1.set(generate_privkey(), compressed)\n+        pubkey1 = eckey1.get_pubkey().get_bytes()\n+        eckey2 = ECKey()\n+        eckey2.set(generate_privkey(), compressed)\n+        for p2sh in [False, True]:\n+            for witv0 in [False, True]:\n+                for hashtype in VALID_SIGHASHES_ECDSA + [random.randrange(0x04, 0x80), random.randrange(0x84, 0x100)]:\n+                    standard = (hashtype in VALID_SIGHASHES_ECDSA) and (compressed or not witv0)\n+                    add_spender(spenders, \"legacy/pk-wrongkey\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, script=CScript([pubkey1, OP_CHECKSIG]), **SINGLE_SIG, key=eckey1, failure={\"key\": eckey2}, sigops_weight=4-3*witv0, **ERR_NO_SUCCESS)\n+                    add_spender(spenders, \"legacy/pkh-sighashflip\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, pkh=pubkey1, key=eckey1, **SIGHASH_BITFLIP, sigops_weight=4-3*witv0, **ERR_NO_SUCCESS)\n+\n+    # Verify that OP_CHECKSIGADD wasn't accidentally added to pre-taproot validation logic.\n+    for p2sh in [False, True]:\n+        for witv0 in [False, True]:\n+            for hashtype in VALID_SIGHASHES_ECDSA + [random.randrange(0x04, 0x80), random.randrange(0x84, 0x100)]:\n+                standard = hashtype in VALID_SIGHASHES_ECDSA and (p2sh or witv0)\n+                add_spender(spenders, \"compat/nocsa\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, script=CScript([OP_IF, OP_11, pubkey1, OP_CHECKSIGADD, OP_12, OP_EQUAL, OP_ELSE, pubkey1, OP_CHECKSIG, OP_ENDIF]), key=eckey1, sigops_weight=4-3*witv0, inputs=[getter(\"sign\"), b''], failure={\"inputs\": [getter(\"sign\"), b'\\x01']}, **ERR_UNDECODABLE)\n+\n+    return spenders\n+\n+def spenders_taproot_inactive():\n+    \"\"\"Spenders for testing that pre-activation Taproot rules don't apply.\"\"\"\n+\n+    spenders = []\n+\n+    sec = generate_privkey()\n+    pub, _ = compute_xonly_pubkey(sec)\n+    scripts = [\n+        (\"pk\", CScript([pub, OP_CHECKSIG])),\n+        (\"future_leaf\", CScript([pub, OP_CHECKSIG]), 0xc2),\n+        (\"op_success\", CScript([pub, OP_CHECKSIG, OP_0, OP_IF, CScriptOp(0x50), OP_ENDIF])),\n+    ]\n+    tap = taproot_construct(pub, scripts)\n+\n+    # Test that keypath spending is valid & standard if compliant, but valid and nonstandard otherwise.\n+    add_spender(spenders, \"inactive/keypath_valid\", key=sec, tap=tap)\n+    add_spender(spenders, \"inactive/keypath_invalidsig\", key=sec, tap=tap, standard=False, sighash=bitflipper(default_sighash))\n+    add_spender(spenders, \"inactive/keypath_empty\", key=sec, tap=tap, standard=False, witness=[])\n+\n+    # Same for scriptpath spending (but using future features like annex, leaf versions, or OP_SUCCESS is nonstandard).\n+    add_spender(spenders, \"inactive/scriptpath_valid\", key=sec, tap=tap, leaf=\"pk\", inputs=[getter(\"sign\")])\n+    add_spender(spenders, \"inactive/scriptpath_invalidsig\", key=sec, tap=tap, leaf=\"pk\", standard=False, inputs=[getter(\"sign\")], sighash=bitflipper(default_sighash))\n+    add_spender(spenders, \"inactive/scriptpath_invalidcb\", key=sec, tap=tap, leaf=\"pk\", standard=False, inputs=[getter(\"sign\")], controlblock=bitflipper(default_controlblock))\n+    add_spender(spenders, \"inactive/scriptpath_valid_unkleaf\", key=sec, tap=tap, leaf=\"future_leaf\", standard=False, inputs=[getter(\"sign\")])\n+    add_spender(spenders, \"inactive/scriptpath_invalid_unkleaf\", key=sec, tap=tap, leaf=\"future_leaf\", standard=False, inputs=[getter(\"sign\")], sighash=bitflipper(default_sighash))\n+    add_spender(spenders, \"inactive/scriptpath_valid_opsuccess\", key=sec, tap=tap, leaf=\"op_success\", standard=False, inputs=[getter(\"sign\")])\n+    add_spender(spenders, \"inactive/scriptpath_valid_opsuccess\", key=sec, tap=tap, leaf=\"op_success\", standard=False, inputs=[getter(\"sign\")], sighash=bitflipper(default_sighash))\n+\n+    return spenders\n+\n+# Data type to keep track of UTXOs, where they were created, and how to spend them.\n+UTXOData = namedtuple('UTXOData', 'outpoint,output,spender')\n+\n+class TaprootTest(BitcoinTestFramework):\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.setup_clean_chain = True\n+        # Node 0 has Taproot inactive, Node 1 active.\n+        self.extra_args = [[\"-whitelist=127.0.0.1\", \"-par=1\", \"-vbparams=taproot:1:1\"], [\"-whitelist=127.0.0.1\", \"-par=1\"]]\n+\n+    def block_submit(self, node, txs, msg, err_msg, cb_pubkey=None, fees=0, sigops_weight=0, witness=False, accept=False):\n+\n+        # Deplete block of any non-tapscript sigops using a single additional 0-value coinbase output.\n+        # It is not impossible to fit enough tapscript sigops to hit the old 80k limit without\n+        # busting txin-level limits. We simply have to account for the p2pk outputs in all\n+        # transactions.\n+        extra_output_script = CScript([OP_CHECKSIG]*((MAX_BLOCK_SIGOPS_WEIGHT - sigops_weight) // WITNESS_SCALE_FACTOR))\n+\n+        block = create_block(self.tip, create_coinbase(self.lastblockheight + 1, pubkey=cb_pubkey, extra_output_script=extra_output_script, fees=fees), self.lastblocktime + 1)\n+        block.nVersion = 4\n+        for tx in txs:\n+            tx.rehash()\n+            block.vtx.append(tx)\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        witness and add_witness_commitment(block)\n+        block.rehash()\n+        block.solve()\n+        block_response = node.submitblock(block.serialize(True).hex())\n+        if err_msg is not None:\n+            assert block_response is not None and err_msg in block_response, \"Missing error message '%s' from block response '%s': %s\" % (err_msg, \"(None)\" if block_response is None else block_response, msg)\n+        if (accept):\n+            assert node.getbestblockhash() == block.hash, \"Failed to accept: %s (response: %s)\" % (msg, block_response)\n+            self.tip = block.sha256\n+            self.lastblockhash = block.hash\n+            self.lastblocktime += 1\n+            self.lastblockheight += 1\n+        else:\n+            assert node.getbestblockhash() == self.lastblockhash, \"Failed to reject: \" + msg\n+\n+    def test_spenders(self, node, spenders, input_counts):\n+        \"\"\"Run randomized tests with a number of \"spenders\".\n+\n+        Steps:\n+            1) Generate an appropriate UTXO for each spender to test spend conditions\n+            2) Generate 100 random addresses of all wallet types: pkh/sh_wpkh/wpkh\n+            3) Select random number of inputs from (1)\n+            4) Select random number of addresses from (2) as outputs\n+\n+        Each spender embodies a test; in a large randomized test, it is verified\n+        that toggling the valid argument to each lambda toggles the validity of\n+        the transaction. This is accomplished by constructing transactions consisting\n+        of all valid inputs, except one invalid one.\n+        \"\"\"\n+\n+        # Generate some coins to fund the wallet.\n+        node.generate(10)\n+\n+        # Construct a bunch of sPKs that send coins back to the host wallet\n+        self.log.info(\"- Constructing addresses for returning coins\")\n+        host_spks = []\n+        host_pubkeys = []\n+        for i in range(16):\n+            addr = node.getnewaddress(address_type=random.choice([\"legacy\", \"p2sh-segwit\", \"bech32\"]))\n+            info = node.getaddressinfo(addr)\n+            spk = bytes.fromhex(info['scriptPubKey'])\n+            host_spks.append(spk)\n+            host_pubkeys.append(bytes.fromhex(info['pubkey']))\n+\n+        # Initialize variables used by block_submit().\n+        self.lastblockhash = node.getbestblockhash()\n+        self.tip = int(self.lastblockhash, 16)\n+        block = node.getblock(self.lastblockhash)\n+        self.lastblockheight = block['height']\n+        self.lastblocktime = block['time']\n+\n+        # Create transactions spending up to 50 of the wallet's inputs, with one output for each spender, and\n+        # one change output at the end. The transaction is constructed on the Python side to enable\n+        # having multiple outputs to the same address and outputs with no assigned address. The wallet\n+        # is then asked to sign it through signrawtransactionwithwallet, and then added to a block on the\n+        # Python side (to bypass standardness rules).\n+        self.log.info(\"- Creating test UTXOs...\")\n+        random.shuffle(spenders)\n+        normal_utxos = []\n+        mismatching_utxos = [] # UTXOs with input that requires mismatching output position\n+        done = 0\n+        while done < len(spenders):\n+            # Compute how many UTXOs to create with this transaction\n+            count_this_tx = min(len(spenders) - done, (len(spenders) + 4) // 5, 10000)\n+\n+            fund_tx = CTransaction()\n+            # Add the 50 highest-value inputs\n+            unspents = node.listunspent()\n+            random.shuffle(unspents)\n+            unspents.sort(key=lambda x: -int(x[\"amount\"] * 100000000))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r502966921",
      "id" : 502966921,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk2NjkyMQ==",
      "original_commit_id" : "58c90569f75221bc4652cbde5cad4dbae543a1ca",
      "original_line" : 1241,
      "original_position" : 1241,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 506131025,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/502966921",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1322187?v=4",
         "events_url" : "https://api.github.com/users/fjahr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fjahr/followers",
         "following_url" : "https://api.github.com/users/fjahr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fjahr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fjahr",
         "id" : 1322187,
         "login" : "fjahr",
         "node_id" : "MDQ6VXNlcjEzMjIxODc=",
         "organizations_url" : "https://api.github.com/users/fjahr/orgs",
         "received_events_url" : "https://api.github.com/users/fjahr/received_events",
         "repos_url" : "https://api.github.com/users/fjahr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fjahr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fjahr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fjahr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r502969975"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/502969975"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "in 58c90569f75221bc4652cbde5cad4dbae543a1ca:\r\n\r\nprobably?\r\n```suggestion\r\n        add_spender(spenders, \"opsuccess/unexecif\", standard=False, tap=tap, leaf=\"unexecif_success\", failure={\"leaf\": \"unexecif_nop\"}, **ERR_CLEANSTACK)\r\n```",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-11T21:47:36Z",
      "diff_hunk" : "@@ -0,0 +1,1403 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expression for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        return tweak_add_privkey(key, tweak)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    scriptsig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    witness_stack = flatten(get(ctx, \"witness\"))\n+    return (scriptsig, witness_stack)\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda returning (scriptsig, witness_stack), taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+# - Whether this test demands being placed in a txin with no corresponding txout (for testing SIGHASH_SINGLE behavior)\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail,need_vin_vout_mismatch\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, need_vin_vout_mismatch=False, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert tap is None\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert script is None\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert script is None\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert script is None\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            return spend(tx, idx, utxos, **conf)\n+        else:\n+            assert failure is not None\n+            return spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None, need_vin_vout_mismatch=need_vin_vout_mismatch)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    return bytes(CScript([pubkey, OP_CHECKSIG]))\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+def zero_appender(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a zero added.\"\"\"\n+    return lambda ctx: deep_eval(ctx, expr) + b\"\\x00\"\n+\n+def byte_popper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with its last byte removed.\"\"\"\n+    return lambda ctx: deep_eval(ctx, expr)[:-1]\n+\n+# Expected error strings\n+\n+ERR_KEYPATH_INVALID_SIG = {\"err_msg\": \"Invalid signature for Taproot key path spending\"}\n+ERR_SCRIPTPATH_INVALID_SIG = {\"err_msg\": \"Signature must be zero for failed CHECK(MULTI)SIG operation\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_TAPSCRIPT_CHECKMULTISIG = {\"err_msg\": \"OP_CHECKMULTISIG(VERIFY) is not available in tapscript\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal in tapscript\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Stack size must be exactly one after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+ERR_CHECKSIGVERIFY = {\"err_msg\": \"Script failed an OP_CHECKSIGVERIFY operation\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+VALID_SIGHASHES_TAPROOT_SINGLE = [\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT_NO_SINGLE = [h for h in VALID_SIGHASHES_TAPROOT if h not in VALID_SIGHASHES_TAPROOT_SINGLE]\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SIG_POP_BYTE = {\"failure\": {\"sign\": byte_popper(default_sign)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+SIG_ADD_ZERO = {\"failure\": {\"sign\": zero_appender(default_sign)}}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 50000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    secs = [generate_privkey() for _ in range(8)]\n+    pubs = [compute_xonly_pubkey(sec)[0] for sec in secs]\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    tap = taproot_construct(pubs[0])\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=secs[0], failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=secs[0], failure={\"sighash\": bitflipper(default_sighash)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=secs[0], failure={\"flag_flip_r\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=secs[0], failure={\"flag_flip_p\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=secs[0], failure={\"signature\": bitflipper(default_signature)}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pubs[0])\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pubs[1])))]\n+            tap = taproot_construct(pubs[0], scripts)\n+            add_spender(spenders, \"sighash/keypath_hashtype_%x\" % hashtype, tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath_hashtype_%x\" % hashtype, tap=tap, leaf=\"s0\", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+            # Test SIGHASH_SINGLE behavior in combination with mismatching outputs\n+            if hashtype in VALID_SIGHASHES_TAPROOT_SINGLE:\n+                add_spender(spenders, \"sighash/keypath_hashtype_mis_%x\" % hashtype, tap=tap, key=secs[0], annex=annex, standard=no_annex, hashtype_actual=random.choice(VALID_SIGHASHES_TAPROOT_NO_SINGLE), failure={\"hashtype_actual\": hashtype}, **ERR_KEYPATH_INVALID_SIG, need_vin_vout_mismatch=True)\n+                add_spender(spenders, \"sighash/scriptpath_hashtype_mis_%x\" % hashtype, tap=tap, leaf=\"s0\", key=secs[1], annex=annex, standard=no_annex, hashtype_actual=random.choice(VALID_SIGHASHES_TAPROOT_NO_SINGLE), **SINGLE_SIG, failure={\"hashtype_actual\": hashtype}, **ERR_SCRIPTPATH_INVALID_SIG, need_vin_vout_mismatch=True)\n+\n+        # Test OP_CODESEPARATOR impact on sighashing.\n+        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+        common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+        scripts = [\n+            (\"pk_codesep\", CScript(random_checksig_style(pubs[1]) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig\n+            (\"codesep_pk\", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pubs[1]))),  # codesep before checksig\n+            (\"branched_codesep\", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pubs[0], OP_ELSE, OP_CODESEPARATOR, pubs[1], OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"sighash/pk_codesep\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/codesep_pk\", tap=tap, leaf=\"codesep_pk\", key=secs[1], codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/left\", tap=tap, leaf=\"branched_codesep\", key=secs[0], codeseppos=3, **common, inputs=[getter(\"sign\"), b'\\x01'], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/right\", tap=tap, leaf=\"branched_codesep\", key=secs[1], codeseppos=6, **common, inputs=[getter(\"sign\"), b''], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Reusing the scripts above, test that various features affect the sighash.\n+    add_spender(spenders, \"sighash/annex\", tap=tap, leaf=\"pk_codesep\", key=secs[1], hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={\"sighash\": override(default_sighash, annex=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/script\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, script_taproot=tap.leaves[\"codesep_pk\"].script)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/leafver\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leafversion=random.choice([x & 0xFE for x in range(0x100) if x & 0xFE != 0xC0]))}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leaf=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/keypath\", tap=tap, key=secs[0], **common, failure={\"sighash\": override(default_sighash, leaf=\"pk_codesep\")}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # Test that invalid hashtypes don't work, both in key path and script path spends\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for invalid_hashtype in [x for x in range(0x100) if x not in VALID_SIGHASHES_TAPROOT]:\n+        add_spender(spenders, \"sighash/keypath_unk_hashtype_%x\" % invalid_hashtype, tap=tap, key=secs[0], hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_KEYPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/scriptpath_unk_hashtype_%x\" % invalid_hashtype, tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Test that hashtype 0 cannot have a hashtype byte, and 1 must have one.\n+    add_spender(spenders, \"sighash/hashtype0_byte_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    # Test that hashtype 0 and hashtype 1 cannot be transmuted into each other.\n+    add_spender(spenders, \"sighash/hashtype0to1_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0to1_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Test aspects of signatures with unusual lengths\n+    for hashtype in [SIGHASH_DEFAULT, random.choice(VALID_SIGHASHES_TAPROOT)]:\n+        scripts = [\n+            (\"csv\", CScript([pubs[2], OP_CHECKSIGVERIFY, OP_1])),\n+            (\"cs_pos\", CScript([pubs[2], OP_CHECKSIG])),\n+            (\"csa_pos\", CScript([OP_0, pubs[2], OP_CHECKSIGADD, OP_1, OP_EQUAL])),\n+            (\"cs_neg\", CScript([pubs[2], OP_CHECKSIG, OP_NOT])),\n+            (\"csa_neg\", CScript([OP_2, pubs[2], OP_CHECKSIGADD, OP_2, OP_EQUAL]))\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[3], scripts)\n+        # Empty signatures\n+        add_spender(spenders, \"siglen/empty_keypath\", tap=tap, key=secs[3], hashtype=hashtype, failure={\"sign\": b\"\"}, **ERR_KEYPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/empty_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_CHECKSIGVERIFY)\n+        add_spender(spenders, \"siglen/empty_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_NO_SUCCESS)\n+        add_spender(spenders, \"siglen/empty_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_NO_SUCCESS)\n+        add_spender(spenders, \"siglen/empty_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": lambda _: random_bytes(random.randrange(1, 100))}, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/empty_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": lambda _: random_bytes(random.randrange(1, 100))}, **ERR_SCRIPTPATH_INVALID_SIG)\n+        # Appending a zero byte to signatures invalidates them\n+        add_spender(spenders, \"siglen/padzero_keypath\", tap=tap, key=secs[3], hashtype=hashtype, **SIG_ADD_ZERO, **ERR_KEYPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/padzero_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/padzero_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/padzero_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/padzero_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_ADD_ZERO, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/padzero_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_ADD_ZERO, **ERR_SCRIPTPATH_INVALID_SIG)\n+        # Removing the last byte from signatures invalidates them\n+        add_spender(spenders, \"siglen/popbyte_keypath\", tap=tap, key=secs[3], hashtype=hashtype, **SIG_POP_BYTE, **ERR_KEYPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/popbyte_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/popbyte_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/popbyte_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/popbyte_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_POP_BYTE, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/popbyte_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_POP_BYTE, **ERR_SCRIPTPATH_INVALID_SIG)\n+        # Verify that an invalid signature is not allowed, not even when the CHECKSIG* is expected to fail.\n+        add_spender(spenders, \"siglen/invalid_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": default_sign, \"sighash\": bitflipper(default_sighash)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/invalid_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": default_sign, \"sighash\": bitflipper(default_sighash)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # == Test that BIP341 spending only applies to witness version 1, program length 32, no P2SH ==\n+\n+    for p2sh in [False, True]:\n+        for witver in range(1, 17):\n+            for witlen in [20, 31, 32, 33]:\n+                def mutate(spk):\n+                    prog = spk[2:]\n+                    assert len(prog) == 32\n+                    if witlen < 32:\n+                        prog = prog[0:witlen]\n+                    elif witlen > 32:\n+                        prog += bytes([0 for _ in range(witlen - 32)])\n+                    return CScript([CScriptOp.encode_op_n(witver), prog])\n+                scripts = [(\"s0\", CScript([pubs[0], OP_CHECKSIG])), (\"dummy\", CScript([OP_RETURN]))]\n+                tap = taproot_construct(pubs[1], scripts)\n+                if not p2sh and witver == 1 and witlen == 32:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, failure={\"leaf\": \"dummy\"}, **ERR_OP_RETURN)\n+                else:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], standard=False)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, standard=False)\n+\n+    # == Test various aspects of BIP341 spending paths ==\n+\n+    # A set of functions that compute the hashing partner in a Merkle tree, designed to exercise\n+    # edge cases. This relies on the taproot_construct feature that a lambda can be passed in\n+    # instead of a subtree, to compute the partner to be hashed with.\n+    PARTNER_MERKLE_FN = [\n+        # Combine with itself\n+        lambda h: h,\n+        # Combine with hash 0\n+        lambda h: bytes([0 for _ in range(32)]),\n+        # Combine with hash 2^256-1\n+        lambda h: bytes([0xff for _ in range(32)]),\n+        # Combine with itself-1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') + 1).to_bytes(32, 'big'),\n+        # Combine with itself-1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') + 1).to_bytes(32, 'little'),\n+        # Combine with random bitflipped version of self.\n+        lambda h: (int.from_bytes(h, 'little') ^ (1 << random.randrange(256))).to_bytes(32, 'little')\n+    ]\n+    # Start with a tree of that has depth 1 for \"128deep\" and depth 2 for \"129deep\".\n+    scripts = [(\"128deep\", CScript([pubs[0], OP_CHECKSIG])), [(\"129deep\", CScript([pubs[0], OP_CHECKSIG])), random.choice(PARTNER_MERKLE_FN)]]\n+    # Add 127 nodes on top of that tree, so that \"128deep\" and \"129deep\" end up at their designated depths.\n+    for _ in range(127):\n+        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+    tap = taproot_construct(pubs[0], scripts)\n+    # Test that spends with a depth of 128 work, but 129 doesn't (even with a tree with weird Merkle branches in it).\n+    add_spender(spenders, \"spendpath/merklelimit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"leaf\": \"129deep\"}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that flipping the negation bit invalidates spends.\n+    add_spender(spenders, \"spendpath/negflag\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"negflag\": lambda ctx: 1 - default_negflag(ctx)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the Merkle branch invalidate it.\n+    add_spender(spenders, \"spendpath/bitflipmerkle\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"merklebranch\": bitflipper(default_merklebranch)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the inner pubkey invalidate it.\n+    add_spender(spenders, \"spendpath/bitflippubkey\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"pubkey_inner\": bitflipper(default_pubkey_inner)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that empty witnesses are invalid.\n+    add_spender(spenders, \"spendpath/emptywit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"witness\": []}, **ERR_EMPTY_WITNESS)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padlongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/trunclongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    scripts = [(\"s\", CScript([pubs[0], OP_CHECKSIG]))]\n+    tap = taproot_construct(pubs[1], scripts)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/truncshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block to 1 byte (\"-1 Merkle length\") invalidates it\n+    add_spender(spenders, \"spendpath/trunc1shortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:1]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    # == Test BIP342 edge cases ==\n+\n+    csa_low_val = random.randrange(0, 17) # Within range for OP_n\n+    csa_low_result = csa_low_val + 1\n+\n+    csa_high_val = random.randrange(17, 100) if random.getrandbits(1) else random.randrange(-100, -1) # Outside OP_n range\n+    csa_high_result = csa_high_val + 1\n+\n+    OVERSIZE_NUMBER = 2**31\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER))), 6)\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER-1))), 5)\n+\n+    big_choices = []\n+    big_scriptops = []\n+    for i in range(1000):\n+        r = random.randrange(len(pubs))\n+        big_choices.append(r)\n+        big_scriptops += [pubs[r], OP_CHECKSIGVERIFY]\n+\n+\n+    def big_spend_inputs(ctx):\n+        \"\"\"Helper function to construct the script input for t33/t34 below.\"\"\"\n+        # Instead of signing 999 times, precompute signatures for every (key, hashtype) combination\n+        sigs = {}\n+        for ht in VALID_SIGHASHES_TAPROOT:\n+            for k in range(len(pubs)):\n+                sigs[(k, ht)] = override(default_sign, hashtype=ht, key=secs[k])(ctx)\n+        num = get(ctx, \"num\")\n+        return [sigs[(big_choices[i], random.choice(VALID_SIGHASHES_TAPROOT))] for i in range(num - 1, -1, -1)]\n+\n+    # Various BIP342 features\n+    scripts = [\n+        # 0) drop stack element and OP_CHECKSIG\n+        (\"t0\", CScript([OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 1) normal OP_CHECKSIG\n+        (\"t1\", CScript([pubs[1], OP_CHECKSIG])),\n+        # 2) normal OP_CHECKSIGVERIFY\n+        (\"t2\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1])),\n+        # 3) Hypothetical OP_CHECKMULTISIG script that takes a single sig as input\n+        (\"t3\", CScript([OP_0, OP_SWAP, OP_1, pubs[1], OP_1, OP_CHECKMULTISIG])),\n+        # 4) Hypothetical OP_CHECKMULTISIGVERIFY script that takes a single sig as input\n+        (\"t4\", CScript([OP_0, OP_SWAP, OP_1, pubs[1], OP_1, OP_CHECKMULTISIGVERIFY, OP_1])),\n+        # 5) OP_IF script that needs a true input\n+        (\"t5\", CScript([OP_IF, pubs[1], OP_CHECKSIG, OP_ELSE, OP_RETURN, OP_ENDIF])),\n+        # 6) OP_NOTIF script that needs a true input\n+        (\"t6\", CScript([OP_NOTIF, OP_RETURN, OP_ELSE, pubs[1], OP_CHECKSIG, OP_ENDIF])),\n+        # 7) OP_CHECKSIG with an empty key\n+        (\"t7\", CScript([OP_0, OP_CHECKSIG])),\n+        # 8) OP_CHECKSIGVERIFY with an empty key\n+        (\"t8\", CScript([OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 9) normal OP_CHECKSIGADD that also ensures return value is correct\n+        (\"t9\", CScript([csa_low_val, pubs[1], OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 10) OP_CHECKSIGADD with empty key\n+        (\"t10\", CScript([csa_low_val, OP_0, OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 11) OP_CHECKSIGADD with missing counter stack element\n+        (\"t11\", CScript([pubs[1], OP_CHECKSIGADD, OP_1, OP_EQUAL])),\n+        # 12) OP_CHECKSIG that needs invalid signature\n+        (\"t12\", CScript([pubs[1], OP_CHECKSIGVERIFY, pubs[0], OP_CHECKSIG, OP_NOT])),\n+        # 13) OP_CHECKSIG with empty key that needs invalid signature\n+        (\"t13\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_CHECKSIG, OP_NOT])),\n+        # 14) OP_CHECKSIGADD that needs invalid signature\n+        (\"t14\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, pubs[0], OP_CHECKSIGADD, OP_NOT])),\n+        # 15) OP_CHECKSIGADD with empty key that needs invalid signature\n+        (\"t15\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGADD, OP_NOT])),\n+        # 16) OP_CHECKSIG with unknown pubkey type\n+        (\"t16\", CScript([OP_1, OP_CHECKSIG])),\n+        # 17) OP_CHECKSIGADD with unknown pubkey type\n+        (\"t17\", CScript([OP_0, OP_1, OP_CHECKSIGADD])),\n+        # 18) OP_CHECKSIGVERIFY with unknown pubkey type\n+        (\"t18\", CScript([OP_1, OP_CHECKSIGVERIFY, OP_1])),\n+        # 19) script longer than 10000 bytes and over 201 non-push opcodes\n+        (\"t19\", CScript([OP_0, OP_0, OP_2DROP] * 10001 + [pubs[1], OP_CHECKSIG])),\n+        # 20) OP_CHECKSIGVERIFY with empty key\n+        (\"t20\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 21) Script that grows the stack to 1000 elements\n+        (\"t21\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 999 + [OP_DROP] * 999)),\n+        # 22) Script that grows the stack to 1001 elements\n+        (\"t22\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 1000 + [OP_DROP] * 1000)),\n+        # 23) Script that expects an input stack of 1000 elements\n+        (\"t23\", CScript([OP_DROP] * 999 + [pubs[1], OP_CHECKSIG])),\n+        # 24) Script that expects an input stack of 1001 elements\n+        (\"t24\", CScript([OP_DROP] * 1000 + [pubs[1], OP_CHECKSIG])),\n+        # 25) Script that pushes a MAX_SCRIPT_ELEMENT_SIZE-bytes element\n+        (\"t25\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE), OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 26) Script that pushes a (MAX_SCRIPT_ELEMENT_SIZE+1)-bytes element\n+        (\"t26\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 27) CHECKSIGADD that must fail because numeric argument number is >4 bytes\n+        (\"t27\", CScript([CScriptNum(OVERSIZE_NUMBER), pubs[1], OP_CHECKSIGADD])),\n+        # 28) Pushes random CScriptNum value, checks OP_CHECKSIGADD result\n+        (\"t28\", CScript([csa_high_val, pubs[1], OP_CHECKSIGADD, csa_high_result, OP_EQUAL])),\n+        # 29) CHECKSIGADD that succeeds with proper sig because numeric argument number is <=4 bytes\n+        (\"t29\", CScript([CScriptNum(OVERSIZE_NUMBER-1), pubs[1], OP_CHECKSIGADD])),\n+        # 30) Variant of t1 with \"normal\" 33-byte pubkey\n+        (\"t30\", CScript([b'\\x03' + pubs[1], OP_CHECKSIG])),\n+        # 31) Variant of t2 with \"normal\" 33-byte pubkey\n+        (\"t31\", CScript([b'\\x02' + pubs[1], OP_CHECKSIGVERIFY, OP_1])),\n+        # 32) Variant of t28 with \"normal\" 33-byte pubkey\n+        (\"t32\", CScript([csa_high_val, b'\\x03' + pubs[1], OP_CHECKSIGADD, csa_high_result, OP_EQUAL])),\n+        # 33) 999-of-999 multisig\n+        (\"t33\", CScript(big_scriptops[:1998] + [OP_1])),\n+        # 34) 1000-of-1000 multisig\n+        (\"t34\", CScript(big_scriptops[:2000] + [OP_1])),\n+        # 35) Variant of t9 that uses a non-minimally encoded input arg\n+        (\"t35\", CScript([bytes([csa_low_val]), pubs[1], OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 36) Empty script\n+        (\"t36\", CScript([])),\n+    ]\n+    # Add many dummies to test huge trees\n+    for j in range(100000):\n+        scripts.append((None, CScript([OP_RETURN, random.randrange(100000)])))\n+    random.shuffle(scripts)\n+    tap = taproot_construct(pubs[0], scripts)\n+    common = {\n+        \"hashtype\": hashtype,\n+        \"key\": secs[1],\n+        \"tap\": tap,\n+    }\n+    # Test that MAX_SCRIPT_ELEMENT_SIZE byte stack element inputs are valid, but not one more (and 80 bytes is standard but 81 is not).\n+    add_spender(spenders, \"tapscript/inputmaxlimit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE)], failure={\"inputs\": [getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1)]}, **ERR_PUSH_LIMIT)\n+    add_spender(spenders, \"tapscript/input80limit\", leaf=\"t0\", **common, inputs=[getter(\"sign\"), random_bytes(80)])\n+    add_spender(spenders, \"tapscript/input81limit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(81)])\n+    # Test that OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY cause failure, but OP_CHECKSIG and OP_CHECKSIGVERIFY work.\n+    add_spender(spenders, \"tapscript/disabled_checkmultisig\", leaf=\"t1\", **common, **SINGLE_SIG, failure={\"leaf\": \"t3\"}, **ERR_TAPSCRIPT_CHECKMULTISIG)\n+    add_spender(spenders, \"tapscript/disabled_checkmultisigverify\", leaf=\"t2\", **common, **SINGLE_SIG, failure={\"leaf\": \"t4\"}, **ERR_TAPSCRIPT_CHECKMULTISIG)\n+    # Test that OP_IF and OP_NOTIF do not accept non-0x01 as truth value (the MINIMALIF rule is consensus in Tapscript)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x02']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x03']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0001']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0100']}, **ERR_MINIMALIF)\n+    # Test that 1-byte public keys (which are unknown) are acceptable but nonstandard with unrelated signatures, but 0-byte public keys are not valid.\n+    add_spender(spenders, \"tapscript/unkpk/checksig\", leaf=\"t16\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigadd\", leaf=\"t17\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigverify\", leaf=\"t18\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that 33-byte public keys (which are unknown) are acceptable but nonstandard with valid signatures, but normal pubkeys are not valid in that case.\n+    add_spender(spenders, \"tapscript/oldpk/checksig\", leaf=\"t30\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t1\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"tapscript/oldpk/checksigadd\", leaf=\"t31\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t2\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"tapscript/oldpk/checksigverify\", leaf=\"t32\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t28\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    # Test that 0-byte public keys are not acceptable.\n+    add_spender(spenders, \"tapscript/emptypk/checksig\", leaf=\"t1\", **SINGLE_SIG, **common, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigverify\", leaf=\"t2\", **SINGLE_SIG, **common, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigadd\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigadd\", leaf=\"t35\", standard=False, **SINGLE_SIG, **common, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that OP_CHECKSIGADD results are as expected\n+    add_spender(spenders, \"tapscript/checksigaddresults\", leaf=\"t28\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    add_spender(spenders, \"tapscript/checksigaddoversize\", leaf=\"t29\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    # Test that OP_CHECKSIGADD requires 3 stack elements.\n+    add_spender(spenders, \"tapscript/checksigadd3args\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t11\"}, **ERR_STACK_EMPTY)\n+    # Test that empty signatures do not cause script failure in OP_CHECKSIG and OP_CHECKSIGADD (but do fail with empty pubkey, and do fail OP_CHECKSIGVERIFY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksig\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t13\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/nochecksigverify\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t20\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksigadd\", leaf=\"t14\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t15\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that scripts over 10000 bytes (and over 201 non-push ops) are acceptable.\n+    add_spender(spenders, \"tapscript/no10000limit\", leaf=\"t19\", **SINGLE_SIG, **common)\n+    # Test that a stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000stack\", leaf=\"t21\", **SINGLE_SIG, **common, failure={\"leaf\": \"t22\"}, **ERR_STACK_SIZE)\n+    # Test that an input stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000inputs\", leaf=\"t23\", **common, inputs=[getter(\"sign\")] + [b'' for _ in range(999)], failure={\"leaf\": \"t24\", \"inputs\": [getter(\"sign\")] + [b'' for _ in range(1000)]}, **ERR_STACK_SIZE)\n+    # Test that pushing a MAX_SCRIPT_ELEMENT_SIZE byte stack element is valid, but one longer is not.\n+    add_spender(spenders, \"tapscript/pushmaxlimit\", leaf=\"t25\", **common, **SINGLE_SIG, failure={\"leaf\": \"t26\"}, **ERR_PUSH_LIMIT)\n+    # Test that 999-of-999 multisig works (but 1000-of-1000 triggers stack size limits)\n+    add_spender(spenders, \"tapscript/bigmulti\", leaf=\"t33\", **common, inputs=big_spend_inputs, num=999, failure={\"leaf\": \"t34\", \"num\": 1000}, **ERR_STACK_SIZE)\n+    # Test that the CLEANSTACK rule is consensus critical in tapscript\n+    add_spender(spenders, \"tapscript/cleanstack\", leaf=\"t36\", tap=tap, inputs=[b'\\x01'], failure={\"inputs\": [b'\\x01', b'\\x01']}, **ERR_CLEANSTACK)\n+\n+    # == Test for sigops ratio limit ==\n+\n+    # Given a number n, and a public key pk, functions that produce a (CScript, sigops). Each script takes as\n+    # input a valid signature with the passed pk followed by a dummy push of bytes that are to be dropped, and\n+    # will execute sigops signature checks.\n+    SIGOPS_RATIO_SCRIPTS = [\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIG.\n+        lambda n, pk: (CScript([OP_DROP, pk] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGVERIFY.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_0, OP_IF, OP_2DUP, OP_CHECKSIGVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_2, OP_SWAP, OP_CHECKSIGADD, OP_3, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIG.\n+        lambda n, pk: (CScript([random_bytes(220), OP_2DROP, pk, OP_1, OP_NOTIF, OP_2DUP, OP_CHECKSIG, OP_VERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_4, OP_SWAP, OP_CHECKSIGADD, OP_5, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGADD.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_1, OP_IF, OP_ELSE, OP_2DUP, OP_6, OP_SWAP, OP_CHECKSIGADD, OP_7, OP_EQUALVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_8, OP_SWAP, OP_CHECKSIGADD, OP_9, OP_EQUAL]), n + 1),\n+        # n+1 OP_CHECKSIGs, but also one OP_CHECKSIG with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, pk, OP_CHECKSIG, OP_NOT, OP_VERIFY, pk] + [OP_2DUP, OP_CHECKSIG, OP_VERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGADDs and 1 OP_CHECKSIG, but also an OP_CHECKSIGADD with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, OP_10, pk, OP_CHECKSIGADD, OP_10, OP_EQUALVERIFY, pk] + [OP_2DUP, OP_16, OP_SWAP, OP_CHECKSIGADD, b'\\x11', OP_EQUALVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+    ]\n+    for annex in [None, bytes([ANNEX_TAG]) + random_bytes(random.randrange(1000))]:\n+        for hashtype in [SIGHASH_DEFAULT, SIGHASH_ALL]:\n+            for pubkey in [pubs[1], random_bytes(random.choice([x for x in range(2, 81) if x != 32]))]:\n+                for fn_num, fn in enumerate(SIGOPS_RATIO_SCRIPTS):\n+                    merkledepth = random.randrange(129)\n+\n+\n+                    def predict_sigops_ratio(n, dummy_size):\n+                        \"\"\"Predict whether spending fn(n, pubkey) with dummy_size will pass the ratio test.\"\"\"\n+                        script, sigops = fn(n, pubkey)\n+                        # Predict the size of the witness for a given choice of n\n+                        stacklen_size = 1\n+                        sig_size = 64 + (hashtype != SIGHASH_DEFAULT)\n+                        siglen_size = 1\n+                        dummylen_size = 1 + 2 * (dummy_size >= 253)\n+                        script_size = len(script)\n+                        scriptlen_size = 1 + 2 * (script_size >= 253)\n+                        control_size = 33 + 32 * merkledepth\n+                        controllen_size = 1 + 2 * (control_size >= 253)\n+                        annex_size = 0 if annex is None else len(annex)\n+                        annexlen_size = 0 if annex is None else 1 + 2 * (annex_size >= 253)\n+                        witsize = stacklen_size + sig_size + siglen_size + dummy_size + dummylen_size + script_size + scriptlen_size + control_size + controllen_size + annex_size + annexlen_size\n+                        # sigops ratio test\n+                        return witsize + 50 >= 50 * sigops\n+                    # Make sure n is high enough that with empty dummy, the script is not valid\n+                    n = 0\n+                    while predict_sigops_ratio(n, 0):\n+                        n += 1\n+                    # But allow picking a bit higher still\n+                    n += random.randrange(5)\n+                    # Now pick dummy size *just* large enough that the overall construction passes\n+                    dummylen = 0\n+                    while not predict_sigops_ratio(n, dummylen):\n+                        dummylen += 1\n+                    scripts = [(\"s\", fn(n, pubkey)[0])]\n+                    for _ in range(merkledepth):\n+                        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+                    tap = taproot_construct(pubs[0], scripts)\n+                    standard = annex is None and dummylen <= 80 and len(pubkey) == 32\n+                    add_spender(spenders, \"tapscript/sigopsratio_%i\" % fn_num, tap=tap, leaf=\"s\", annex=annex, hashtype=hashtype, key=secs[1], inputs=[getter(\"sign\"), random_bytes(dummylen)], standard=standard, failure={\"inputs\": [getter(\"sign\"), random_bytes(dummylen - 1)]}, **ERR_SIGOPS_RATIO)\n+\n+    # Future leaf versions\n+    for leafver in range(0, 0x100, 2):\n+        if leafver == LEAF_VERSION_TAPSCRIPT or leafver == ANNEX_TAG:\n+            # Skip the defined LEAF_VERSION_TAPSCRIPT, and the ANNEX_TAG which is not usable as leaf version\n+            continue\n+        scripts = [\n+            (\"bare_c0\", CScript([OP_NOP])),\n+            (\"bare_unkver\", CScript([OP_NOP]), leafver),\n+            (\"return_c0\", CScript([OP_RETURN])),\n+            (\"return_unkver\", CScript([OP_RETURN]), leafver),\n+            (\"undecodable_c0\", CScript([OP_PUSHDATA1])),\n+            (\"undecodable_unkver\", CScript([OP_PUSHDATA1]), leafver),\n+            (\"bigpush_c0\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP])),\n+            (\"bigpush_unkver\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP]), leafver),\n+            (\"1001push_c0\", CScript([OP_0] * 1001)),\n+            (\"1001push_unkver\", CScript([OP_0] * 1001), leafver),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"unkver/bare\", standard=False, tap=tap, leaf=\"bare_unkver\", failure={\"leaf\": \"bare_c0\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"unkver/return\", standard=False, tap=tap, leaf=\"return_unkver\", failure={\"leaf\": \"return_c0\"}, **ERR_OP_RETURN)\n+        add_spender(spenders, \"unkver/undecodable\", standard=False, tap=tap, leaf=\"undecodable_unkver\", failure={\"leaf\": \"undecodable_c0\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"unkver/bigpush\", standard=False, tap=tap, leaf=\"bigpush_unkver\", failure={\"leaf\": \"bigpush_c0\"}, **ERR_PUSH_LIMIT)\n+        add_spender(spenders, \"unkver/1001push\", standard=False, tap=tap, leaf=\"1001push_unkver\", failure={\"leaf\": \"1001push_c0\"}, **ERR_STACK_SIZE)\n+        add_spender(spenders, \"unkver/1001inputs\", standard=False, tap=tap, leaf=\"bare_unkver\", inputs=[b'']*1001, failure={\"leaf\": \"bare_c0\"}, **ERR_STACK_SIZE)\n+\n+    # OP_SUCCESSx tests.\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for opval in range(76, 0x100):\n+        opcode = CScriptOp(opval)\n+        if not is_op_success(opcode):\n+            continue\n+        scripts = [\n+            (\"bare_success\", CScript([opcode])),\n+            (\"bare_nop\", CScript([OP_NOP])),\n+            (\"unexecif_success\", CScript([OP_0, OP_IF, opcode, OP_ENDIF])),\n+            (\"unexecif_nop\", CScript([OP_0, OP_IF, OP_NOP, OP_ENDIF])),\n+            (\"return_success\", CScript([OP_RETURN, opcode])),\n+            (\"return_nop\", CScript([OP_RETURN, OP_NOP])),\n+            (\"undecodable_success\", CScript([opcode, OP_PUSHDATA1])),\n+            (\"undecodable_nop\", CScript([OP_NOP, OP_PUSHDATA1])),\n+            (\"undecodable_bypassed_success\", CScript([OP_PUSHDATA1, OP_2, opcode])),\n+            (\"bigpush_success\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, opcode])),\n+            (\"bigpush_nop\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, OP_NOP])),\n+            (\"1001push_success\", CScript([OP_0] * 1001 + [opcode])),\n+            (\"1001push_nop\", CScript([OP_0] * 1001 + [OP_NOP])),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"opsuccess/bare\", standard=False, tap=tap, leaf=\"bare_success\", failure={\"leaf\": \"bare_nop\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"opsuccess/exexecif\", standard=False, tap=tap, leaf=\"unexecif_success\", failure={\"leaf\": \"unexecif_nop\"}, **ERR_CLEANSTACK)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r502969975",
      "id" : 502969975,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk2OTk3NQ==",
      "original_commit_id" : "58c90569f75221bc4652cbde5cad4dbae543a1ca",
      "original_line" : 1069,
      "original_position" : 1069,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 506131025,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/502969975",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1322187?v=4",
         "events_url" : "https://api.github.com/users/fjahr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fjahr/followers",
         "following_url" : "https://api.github.com/users/fjahr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fjahr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fjahr",
         "id" : 1322187,
         "login" : "fjahr",
         "node_id" : "MDQ6VXNlcjEzMjIxODc=",
         "organizations_url" : "https://api.github.com/users/fjahr/orgs",
         "received_events_url" : "https://api.github.com/users/fjahr/received_events",
         "repos_url" : "https://api.github.com/users/fjahr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fjahr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fjahr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fjahr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503074547"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503074547"
         }
      },
      "author_association" : "MEMBER",
      "body" : "50f0a10f7b2e45491775c1166c4593e7fa8cfd4b\r\n\r\n```suggestion\r\n    if (hash_type >= 0x84 || (hash_type >= 0x04 && hash_type <= 0x80)) return false;\r\n```\r\nseems slightly more straightforward, IMO.\r\n\r\nInterpreting it becomes \"If the hash type is above 0x84 or within 0x04 and 0x80\" vs \"if it is NOT the case that the hash type is <= 0x03 or within 0x81 and 0x83\".",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-12T06:54:59Z",
      "diff_hunk" : "@@ -1291,35 +1389,176 @@ uint256 GetOutputsSHA256(const T& txTo)\n     return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n+\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n+    }\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = SHA256Uint256(GetPrevoutsSHA256(txTo));\n-        hashSequence = SHA256Uint256(GetSequencesSHA256(txTo));\n-        hashOutputs = SHA256Uint256(GetOutputsSHA256(txTo));\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143_segwit = false;\n+    bool uses_bip341_taproot = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every native witness v1 spend as a Taproot spend. This only works if spent_outputs was\n+                // provided as well, but if it wasn't, actual validation will fail anyway.\n+                uses_bip341_taproot = true;\n+            } else {\n+                // Treat every spend that's not known to native witness v1 as a Witness v0 spend. This branch may\n+                // also be taken for unknown witness versions, but it is harmless, and being precise would require\n+                // P2SH evaluation to find the redeemScript.\n+                uses_bip143_segwit = true;\n+            }\n+        }\n+        if (uses_bip341_taproot && uses_bip143_segwit) break; // No need to scan further if we already need all.\n     }\n \n-    m_ready = true;\n+    if (uses_bip143_segwit || uses_bip341_taproot) {\n+        // Computations shared between both sighash schemes.\n+        m_prevouts_single_hash = GetPrevoutsSHA256(txTo);\n+        m_sequences_single_hash = GetSequencesSHA256(txTo);\n+        m_outputs_single_hash = GetOutputsSHA256(txTo);\n+    }\n+    if (uses_bip143_segwit) {\n+        hashPrevouts = SHA256Uint256(m_prevouts_single_hash);\n+        hashSequence = SHA256Uint256(m_sequences_single_hash);\n+        hashOutputs = SHA256Uint256(m_outputs_single_hash);\n+        m_bip143_segwit_ready = true;\n+    }\n+    if (uses_bip341_taproot) {\n+        m_spent_amounts_single_hash = GetSpentAmountsSHA256(m_spent_outputs);\n+        m_spent_scripts_single_hash = GetSpentScriptsSHA256(m_spent_outputs);\n+        m_bip341_taproot_ready = true;\n+    }\n }\n \n template <class T>\n PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n {\n-    Init(txTo);\n+    Init(txTo, {});\n }\n \n // explicit instantiation\n-template void PrecomputedTransactionData::Init(const CTransaction& txTo);\n-template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo);\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+static const CHashWriter HASHER_TAPLEAF = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HASHER_TAPBRANCH = TaggedHash(\"TapBranch\");\n+static const CHashWriter HASHER_TAPTWEAK = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const uint8_t key_version, const PrecomputedTransactionData& cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    case SigVersion::TAPSCRIPT:\n+        ext_flag = 1;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache.m_bip341_taproot_ready && cache.m_spent_outputs_ready);\n+\n+    CHashWriter ss = HASHER_TAPSIGHASH;\n+\n+    // Epoch\n+    static constexpr uint8_t EPOCH = 0;\n+    ss << EPOCH;\n+\n+    // Hash type\n+    const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n+    const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;\n+    if (!(hash_type <= 0x03 || (hash_type >= 0x81 && hash_type <= 0x83))) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503074547",
      "id" : 503074547,
      "in_reply_to_id" : 496155450,
      "line" : 1523,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA3NDU0Nw==",
      "original_commit_id" : "80efcba5e7ad84f68f5cd59c05fc87134fc9fb69",
      "original_line" : 1523,
      "original_position" : 348,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 370,
      "pull_request_review_id" : 506336832,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503074547",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503080494"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503080494"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This seems to disappear in a later commit so not really an issue, but I'm curious why this isn't `const auto& witstack = tx_to.[...]` which should effectively have the same result, except as a C++ ref rather than a pointer.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-12T07:07:58Z",
      "diff_hunk" : "@@ -1322,6 +1378,75 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, uint32_t in_pos, uint8_t hash_type, SigVersion sigversion, uint8_t key_version, const PrecomputedTransactionData& cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache.m_bip341_taproot_ready && cache.m_spent_outputs_ready);\n+\n+    CHashWriter ss = HASHER_TAPSIGHASH;\n+\n+    // Epoch\n+    static constexpr uint8_t EPOCH = 0;\n+    ss << EPOCH;\n+\n+    // Hash type\n+    const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n+    const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;\n+    if (!(hash_type <= 0x03 || (hash_type >= 0x81 && hash_type <= 0x83))) return false;\n+    ss << hash_type;\n+\n+    // Transaction level data\n+    ss << tx_to.nVersion;\n+    ss << tx_to.nLockTime;\n+    if (input_type != SIGHASH_ANYONECANPAY) {\n+        ss << cache.m_prevouts_single_hash;\n+        ss << cache.m_spent_amounts_single_hash;\n+        ss << cache.m_spent_scripts_single_hash;\n+        ss << cache.m_sequences_single_hash;\n+    }\n+    if (output_type == SIGHASH_ALL) {\n+        ss << cache.m_outputs_single_hash;\n+    }\n+\n+    // Data about the input/prevout being spent\n+    const auto* witstack = &tx_to.vin[in_pos].scriptWitness.stack;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503080494",
      "id" : 503080494,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA4MDQ5NA==",
      "original_commit_id" : "50f0a10f7b2e45491775c1166c4593e7fa8cfd4b",
      "original_line" : 1423,
      "original_position" : 133,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 506336832,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503080494",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503121398"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503121398"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This is no longer the case after later commits, where actual script semantics are added.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-12T08:24:07Z",
      "diff_hunk" : "@@ -1708,11 +1731,41 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n         } else {\n             return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH);\n         }\n+    } else if (witversion == 1 && program.size() == WITNESS_V1_TAPROOT_SIZE && !is_p2sh) {\n+        // BIP341 Taproot: 32-byte non-P2SH witness v1 program (which encodes a P2C-tweaked pubkey)\n+        if (!(flags & SCRIPT_VERIFY_TAPROOT)) return set_success(serror);\n+        if (stack.size() == 0) return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);\n+        if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {\n+            // Drop annex (this is non-standard; see IsWitnessStandard)\n+            SpanPopBack(stack);\n+        }\n+        if (stack.size() == 1) {\n+            // Key path spending (stack size is 1 after removing optional annex)\n+            if (!checker.CheckSchnorrSignature(stack.front(), program, SigVersion::TAPROOT, serror)) {\n+                return false;\n+            }\n+            return set_success(serror);\n+        } else {\n+            // Script path spending (stack size is >1 after removing optional annex)\n+            const valtype& control = SpanPopBack(stack);\n+            const valtype& script_bytes = SpanPopBack(stack);\n+            exec_script = CScript(script_bytes.begin(), script_bytes.end());\n+            if (control.size() < TAPROOT_CONTROL_BASE_SIZE || control.size() > TAPROOT_CONTROL_MAX_SIZE || ((control.size() - TAPROOT_CONTROL_BASE_SIZE) % TAPROOT_CONTROL_NODE_SIZE) != 0) {\n+                return set_error(serror, SCRIPT_ERR_TAPROOT_WRONG_CONTROL_SIZE);\n+            }\n+            if (!VerifyTaprootCommitment(control, program, exec_script)) {\n+                return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);\n+            }\n+            if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503121398",
      "id" : 503121398,
      "in_reply_to_id" : 502885312,
      "line" : 1922,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzEyMTM5OA==",
      "original_commit_id" : "68f87cb0da326bcaa2570ed6299a7ee1c6d7b5f6",
      "original_line" : 1922,
      "original_position" : 86,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 644,
      "pull_request_review_id" : 506397864,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503121398",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503157129"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503157129"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-12T09:20:22Z",
      "diff_hunk" : "@@ -1322,6 +1378,75 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, uint32_t in_pos, uint8_t hash_type, SigVersion sigversion, uint8_t key_version, const PrecomputedTransactionData& cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache.m_bip341_taproot_ready && cache.m_spent_outputs_ready);\n+\n+    CHashWriter ss = HASHER_TAPSIGHASH;\n+\n+    // Epoch\n+    static constexpr uint8_t EPOCH = 0;\n+    ss << EPOCH;\n+\n+    // Hash type\n+    const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n+    const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;\n+    if (!(hash_type <= 0x03 || (hash_type >= 0x81 && hash_type <= 0x83))) return false;\n+    ss << hash_type;\n+\n+    // Transaction level data\n+    ss << tx_to.nVersion;\n+    ss << tx_to.nLockTime;\n+    if (input_type != SIGHASH_ANYONECANPAY) {\n+        ss << cache.m_prevouts_single_hash;\n+        ss << cache.m_spent_amounts_single_hash;\n+        ss << cache.m_spent_scripts_single_hash;\n+        ss << cache.m_sequences_single_hash;\n+    }\n+    if (output_type == SIGHASH_ALL) {\n+        ss << cache.m_outputs_single_hash;\n+    }\n+\n+    // Data about the input/prevout being spent\n+    const auto* witstack = &tx_to.vin[in_pos].scriptWitness.stack;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503157129",
      "id" : 503157129,
      "in_reply_to_id" : 503080494,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE1NzEyOQ==",
      "original_commit_id" : "50f0a10f7b2e45491775c1166c4593e7fa8cfd4b",
      "original_line" : 1423,
      "original_position" : 133,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 506443206,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503157129",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503157211"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503157211"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-12T09:20:31Z",
      "diff_hunk" : "@@ -0,0 +1,1403 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expression for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        return tweak_add_privkey(key, tweak)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    scriptsig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    witness_stack = flatten(get(ctx, \"witness\"))\n+    return (scriptsig, witness_stack)\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda returning (scriptsig, witness_stack), taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+# - Whether this test demands being placed in a txin with no corresponding txout (for testing SIGHASH_SINGLE behavior)\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail,need_vin_vout_mismatch\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, need_vin_vout_mismatch=False, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert tap is None\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert script is None\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert script is None\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert script is None\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            return spend(tx, idx, utxos, **conf)\n+        else:\n+            assert failure is not None\n+            return spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None, need_vin_vout_mismatch=need_vin_vout_mismatch)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    return bytes(CScript([pubkey, OP_CHECKSIG]))\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+def zero_appender(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a zero added.\"\"\"\n+    return lambda ctx: deep_eval(ctx, expr) + b\"\\x00\"\n+\n+def byte_popper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with its last byte removed.\"\"\"\n+    return lambda ctx: deep_eval(ctx, expr)[:-1]\n+\n+# Expected error strings\n+\n+ERR_KEYPATH_INVALID_SIG = {\"err_msg\": \"Invalid signature for Taproot key path spending\"}\n+ERR_SCRIPTPATH_INVALID_SIG = {\"err_msg\": \"Signature must be zero for failed CHECK(MULTI)SIG operation\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_TAPSCRIPT_CHECKMULTISIG = {\"err_msg\": \"OP_CHECKMULTISIG(VERIFY) is not available in tapscript\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal in tapscript\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Stack size must be exactly one after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+ERR_CHECKSIGVERIFY = {\"err_msg\": \"Script failed an OP_CHECKSIGVERIFY operation\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+VALID_SIGHASHES_TAPROOT_SINGLE = [\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT_NO_SINGLE = [h for h in VALID_SIGHASHES_TAPROOT if h not in VALID_SIGHASHES_TAPROOT_SINGLE]\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SIG_POP_BYTE = {\"failure\": {\"sign\": byte_popper(default_sign)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+SIG_ADD_ZERO = {\"failure\": {\"sign\": zero_appender(default_sign)}}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 50000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    secs = [generate_privkey() for _ in range(8)]\n+    pubs = [compute_xonly_pubkey(sec)[0] for sec in secs]\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    tap = taproot_construct(pubs[0])\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=secs[0], failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=secs[0], failure={\"sighash\": bitflipper(default_sighash)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=secs[0], failure={\"flag_flip_r\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=secs[0], failure={\"flag_flip_p\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=secs[0], failure={\"signature\": bitflipper(default_signature)}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pubs[0])\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pubs[1])))]\n+            tap = taproot_construct(pubs[0], scripts)\n+            add_spender(spenders, \"sighash/keypath_hashtype_%x\" % hashtype, tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath_hashtype_%x\" % hashtype, tap=tap, leaf=\"s0\", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+            # Test SIGHASH_SINGLE behavior in combination with mismatching outputs\n+            if hashtype in VALID_SIGHASHES_TAPROOT_SINGLE:\n+                add_spender(spenders, \"sighash/keypath_hashtype_mis_%x\" % hashtype, tap=tap, key=secs[0], annex=annex, standard=no_annex, hashtype_actual=random.choice(VALID_SIGHASHES_TAPROOT_NO_SINGLE), failure={\"hashtype_actual\": hashtype}, **ERR_KEYPATH_INVALID_SIG, need_vin_vout_mismatch=True)\n+                add_spender(spenders, \"sighash/scriptpath_hashtype_mis_%x\" % hashtype, tap=tap, leaf=\"s0\", key=secs[1], annex=annex, standard=no_annex, hashtype_actual=random.choice(VALID_SIGHASHES_TAPROOT_NO_SINGLE), **SINGLE_SIG, failure={\"hashtype_actual\": hashtype}, **ERR_SCRIPTPATH_INVALID_SIG, need_vin_vout_mismatch=True)\n+\n+        # Test OP_CODESEPARATOR impact on sighashing.\n+        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+        common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+        scripts = [\n+            (\"pk_codesep\", CScript(random_checksig_style(pubs[1]) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig\n+            (\"codesep_pk\", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pubs[1]))),  # codesep before checksig\n+            (\"branched_codesep\", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pubs[0], OP_ELSE, OP_CODESEPARATOR, pubs[1], OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"sighash/pk_codesep\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/codesep_pk\", tap=tap, leaf=\"codesep_pk\", key=secs[1], codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/left\", tap=tap, leaf=\"branched_codesep\", key=secs[0], codeseppos=3, **common, inputs=[getter(\"sign\"), b'\\x01'], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/right\", tap=tap, leaf=\"branched_codesep\", key=secs[1], codeseppos=6, **common, inputs=[getter(\"sign\"), b''], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Reusing the scripts above, test that various features affect the sighash.\n+    add_spender(spenders, \"sighash/annex\", tap=tap, leaf=\"pk_codesep\", key=secs[1], hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={\"sighash\": override(default_sighash, annex=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/script\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, script_taproot=tap.leaves[\"codesep_pk\"].script)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/leafver\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leafversion=random.choice([x & 0xFE for x in range(0x100) if x & 0xFE != 0xC0]))}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leaf=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/keypath\", tap=tap, key=secs[0], **common, failure={\"sighash\": override(default_sighash, leaf=\"pk_codesep\")}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # Test that invalid hashtypes don't work, both in key path and script path spends\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for invalid_hashtype in [x for x in range(0x100) if x not in VALID_SIGHASHES_TAPROOT]:\n+        add_spender(spenders, \"sighash/keypath_unk_hashtype_%x\" % invalid_hashtype, tap=tap, key=secs[0], hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_KEYPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/scriptpath_unk_hashtype_%x\" % invalid_hashtype, tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Test that hashtype 0 cannot have a hashtype byte, and 1 must have one.\n+    add_spender(spenders, \"sighash/hashtype0_byte_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    # Test that hashtype 0 and hashtype 1 cannot be transmuted into each other.\n+    add_spender(spenders, \"sighash/hashtype0to1_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0to1_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Test aspects of signatures with unusual lengths\n+    for hashtype in [SIGHASH_DEFAULT, random.choice(VALID_SIGHASHES_TAPROOT)]:\n+        scripts = [\n+            (\"csv\", CScript([pubs[2], OP_CHECKSIGVERIFY, OP_1])),\n+            (\"cs_pos\", CScript([pubs[2], OP_CHECKSIG])),\n+            (\"csa_pos\", CScript([OP_0, pubs[2], OP_CHECKSIGADD, OP_1, OP_EQUAL])),\n+            (\"cs_neg\", CScript([pubs[2], OP_CHECKSIG, OP_NOT])),\n+            (\"csa_neg\", CScript([OP_2, pubs[2], OP_CHECKSIGADD, OP_2, OP_EQUAL]))\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[3], scripts)\n+        # Empty signatures\n+        add_spender(spenders, \"siglen/empty_keypath\", tap=tap, key=secs[3], hashtype=hashtype, failure={\"sign\": b\"\"}, **ERR_KEYPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/empty_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_CHECKSIGVERIFY)\n+        add_spender(spenders, \"siglen/empty_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_NO_SUCCESS)\n+        add_spender(spenders, \"siglen/empty_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_NO_SUCCESS)\n+        add_spender(spenders, \"siglen/empty_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": lambda _: random_bytes(random.randrange(1, 100))}, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/empty_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": lambda _: random_bytes(random.randrange(1, 100))}, **ERR_SCRIPTPATH_INVALID_SIG)\n+        # Appending a zero byte to signatures invalidates them\n+        add_spender(spenders, \"siglen/padzero_keypath\", tap=tap, key=secs[3], hashtype=hashtype, **SIG_ADD_ZERO, **ERR_KEYPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/padzero_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/padzero_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/padzero_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/padzero_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_ADD_ZERO, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/padzero_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_ADD_ZERO, **ERR_SCRIPTPATH_INVALID_SIG)\n+        # Removing the last byte from signatures invalidates them\n+        add_spender(spenders, \"siglen/popbyte_keypath\", tap=tap, key=secs[3], hashtype=hashtype, **SIG_POP_BYTE, **ERR_KEYPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/popbyte_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/popbyte_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/popbyte_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/popbyte_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_POP_BYTE, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/popbyte_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_POP_BYTE, **ERR_SCRIPTPATH_INVALID_SIG)\n+        # Verify that an invalid signature is not allowed, not even when the CHECKSIG* is expected to fail.\n+        add_spender(spenders, \"siglen/invalid_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": default_sign, \"sighash\": bitflipper(default_sighash)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/invalid_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": default_sign, \"sighash\": bitflipper(default_sighash)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # == Test that BIP341 spending only applies to witness version 1, program length 32, no P2SH ==\n+\n+    for p2sh in [False, True]:\n+        for witver in range(1, 17):\n+            for witlen in [20, 31, 32, 33]:\n+                def mutate(spk):\n+                    prog = spk[2:]\n+                    assert len(prog) == 32\n+                    if witlen < 32:\n+                        prog = prog[0:witlen]\n+                    elif witlen > 32:\n+                        prog += bytes([0 for _ in range(witlen - 32)])\n+                    return CScript([CScriptOp.encode_op_n(witver), prog])\n+                scripts = [(\"s0\", CScript([pubs[0], OP_CHECKSIG])), (\"dummy\", CScript([OP_RETURN]))]\n+                tap = taproot_construct(pubs[1], scripts)\n+                if not p2sh and witver == 1 and witlen == 32:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, failure={\"leaf\": \"dummy\"}, **ERR_OP_RETURN)\n+                else:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], standard=False)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, standard=False)\n+\n+    # == Test various aspects of BIP341 spending paths ==\n+\n+    # A set of functions that compute the hashing partner in a Merkle tree, designed to exercise\n+    # edge cases. This relies on the taproot_construct feature that a lambda can be passed in\n+    # instead of a subtree, to compute the partner to be hashed with.\n+    PARTNER_MERKLE_FN = [\n+        # Combine with itself\n+        lambda h: h,\n+        # Combine with hash 0\n+        lambda h: bytes([0 for _ in range(32)]),\n+        # Combine with hash 2^256-1\n+        lambda h: bytes([0xff for _ in range(32)]),\n+        # Combine with itself-1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') + 1).to_bytes(32, 'big'),\n+        # Combine with itself-1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') + 1).to_bytes(32, 'little'),\n+        # Combine with random bitflipped version of self.\n+        lambda h: (int.from_bytes(h, 'little') ^ (1 << random.randrange(256))).to_bytes(32, 'little')\n+    ]\n+    # Start with a tree of that has depth 1 for \"128deep\" and depth 2 for \"129deep\".\n+    scripts = [(\"128deep\", CScript([pubs[0], OP_CHECKSIG])), [(\"129deep\", CScript([pubs[0], OP_CHECKSIG])), random.choice(PARTNER_MERKLE_FN)]]\n+    # Add 127 nodes on top of that tree, so that \"128deep\" and \"129deep\" end up at their designated depths.\n+    for _ in range(127):\n+        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+    tap = taproot_construct(pubs[0], scripts)\n+    # Test that spends with a depth of 128 work, but 129 doesn't (even with a tree with weird Merkle branches in it).\n+    add_spender(spenders, \"spendpath/merklelimit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"leaf\": \"129deep\"}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that flipping the negation bit invalidates spends.\n+    add_spender(spenders, \"spendpath/negflag\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"negflag\": lambda ctx: 1 - default_negflag(ctx)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the Merkle branch invalidate it.\n+    add_spender(spenders, \"spendpath/bitflipmerkle\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"merklebranch\": bitflipper(default_merklebranch)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the inner pubkey invalidate it.\n+    add_spender(spenders, \"spendpath/bitflippubkey\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"pubkey_inner\": bitflipper(default_pubkey_inner)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that empty witnesses are invalid.\n+    add_spender(spenders, \"spendpath/emptywit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"witness\": []}, **ERR_EMPTY_WITNESS)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padlongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/trunclongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    scripts = [(\"s\", CScript([pubs[0], OP_CHECKSIG]))]\n+    tap = taproot_construct(pubs[1], scripts)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/truncshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block to 1 byte (\"-1 Merkle length\") invalidates it\n+    add_spender(spenders, \"spendpath/trunc1shortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:1]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    # == Test BIP342 edge cases ==\n+\n+    csa_low_val = random.randrange(0, 17) # Within range for OP_n\n+    csa_low_result = csa_low_val + 1\n+\n+    csa_high_val = random.randrange(17, 100) if random.getrandbits(1) else random.randrange(-100, -1) # Outside OP_n range\n+    csa_high_result = csa_high_val + 1\n+\n+    OVERSIZE_NUMBER = 2**31\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER))), 6)\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER-1))), 5)\n+\n+    big_choices = []\n+    big_scriptops = []\n+    for i in range(1000):\n+        r = random.randrange(len(pubs))\n+        big_choices.append(r)\n+        big_scriptops += [pubs[r], OP_CHECKSIGVERIFY]\n+\n+\n+    def big_spend_inputs(ctx):\n+        \"\"\"Helper function to construct the script input for t33/t34 below.\"\"\"\n+        # Instead of signing 999 times, precompute signatures for every (key, hashtype) combination\n+        sigs = {}\n+        for ht in VALID_SIGHASHES_TAPROOT:\n+            for k in range(len(pubs)):\n+                sigs[(k, ht)] = override(default_sign, hashtype=ht, key=secs[k])(ctx)\n+        num = get(ctx, \"num\")\n+        return [sigs[(big_choices[i], random.choice(VALID_SIGHASHES_TAPROOT))] for i in range(num - 1, -1, -1)]\n+\n+    # Various BIP342 features\n+    scripts = [\n+        # 0) drop stack element and OP_CHECKSIG\n+        (\"t0\", CScript([OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 1) normal OP_CHECKSIG\n+        (\"t1\", CScript([pubs[1], OP_CHECKSIG])),\n+        # 2) normal OP_CHECKSIGVERIFY\n+        (\"t2\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1])),\n+        # 3) Hypothetical OP_CHECKMULTISIG script that takes a single sig as input\n+        (\"t3\", CScript([OP_0, OP_SWAP, OP_1, pubs[1], OP_1, OP_CHECKMULTISIG])),\n+        # 4) Hypothetical OP_CHECKMULTISIGVERIFY script that takes a single sig as input\n+        (\"t4\", CScript([OP_0, OP_SWAP, OP_1, pubs[1], OP_1, OP_CHECKMULTISIGVERIFY, OP_1])),\n+        # 5) OP_IF script that needs a true input\n+        (\"t5\", CScript([OP_IF, pubs[1], OP_CHECKSIG, OP_ELSE, OP_RETURN, OP_ENDIF])),\n+        # 6) OP_NOTIF script that needs a true input\n+        (\"t6\", CScript([OP_NOTIF, OP_RETURN, OP_ELSE, pubs[1], OP_CHECKSIG, OP_ENDIF])),\n+        # 7) OP_CHECKSIG with an empty key\n+        (\"t7\", CScript([OP_0, OP_CHECKSIG])),\n+        # 8) OP_CHECKSIGVERIFY with an empty key\n+        (\"t8\", CScript([OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 9) normal OP_CHECKSIGADD that also ensures return value is correct\n+        (\"t9\", CScript([csa_low_val, pubs[1], OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 10) OP_CHECKSIGADD with empty key\n+        (\"t10\", CScript([csa_low_val, OP_0, OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 11) OP_CHECKSIGADD with missing counter stack element\n+        (\"t11\", CScript([pubs[1], OP_CHECKSIGADD, OP_1, OP_EQUAL])),\n+        # 12) OP_CHECKSIG that needs invalid signature\n+        (\"t12\", CScript([pubs[1], OP_CHECKSIGVERIFY, pubs[0], OP_CHECKSIG, OP_NOT])),\n+        # 13) OP_CHECKSIG with empty key that needs invalid signature\n+        (\"t13\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_CHECKSIG, OP_NOT])),\n+        # 14) OP_CHECKSIGADD that needs invalid signature\n+        (\"t14\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, pubs[0], OP_CHECKSIGADD, OP_NOT])),\n+        # 15) OP_CHECKSIGADD with empty key that needs invalid signature\n+        (\"t15\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGADD, OP_NOT])),\n+        # 16) OP_CHECKSIG with unknown pubkey type\n+        (\"t16\", CScript([OP_1, OP_CHECKSIG])),\n+        # 17) OP_CHECKSIGADD with unknown pubkey type\n+        (\"t17\", CScript([OP_0, OP_1, OP_CHECKSIGADD])),\n+        # 18) OP_CHECKSIGVERIFY with unknown pubkey type\n+        (\"t18\", CScript([OP_1, OP_CHECKSIGVERIFY, OP_1])),\n+        # 19) script longer than 10000 bytes and over 201 non-push opcodes\n+        (\"t19\", CScript([OP_0, OP_0, OP_2DROP] * 10001 + [pubs[1], OP_CHECKSIG])),\n+        # 20) OP_CHECKSIGVERIFY with empty key\n+        (\"t20\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 21) Script that grows the stack to 1000 elements\n+        (\"t21\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 999 + [OP_DROP] * 999)),\n+        # 22) Script that grows the stack to 1001 elements\n+        (\"t22\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 1000 + [OP_DROP] * 1000)),\n+        # 23) Script that expects an input stack of 1000 elements\n+        (\"t23\", CScript([OP_DROP] * 999 + [pubs[1], OP_CHECKSIG])),\n+        # 24) Script that expects an input stack of 1001 elements\n+        (\"t24\", CScript([OP_DROP] * 1000 + [pubs[1], OP_CHECKSIG])),\n+        # 25) Script that pushes a MAX_SCRIPT_ELEMENT_SIZE-bytes element\n+        (\"t25\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE), OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 26) Script that pushes a (MAX_SCRIPT_ELEMENT_SIZE+1)-bytes element\n+        (\"t26\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 27) CHECKSIGADD that must fail because numeric argument number is >4 bytes\n+        (\"t27\", CScript([CScriptNum(OVERSIZE_NUMBER), pubs[1], OP_CHECKSIGADD])),\n+        # 28) Pushes random CScriptNum value, checks OP_CHECKSIGADD result\n+        (\"t28\", CScript([csa_high_val, pubs[1], OP_CHECKSIGADD, csa_high_result, OP_EQUAL])),\n+        # 29) CHECKSIGADD that succeeds with proper sig because numeric argument number is <=4 bytes\n+        (\"t29\", CScript([CScriptNum(OVERSIZE_NUMBER-1), pubs[1], OP_CHECKSIGADD])),\n+        # 30) Variant of t1 with \"normal\" 33-byte pubkey\n+        (\"t30\", CScript([b'\\x03' + pubs[1], OP_CHECKSIG])),\n+        # 31) Variant of t2 with \"normal\" 33-byte pubkey\n+        (\"t31\", CScript([b'\\x02' + pubs[1], OP_CHECKSIGVERIFY, OP_1])),\n+        # 32) Variant of t28 with \"normal\" 33-byte pubkey\n+        (\"t32\", CScript([csa_high_val, b'\\x03' + pubs[1], OP_CHECKSIGADD, csa_high_result, OP_EQUAL])),\n+        # 33) 999-of-999 multisig\n+        (\"t33\", CScript(big_scriptops[:1998] + [OP_1])),\n+        # 34) 1000-of-1000 multisig\n+        (\"t34\", CScript(big_scriptops[:2000] + [OP_1])),\n+        # 35) Variant of t9 that uses a non-minimally encoded input arg\n+        (\"t35\", CScript([bytes([csa_low_val]), pubs[1], OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 36) Empty script\n+        (\"t36\", CScript([])),\n+    ]\n+    # Add many dummies to test huge trees\n+    for j in range(100000):\n+        scripts.append((None, CScript([OP_RETURN, random.randrange(100000)])))\n+    random.shuffle(scripts)\n+    tap = taproot_construct(pubs[0], scripts)\n+    common = {\n+        \"hashtype\": hashtype,\n+        \"key\": secs[1],\n+        \"tap\": tap,\n+    }\n+    # Test that MAX_SCRIPT_ELEMENT_SIZE byte stack element inputs are valid, but not one more (and 80 bytes is standard but 81 is not).\n+    add_spender(spenders, \"tapscript/inputmaxlimit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE)], failure={\"inputs\": [getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1)]}, **ERR_PUSH_LIMIT)\n+    add_spender(spenders, \"tapscript/input80limit\", leaf=\"t0\", **common, inputs=[getter(\"sign\"), random_bytes(80)])\n+    add_spender(spenders, \"tapscript/input81limit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(81)])\n+    # Test that OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY cause failure, but OP_CHECKSIG and OP_CHECKSIGVERIFY work.\n+    add_spender(spenders, \"tapscript/disabled_checkmultisig\", leaf=\"t1\", **common, **SINGLE_SIG, failure={\"leaf\": \"t3\"}, **ERR_TAPSCRIPT_CHECKMULTISIG)\n+    add_spender(spenders, \"tapscript/disabled_checkmultisigverify\", leaf=\"t2\", **common, **SINGLE_SIG, failure={\"leaf\": \"t4\"}, **ERR_TAPSCRIPT_CHECKMULTISIG)\n+    # Test that OP_IF and OP_NOTIF do not accept non-0x01 as truth value (the MINIMALIF rule is consensus in Tapscript)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x02']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x03']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0001']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0100']}, **ERR_MINIMALIF)\n+    # Test that 1-byte public keys (which are unknown) are acceptable but nonstandard with unrelated signatures, but 0-byte public keys are not valid.\n+    add_spender(spenders, \"tapscript/unkpk/checksig\", leaf=\"t16\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigadd\", leaf=\"t17\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigverify\", leaf=\"t18\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that 33-byte public keys (which are unknown) are acceptable but nonstandard with valid signatures, but normal pubkeys are not valid in that case.\n+    add_spender(spenders, \"tapscript/oldpk/checksig\", leaf=\"t30\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t1\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"tapscript/oldpk/checksigadd\", leaf=\"t31\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t2\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"tapscript/oldpk/checksigverify\", leaf=\"t32\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t28\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    # Test that 0-byte public keys are not acceptable.\n+    add_spender(spenders, \"tapscript/emptypk/checksig\", leaf=\"t1\", **SINGLE_SIG, **common, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigverify\", leaf=\"t2\", **SINGLE_SIG, **common, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigadd\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigadd\", leaf=\"t35\", standard=False, **SINGLE_SIG, **common, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that OP_CHECKSIGADD results are as expected\n+    add_spender(spenders, \"tapscript/checksigaddresults\", leaf=\"t28\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    add_spender(spenders, \"tapscript/checksigaddoversize\", leaf=\"t29\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    # Test that OP_CHECKSIGADD requires 3 stack elements.\n+    add_spender(spenders, \"tapscript/checksigadd3args\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t11\"}, **ERR_STACK_EMPTY)\n+    # Test that empty signatures do not cause script failure in OP_CHECKSIG and OP_CHECKSIGADD (but do fail with empty pubkey, and do fail OP_CHECKSIGVERIFY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksig\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t13\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/nochecksigverify\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t20\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksigadd\", leaf=\"t14\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t15\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that scripts over 10000 bytes (and over 201 non-push ops) are acceptable.\n+    add_spender(spenders, \"tapscript/no10000limit\", leaf=\"t19\", **SINGLE_SIG, **common)\n+    # Test that a stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000stack\", leaf=\"t21\", **SINGLE_SIG, **common, failure={\"leaf\": \"t22\"}, **ERR_STACK_SIZE)\n+    # Test that an input stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000inputs\", leaf=\"t23\", **common, inputs=[getter(\"sign\")] + [b'' for _ in range(999)], failure={\"leaf\": \"t24\", \"inputs\": [getter(\"sign\")] + [b'' for _ in range(1000)]}, **ERR_STACK_SIZE)\n+    # Test that pushing a MAX_SCRIPT_ELEMENT_SIZE byte stack element is valid, but one longer is not.\n+    add_spender(spenders, \"tapscript/pushmaxlimit\", leaf=\"t25\", **common, **SINGLE_SIG, failure={\"leaf\": \"t26\"}, **ERR_PUSH_LIMIT)\n+    # Test that 999-of-999 multisig works (but 1000-of-1000 triggers stack size limits)\n+    add_spender(spenders, \"tapscript/bigmulti\", leaf=\"t33\", **common, inputs=big_spend_inputs, num=999, failure={\"leaf\": \"t34\", \"num\": 1000}, **ERR_STACK_SIZE)\n+    # Test that the CLEANSTACK rule is consensus critical in tapscript\n+    add_spender(spenders, \"tapscript/cleanstack\", leaf=\"t36\", tap=tap, inputs=[b'\\x01'], failure={\"inputs\": [b'\\x01', b'\\x01']}, **ERR_CLEANSTACK)\n+\n+    # == Test for sigops ratio limit ==\n+\n+    # Given a number n, and a public key pk, functions that produce a (CScript, sigops). Each script takes as\n+    # input a valid signature with the passed pk followed by a dummy push of bytes that are to be dropped, and\n+    # will execute sigops signature checks.\n+    SIGOPS_RATIO_SCRIPTS = [\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIG.\n+        lambda n, pk: (CScript([OP_DROP, pk] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGVERIFY.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_0, OP_IF, OP_2DUP, OP_CHECKSIGVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_2, OP_SWAP, OP_CHECKSIGADD, OP_3, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIG.\n+        lambda n, pk: (CScript([random_bytes(220), OP_2DROP, pk, OP_1, OP_NOTIF, OP_2DUP, OP_CHECKSIG, OP_VERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_4, OP_SWAP, OP_CHECKSIGADD, OP_5, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGADD.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_1, OP_IF, OP_ELSE, OP_2DUP, OP_6, OP_SWAP, OP_CHECKSIGADD, OP_7, OP_EQUALVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_8, OP_SWAP, OP_CHECKSIGADD, OP_9, OP_EQUAL]), n + 1),\n+        # n+1 OP_CHECKSIGs, but also one OP_CHECKSIG with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, pk, OP_CHECKSIG, OP_NOT, OP_VERIFY, pk] + [OP_2DUP, OP_CHECKSIG, OP_VERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGADDs and 1 OP_CHECKSIG, but also an OP_CHECKSIGADD with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, OP_10, pk, OP_CHECKSIGADD, OP_10, OP_EQUALVERIFY, pk] + [OP_2DUP, OP_16, OP_SWAP, OP_CHECKSIGADD, b'\\x11', OP_EQUALVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+    ]\n+    for annex in [None, bytes([ANNEX_TAG]) + random_bytes(random.randrange(1000))]:\n+        for hashtype in [SIGHASH_DEFAULT, SIGHASH_ALL]:\n+            for pubkey in [pubs[1], random_bytes(random.choice([x for x in range(2, 81) if x != 32]))]:\n+                for fn_num, fn in enumerate(SIGOPS_RATIO_SCRIPTS):\n+                    merkledepth = random.randrange(129)\n+\n+\n+                    def predict_sigops_ratio(n, dummy_size):\n+                        \"\"\"Predict whether spending fn(n, pubkey) with dummy_size will pass the ratio test.\"\"\"\n+                        script, sigops = fn(n, pubkey)\n+                        # Predict the size of the witness for a given choice of n\n+                        stacklen_size = 1\n+                        sig_size = 64 + (hashtype != SIGHASH_DEFAULT)\n+                        siglen_size = 1\n+                        dummylen_size = 1 + 2 * (dummy_size >= 253)\n+                        script_size = len(script)\n+                        scriptlen_size = 1 + 2 * (script_size >= 253)\n+                        control_size = 33 + 32 * merkledepth\n+                        controllen_size = 1 + 2 * (control_size >= 253)\n+                        annex_size = 0 if annex is None else len(annex)\n+                        annexlen_size = 0 if annex is None else 1 + 2 * (annex_size >= 253)\n+                        witsize = stacklen_size + sig_size + siglen_size + dummy_size + dummylen_size + script_size + scriptlen_size + control_size + controllen_size + annex_size + annexlen_size\n+                        # sigops ratio test\n+                        return witsize + 50 >= 50 * sigops\n+                    # Make sure n is high enough that with empty dummy, the script is not valid\n+                    n = 0\n+                    while predict_sigops_ratio(n, 0):\n+                        n += 1\n+                    # But allow picking a bit higher still\n+                    n += random.randrange(5)\n+                    # Now pick dummy size *just* large enough that the overall construction passes\n+                    dummylen = 0\n+                    while not predict_sigops_ratio(n, dummylen):\n+                        dummylen += 1\n+                    scripts = [(\"s\", fn(n, pubkey)[0])]\n+                    for _ in range(merkledepth):\n+                        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+                    tap = taproot_construct(pubs[0], scripts)\n+                    standard = annex is None and dummylen <= 80 and len(pubkey) == 32\n+                    add_spender(spenders, \"tapscript/sigopsratio_%i\" % fn_num, tap=tap, leaf=\"s\", annex=annex, hashtype=hashtype, key=secs[1], inputs=[getter(\"sign\"), random_bytes(dummylen)], standard=standard, failure={\"inputs\": [getter(\"sign\"), random_bytes(dummylen - 1)]}, **ERR_SIGOPS_RATIO)\n+\n+    # Future leaf versions\n+    for leafver in range(0, 0x100, 2):\n+        if leafver == LEAF_VERSION_TAPSCRIPT or leafver == ANNEX_TAG:\n+            # Skip the defined LEAF_VERSION_TAPSCRIPT, and the ANNEX_TAG which is not usable as leaf version\n+            continue\n+        scripts = [\n+            (\"bare_c0\", CScript([OP_NOP])),\n+            (\"bare_unkver\", CScript([OP_NOP]), leafver),\n+            (\"return_c0\", CScript([OP_RETURN])),\n+            (\"return_unkver\", CScript([OP_RETURN]), leafver),\n+            (\"undecodable_c0\", CScript([OP_PUSHDATA1])),\n+            (\"undecodable_unkver\", CScript([OP_PUSHDATA1]), leafver),\n+            (\"bigpush_c0\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP])),\n+            (\"bigpush_unkver\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP]), leafver),\n+            (\"1001push_c0\", CScript([OP_0] * 1001)),\n+            (\"1001push_unkver\", CScript([OP_0] * 1001), leafver),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"unkver/bare\", standard=False, tap=tap, leaf=\"bare_unkver\", failure={\"leaf\": \"bare_c0\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"unkver/return\", standard=False, tap=tap, leaf=\"return_unkver\", failure={\"leaf\": \"return_c0\"}, **ERR_OP_RETURN)\n+        add_spender(spenders, \"unkver/undecodable\", standard=False, tap=tap, leaf=\"undecodable_unkver\", failure={\"leaf\": \"undecodable_c0\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"unkver/bigpush\", standard=False, tap=tap, leaf=\"bigpush_unkver\", failure={\"leaf\": \"bigpush_c0\"}, **ERR_PUSH_LIMIT)\n+        add_spender(spenders, \"unkver/1001push\", standard=False, tap=tap, leaf=\"1001push_unkver\", failure={\"leaf\": \"1001push_c0\"}, **ERR_STACK_SIZE)\n+        add_spender(spenders, \"unkver/1001inputs\", standard=False, tap=tap, leaf=\"bare_unkver\", inputs=[b'']*1001, failure={\"leaf\": \"bare_c0\"}, **ERR_STACK_SIZE)\n+\n+    # OP_SUCCESSx tests.\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for opval in range(76, 0x100):\n+        opcode = CScriptOp(opval)\n+        if not is_op_success(opcode):\n+            continue\n+        scripts = [\n+            (\"bare_success\", CScript([opcode])),\n+            (\"bare_nop\", CScript([OP_NOP])),\n+            (\"unexecif_success\", CScript([OP_0, OP_IF, opcode, OP_ENDIF])),\n+            (\"unexecif_nop\", CScript([OP_0, OP_IF, OP_NOP, OP_ENDIF])),\n+            (\"return_success\", CScript([OP_RETURN, opcode])),\n+            (\"return_nop\", CScript([OP_RETURN, OP_NOP])),\n+            (\"undecodable_success\", CScript([opcode, OP_PUSHDATA1])),\n+            (\"undecodable_nop\", CScript([OP_NOP, OP_PUSHDATA1])),\n+            (\"undecodable_bypassed_success\", CScript([OP_PUSHDATA1, OP_2, opcode])),\n+            (\"bigpush_success\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, opcode])),\n+            (\"bigpush_nop\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, OP_NOP])),\n+            (\"1001push_success\", CScript([OP_0] * 1001 + [opcode])),\n+            (\"1001push_nop\", CScript([OP_0] * 1001 + [OP_NOP])),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"opsuccess/bare\", standard=False, tap=tap, leaf=\"bare_success\", failure={\"leaf\": \"bare_nop\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"opsuccess/exexecif\", standard=False, tap=tap, leaf=\"unexecif_success\", failure={\"leaf\": \"unexecif_nop\"}, **ERR_CLEANSTACK)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503157211",
      "id" : 503157211,
      "in_reply_to_id" : 502969975,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE1NzIxMQ==",
      "original_commit_id" : "58c90569f75221bc4652cbde5cad4dbae543a1ca",
      "original_line" : 1069,
      "original_position" : 1069,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 506443312,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503157211",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503157327"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503157327"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nice, done.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-12T09:20:41Z",
      "diff_hunk" : "@@ -0,0 +1,1403 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expression for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        return tweak_add_privkey(key, tweak)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    scriptsig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    witness_stack = flatten(get(ctx, \"witness\"))\n+    return (scriptsig, witness_stack)\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda returning (scriptsig, witness_stack), taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+# - Whether this test demands being placed in a txin with no corresponding txout (for testing SIGHASH_SINGLE behavior)\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail,need_vin_vout_mismatch\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, need_vin_vout_mismatch=False, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert tap is None\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert script is None\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert script is None\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert script is None\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            return spend(tx, idx, utxos, **conf)\n+        else:\n+            assert failure is not None\n+            return spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None, need_vin_vout_mismatch=need_vin_vout_mismatch)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    return bytes(CScript([pubkey, OP_CHECKSIG]))\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+def zero_appender(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a zero added.\"\"\"\n+    return lambda ctx: deep_eval(ctx, expr) + b\"\\x00\"\n+\n+def byte_popper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with its last byte removed.\"\"\"\n+    return lambda ctx: deep_eval(ctx, expr)[:-1]\n+\n+# Expected error strings\n+\n+ERR_KEYPATH_INVALID_SIG = {\"err_msg\": \"Invalid signature for Taproot key path spending\"}\n+ERR_SCRIPTPATH_INVALID_SIG = {\"err_msg\": \"Signature must be zero for failed CHECK(MULTI)SIG operation\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_TAPSCRIPT_CHECKMULTISIG = {\"err_msg\": \"OP_CHECKMULTISIG(VERIFY) is not available in tapscript\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal in tapscript\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Stack size must be exactly one after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+ERR_CHECKSIGVERIFY = {\"err_msg\": \"Script failed an OP_CHECKSIGVERIFY operation\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+VALID_SIGHASHES_TAPROOT_SINGLE = [\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT_NO_SINGLE = [h for h in VALID_SIGHASHES_TAPROOT if h not in VALID_SIGHASHES_TAPROOT_SINGLE]\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SIG_POP_BYTE = {\"failure\": {\"sign\": byte_popper(default_sign)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+SIG_ADD_ZERO = {\"failure\": {\"sign\": zero_appender(default_sign)}}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 50000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    secs = [generate_privkey() for _ in range(8)]\n+    pubs = [compute_xonly_pubkey(sec)[0] for sec in secs]\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    tap = taproot_construct(pubs[0])\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=secs[0], failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=secs[0], failure={\"sighash\": bitflipper(default_sighash)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=secs[0], failure={\"flag_flip_r\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=secs[0], failure={\"flag_flip_p\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=secs[0], failure={\"signature\": bitflipper(default_signature)}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pubs[0])\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pubs[1])))]\n+            tap = taproot_construct(pubs[0], scripts)\n+            add_spender(spenders, \"sighash/keypath_hashtype_%x\" % hashtype, tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath_hashtype_%x\" % hashtype, tap=tap, leaf=\"s0\", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+            # Test SIGHASH_SINGLE behavior in combination with mismatching outputs\n+            if hashtype in VALID_SIGHASHES_TAPROOT_SINGLE:\n+                add_spender(spenders, \"sighash/keypath_hashtype_mis_%x\" % hashtype, tap=tap, key=secs[0], annex=annex, standard=no_annex, hashtype_actual=random.choice(VALID_SIGHASHES_TAPROOT_NO_SINGLE), failure={\"hashtype_actual\": hashtype}, **ERR_KEYPATH_INVALID_SIG, need_vin_vout_mismatch=True)\n+                add_spender(spenders, \"sighash/scriptpath_hashtype_mis_%x\" % hashtype, tap=tap, leaf=\"s0\", key=secs[1], annex=annex, standard=no_annex, hashtype_actual=random.choice(VALID_SIGHASHES_TAPROOT_NO_SINGLE), **SINGLE_SIG, failure={\"hashtype_actual\": hashtype}, **ERR_SCRIPTPATH_INVALID_SIG, need_vin_vout_mismatch=True)\n+\n+        # Test OP_CODESEPARATOR impact on sighashing.\n+        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+        common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+        scripts = [\n+            (\"pk_codesep\", CScript(random_checksig_style(pubs[1]) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig\n+            (\"codesep_pk\", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pubs[1]))),  # codesep before checksig\n+            (\"branched_codesep\", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pubs[0], OP_ELSE, OP_CODESEPARATOR, pubs[1], OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"sighash/pk_codesep\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/codesep_pk\", tap=tap, leaf=\"codesep_pk\", key=secs[1], codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/left\", tap=tap, leaf=\"branched_codesep\", key=secs[0], codeseppos=3, **common, inputs=[getter(\"sign\"), b'\\x01'], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/right\", tap=tap, leaf=\"branched_codesep\", key=secs[1], codeseppos=6, **common, inputs=[getter(\"sign\"), b''], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Reusing the scripts above, test that various features affect the sighash.\n+    add_spender(spenders, \"sighash/annex\", tap=tap, leaf=\"pk_codesep\", key=secs[1], hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={\"sighash\": override(default_sighash, annex=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/script\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, script_taproot=tap.leaves[\"codesep_pk\"].script)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/leafver\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leafversion=random.choice([x & 0xFE for x in range(0x100) if x & 0xFE != 0xC0]))}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leaf=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/keypath\", tap=tap, key=secs[0], **common, failure={\"sighash\": override(default_sighash, leaf=\"pk_codesep\")}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # Test that invalid hashtypes don't work, both in key path and script path spends\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for invalid_hashtype in [x for x in range(0x100) if x not in VALID_SIGHASHES_TAPROOT]:\n+        add_spender(spenders, \"sighash/keypath_unk_hashtype_%x\" % invalid_hashtype, tap=tap, key=secs[0], hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_KEYPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/scriptpath_unk_hashtype_%x\" % invalid_hashtype, tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Test that hashtype 0 cannot have a hashtype byte, and 1 must have one.\n+    add_spender(spenders, \"sighash/hashtype0_byte_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    # Test that hashtype 0 and hashtype 1 cannot be transmuted into each other.\n+    add_spender(spenders, \"sighash/hashtype0to1_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0to1_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Test aspects of signatures with unusual lengths\n+    for hashtype in [SIGHASH_DEFAULT, random.choice(VALID_SIGHASHES_TAPROOT)]:\n+        scripts = [\n+            (\"csv\", CScript([pubs[2], OP_CHECKSIGVERIFY, OP_1])),\n+            (\"cs_pos\", CScript([pubs[2], OP_CHECKSIG])),\n+            (\"csa_pos\", CScript([OP_0, pubs[2], OP_CHECKSIGADD, OP_1, OP_EQUAL])),\n+            (\"cs_neg\", CScript([pubs[2], OP_CHECKSIG, OP_NOT])),\n+            (\"csa_neg\", CScript([OP_2, pubs[2], OP_CHECKSIGADD, OP_2, OP_EQUAL]))\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[3], scripts)\n+        # Empty signatures\n+        add_spender(spenders, \"siglen/empty_keypath\", tap=tap, key=secs[3], hashtype=hashtype, failure={\"sign\": b\"\"}, **ERR_KEYPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/empty_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_CHECKSIGVERIFY)\n+        add_spender(spenders, \"siglen/empty_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_NO_SUCCESS)\n+        add_spender(spenders, \"siglen/empty_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_NO_SUCCESS)\n+        add_spender(spenders, \"siglen/empty_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": lambda _: random_bytes(random.randrange(1, 100))}, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/empty_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": lambda _: random_bytes(random.randrange(1, 100))}, **ERR_SCRIPTPATH_INVALID_SIG)\n+        # Appending a zero byte to signatures invalidates them\n+        add_spender(spenders, \"siglen/padzero_keypath\", tap=tap, key=secs[3], hashtype=hashtype, **SIG_ADD_ZERO, **ERR_KEYPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/padzero_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/padzero_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/padzero_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/padzero_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_ADD_ZERO, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/padzero_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_ADD_ZERO, **ERR_SCRIPTPATH_INVALID_SIG)\n+        # Removing the last byte from signatures invalidates them\n+        add_spender(spenders, \"siglen/popbyte_keypath\", tap=tap, key=secs[3], hashtype=hashtype, **SIG_POP_BYTE, **ERR_KEYPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/popbyte_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/popbyte_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/popbyte_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/popbyte_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_POP_BYTE, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/popbyte_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_POP_BYTE, **ERR_SCRIPTPATH_INVALID_SIG)\n+        # Verify that an invalid signature is not allowed, not even when the CHECKSIG* is expected to fail.\n+        add_spender(spenders, \"siglen/invalid_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": default_sign, \"sighash\": bitflipper(default_sighash)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/invalid_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": default_sign, \"sighash\": bitflipper(default_sighash)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # == Test that BIP341 spending only applies to witness version 1, program length 32, no P2SH ==\n+\n+    for p2sh in [False, True]:\n+        for witver in range(1, 17):\n+            for witlen in [20, 31, 32, 33]:\n+                def mutate(spk):\n+                    prog = spk[2:]\n+                    assert len(prog) == 32\n+                    if witlen < 32:\n+                        prog = prog[0:witlen]\n+                    elif witlen > 32:\n+                        prog += bytes([0 for _ in range(witlen - 32)])\n+                    return CScript([CScriptOp.encode_op_n(witver), prog])\n+                scripts = [(\"s0\", CScript([pubs[0], OP_CHECKSIG])), (\"dummy\", CScript([OP_RETURN]))]\n+                tap = taproot_construct(pubs[1], scripts)\n+                if not p2sh and witver == 1 and witlen == 32:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, failure={\"leaf\": \"dummy\"}, **ERR_OP_RETURN)\n+                else:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], standard=False)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, standard=False)\n+\n+    # == Test various aspects of BIP341 spending paths ==\n+\n+    # A set of functions that compute the hashing partner in a Merkle tree, designed to exercise\n+    # edge cases. This relies on the taproot_construct feature that a lambda can be passed in\n+    # instead of a subtree, to compute the partner to be hashed with.\n+    PARTNER_MERKLE_FN = [\n+        # Combine with itself\n+        lambda h: h,\n+        # Combine with hash 0\n+        lambda h: bytes([0 for _ in range(32)]),\n+        # Combine with hash 2^256-1\n+        lambda h: bytes([0xff for _ in range(32)]),\n+        # Combine with itself-1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') + 1).to_bytes(32, 'big'),\n+        # Combine with itself-1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') + 1).to_bytes(32, 'little'),\n+        # Combine with random bitflipped version of self.\n+        lambda h: (int.from_bytes(h, 'little') ^ (1 << random.randrange(256))).to_bytes(32, 'little')\n+    ]\n+    # Start with a tree of that has depth 1 for \"128deep\" and depth 2 for \"129deep\".\n+    scripts = [(\"128deep\", CScript([pubs[0], OP_CHECKSIG])), [(\"129deep\", CScript([pubs[0], OP_CHECKSIG])), random.choice(PARTNER_MERKLE_FN)]]\n+    # Add 127 nodes on top of that tree, so that \"128deep\" and \"129deep\" end up at their designated depths.\n+    for _ in range(127):\n+        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+    tap = taproot_construct(pubs[0], scripts)\n+    # Test that spends with a depth of 128 work, but 129 doesn't (even with a tree with weird Merkle branches in it).\n+    add_spender(spenders, \"spendpath/merklelimit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"leaf\": \"129deep\"}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that flipping the negation bit invalidates spends.\n+    add_spender(spenders, \"spendpath/negflag\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"negflag\": lambda ctx: 1 - default_negflag(ctx)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the Merkle branch invalidate it.\n+    add_spender(spenders, \"spendpath/bitflipmerkle\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"merklebranch\": bitflipper(default_merklebranch)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the inner pubkey invalidate it.\n+    add_spender(spenders, \"spendpath/bitflippubkey\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"pubkey_inner\": bitflipper(default_pubkey_inner)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that empty witnesses are invalid.\n+    add_spender(spenders, \"spendpath/emptywit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"witness\": []}, **ERR_EMPTY_WITNESS)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padlongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/trunclongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    scripts = [(\"s\", CScript([pubs[0], OP_CHECKSIG]))]\n+    tap = taproot_construct(pubs[1], scripts)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/truncshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block to 1 byte (\"-1 Merkle length\") invalidates it\n+    add_spender(spenders, \"spendpath/trunc1shortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:1]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    # == Test BIP342 edge cases ==\n+\n+    csa_low_val = random.randrange(0, 17) # Within range for OP_n\n+    csa_low_result = csa_low_val + 1\n+\n+    csa_high_val = random.randrange(17, 100) if random.getrandbits(1) else random.randrange(-100, -1) # Outside OP_n range\n+    csa_high_result = csa_high_val + 1\n+\n+    OVERSIZE_NUMBER = 2**31\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER))), 6)\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER-1))), 5)\n+\n+    big_choices = []\n+    big_scriptops = []\n+    for i in range(1000):\n+        r = random.randrange(len(pubs))\n+        big_choices.append(r)\n+        big_scriptops += [pubs[r], OP_CHECKSIGVERIFY]\n+\n+\n+    def big_spend_inputs(ctx):\n+        \"\"\"Helper function to construct the script input for t33/t34 below.\"\"\"\n+        # Instead of signing 999 times, precompute signatures for every (key, hashtype) combination\n+        sigs = {}\n+        for ht in VALID_SIGHASHES_TAPROOT:\n+            for k in range(len(pubs)):\n+                sigs[(k, ht)] = override(default_sign, hashtype=ht, key=secs[k])(ctx)\n+        num = get(ctx, \"num\")\n+        return [sigs[(big_choices[i], random.choice(VALID_SIGHASHES_TAPROOT))] for i in range(num - 1, -1, -1)]\n+\n+    # Various BIP342 features\n+    scripts = [\n+        # 0) drop stack element and OP_CHECKSIG\n+        (\"t0\", CScript([OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 1) normal OP_CHECKSIG\n+        (\"t1\", CScript([pubs[1], OP_CHECKSIG])),\n+        # 2) normal OP_CHECKSIGVERIFY\n+        (\"t2\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1])),\n+        # 3) Hypothetical OP_CHECKMULTISIG script that takes a single sig as input\n+        (\"t3\", CScript([OP_0, OP_SWAP, OP_1, pubs[1], OP_1, OP_CHECKMULTISIG])),\n+        # 4) Hypothetical OP_CHECKMULTISIGVERIFY script that takes a single sig as input\n+        (\"t4\", CScript([OP_0, OP_SWAP, OP_1, pubs[1], OP_1, OP_CHECKMULTISIGVERIFY, OP_1])),\n+        # 5) OP_IF script that needs a true input\n+        (\"t5\", CScript([OP_IF, pubs[1], OP_CHECKSIG, OP_ELSE, OP_RETURN, OP_ENDIF])),\n+        # 6) OP_NOTIF script that needs a true input\n+        (\"t6\", CScript([OP_NOTIF, OP_RETURN, OP_ELSE, pubs[1], OP_CHECKSIG, OP_ENDIF])),\n+        # 7) OP_CHECKSIG with an empty key\n+        (\"t7\", CScript([OP_0, OP_CHECKSIG])),\n+        # 8) OP_CHECKSIGVERIFY with an empty key\n+        (\"t8\", CScript([OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 9) normal OP_CHECKSIGADD that also ensures return value is correct\n+        (\"t9\", CScript([csa_low_val, pubs[1], OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 10) OP_CHECKSIGADD with empty key\n+        (\"t10\", CScript([csa_low_val, OP_0, OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 11) OP_CHECKSIGADD with missing counter stack element\n+        (\"t11\", CScript([pubs[1], OP_CHECKSIGADD, OP_1, OP_EQUAL])),\n+        # 12) OP_CHECKSIG that needs invalid signature\n+        (\"t12\", CScript([pubs[1], OP_CHECKSIGVERIFY, pubs[0], OP_CHECKSIG, OP_NOT])),\n+        # 13) OP_CHECKSIG with empty key that needs invalid signature\n+        (\"t13\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_CHECKSIG, OP_NOT])),\n+        # 14) OP_CHECKSIGADD that needs invalid signature\n+        (\"t14\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, pubs[0], OP_CHECKSIGADD, OP_NOT])),\n+        # 15) OP_CHECKSIGADD with empty key that needs invalid signature\n+        (\"t15\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGADD, OP_NOT])),\n+        # 16) OP_CHECKSIG with unknown pubkey type\n+        (\"t16\", CScript([OP_1, OP_CHECKSIG])),\n+        # 17) OP_CHECKSIGADD with unknown pubkey type\n+        (\"t17\", CScript([OP_0, OP_1, OP_CHECKSIGADD])),\n+        # 18) OP_CHECKSIGVERIFY with unknown pubkey type\n+        (\"t18\", CScript([OP_1, OP_CHECKSIGVERIFY, OP_1])),\n+        # 19) script longer than 10000 bytes and over 201 non-push opcodes\n+        (\"t19\", CScript([OP_0, OP_0, OP_2DROP] * 10001 + [pubs[1], OP_CHECKSIG])),\n+        # 20) OP_CHECKSIGVERIFY with empty key\n+        (\"t20\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 21) Script that grows the stack to 1000 elements\n+        (\"t21\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 999 + [OP_DROP] * 999)),\n+        # 22) Script that grows the stack to 1001 elements\n+        (\"t22\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 1000 + [OP_DROP] * 1000)),\n+        # 23) Script that expects an input stack of 1000 elements\n+        (\"t23\", CScript([OP_DROP] * 999 + [pubs[1], OP_CHECKSIG])),\n+        # 24) Script that expects an input stack of 1001 elements\n+        (\"t24\", CScript([OP_DROP] * 1000 + [pubs[1], OP_CHECKSIG])),\n+        # 25) Script that pushes a MAX_SCRIPT_ELEMENT_SIZE-bytes element\n+        (\"t25\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE), OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 26) Script that pushes a (MAX_SCRIPT_ELEMENT_SIZE+1)-bytes element\n+        (\"t26\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 27) CHECKSIGADD that must fail because numeric argument number is >4 bytes\n+        (\"t27\", CScript([CScriptNum(OVERSIZE_NUMBER), pubs[1], OP_CHECKSIGADD])),\n+        # 28) Pushes random CScriptNum value, checks OP_CHECKSIGADD result\n+        (\"t28\", CScript([csa_high_val, pubs[1], OP_CHECKSIGADD, csa_high_result, OP_EQUAL])),\n+        # 29) CHECKSIGADD that succeeds with proper sig because numeric argument number is <=4 bytes\n+        (\"t29\", CScript([CScriptNum(OVERSIZE_NUMBER-1), pubs[1], OP_CHECKSIGADD])),\n+        # 30) Variant of t1 with \"normal\" 33-byte pubkey\n+        (\"t30\", CScript([b'\\x03' + pubs[1], OP_CHECKSIG])),\n+        # 31) Variant of t2 with \"normal\" 33-byte pubkey\n+        (\"t31\", CScript([b'\\x02' + pubs[1], OP_CHECKSIGVERIFY, OP_1])),\n+        # 32) Variant of t28 with \"normal\" 33-byte pubkey\n+        (\"t32\", CScript([csa_high_val, b'\\x03' + pubs[1], OP_CHECKSIGADD, csa_high_result, OP_EQUAL])),\n+        # 33) 999-of-999 multisig\n+        (\"t33\", CScript(big_scriptops[:1998] + [OP_1])),\n+        # 34) 1000-of-1000 multisig\n+        (\"t34\", CScript(big_scriptops[:2000] + [OP_1])),\n+        # 35) Variant of t9 that uses a non-minimally encoded input arg\n+        (\"t35\", CScript([bytes([csa_low_val]), pubs[1], OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 36) Empty script\n+        (\"t36\", CScript([])),\n+    ]\n+    # Add many dummies to test huge trees\n+    for j in range(100000):\n+        scripts.append((None, CScript([OP_RETURN, random.randrange(100000)])))\n+    random.shuffle(scripts)\n+    tap = taproot_construct(pubs[0], scripts)\n+    common = {\n+        \"hashtype\": hashtype,\n+        \"key\": secs[1],\n+        \"tap\": tap,\n+    }\n+    # Test that MAX_SCRIPT_ELEMENT_SIZE byte stack element inputs are valid, but not one more (and 80 bytes is standard but 81 is not).\n+    add_spender(spenders, \"tapscript/inputmaxlimit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE)], failure={\"inputs\": [getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1)]}, **ERR_PUSH_LIMIT)\n+    add_spender(spenders, \"tapscript/input80limit\", leaf=\"t0\", **common, inputs=[getter(\"sign\"), random_bytes(80)])\n+    add_spender(spenders, \"tapscript/input81limit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(81)])\n+    # Test that OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY cause failure, but OP_CHECKSIG and OP_CHECKSIGVERIFY work.\n+    add_spender(spenders, \"tapscript/disabled_checkmultisig\", leaf=\"t1\", **common, **SINGLE_SIG, failure={\"leaf\": \"t3\"}, **ERR_TAPSCRIPT_CHECKMULTISIG)\n+    add_spender(spenders, \"tapscript/disabled_checkmultisigverify\", leaf=\"t2\", **common, **SINGLE_SIG, failure={\"leaf\": \"t4\"}, **ERR_TAPSCRIPT_CHECKMULTISIG)\n+    # Test that OP_IF and OP_NOTIF do not accept non-0x01 as truth value (the MINIMALIF rule is consensus in Tapscript)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x02']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x03']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0001']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0100']}, **ERR_MINIMALIF)\n+    # Test that 1-byte public keys (which are unknown) are acceptable but nonstandard with unrelated signatures, but 0-byte public keys are not valid.\n+    add_spender(spenders, \"tapscript/unkpk/checksig\", leaf=\"t16\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigadd\", leaf=\"t17\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigverify\", leaf=\"t18\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that 33-byte public keys (which are unknown) are acceptable but nonstandard with valid signatures, but normal pubkeys are not valid in that case.\n+    add_spender(spenders, \"tapscript/oldpk/checksig\", leaf=\"t30\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t1\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"tapscript/oldpk/checksigadd\", leaf=\"t31\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t2\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"tapscript/oldpk/checksigverify\", leaf=\"t32\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t28\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    # Test that 0-byte public keys are not acceptable.\n+    add_spender(spenders, \"tapscript/emptypk/checksig\", leaf=\"t1\", **SINGLE_SIG, **common, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigverify\", leaf=\"t2\", **SINGLE_SIG, **common, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigadd\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigadd\", leaf=\"t35\", standard=False, **SINGLE_SIG, **common, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that OP_CHECKSIGADD results are as expected\n+    add_spender(spenders, \"tapscript/checksigaddresults\", leaf=\"t28\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    add_spender(spenders, \"tapscript/checksigaddoversize\", leaf=\"t29\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    # Test that OP_CHECKSIGADD requires 3 stack elements.\n+    add_spender(spenders, \"tapscript/checksigadd3args\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t11\"}, **ERR_STACK_EMPTY)\n+    # Test that empty signatures do not cause script failure in OP_CHECKSIG and OP_CHECKSIGADD (but do fail with empty pubkey, and do fail OP_CHECKSIGVERIFY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksig\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t13\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/nochecksigverify\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t20\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksigadd\", leaf=\"t14\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t15\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that scripts over 10000 bytes (and over 201 non-push ops) are acceptable.\n+    add_spender(spenders, \"tapscript/no10000limit\", leaf=\"t19\", **SINGLE_SIG, **common)\n+    # Test that a stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000stack\", leaf=\"t21\", **SINGLE_SIG, **common, failure={\"leaf\": \"t22\"}, **ERR_STACK_SIZE)\n+    # Test that an input stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000inputs\", leaf=\"t23\", **common, inputs=[getter(\"sign\")] + [b'' for _ in range(999)], failure={\"leaf\": \"t24\", \"inputs\": [getter(\"sign\")] + [b'' for _ in range(1000)]}, **ERR_STACK_SIZE)\n+    # Test that pushing a MAX_SCRIPT_ELEMENT_SIZE byte stack element is valid, but one longer is not.\n+    add_spender(spenders, \"tapscript/pushmaxlimit\", leaf=\"t25\", **common, **SINGLE_SIG, failure={\"leaf\": \"t26\"}, **ERR_PUSH_LIMIT)\n+    # Test that 999-of-999 multisig works (but 1000-of-1000 triggers stack size limits)\n+    add_spender(spenders, \"tapscript/bigmulti\", leaf=\"t33\", **common, inputs=big_spend_inputs, num=999, failure={\"leaf\": \"t34\", \"num\": 1000}, **ERR_STACK_SIZE)\n+    # Test that the CLEANSTACK rule is consensus critical in tapscript\n+    add_spender(spenders, \"tapscript/cleanstack\", leaf=\"t36\", tap=tap, inputs=[b'\\x01'], failure={\"inputs\": [b'\\x01', b'\\x01']}, **ERR_CLEANSTACK)\n+\n+    # == Test for sigops ratio limit ==\n+\n+    # Given a number n, and a public key pk, functions that produce a (CScript, sigops). Each script takes as\n+    # input a valid signature with the passed pk followed by a dummy push of bytes that are to be dropped, and\n+    # will execute sigops signature checks.\n+    SIGOPS_RATIO_SCRIPTS = [\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIG.\n+        lambda n, pk: (CScript([OP_DROP, pk] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGVERIFY.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_0, OP_IF, OP_2DUP, OP_CHECKSIGVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_2, OP_SWAP, OP_CHECKSIGADD, OP_3, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIG.\n+        lambda n, pk: (CScript([random_bytes(220), OP_2DROP, pk, OP_1, OP_NOTIF, OP_2DUP, OP_CHECKSIG, OP_VERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_4, OP_SWAP, OP_CHECKSIGADD, OP_5, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGADD.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_1, OP_IF, OP_ELSE, OP_2DUP, OP_6, OP_SWAP, OP_CHECKSIGADD, OP_7, OP_EQUALVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_8, OP_SWAP, OP_CHECKSIGADD, OP_9, OP_EQUAL]), n + 1),\n+        # n+1 OP_CHECKSIGs, but also one OP_CHECKSIG with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, pk, OP_CHECKSIG, OP_NOT, OP_VERIFY, pk] + [OP_2DUP, OP_CHECKSIG, OP_VERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGADDs and 1 OP_CHECKSIG, but also an OP_CHECKSIGADD with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, OP_10, pk, OP_CHECKSIGADD, OP_10, OP_EQUALVERIFY, pk] + [OP_2DUP, OP_16, OP_SWAP, OP_CHECKSIGADD, b'\\x11', OP_EQUALVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+    ]\n+    for annex in [None, bytes([ANNEX_TAG]) + random_bytes(random.randrange(1000))]:\n+        for hashtype in [SIGHASH_DEFAULT, SIGHASH_ALL]:\n+            for pubkey in [pubs[1], random_bytes(random.choice([x for x in range(2, 81) if x != 32]))]:\n+                for fn_num, fn in enumerate(SIGOPS_RATIO_SCRIPTS):\n+                    merkledepth = random.randrange(129)\n+\n+\n+                    def predict_sigops_ratio(n, dummy_size):\n+                        \"\"\"Predict whether spending fn(n, pubkey) with dummy_size will pass the ratio test.\"\"\"\n+                        script, sigops = fn(n, pubkey)\n+                        # Predict the size of the witness for a given choice of n\n+                        stacklen_size = 1\n+                        sig_size = 64 + (hashtype != SIGHASH_DEFAULT)\n+                        siglen_size = 1\n+                        dummylen_size = 1 + 2 * (dummy_size >= 253)\n+                        script_size = len(script)\n+                        scriptlen_size = 1 + 2 * (script_size >= 253)\n+                        control_size = 33 + 32 * merkledepth\n+                        controllen_size = 1 + 2 * (control_size >= 253)\n+                        annex_size = 0 if annex is None else len(annex)\n+                        annexlen_size = 0 if annex is None else 1 + 2 * (annex_size >= 253)\n+                        witsize = stacklen_size + sig_size + siglen_size + dummy_size + dummylen_size + script_size + scriptlen_size + control_size + controllen_size + annex_size + annexlen_size\n+                        # sigops ratio test\n+                        return witsize + 50 >= 50 * sigops\n+                    # Make sure n is high enough that with empty dummy, the script is not valid\n+                    n = 0\n+                    while predict_sigops_ratio(n, 0):\n+                        n += 1\n+                    # But allow picking a bit higher still\n+                    n += random.randrange(5)\n+                    # Now pick dummy size *just* large enough that the overall construction passes\n+                    dummylen = 0\n+                    while not predict_sigops_ratio(n, dummylen):\n+                        dummylen += 1\n+                    scripts = [(\"s\", fn(n, pubkey)[0])]\n+                    for _ in range(merkledepth):\n+                        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+                    tap = taproot_construct(pubs[0], scripts)\n+                    standard = annex is None and dummylen <= 80 and len(pubkey) == 32\n+                    add_spender(spenders, \"tapscript/sigopsratio_%i\" % fn_num, tap=tap, leaf=\"s\", annex=annex, hashtype=hashtype, key=secs[1], inputs=[getter(\"sign\"), random_bytes(dummylen)], standard=standard, failure={\"inputs\": [getter(\"sign\"), random_bytes(dummylen - 1)]}, **ERR_SIGOPS_RATIO)\n+\n+    # Future leaf versions\n+    for leafver in range(0, 0x100, 2):\n+        if leafver == LEAF_VERSION_TAPSCRIPT or leafver == ANNEX_TAG:\n+            # Skip the defined LEAF_VERSION_TAPSCRIPT, and the ANNEX_TAG which is not usable as leaf version\n+            continue\n+        scripts = [\n+            (\"bare_c0\", CScript([OP_NOP])),\n+            (\"bare_unkver\", CScript([OP_NOP]), leafver),\n+            (\"return_c0\", CScript([OP_RETURN])),\n+            (\"return_unkver\", CScript([OP_RETURN]), leafver),\n+            (\"undecodable_c0\", CScript([OP_PUSHDATA1])),\n+            (\"undecodable_unkver\", CScript([OP_PUSHDATA1]), leafver),\n+            (\"bigpush_c0\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP])),\n+            (\"bigpush_unkver\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP]), leafver),\n+            (\"1001push_c0\", CScript([OP_0] * 1001)),\n+            (\"1001push_unkver\", CScript([OP_0] * 1001), leafver),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"unkver/bare\", standard=False, tap=tap, leaf=\"bare_unkver\", failure={\"leaf\": \"bare_c0\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"unkver/return\", standard=False, tap=tap, leaf=\"return_unkver\", failure={\"leaf\": \"return_c0\"}, **ERR_OP_RETURN)\n+        add_spender(spenders, \"unkver/undecodable\", standard=False, tap=tap, leaf=\"undecodable_unkver\", failure={\"leaf\": \"undecodable_c0\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"unkver/bigpush\", standard=False, tap=tap, leaf=\"bigpush_unkver\", failure={\"leaf\": \"bigpush_c0\"}, **ERR_PUSH_LIMIT)\n+        add_spender(spenders, \"unkver/1001push\", standard=False, tap=tap, leaf=\"1001push_unkver\", failure={\"leaf\": \"1001push_c0\"}, **ERR_STACK_SIZE)\n+        add_spender(spenders, \"unkver/1001inputs\", standard=False, tap=tap, leaf=\"bare_unkver\", inputs=[b'']*1001, failure={\"leaf\": \"bare_c0\"}, **ERR_STACK_SIZE)\n+\n+    # OP_SUCCESSx tests.\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for opval in range(76, 0x100):\n+        opcode = CScriptOp(opval)\n+        if not is_op_success(opcode):\n+            continue\n+        scripts = [\n+            (\"bare_success\", CScript([opcode])),\n+            (\"bare_nop\", CScript([OP_NOP])),\n+            (\"unexecif_success\", CScript([OP_0, OP_IF, opcode, OP_ENDIF])),\n+            (\"unexecif_nop\", CScript([OP_0, OP_IF, OP_NOP, OP_ENDIF])),\n+            (\"return_success\", CScript([OP_RETURN, opcode])),\n+            (\"return_nop\", CScript([OP_RETURN, OP_NOP])),\n+            (\"undecodable_success\", CScript([opcode, OP_PUSHDATA1])),\n+            (\"undecodable_nop\", CScript([OP_NOP, OP_PUSHDATA1])),\n+            (\"undecodable_bypassed_success\", CScript([OP_PUSHDATA1, OP_2, opcode])),\n+            (\"bigpush_success\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, opcode])),\n+            (\"bigpush_nop\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, OP_NOP])),\n+            (\"1001push_success\", CScript([OP_0] * 1001 + [opcode])),\n+            (\"1001push_nop\", CScript([OP_0] * 1001 + [OP_NOP])),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"opsuccess/bare\", standard=False, tap=tap, leaf=\"bare_success\", failure={\"leaf\": \"bare_nop\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"opsuccess/exexecif\", standard=False, tap=tap, leaf=\"unexecif_success\", failure={\"leaf\": \"unexecif_nop\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"opsuccess/return\", standard=False, tap=tap, leaf=\"return_success\", failure={\"leaf\": \"return_nop\"}, **ERR_OP_RETURN)\n+        add_spender(spenders, \"opsuccess/undecodable\", standard=False, tap=tap, leaf=\"undecodable_success\", failure={\"leaf\": \"undecodable_nop\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"opsuccess/undecodable_bypass\", standard=False, tap=tap, leaf=\"undecodable_success\", failure={\"leaf\": \"undecodable_bypassed_success\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"opsuccess/bigpush\", standard=False, tap=tap, leaf=\"bigpush_success\", failure={\"leaf\": \"bigpush_nop\"}, **ERR_PUSH_LIMIT)\n+        add_spender(spenders, \"opsuccess/1001push\", standard=False, tap=tap, leaf=\"1001push_success\", failure={\"leaf\": \"1001push_nop\"}, **ERR_STACK_SIZE)\n+        add_spender(spenders, \"opsuccess/1001inputs\", standard=False, tap=tap, leaf=\"bare_success\", inputs=[b'']*1001, failure={\"leaf\": \"bare_nop\"}, **ERR_STACK_SIZE)\n+\n+    # Non-OP_SUCCESSx (verify that those aren't accidentally treated as OP_SUCCESSx)\n+    for opval in range(0, 0x100):\n+        opcode = CScriptOp(opval)\n+        if is_op_success(opcode):\n+            continue\n+        scripts = [\n+            (\"normal\", CScript([OP_RETURN, opcode] + [OP_NOP] * 75)),\n+            (\"op_success\", CScript([OP_RETURN, CScriptOp(0x50)]))\n+        ]\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"alwaysvalid/notsuccessx\", tap=tap, leaf=\"op_success\", inputs=[], standard=False, failure={\"leaf\": \"normal\"}) # err_msg differs based on opcode\n+\n+    # == Legacy tests ==\n+\n+    # Also add a few legacy spends into the mix, so that transactions which combine taproot and pre-taproot spends get tested too.\n+    for compressed in [False, True]:\n+        eckey1 = ECKey()\n+        eckey1.set(generate_privkey(), compressed)\n+        pubkey1 = eckey1.get_pubkey().get_bytes()\n+        eckey2 = ECKey()\n+        eckey2.set(generate_privkey(), compressed)\n+        for p2sh in [False, True]:\n+            for witv0 in [False, True]:\n+                for hashtype in VALID_SIGHASHES_ECDSA + [random.randrange(0x04, 0x80), random.randrange(0x84, 0x100)]:\n+                    standard = (hashtype in VALID_SIGHASHES_ECDSA) and (compressed or not witv0)\n+                    add_spender(spenders, \"legacy/pk-wrongkey\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, script=CScript([pubkey1, OP_CHECKSIG]), **SINGLE_SIG, key=eckey1, failure={\"key\": eckey2}, sigops_weight=4-3*witv0, **ERR_NO_SUCCESS)\n+                    add_spender(spenders, \"legacy/pkh-sighashflip\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, pkh=pubkey1, key=eckey1, **SIGHASH_BITFLIP, sigops_weight=4-3*witv0, **ERR_NO_SUCCESS)\n+\n+    # Verify that OP_CHECKSIGADD wasn't accidentally added to pre-taproot validation logic.\n+    for p2sh in [False, True]:\n+        for witv0 in [False, True]:\n+            for hashtype in VALID_SIGHASHES_ECDSA + [random.randrange(0x04, 0x80), random.randrange(0x84, 0x100)]:\n+                standard = hashtype in VALID_SIGHASHES_ECDSA and (p2sh or witv0)\n+                add_spender(spenders, \"compat/nocsa\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, script=CScript([OP_IF, OP_11, pubkey1, OP_CHECKSIGADD, OP_12, OP_EQUAL, OP_ELSE, pubkey1, OP_CHECKSIG, OP_ENDIF]), key=eckey1, sigops_weight=4-3*witv0, inputs=[getter(\"sign\"), b''], failure={\"inputs\": [getter(\"sign\"), b'\\x01']}, **ERR_UNDECODABLE)\n+\n+    return spenders\n+\n+def spenders_taproot_inactive():\n+    \"\"\"Spenders for testing that pre-activation Taproot rules don't apply.\"\"\"\n+\n+    spenders = []\n+\n+    sec = generate_privkey()\n+    pub, _ = compute_xonly_pubkey(sec)\n+    scripts = [\n+        (\"pk\", CScript([pub, OP_CHECKSIG])),\n+        (\"future_leaf\", CScript([pub, OP_CHECKSIG]), 0xc2),\n+        (\"op_success\", CScript([pub, OP_CHECKSIG, OP_0, OP_IF, CScriptOp(0x50), OP_ENDIF])),\n+    ]\n+    tap = taproot_construct(pub, scripts)\n+\n+    # Test that keypath spending is valid & standard if compliant, but valid and nonstandard otherwise.\n+    add_spender(spenders, \"inactive/keypath_valid\", key=sec, tap=tap)\n+    add_spender(spenders, \"inactive/keypath_invalidsig\", key=sec, tap=tap, standard=False, sighash=bitflipper(default_sighash))\n+    add_spender(spenders, \"inactive/keypath_empty\", key=sec, tap=tap, standard=False, witness=[])\n+\n+    # Same for scriptpath spending (but using future features like annex, leaf versions, or OP_SUCCESS is nonstandard).\n+    add_spender(spenders, \"inactive/scriptpath_valid\", key=sec, tap=tap, leaf=\"pk\", inputs=[getter(\"sign\")])\n+    add_spender(spenders, \"inactive/scriptpath_invalidsig\", key=sec, tap=tap, leaf=\"pk\", standard=False, inputs=[getter(\"sign\")], sighash=bitflipper(default_sighash))\n+    add_spender(spenders, \"inactive/scriptpath_invalidcb\", key=sec, tap=tap, leaf=\"pk\", standard=False, inputs=[getter(\"sign\")], controlblock=bitflipper(default_controlblock))\n+    add_spender(spenders, \"inactive/scriptpath_valid_unkleaf\", key=sec, tap=tap, leaf=\"future_leaf\", standard=False, inputs=[getter(\"sign\")])\n+    add_spender(spenders, \"inactive/scriptpath_invalid_unkleaf\", key=sec, tap=tap, leaf=\"future_leaf\", standard=False, inputs=[getter(\"sign\")], sighash=bitflipper(default_sighash))\n+    add_spender(spenders, \"inactive/scriptpath_valid_opsuccess\", key=sec, tap=tap, leaf=\"op_success\", standard=False, inputs=[getter(\"sign\")])\n+    add_spender(spenders, \"inactive/scriptpath_valid_opsuccess\", key=sec, tap=tap, leaf=\"op_success\", standard=False, inputs=[getter(\"sign\")], sighash=bitflipper(default_sighash))\n+\n+    return spenders\n+\n+# Data type to keep track of UTXOs, where they were created, and how to spend them.\n+UTXOData = namedtuple('UTXOData', 'outpoint,output,spender')\n+\n+class TaprootTest(BitcoinTestFramework):\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.setup_clean_chain = True\n+        # Node 0 has Taproot inactive, Node 1 active.\n+        self.extra_args = [[\"-whitelist=127.0.0.1\", \"-par=1\", \"-vbparams=taproot:1:1\"], [\"-whitelist=127.0.0.1\", \"-par=1\"]]\n+\n+    def block_submit(self, node, txs, msg, err_msg, cb_pubkey=None, fees=0, sigops_weight=0, witness=False, accept=False):\n+\n+        # Deplete block of any non-tapscript sigops using a single additional 0-value coinbase output.\n+        # It is not impossible to fit enough tapscript sigops to hit the old 80k limit without\n+        # busting txin-level limits. We simply have to account for the p2pk outputs in all\n+        # transactions.\n+        extra_output_script = CScript([OP_CHECKSIG]*((MAX_BLOCK_SIGOPS_WEIGHT - sigops_weight) // WITNESS_SCALE_FACTOR))\n+\n+        block = create_block(self.tip, create_coinbase(self.lastblockheight + 1, pubkey=cb_pubkey, extra_output_script=extra_output_script, fees=fees), self.lastblocktime + 1)\n+        block.nVersion = 4\n+        for tx in txs:\n+            tx.rehash()\n+            block.vtx.append(tx)\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        witness and add_witness_commitment(block)\n+        block.rehash()\n+        block.solve()\n+        block_response = node.submitblock(block.serialize(True).hex())\n+        if err_msg is not None:\n+            assert block_response is not None and err_msg in block_response, \"Missing error message '%s' from block response '%s': %s\" % (err_msg, \"(None)\" if block_response is None else block_response, msg)\n+        if (accept):\n+            assert node.getbestblockhash() == block.hash, \"Failed to accept: %s (response: %s)\" % (msg, block_response)\n+            self.tip = block.sha256\n+            self.lastblockhash = block.hash\n+            self.lastblocktime += 1\n+            self.lastblockheight += 1\n+        else:\n+            assert node.getbestblockhash() == self.lastblockhash, \"Failed to reject: \" + msg\n+\n+    def test_spenders(self, node, spenders, input_counts):\n+        \"\"\"Run randomized tests with a number of \"spenders\".\n+\n+        Steps:\n+            1) Generate an appropriate UTXO for each spender to test spend conditions\n+            2) Generate 100 random addresses of all wallet types: pkh/sh_wpkh/wpkh\n+            3) Select random number of inputs from (1)\n+            4) Select random number of addresses from (2) as outputs\n+\n+        Each spender embodies a test; in a large randomized test, it is verified\n+        that toggling the valid argument to each lambda toggles the validity of\n+        the transaction. This is accomplished by constructing transactions consisting\n+        of all valid inputs, except one invalid one.\n+        \"\"\"\n+\n+        # Generate some coins to fund the wallet.\n+        node.generate(10)\n+\n+        # Construct a bunch of sPKs that send coins back to the host wallet\n+        self.log.info(\"- Constructing addresses for returning coins\")\n+        host_spks = []\n+        host_pubkeys = []\n+        for i in range(16):\n+            addr = node.getnewaddress(address_type=random.choice([\"legacy\", \"p2sh-segwit\", \"bech32\"]))\n+            info = node.getaddressinfo(addr)\n+            spk = bytes.fromhex(info['scriptPubKey'])\n+            host_spks.append(spk)\n+            host_pubkeys.append(bytes.fromhex(info['pubkey']))\n+\n+        # Initialize variables used by block_submit().\n+        self.lastblockhash = node.getbestblockhash()\n+        self.tip = int(self.lastblockhash, 16)\n+        block = node.getblock(self.lastblockhash)\n+        self.lastblockheight = block['height']\n+        self.lastblocktime = block['time']\n+\n+        # Create transactions spending up to 50 of the wallet's inputs, with one output for each spender, and\n+        # one change output at the end. The transaction is constructed on the Python side to enable\n+        # having multiple outputs to the same address and outputs with no assigned address. The wallet\n+        # is then asked to sign it through signrawtransactionwithwallet, and then added to a block on the\n+        # Python side (to bypass standardness rules).\n+        self.log.info(\"- Creating test UTXOs...\")\n+        random.shuffle(spenders)\n+        normal_utxos = []\n+        mismatching_utxos = [] # UTXOs with input that requires mismatching output position\n+        done = 0\n+        while done < len(spenders):\n+            # Compute how many UTXOs to create with this transaction\n+            count_this_tx = min(len(spenders) - done, (len(spenders) + 4) // 5, 10000)\n+\n+            fund_tx = CTransaction()\n+            # Add the 50 highest-value inputs\n+            unspents = node.listunspent()\n+            random.shuffle(unspents)\n+            unspents.sort(key=lambda x: -int(x[\"amount\"] * 100000000))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503157327",
      "id" : 503157327,
      "in_reply_to_id" : 502966921,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE1NzMyNw==",
      "original_commit_id" : "58c90569f75221bc4652cbde5cad4dbae543a1ca",
      "original_line" : 1241,
      "original_position" : 1241,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 506443466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503157327",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503157420"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503157420"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Indded, fixed.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-12T09:20:51Z",
      "diff_hunk" : "@@ -0,0 +1,1403 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expression for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        return tweak_add_privkey(key, tweak)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    scriptsig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    witness_stack = flatten(get(ctx, \"witness\"))\n+    return (scriptsig, witness_stack)\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda returning (scriptsig, witness_stack), taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+# - Whether this test demands being placed in a txin with no corresponding txout (for testing SIGHASH_SINGLE behavior)\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail,need_vin_vout_mismatch\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, need_vin_vout_mismatch=False, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert tap is None\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert script is None\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert script is None\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert script is None\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            return spend(tx, idx, utxos, **conf)\n+        else:\n+            assert failure is not None\n+            return spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None, need_vin_vout_mismatch=need_vin_vout_mismatch)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    return bytes(CScript([pubkey, OP_CHECKSIG]))\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+def zero_appender(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a zero added.\"\"\"\n+    return lambda ctx: deep_eval(ctx, expr) + b\"\\x00\"\n+\n+def byte_popper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with its last byte removed.\"\"\"\n+    return lambda ctx: deep_eval(ctx, expr)[:-1]\n+\n+# Expected error strings\n+\n+ERR_KEYPATH_INVALID_SIG = {\"err_msg\": \"Invalid signature for Taproot key path spending\"}\n+ERR_SCRIPTPATH_INVALID_SIG = {\"err_msg\": \"Signature must be zero for failed CHECK(MULTI)SIG operation\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_TAPSCRIPT_CHECKMULTISIG = {\"err_msg\": \"OP_CHECKMULTISIG(VERIFY) is not available in tapscript\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal in tapscript\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Stack size must be exactly one after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+ERR_CHECKSIGVERIFY = {\"err_msg\": \"Script failed an OP_CHECKSIGVERIFY operation\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+VALID_SIGHASHES_TAPROOT_SINGLE = [\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT_NO_SINGLE = [h for h in VALID_SIGHASHES_TAPROOT if h not in VALID_SIGHASHES_TAPROOT_SINGLE]\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SIG_POP_BYTE = {\"failure\": {\"sign\": byte_popper(default_sign)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+SIG_ADD_ZERO = {\"failure\": {\"sign\": zero_appender(default_sign)}}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 50000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    secs = [generate_privkey() for _ in range(8)]\n+    pubs = [compute_xonly_pubkey(sec)[0] for sec in secs]\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    tap = taproot_construct(pubs[0])\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=secs[0], failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=secs[0], failure={\"sighash\": bitflipper(default_sighash)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=secs[0], failure={\"flag_flip_r\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=secs[0], failure={\"flag_flip_p\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=secs[0], failure={\"signature\": bitflipper(default_signature)}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pubs[0])\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pubs[1])))]\n+            tap = taproot_construct(pubs[0], scripts)\n+            add_spender(spenders, \"sighash/keypath_hashtype_%x\" % hashtype, tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath_hashtype_%x\" % hashtype, tap=tap, leaf=\"s0\", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+            # Test SIGHASH_SINGLE behavior in combination with mismatching outputs\n+            if hashtype in VALID_SIGHASHES_TAPROOT_SINGLE:\n+                add_spender(spenders, \"sighash/keypath_hashtype_mis_%x\" % hashtype, tap=tap, key=secs[0], annex=annex, standard=no_annex, hashtype_actual=random.choice(VALID_SIGHASHES_TAPROOT_NO_SINGLE), failure={\"hashtype_actual\": hashtype}, **ERR_KEYPATH_INVALID_SIG, need_vin_vout_mismatch=True)\n+                add_spender(spenders, \"sighash/scriptpath_hashtype_mis_%x\" % hashtype, tap=tap, leaf=\"s0\", key=secs[1], annex=annex, standard=no_annex, hashtype_actual=random.choice(VALID_SIGHASHES_TAPROOT_NO_SINGLE), **SINGLE_SIG, failure={\"hashtype_actual\": hashtype}, **ERR_SCRIPTPATH_INVALID_SIG, need_vin_vout_mismatch=True)\n+\n+        # Test OP_CODESEPARATOR impact on sighashing.\n+        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+        common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+        scripts = [\n+            (\"pk_codesep\", CScript(random_checksig_style(pubs[1]) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig\n+            (\"codesep_pk\", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pubs[1]))),  # codesep before checksig\n+            (\"branched_codesep\", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pubs[0], OP_ELSE, OP_CODESEPARATOR, pubs[1], OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"sighash/pk_codesep\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/codesep_pk\", tap=tap, leaf=\"codesep_pk\", key=secs[1], codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/left\", tap=tap, leaf=\"branched_codesep\", key=secs[0], codeseppos=3, **common, inputs=[getter(\"sign\"), b'\\x01'], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/right\", tap=tap, leaf=\"branched_codesep\", key=secs[1], codeseppos=6, **common, inputs=[getter(\"sign\"), b''], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Reusing the scripts above, test that various features affect the sighash.\n+    add_spender(spenders, \"sighash/annex\", tap=tap, leaf=\"pk_codesep\", key=secs[1], hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={\"sighash\": override(default_sighash, annex=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/script\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, script_taproot=tap.leaves[\"codesep_pk\"].script)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/leafver\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leafversion=random.choice([x & 0xFE for x in range(0x100) if x & 0xFE != 0xC0]))}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leaf=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/keypath\", tap=tap, key=secs[0], **common, failure={\"sighash\": override(default_sighash, leaf=\"pk_codesep\")}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # Test that invalid hashtypes don't work, both in key path and script path spends\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for invalid_hashtype in [x for x in range(0x100) if x not in VALID_SIGHASHES_TAPROOT]:\n+        add_spender(spenders, \"sighash/keypath_unk_hashtype_%x\" % invalid_hashtype, tap=tap, key=secs[0], hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_KEYPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/scriptpath_unk_hashtype_%x\" % invalid_hashtype, tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Test that hashtype 0 cannot have a hashtype byte, and 1 must have one.\n+    add_spender(spenders, \"sighash/hashtype0_byte_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    # Test that hashtype 0 and hashtype 1 cannot be transmuted into each other.\n+    add_spender(spenders, \"sighash/hashtype0to1_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0to1_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Test aspects of signatures with unusual lengths\n+    for hashtype in [SIGHASH_DEFAULT, random.choice(VALID_SIGHASHES_TAPROOT)]:\n+        scripts = [\n+            (\"csv\", CScript([pubs[2], OP_CHECKSIGVERIFY, OP_1])),\n+            (\"cs_pos\", CScript([pubs[2], OP_CHECKSIG])),\n+            (\"csa_pos\", CScript([OP_0, pubs[2], OP_CHECKSIGADD, OP_1, OP_EQUAL])),\n+            (\"cs_neg\", CScript([pubs[2], OP_CHECKSIG, OP_NOT])),\n+            (\"csa_neg\", CScript([OP_2, pubs[2], OP_CHECKSIGADD, OP_2, OP_EQUAL]))\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[3], scripts)\n+        # Empty signatures\n+        add_spender(spenders, \"siglen/empty_keypath\", tap=tap, key=secs[3], hashtype=hashtype, failure={\"sign\": b\"\"}, **ERR_KEYPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/empty_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_CHECKSIGVERIFY)\n+        add_spender(spenders, \"siglen/empty_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_NO_SUCCESS)\n+        add_spender(spenders, \"siglen/empty_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_NO_SUCCESS)\n+        add_spender(spenders, \"siglen/empty_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": lambda _: random_bytes(random.randrange(1, 100))}, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/empty_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": lambda _: random_bytes(random.randrange(1, 100))}, **ERR_SCRIPTPATH_INVALID_SIG)\n+        # Appending a zero byte to signatures invalidates them\n+        add_spender(spenders, \"siglen/padzero_keypath\", tap=tap, key=secs[3], hashtype=hashtype, **SIG_ADD_ZERO, **ERR_KEYPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/padzero_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/padzero_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/padzero_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/padzero_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_ADD_ZERO, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/padzero_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_ADD_ZERO, **ERR_SCRIPTPATH_INVALID_SIG)\n+        # Removing the last byte from signatures invalidates them\n+        add_spender(spenders, \"siglen/popbyte_keypath\", tap=tap, key=secs[3], hashtype=hashtype, **SIG_POP_BYTE, **ERR_KEYPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/popbyte_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/popbyte_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/popbyte_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/popbyte_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_POP_BYTE, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/popbyte_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_POP_BYTE, **ERR_SCRIPTPATH_INVALID_SIG)\n+        # Verify that an invalid signature is not allowed, not even when the CHECKSIG* is expected to fail.\n+        add_spender(spenders, \"siglen/invalid_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": default_sign, \"sighash\": bitflipper(default_sighash)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"siglen/invalid_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": default_sign, \"sighash\": bitflipper(default_sighash)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # == Test that BIP341 spending only applies to witness version 1, program length 32, no P2SH ==\n+\n+    for p2sh in [False, True]:\n+        for witver in range(1, 17):\n+            for witlen in [20, 31, 32, 33]:\n+                def mutate(spk):\n+                    prog = spk[2:]\n+                    assert len(prog) == 32\n+                    if witlen < 32:\n+                        prog = prog[0:witlen]\n+                    elif witlen > 32:\n+                        prog += bytes([0 for _ in range(witlen - 32)])\n+                    return CScript([CScriptOp.encode_op_n(witver), prog])\n+                scripts = [(\"s0\", CScript([pubs[0], OP_CHECKSIG])), (\"dummy\", CScript([OP_RETURN]))]\n+                tap = taproot_construct(pubs[1], scripts)\n+                if not p2sh and witver == 1 and witlen == 32:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, failure={\"leaf\": \"dummy\"}, **ERR_OP_RETURN)\n+                else:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], standard=False)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, standard=False)\n+\n+    # == Test various aspects of BIP341 spending paths ==\n+\n+    # A set of functions that compute the hashing partner in a Merkle tree, designed to exercise\n+    # edge cases. This relies on the taproot_construct feature that a lambda can be passed in\n+    # instead of a subtree, to compute the partner to be hashed with.\n+    PARTNER_MERKLE_FN = [\n+        # Combine with itself\n+        lambda h: h,\n+        # Combine with hash 0\n+        lambda h: bytes([0 for _ in range(32)]),\n+        # Combine with hash 2^256-1\n+        lambda h: bytes([0xff for _ in range(32)]),\n+        # Combine with itself-1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') + 1).to_bytes(32, 'big'),\n+        # Combine with itself-1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') + 1).to_bytes(32, 'little'),\n+        # Combine with random bitflipped version of self.\n+        lambda h: (int.from_bytes(h, 'little') ^ (1 << random.randrange(256))).to_bytes(32, 'little')\n+    ]\n+    # Start with a tree of that has depth 1 for \"128deep\" and depth 2 for \"129deep\".\n+    scripts = [(\"128deep\", CScript([pubs[0], OP_CHECKSIG])), [(\"129deep\", CScript([pubs[0], OP_CHECKSIG])), random.choice(PARTNER_MERKLE_FN)]]\n+    # Add 127 nodes on top of that tree, so that \"128deep\" and \"129deep\" end up at their designated depths.\n+    for _ in range(127):\n+        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+    tap = taproot_construct(pubs[0], scripts)\n+    # Test that spends with a depth of 128 work, but 129 doesn't (even with a tree with weird Merkle branches in it).\n+    add_spender(spenders, \"spendpath/merklelimit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"leaf\": \"129deep\"}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that flipping the negation bit invalidates spends.\n+    add_spender(spenders, \"spendpath/negflag\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"negflag\": lambda ctx: 1 - default_negflag(ctx)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the Merkle branch invalidate it.\n+    add_spender(spenders, \"spendpath/bitflipmerkle\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"merklebranch\": bitflipper(default_merklebranch)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the inner pubkey invalidate it.\n+    add_spender(spenders, \"spendpath/bitflippubkey\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"pubkey_inner\": bitflipper(default_pubkey_inner)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that empty witnesses are invalid.\n+    add_spender(spenders, \"spendpath/emptywit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"witness\": []}, **ERR_EMPTY_WITNESS)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padlongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/trunclongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    scripts = [(\"s\", CScript([pubs[0], OP_CHECKSIG]))]\n+    tap = taproot_construct(pubs[1], scripts)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/truncshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block to 1 byte (\"-1 Merkle length\") invalidates it\n+    add_spender(spenders, \"spendpath/trunc1shortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:1]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    # == Test BIP342 edge cases ==\n+\n+    csa_low_val = random.randrange(0, 17) # Within range for OP_n\n+    csa_low_result = csa_low_val + 1\n+\n+    csa_high_val = random.randrange(17, 100) if random.getrandbits(1) else random.randrange(-100, -1) # Outside OP_n range\n+    csa_high_result = csa_high_val + 1\n+\n+    OVERSIZE_NUMBER = 2**31\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER))), 6)\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER-1))), 5)\n+\n+    big_choices = []\n+    big_scriptops = []\n+    for i in range(1000):\n+        r = random.randrange(len(pubs))\n+        big_choices.append(r)\n+        big_scriptops += [pubs[r], OP_CHECKSIGVERIFY]\n+\n+\n+    def big_spend_inputs(ctx):\n+        \"\"\"Helper function to construct the script input for t33/t34 below.\"\"\"\n+        # Instead of signing 999 times, precompute signatures for every (key, hashtype) combination\n+        sigs = {}\n+        for ht in VALID_SIGHASHES_TAPROOT:\n+            for k in range(len(pubs)):\n+                sigs[(k, ht)] = override(default_sign, hashtype=ht, key=secs[k])(ctx)\n+        num = get(ctx, \"num\")\n+        return [sigs[(big_choices[i], random.choice(VALID_SIGHASHES_TAPROOT))] for i in range(num - 1, -1, -1)]\n+\n+    # Various BIP342 features\n+    scripts = [\n+        # 0) drop stack element and OP_CHECKSIG\n+        (\"t0\", CScript([OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 1) normal OP_CHECKSIG\n+        (\"t1\", CScript([pubs[1], OP_CHECKSIG])),\n+        # 2) normal OP_CHECKSIGVERIFY\n+        (\"t2\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1])),\n+        # 3) Hypothetical OP_CHECKMULTISIG script that takes a single sig as input\n+        (\"t3\", CScript([OP_0, OP_SWAP, OP_1, pubs[1], OP_1, OP_CHECKMULTISIG])),\n+        # 4) Hypothetical OP_CHECKMULTISIGVERIFY script that takes a single sig as input\n+        (\"t4\", CScript([OP_0, OP_SWAP, OP_1, pubs[1], OP_1, OP_CHECKMULTISIGVERIFY, OP_1])),\n+        # 5) OP_IF script that needs a true input\n+        (\"t5\", CScript([OP_IF, pubs[1], OP_CHECKSIG, OP_ELSE, OP_RETURN, OP_ENDIF])),\n+        # 6) OP_NOTIF script that needs a true input\n+        (\"t6\", CScript([OP_NOTIF, OP_RETURN, OP_ELSE, pubs[1], OP_CHECKSIG, OP_ENDIF])),\n+        # 7) OP_CHECKSIG with an empty key\n+        (\"t7\", CScript([OP_0, OP_CHECKSIG])),\n+        # 8) OP_CHECKSIGVERIFY with an empty key\n+        (\"t8\", CScript([OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 9) normal OP_CHECKSIGADD that also ensures return value is correct\n+        (\"t9\", CScript([csa_low_val, pubs[1], OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 10) OP_CHECKSIGADD with empty key\n+        (\"t10\", CScript([csa_low_val, OP_0, OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 11) OP_CHECKSIGADD with missing counter stack element\n+        (\"t11\", CScript([pubs[1], OP_CHECKSIGADD, OP_1, OP_EQUAL])),\n+        # 12) OP_CHECKSIG that needs invalid signature\n+        (\"t12\", CScript([pubs[1], OP_CHECKSIGVERIFY, pubs[0], OP_CHECKSIG, OP_NOT])),\n+        # 13) OP_CHECKSIG with empty key that needs invalid signature\n+        (\"t13\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_CHECKSIG, OP_NOT])),\n+        # 14) OP_CHECKSIGADD that needs invalid signature\n+        (\"t14\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, pubs[0], OP_CHECKSIGADD, OP_NOT])),\n+        # 15) OP_CHECKSIGADD with empty key that needs invalid signature\n+        (\"t15\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGADD, OP_NOT])),\n+        # 16) OP_CHECKSIG with unknown pubkey type\n+        (\"t16\", CScript([OP_1, OP_CHECKSIG])),\n+        # 17) OP_CHECKSIGADD with unknown pubkey type\n+        (\"t17\", CScript([OP_0, OP_1, OP_CHECKSIGADD])),\n+        # 18) OP_CHECKSIGVERIFY with unknown pubkey type\n+        (\"t18\", CScript([OP_1, OP_CHECKSIGVERIFY, OP_1])),\n+        # 19) script longer than 10000 bytes and over 201 non-push opcodes\n+        (\"t19\", CScript([OP_0, OP_0, OP_2DROP] * 10001 + [pubs[1], OP_CHECKSIG])),\n+        # 20) OP_CHECKSIGVERIFY with empty key\n+        (\"t20\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 21) Script that grows the stack to 1000 elements\n+        (\"t21\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 999 + [OP_DROP] * 999)),\n+        # 22) Script that grows the stack to 1001 elements\n+        (\"t22\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 1000 + [OP_DROP] * 1000)),\n+        # 23) Script that expects an input stack of 1000 elements\n+        (\"t23\", CScript([OP_DROP] * 999 + [pubs[1], OP_CHECKSIG])),\n+        # 24) Script that expects an input stack of 1001 elements\n+        (\"t24\", CScript([OP_DROP] * 1000 + [pubs[1], OP_CHECKSIG])),\n+        # 25) Script that pushes a MAX_SCRIPT_ELEMENT_SIZE-bytes element\n+        (\"t25\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE), OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 26) Script that pushes a (MAX_SCRIPT_ELEMENT_SIZE+1)-bytes element\n+        (\"t26\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 27) CHECKSIGADD that must fail because numeric argument number is >4 bytes\n+        (\"t27\", CScript([CScriptNum(OVERSIZE_NUMBER), pubs[1], OP_CHECKSIGADD])),\n+        # 28) Pushes random CScriptNum value, checks OP_CHECKSIGADD result\n+        (\"t28\", CScript([csa_high_val, pubs[1], OP_CHECKSIGADD, csa_high_result, OP_EQUAL])),\n+        # 29) CHECKSIGADD that succeeds with proper sig because numeric argument number is <=4 bytes\n+        (\"t29\", CScript([CScriptNum(OVERSIZE_NUMBER-1), pubs[1], OP_CHECKSIGADD])),\n+        # 30) Variant of t1 with \"normal\" 33-byte pubkey\n+        (\"t30\", CScript([b'\\x03' + pubs[1], OP_CHECKSIG])),\n+        # 31) Variant of t2 with \"normal\" 33-byte pubkey\n+        (\"t31\", CScript([b'\\x02' + pubs[1], OP_CHECKSIGVERIFY, OP_1])),\n+        # 32) Variant of t28 with \"normal\" 33-byte pubkey\n+        (\"t32\", CScript([csa_high_val, b'\\x03' + pubs[1], OP_CHECKSIGADD, csa_high_result, OP_EQUAL])),\n+        # 33) 999-of-999 multisig\n+        (\"t33\", CScript(big_scriptops[:1998] + [OP_1])),\n+        # 34) 1000-of-1000 multisig\n+        (\"t34\", CScript(big_scriptops[:2000] + [OP_1])),\n+        # 35) Variant of t9 that uses a non-minimally encoded input arg\n+        (\"t35\", CScript([bytes([csa_low_val]), pubs[1], OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 36) Empty script\n+        (\"t36\", CScript([])),\n+    ]\n+    # Add many dummies to test huge trees\n+    for j in range(100000):\n+        scripts.append((None, CScript([OP_RETURN, random.randrange(100000)])))\n+    random.shuffle(scripts)\n+    tap = taproot_construct(pubs[0], scripts)\n+    common = {\n+        \"hashtype\": hashtype,\n+        \"key\": secs[1],\n+        \"tap\": tap,\n+    }\n+    # Test that MAX_SCRIPT_ELEMENT_SIZE byte stack element inputs are valid, but not one more (and 80 bytes is standard but 81 is not).\n+    add_spender(spenders, \"tapscript/inputmaxlimit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE)], failure={\"inputs\": [getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1)]}, **ERR_PUSH_LIMIT)\n+    add_spender(spenders, \"tapscript/input80limit\", leaf=\"t0\", **common, inputs=[getter(\"sign\"), random_bytes(80)])\n+    add_spender(spenders, \"tapscript/input81limit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(81)])\n+    # Test that OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY cause failure, but OP_CHECKSIG and OP_CHECKSIGVERIFY work.\n+    add_spender(spenders, \"tapscript/disabled_checkmultisig\", leaf=\"t1\", **common, **SINGLE_SIG, failure={\"leaf\": \"t3\"}, **ERR_TAPSCRIPT_CHECKMULTISIG)\n+    add_spender(spenders, \"tapscript/disabled_checkmultisigverify\", leaf=\"t2\", **common, **SINGLE_SIG, failure={\"leaf\": \"t4\"}, **ERR_TAPSCRIPT_CHECKMULTISIG)\n+    # Test that OP_IF and OP_NOTIF do not accept non-0x01 as truth value (the MINIMALIF rule is consensus in Tapscript)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x02']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x03']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0001']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0100']}, **ERR_MINIMALIF)\n+    # Test that 1-byte public keys (which are unknown) are acceptable but nonstandard with unrelated signatures, but 0-byte public keys are not valid.\n+    add_spender(spenders, \"tapscript/unkpk/checksig\", leaf=\"t16\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigadd\", leaf=\"t17\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigverify\", leaf=\"t18\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that 33-byte public keys (which are unknown) are acceptable but nonstandard with valid signatures, but normal pubkeys are not valid in that case.\n+    add_spender(spenders, \"tapscript/oldpk/checksig\", leaf=\"t30\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t1\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"tapscript/oldpk/checksigadd\", leaf=\"t31\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t2\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"tapscript/oldpk/checksigverify\", leaf=\"t32\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t28\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    # Test that 0-byte public keys are not acceptable.\n+    add_spender(spenders, \"tapscript/emptypk/checksig\", leaf=\"t1\", **SINGLE_SIG, **common, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigverify\", leaf=\"t2\", **SINGLE_SIG, **common, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigadd\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigadd\", leaf=\"t35\", standard=False, **SINGLE_SIG, **common, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that OP_CHECKSIGADD results are as expected\n+    add_spender(spenders, \"tapscript/checksigaddresults\", leaf=\"t28\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    add_spender(spenders, \"tapscript/checksigaddoversize\", leaf=\"t29\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    # Test that OP_CHECKSIGADD requires 3 stack elements.\n+    add_spender(spenders, \"tapscript/checksigadd3args\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t11\"}, **ERR_STACK_EMPTY)\n+    # Test that empty signatures do not cause script failure in OP_CHECKSIG and OP_CHECKSIGADD (but do fail with empty pubkey, and do fail OP_CHECKSIGVERIFY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksig\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t13\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/nochecksigverify\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t20\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksigadd\", leaf=\"t14\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t15\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that scripts over 10000 bytes (and over 201 non-push ops) are acceptable.\n+    add_spender(spenders, \"tapscript/no10000limit\", leaf=\"t19\", **SINGLE_SIG, **common)\n+    # Test that a stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000stack\", leaf=\"t21\", **SINGLE_SIG, **common, failure={\"leaf\": \"t22\"}, **ERR_STACK_SIZE)\n+    # Test that an input stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000inputs\", leaf=\"t23\", **common, inputs=[getter(\"sign\")] + [b'' for _ in range(999)], failure={\"leaf\": \"t24\", \"inputs\": [getter(\"sign\")] + [b'' for _ in range(1000)]}, **ERR_STACK_SIZE)\n+    # Test that pushing a MAX_SCRIPT_ELEMENT_SIZE byte stack element is valid, but one longer is not.\n+    add_spender(spenders, \"tapscript/pushmaxlimit\", leaf=\"t25\", **common, **SINGLE_SIG, failure={\"leaf\": \"t26\"}, **ERR_PUSH_LIMIT)\n+    # Test that 999-of-999 multisig works (but 1000-of-1000 triggers stack size limits)\n+    add_spender(spenders, \"tapscript/bigmulti\", leaf=\"t33\", **common, inputs=big_spend_inputs, num=999, failure={\"leaf\": \"t34\", \"num\": 1000}, **ERR_STACK_SIZE)\n+    # Test that the CLEANSTACK rule is consensus critical in tapscript\n+    add_spender(spenders, \"tapscript/cleanstack\", leaf=\"t36\", tap=tap, inputs=[b'\\x01'], failure={\"inputs\": [b'\\x01', b'\\x01']}, **ERR_CLEANSTACK)\n+\n+    # == Test for sigops ratio limit ==\n+\n+    # Given a number n, and a public key pk, functions that produce a (CScript, sigops). Each script takes as\n+    # input a valid signature with the passed pk followed by a dummy push of bytes that are to be dropped, and\n+    # will execute sigops signature checks.\n+    SIGOPS_RATIO_SCRIPTS = [\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIG.\n+        lambda n, pk: (CScript([OP_DROP, pk] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGVERIFY.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_0, OP_IF, OP_2DUP, OP_CHECKSIGVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_2, OP_SWAP, OP_CHECKSIGADD, OP_3, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIG.\n+        lambda n, pk: (CScript([random_bytes(220), OP_2DROP, pk, OP_1, OP_NOTIF, OP_2DUP, OP_CHECKSIG, OP_VERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_4, OP_SWAP, OP_CHECKSIGADD, OP_5, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGADD.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_1, OP_IF, OP_ELSE, OP_2DUP, OP_6, OP_SWAP, OP_CHECKSIGADD, OP_7, OP_EQUALVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_8, OP_SWAP, OP_CHECKSIGADD, OP_9, OP_EQUAL]), n + 1),\n+        # n+1 OP_CHECKSIGs, but also one OP_CHECKSIG with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, pk, OP_CHECKSIG, OP_NOT, OP_VERIFY, pk] + [OP_2DUP, OP_CHECKSIG, OP_VERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGADDs and 1 OP_CHECKSIG, but also an OP_CHECKSIGADD with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, OP_10, pk, OP_CHECKSIGADD, OP_10, OP_EQUALVERIFY, pk] + [OP_2DUP, OP_16, OP_SWAP, OP_CHECKSIGADD, b'\\x11', OP_EQUALVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+    ]\n+    for annex in [None, bytes([ANNEX_TAG]) + random_bytes(random.randrange(1000))]:\n+        for hashtype in [SIGHASH_DEFAULT, SIGHASH_ALL]:\n+            for pubkey in [pubs[1], random_bytes(random.choice([x for x in range(2, 81) if x != 32]))]:\n+                for fn_num, fn in enumerate(SIGOPS_RATIO_SCRIPTS):\n+                    merkledepth = random.randrange(129)\n+\n+\n+                    def predict_sigops_ratio(n, dummy_size):\n+                        \"\"\"Predict whether spending fn(n, pubkey) with dummy_size will pass the ratio test.\"\"\"\n+                        script, sigops = fn(n, pubkey)\n+                        # Predict the size of the witness for a given choice of n\n+                        stacklen_size = 1\n+                        sig_size = 64 + (hashtype != SIGHASH_DEFAULT)\n+                        siglen_size = 1\n+                        dummylen_size = 1 + 2 * (dummy_size >= 253)\n+                        script_size = len(script)\n+                        scriptlen_size = 1 + 2 * (script_size >= 253)\n+                        control_size = 33 + 32 * merkledepth\n+                        controllen_size = 1 + 2 * (control_size >= 253)\n+                        annex_size = 0 if annex is None else len(annex)\n+                        annexlen_size = 0 if annex is None else 1 + 2 * (annex_size >= 253)\n+                        witsize = stacklen_size + sig_size + siglen_size + dummy_size + dummylen_size + script_size + scriptlen_size + control_size + controllen_size + annex_size + annexlen_size\n+                        # sigops ratio test\n+                        return witsize + 50 >= 50 * sigops\n+                    # Make sure n is high enough that with empty dummy, the script is not valid\n+                    n = 0\n+                    while predict_sigops_ratio(n, 0):\n+                        n += 1\n+                    # But allow picking a bit higher still\n+                    n += random.randrange(5)\n+                    # Now pick dummy size *just* large enough that the overall construction passes\n+                    dummylen = 0\n+                    while not predict_sigops_ratio(n, dummylen):\n+                        dummylen += 1\n+                    scripts = [(\"s\", fn(n, pubkey)[0])]\n+                    for _ in range(merkledepth):\n+                        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+                    tap = taproot_construct(pubs[0], scripts)\n+                    standard = annex is None and dummylen <= 80 and len(pubkey) == 32\n+                    add_spender(spenders, \"tapscript/sigopsratio_%i\" % fn_num, tap=tap, leaf=\"s\", annex=annex, hashtype=hashtype, key=secs[1], inputs=[getter(\"sign\"), random_bytes(dummylen)], standard=standard, failure={\"inputs\": [getter(\"sign\"), random_bytes(dummylen - 1)]}, **ERR_SIGOPS_RATIO)\n+\n+    # Future leaf versions\n+    for leafver in range(0, 0x100, 2):\n+        if leafver == LEAF_VERSION_TAPSCRIPT or leafver == ANNEX_TAG:\n+            # Skip the defined LEAF_VERSION_TAPSCRIPT, and the ANNEX_TAG which is not usable as leaf version\n+            continue\n+        scripts = [\n+            (\"bare_c0\", CScript([OP_NOP])),\n+            (\"bare_unkver\", CScript([OP_NOP]), leafver),\n+            (\"return_c0\", CScript([OP_RETURN])),\n+            (\"return_unkver\", CScript([OP_RETURN]), leafver),\n+            (\"undecodable_c0\", CScript([OP_PUSHDATA1])),\n+            (\"undecodable_unkver\", CScript([OP_PUSHDATA1]), leafver),\n+            (\"bigpush_c0\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP])),\n+            (\"bigpush_unkver\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP]), leafver),\n+            (\"1001push_c0\", CScript([OP_0] * 1001)),\n+            (\"1001push_unkver\", CScript([OP_0] * 1001), leafver),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"unkver/bare\", standard=False, tap=tap, leaf=\"bare_unkver\", failure={\"leaf\": \"bare_c0\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"unkver/return\", standard=False, tap=tap, leaf=\"return_unkver\", failure={\"leaf\": \"return_c0\"}, **ERR_OP_RETURN)\n+        add_spender(spenders, \"unkver/undecodable\", standard=False, tap=tap, leaf=\"undecodable_unkver\", failure={\"leaf\": \"undecodable_c0\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"unkver/bigpush\", standard=False, tap=tap, leaf=\"bigpush_unkver\", failure={\"leaf\": \"bigpush_c0\"}, **ERR_PUSH_LIMIT)\n+        add_spender(spenders, \"unkver/1001push\", standard=False, tap=tap, leaf=\"1001push_unkver\", failure={\"leaf\": \"1001push_c0\"}, **ERR_STACK_SIZE)\n+        add_spender(spenders, \"unkver/1001inputs\", standard=False, tap=tap, leaf=\"bare_unkver\", inputs=[b'']*1001, failure={\"leaf\": \"bare_c0\"}, **ERR_STACK_SIZE)\n+\n+    # OP_SUCCESSx tests.\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for opval in range(76, 0x100):\n+        opcode = CScriptOp(opval)\n+        if not is_op_success(opcode):\n+            continue\n+        scripts = [\n+            (\"bare_success\", CScript([opcode])),\n+            (\"bare_nop\", CScript([OP_NOP])),\n+            (\"unexecif_success\", CScript([OP_0, OP_IF, opcode, OP_ENDIF])),\n+            (\"unexecif_nop\", CScript([OP_0, OP_IF, OP_NOP, OP_ENDIF])),\n+            (\"return_success\", CScript([OP_RETURN, opcode])),\n+            (\"return_nop\", CScript([OP_RETURN, OP_NOP])),\n+            (\"undecodable_success\", CScript([opcode, OP_PUSHDATA1])),\n+            (\"undecodable_nop\", CScript([OP_NOP, OP_PUSHDATA1])),\n+            (\"undecodable_bypassed_success\", CScript([OP_PUSHDATA1, OP_2, opcode])),\n+            (\"bigpush_success\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, opcode])),\n+            (\"bigpush_nop\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, OP_NOP])),\n+            (\"1001push_success\", CScript([OP_0] * 1001 + [opcode])),\n+            (\"1001push_nop\", CScript([OP_0] * 1001 + [OP_NOP])),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"opsuccess/bare\", standard=False, tap=tap, leaf=\"bare_success\", failure={\"leaf\": \"bare_nop\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"opsuccess/exexecif\", standard=False, tap=tap, leaf=\"unexecif_success\", failure={\"leaf\": \"unexecif_nop\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"opsuccess/return\", standard=False, tap=tap, leaf=\"return_success\", failure={\"leaf\": \"return_nop\"}, **ERR_OP_RETURN)\n+        add_spender(spenders, \"opsuccess/undecodable\", standard=False, tap=tap, leaf=\"undecodable_success\", failure={\"leaf\": \"undecodable_nop\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"opsuccess/undecodable_bypass\", standard=False, tap=tap, leaf=\"undecodable_success\", failure={\"leaf\": \"undecodable_bypassed_success\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"opsuccess/bigpush\", standard=False, tap=tap, leaf=\"bigpush_success\", failure={\"leaf\": \"bigpush_nop\"}, **ERR_PUSH_LIMIT)\n+        add_spender(spenders, \"opsuccess/1001push\", standard=False, tap=tap, leaf=\"1001push_success\", failure={\"leaf\": \"1001push_nop\"}, **ERR_STACK_SIZE)\n+        add_spender(spenders, \"opsuccess/1001inputs\", standard=False, tap=tap, leaf=\"bare_success\", inputs=[b'']*1001, failure={\"leaf\": \"bare_nop\"}, **ERR_STACK_SIZE)\n+\n+    # Non-OP_SUCCESSx (verify that those aren't accidentally treated as OP_SUCCESSx)\n+    for opval in range(0, 0x100):\n+        opcode = CScriptOp(opval)\n+        if is_op_success(opcode):\n+            continue\n+        scripts = [\n+            (\"normal\", CScript([OP_RETURN, opcode] + [OP_NOP] * 75)),\n+            (\"op_success\", CScript([OP_RETURN, CScriptOp(0x50)]))\n+        ]\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"alwaysvalid/notsuccessx\", tap=tap, leaf=\"op_success\", inputs=[], standard=False, failure={\"leaf\": \"normal\"}) # err_msg differs based on opcode\n+\n+    # == Legacy tests ==\n+\n+    # Also add a few legacy spends into the mix, so that transactions which combine taproot and pre-taproot spends get tested too.\n+    for compressed in [False, True]:\n+        eckey1 = ECKey()\n+        eckey1.set(generate_privkey(), compressed)\n+        pubkey1 = eckey1.get_pubkey().get_bytes()\n+        eckey2 = ECKey()\n+        eckey2.set(generate_privkey(), compressed)\n+        for p2sh in [False, True]:\n+            for witv0 in [False, True]:\n+                for hashtype in VALID_SIGHASHES_ECDSA + [random.randrange(0x04, 0x80), random.randrange(0x84, 0x100)]:\n+                    standard = (hashtype in VALID_SIGHASHES_ECDSA) and (compressed or not witv0)\n+                    add_spender(spenders, \"legacy/pk-wrongkey\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, script=CScript([pubkey1, OP_CHECKSIG]), **SINGLE_SIG, key=eckey1, failure={\"key\": eckey2}, sigops_weight=4-3*witv0, **ERR_NO_SUCCESS)\n+                    add_spender(spenders, \"legacy/pkh-sighashflip\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, pkh=pubkey1, key=eckey1, **SIGHASH_BITFLIP, sigops_weight=4-3*witv0, **ERR_NO_SUCCESS)\n+\n+    # Verify that OP_CHECKSIGADD wasn't accidentally added to pre-taproot validation logic.\n+    for p2sh in [False, True]:\n+        for witv0 in [False, True]:\n+            for hashtype in VALID_SIGHASHES_ECDSA + [random.randrange(0x04, 0x80), random.randrange(0x84, 0x100)]:\n+                standard = hashtype in VALID_SIGHASHES_ECDSA and (p2sh or witv0)\n+                add_spender(spenders, \"compat/nocsa\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, script=CScript([OP_IF, OP_11, pubkey1, OP_CHECKSIGADD, OP_12, OP_EQUAL, OP_ELSE, pubkey1, OP_CHECKSIG, OP_ENDIF]), key=eckey1, sigops_weight=4-3*witv0, inputs=[getter(\"sign\"), b''], failure={\"inputs\": [getter(\"sign\"), b'\\x01']}, **ERR_UNDECODABLE)\n+\n+    return spenders\n+\n+def spenders_taproot_inactive():\n+    \"\"\"Spenders for testing that pre-activation Taproot rules don't apply.\"\"\"\n+\n+    spenders = []\n+\n+    sec = generate_privkey()\n+    pub, _ = compute_xonly_pubkey(sec)\n+    scripts = [\n+        (\"pk\", CScript([pub, OP_CHECKSIG])),\n+        (\"future_leaf\", CScript([pub, OP_CHECKSIG]), 0xc2),\n+        (\"op_success\", CScript([pub, OP_CHECKSIG, OP_0, OP_IF, CScriptOp(0x50), OP_ENDIF])),\n+    ]\n+    tap = taproot_construct(pub, scripts)\n+\n+    # Test that keypath spending is valid & standard if compliant, but valid and nonstandard otherwise.\n+    add_spender(spenders, \"inactive/keypath_valid\", key=sec, tap=tap)\n+    add_spender(spenders, \"inactive/keypath_invalidsig\", key=sec, tap=tap, standard=False, sighash=bitflipper(default_sighash))\n+    add_spender(spenders, \"inactive/keypath_empty\", key=sec, tap=tap, standard=False, witness=[])\n+\n+    # Same for scriptpath spending (but using future features like annex, leaf versions, or OP_SUCCESS is nonstandard).\n+    add_spender(spenders, \"inactive/scriptpath_valid\", key=sec, tap=tap, leaf=\"pk\", inputs=[getter(\"sign\")])\n+    add_spender(spenders, \"inactive/scriptpath_invalidsig\", key=sec, tap=tap, leaf=\"pk\", standard=False, inputs=[getter(\"sign\")], sighash=bitflipper(default_sighash))\n+    add_spender(spenders, \"inactive/scriptpath_invalidcb\", key=sec, tap=tap, leaf=\"pk\", standard=False, inputs=[getter(\"sign\")], controlblock=bitflipper(default_controlblock))\n+    add_spender(spenders, \"inactive/scriptpath_valid_unkleaf\", key=sec, tap=tap, leaf=\"future_leaf\", standard=False, inputs=[getter(\"sign\")])\n+    add_spender(spenders, \"inactive/scriptpath_invalid_unkleaf\", key=sec, tap=tap, leaf=\"future_leaf\", standard=False, inputs=[getter(\"sign\")], sighash=bitflipper(default_sighash))\n+    add_spender(spenders, \"inactive/scriptpath_valid_opsuccess\", key=sec, tap=tap, leaf=\"op_success\", standard=False, inputs=[getter(\"sign\")])\n+    add_spender(spenders, \"inactive/scriptpath_valid_opsuccess\", key=sec, tap=tap, leaf=\"op_success\", standard=False, inputs=[getter(\"sign\")], sighash=bitflipper(default_sighash))\n+\n+    return spenders\n+\n+# Data type to keep track of UTXOs, where they were created, and how to spend them.\n+UTXOData = namedtuple('UTXOData', 'outpoint,output,spender')\n+\n+class TaprootTest(BitcoinTestFramework):\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.setup_clean_chain = True\n+        # Node 0 has Taproot inactive, Node 1 active.\n+        self.extra_args = [[\"-whitelist=127.0.0.1\", \"-par=1\", \"-vbparams=taproot:1:1\"], [\"-whitelist=127.0.0.1\", \"-par=1\"]]\n+\n+    def block_submit(self, node, txs, msg, err_msg, cb_pubkey=None, fees=0, sigops_weight=0, witness=False, accept=False):\n+\n+        # Deplete block of any non-tapscript sigops using a single additional 0-value coinbase output.\n+        # It is not impossible to fit enough tapscript sigops to hit the old 80k limit without\n+        # busting txin-level limits. We simply have to account for the p2pk outputs in all\n+        # transactions.\n+        extra_output_script = CScript([OP_CHECKSIG]*((MAX_BLOCK_SIGOPS_WEIGHT - sigops_weight) // WITNESS_SCALE_FACTOR))\n+\n+        block = create_block(self.tip, create_coinbase(self.lastblockheight + 1, pubkey=cb_pubkey, extra_output_script=extra_output_script, fees=fees), self.lastblocktime + 1)\n+        block.nVersion = 4\n+        for tx in txs:\n+            tx.rehash()\n+            block.vtx.append(tx)\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        witness and add_witness_commitment(block)\n+        block.rehash()\n+        block.solve()\n+        block_response = node.submitblock(block.serialize(True).hex())\n+        if err_msg is not None:\n+            assert block_response is not None and err_msg in block_response, \"Missing error message '%s' from block response '%s': %s\" % (err_msg, \"(None)\" if block_response is None else block_response, msg)\n+        if (accept):\n+            assert node.getbestblockhash() == block.hash, \"Failed to accept: %s (response: %s)\" % (msg, block_response)\n+            self.tip = block.sha256\n+            self.lastblockhash = block.hash\n+            self.lastblocktime += 1\n+            self.lastblockheight += 1\n+        else:\n+            assert node.getbestblockhash() == self.lastblockhash, \"Failed to reject: \" + msg\n+\n+    def test_spenders(self, node, spenders, input_counts):\n+        \"\"\"Run randomized tests with a number of \"spenders\".\n+\n+        Steps:\n+            1) Generate an appropriate UTXO for each spender to test spend conditions\n+            2) Generate 100 random addresses of all wallet types: pkh/sh_wpkh/wpkh\n+            3) Select random number of inputs from (1)\n+            4) Select random number of addresses from (2) as outputs\n+\n+        Each spender embodies a test; in a large randomized test, it is verified\n+        that toggling the valid argument to each lambda toggles the validity of\n+        the transaction. This is accomplished by constructing transactions consisting\n+        of all valid inputs, except one invalid one.\n+        \"\"\"\n+\n+        # Generate some coins to fund the wallet.\n+        node.generate(10)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503157420",
      "id" : 503157420,
      "in_reply_to_id" : 502965296,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE1NzQyMA==",
      "original_commit_id" : "58c90569f75221bc4652cbde5cad4dbae543a1ca",
      "original_line" : 1203,
      "original_position" : 1203,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 506443582,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503157420",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503157515"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503157515"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-12T09:21:00Z",
      "diff_hunk" : "@@ -0,0 +1,1403 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503157515",
      "id" : 503157515,
      "in_reply_to_id" : 502963706,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE1NzUxNQ==",
      "original_commit_id" : "58c90569f75221bc4652cbde5cad4dbae543a1ca",
      "original_line" : 100,
      "original_position" : 100,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 506443710,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503157515",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503157634"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503157634"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-12T09:21:10Z",
      "diff_hunk" : "@@ -371,6 +368,66 @@ static bool EvalChecksig(const valtype& vchSig, const valtype& vchPubKey, CScrip\n     return true;\n }\n \n+static bool EvalChecksigTapscript(const valtype& sig, const valtype& pubkey, ScriptExecutionData& execdata, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& success)\n+{\n+    assert(sigversion == SigVersion::TAPSCRIPT);\n+\n+    /*\n+     *  The following validation sequence is consensus critical. Please note how --\n+     *    upgradable public key versions precede other rules;\n+     *    the script execution fails when using empty signature with invalid public key;\n+     *    the script execution fails when using non-empty invalid signature.\n+     */\n+    success = !sig.empty();\n+    if (success) {\n+        // Implement the sigops/witnesssize ratio test.\n+        // Passing with an upgradable public key version is also counted.\n+        assert(execdata.m_validation_weight_left_init);\n+        execdata.m_validation_weight_left -= VALIDATION_WEIGHT_PER_SIGOP_PASSED;\n+        if (execdata.m_validation_weight_left < 0) {\n+            return set_error(serror, SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT);\n+        }\n+    }\n+    if (pubkey.size() == 0) {\n+        return set_error(serror, SCRIPT_ERR_PUBKEYTYPE);\n+    } else if (pubkey.size() == 32) {\n+        if (success && !checker.CheckSchnorrSignature(sig, pubkey, sigversion, execdata, serror)) {\n+            return false;\n+        }\n+    } else {\n+        /*\n+         *  New public key version softforks should be defined before this `else` block.\n+         *  Generally, the new code should not do anything but failing the script execution. To avoid\n+         *  consensus bugs, it should not modify any existing values (including success).\n+         */\n+        if ((flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE) != 0) {\n+            return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE);\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+/** Helper for OP_CHECKSIG, OP_CHECKSIGVERIFY, and (in Tapscript) OP_CHECKSIGADD.\n+ *\n+ * A return value of false means the script fails entirely. When true is returned, the\n+ * fSuccess variable indicates whether the signature check itself succeeded.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503157634",
      "id" : 503157634,
      "in_reply_to_id" : 502955684,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE1NzYzNA==",
      "original_commit_id" : "c3825c1bc41815d9b27d9a5dc36e46165b2f5861",
      "original_line" : 414,
      "original_position" : 64,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 506443836,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503157634",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503157724"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503157724"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Added.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-12T09:21:19Z",
      "diff_hunk" : "@@ -1539,13 +1539,19 @@ bool CheckInputScripts(const CTransaction& tx, TxValidationState &state, const C\n     }\n \n     if (!txdata.m_ready) {\n-        txdata.Init(tx);\n+        std::vector<CTxOut> spent_outputs;\n+        spent_outputs.reserve(tx.vin.size());\n+\n+        for (const auto& txin : tx.vin) {\n+            const COutPoint& prevout = txin.prevout;\n+            const Coin& coin = inputs.AccessCoin(prevout);\n+            assert(!coin.IsSpent());\n+            spent_outputs.emplace_back(coin.out);\n+        }\n+        txdata.Init(tx, std::move(spent_outputs));\n     }\n \n     for (unsigned int i = 0; i < tx.vin.size(); i++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503157724",
      "id" : 503157724,
      "in_reply_to_id" : 502840625,
      "line" : 1555,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE1NzcyNA==",
      "original_commit_id" : "6b0f2a4320aebe1b802763a559cbaf3c348c2ffc",
      "original_line" : 1555,
      "original_position" : 17,
      "original_start_line" : null,
      "path" : "src/validation.cpp",
      "position" : 20,
      "pull_request_review_id" : 506443954,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503157724",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Addressed comments by @fjahr and @kallewoof above. Details are in #19997.",
      "created_at" : "2020-10-12T09:21:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-706997520",
      "id" : 706997520,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwNjk5NzUyMA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-12T09:21:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/706997520",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Re-ACK sans the fuccess typo.\r\n\r\n<details><summary>Local diff between 4a7e0171c0eec437c5de2b0eb316c5088e5b07b0 and cc036c251c16eda1cdc558db2049e8db0f3a50b7 (but don't take my word for it)</summary>\r\n<p>\r\n\r\n```diff\r\ndiff --git a/src/pubkey.cpp b/src/pubkey.cpp\r\nindex 689328765..4d734fc89 100644\r\n--- a/src/pubkey.cpp\r\n+++ b/src/pubkey.cpp\r\n@@ -173,7 +173,8 @@ XOnlyPubKey::XOnlyPubKey(Span<const unsigned char> bytes)\r\n     std::copy(bytes.begin(), bytes.end(), m_keydata.begin());\r\n }\r\n \r\n-bool XOnlyPubKey::VerifySchnorr(const uint256& msg, Span<const unsigned char> sigbytes) const {\r\n+bool XOnlyPubKey::VerifySchnorr(const uint256& msg, Span<const unsigned char> sigbytes) const\r\n+{\r\n     assert(sigbytes.size() == 64);\r\n     secp256k1_xonly_pubkey pubkey;\r\n     if (!secp256k1_xonly_pubkey_parse(secp256k1_context_verify, &pubkey, m_keydata.data())) return false;\r\ndiff --git a/src/pubkey.h b/src/pubkey.h\r\nindex 65f3fdf38..0f784b86e 100644\r\n--- a/src/pubkey.h\r\n+++ b/src/pubkey.h\r\n@@ -207,7 +207,8 @@ public:\r\n     bool Derive(CPubKey& pubkeyChild, ChainCode &ccChild, unsigned int nChild, const ChainCode& cc) const;\r\n };\r\n \r\n-class XOnlyPubKey {\r\n+class XOnlyPubKey\r\n+{\r\n private:\r\n     uint256 m_keydata;\r\n \r\ndiff --git a/src/script/interpreter.cpp b/src/script/interpreter.cpp\r\nindex 92994a56e..1067a5293 100644\r\n--- a/src/script/interpreter.cpp\r\n+++ b/src/script/interpreter.cpp\r\n@@ -392,13 +392,13 @@ static bool EvalChecksigTapscript(const valtype& sig, const valtype& pubkey, Scr\r\n         return set_error(serror, SCRIPT_ERR_PUBKEYTYPE);\r\n     } else if (pubkey.size() == 32) {\r\n         if (success && !checker.CheckSchnorrSignature(sig, pubkey, sigversion, execdata, serror)) {\r\n-            return false;\r\n+            return false; // serror is set\r\n         }\r\n     } else {\r\n         /*\r\n          *  New public key version softforks should be defined before this `else` block.\r\n          *  Generally, the new code should not do anything but failing the script execution. To avoid\r\n-         *  consensus bugs, it should not modify any existing values (including success).\r\n+         *  consensus bugs, it should not modify any existing values (including `success`).\r\n          */\r\n         if ((flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE) != 0) {\r\n             return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE);\r\n@@ -411,7 +411,7 @@ static bool EvalChecksigTapscript(const valtype& sig, const valtype& pubkey, Scr\r\n /** Helper for OP_CHECKSIG, OP_CHECKSIGVERIFY, and (in Tapscript) OP_CHECKSIGADD.\r\n  *\r\n  * A return value of false means the script fails entirely. When true is returned, the\r\n- * fSuccess variable indicates whether the signature check itself succeeded.\r\n+ * fuccess variable indicates whether the signature check itself succeeded.\r\n  */\r\n static bool EvalChecksig(const valtype& sig, const valtype& pubkey, CScript::const_iterator pbegincodehash, CScript::const_iterator pend, ScriptExecutionData& execdata, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& success)\r\n {\r\n@@ -1814,9 +1814,7 @@ static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CS\r\n         }\r\n \r\n         // Tapscript enforces initial stack size limits (altstack is empty here)\r\n-        if (stack.size() > MAX_STACK_SIZE) {\r\n-            return set_error(serror, SCRIPT_ERR_STACK_SIZE);\r\n-        }\r\n+        if (stack.size() > MAX_STACK_SIZE) return set_error(serror, SCRIPT_ERR_STACK_SIZE);\r\n     }\r\n \r\n     // Disallow stack item size > MAX_SCRIPT_ELEMENT_SIZE in witness stack\r\n@@ -1900,7 +1898,7 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\r\n         if (stack.size() == 1) {\r\n             // Key path spending (stack size is 1 after removing optional annex)\r\n             if (!checker.CheckSchnorrSignature(stack.front(), program, SigVersion::TAPROOT, execdata, serror)) {\r\n-                return false;\r\n+                return false; // serror is set\r\n             }\r\n             return set_success(serror);\r\n         } else {\r\ndiff --git a/src/validation.cpp b/src/validation.cpp\r\nindex fdabff9bb..0b78ba677 100644\r\n--- a/src/validation.cpp\r\n+++ b/src/validation.cpp\r\n@@ -1550,6 +1550,7 @@ bool CheckInputScripts(const CTransaction& tx, TxValidationState &state, const C\r\n         }\r\n         txdata.Init(tx, std::move(spent_outputs));\r\n     }\r\n+    assert(txdata.m_spent_outputs.size() == tx.vin.size());\r\n \r\n     for (unsigned int i = 0; i < tx.vin.size(); i++) {\r\n \r\ndiff --git a/test/functional/feature_taproot.py b/test/functional/feature_taproot.py\r\nindex 82ccdae06..7b534c1c2 100755\r\n--- a/test/functional/feature_taproot.py\r\n+++ b/test/functional/feature_taproot.py\r\n@@ -100,7 +100,7 @@ import random\r\n # - lists of values\r\n # - callables which, when fed the context object as argument, produce any of these\r\n #\r\n-# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\r\n+# The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\r\n #\r\n # The get(ctx, name) function can evaluate a name, and cache its result in the context.\r\n # getter(name) can be used to construct a callable that evaluates name. For example:\r\n@@ -1070,7 +1070,7 @@ def spenders_taproot_active():\r\n         random.shuffle(scripts)\r\n         tap = taproot_construct(pubs[0], scripts)\r\n         add_spender(spenders, \"opsuccess/bare\", standard=False, tap=tap, leaf=\"bare_success\", failure={\"leaf\": \"bare_nop\"}, **ERR_CLEANSTACK)\r\n-        add_spender(spenders, \"opsuccess/exexecif\", standard=False, tap=tap, leaf=\"unexecif_success\", failure={\"leaf\": \"unexecif_nop\"}, **ERR_CLEANSTACK)\r\n+        add_spender(spenders, \"opsuccess/unexecif\", standard=False, tap=tap, leaf=\"unexecif_success\", failure={\"leaf\": \"unexecif_nop\"}, **ERR_CLEANSTACK)\r\n         add_spender(spenders, \"opsuccess/return\", standard=False, tap=tap, leaf=\"return_success\", failure={\"leaf\": \"return_nop\"}, **ERR_OP_RETURN)\r\n         add_spender(spenders, \"opsuccess/undecodable\", standard=False, tap=tap, leaf=\"undecodable_success\", failure={\"leaf\": \"undecodable_nop\"}, **ERR_UNDECODABLE)\r\n         add_spender(spenders, \"opsuccess/undecodable_bypass\", standard=False, tap=tap, leaf=\"undecodable_success\", failure={\"leaf\": \"undecodable_bypassed_success\"}, **ERR_UNDECODABLE)\r\n@@ -1245,9 +1245,6 @@ class TaprootTest(BitcoinTestFramework):\r\n         of all valid inputs, except one invalid one.\r\n         \"\"\"\r\n \r\n-        # Generate some coins to fund the wallet.\r\n-        node.generate(10)\r\n-\r\n         # Construct a bunch of sPKs that send coins back to the host wallet\r\n         self.log.info(\"- Constructing addresses for returning coins\")\r\n         host_spks = []\r\n@@ -1284,7 +1281,7 @@ class TaprootTest(BitcoinTestFramework):\r\n             # Add the 50 highest-value inputs\r\n             unspents = node.listunspent()\r\n             random.shuffle(unspents)\r\n-            unspents.sort(key=lambda x: -int(x[\"amount\"] * 100000000))\r\n+            unspents.sort(key=lambda x: int(x[\"amount\"] * 100000000), reverse=True)\r\n             if len(unspents) > 50:\r\n                 unspents = unspents[:50]\r\n             random.shuffle(unspents)\r\n\r\n```\r\n</p>\r\n</details>\r\n",
      "created_at" : "2020-10-12T09:30:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-707002605",
      "id" : 707002605,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwNzAwMjYwNQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-12T09:31:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/707002605",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503236815"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503236815"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n * success variable indicates whether the signature check itself succeeded.\r\n```",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-12T11:41:05Z",
      "diff_hunk" : "@@ -363,15 +360,75 @@ static bool EvalChecksig(const valtype& vchSig, const valtype& vchPubKey, CScrip\n         //serror is set\n         return false;\n     }\n-    fSuccess = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion);\n+    fSuccess = checker.CheckECDSASignature(vchSig, vchPubKey, scriptCode, sigversion);\n \n     if (!fSuccess && (flags & SCRIPT_VERIFY_NULLFAIL) && vchSig.size())\n         return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);\n \n     return true;\n }\n \n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)\n+static bool EvalChecksigTapscript(const valtype& sig, const valtype& pubkey, ScriptExecutionData& execdata, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& success)\n+{\n+    assert(sigversion == SigVersion::TAPSCRIPT);\n+\n+    /*\n+     *  The following validation sequence is consensus critical. Please note how --\n+     *    upgradable public key versions precede other rules;\n+     *    the script execution fails when using empty signature with invalid public key;\n+     *    the script execution fails when using non-empty invalid signature.\n+     */\n+    success = !sig.empty();\n+    if (success) {\n+        // Implement the sigops/witnesssize ratio test.\n+        // Passing with an upgradable public key version is also counted.\n+        assert(execdata.m_validation_weight_left_init);\n+        execdata.m_validation_weight_left -= VALIDATION_WEIGHT_PER_SIGOP_PASSED;\n+        if (execdata.m_validation_weight_left < 0) {\n+            return set_error(serror, SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT);\n+        }\n+    }\n+    if (pubkey.size() == 0) {\n+        return set_error(serror, SCRIPT_ERR_PUBKEYTYPE);\n+    } else if (pubkey.size() == 32) {\n+        if (success && !checker.CheckSchnorrSignature(sig, pubkey, sigversion, execdata, serror)) {\n+            return false; // serror is set\n+        }\n+    } else {\n+        /*\n+         *  New public key version softforks should be defined before this `else` block.\n+         *  Generally, the new code should not do anything but failing the script execution. To avoid\n+         *  consensus bugs, it should not modify any existing values (including `success`).\n+         */\n+        if ((flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE) != 0) {\n+            return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE);\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+/** Helper for OP_CHECKSIG, OP_CHECKSIGVERIFY, and (in Tapscript) OP_CHECKSIGADD.\n+ *\n+ * A return value of false means the script fails entirely. When true is returned, the\n+ * fuccess variable indicates whether the signature check itself succeeded.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503236815",
      "id" : 503236815,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzIzNjgxNQ==",
      "original_commit_id" : "cc036c251c16eda1cdc558db2049e8db0f3a50b7",
      "original_line" : 414,
      "original_position" : 74,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 506542869,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503236815",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "reACK cc036c2",
      "created_at" : "2020-10-12T14:36:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-707159658",
      "id" : 707159658,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwNzE1OTY1OA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-12T14:36:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/707159658",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/15256660?v=4",
         "events_url" : "https://api.github.com/users/benthecarman/events{/privacy}",
         "followers_url" : "https://api.github.com/users/benthecarman/followers",
         "following_url" : "https://api.github.com/users/benthecarman/following{/other_user}",
         "gists_url" : "https://api.github.com/users/benthecarman/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/benthecarman",
         "id" : 15256660,
         "login" : "benthecarman",
         "node_id" : "MDQ6VXNlcjE1MjU2NjYw",
         "organizations_url" : "https://api.github.com/users/benthecarman/orgs",
         "received_events_url" : "https://api.github.com/users/benthecarman/received_events",
         "repos_url" : "https://api.github.com/users/benthecarman/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/benthecarman/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/benthecarman/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/benthecarman"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503477740"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503477740"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In 614479450e911dba6938bb7feb85088229faf9b1 \"Implement Taproot signature hashing (BIP 341)\"\r\n\r\nnit: remove `key_version` here. It is removed in the next commit anyways.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-12T18:57:13Z",
      "diff_hunk" : "@@ -1322,6 +1378,75 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, uint32_t in_pos, uint8_t hash_type, SigVersion sigversion, uint8_t key_version, const PrecomputedTransactionData& cache)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503477740",
      "id" : 503477740,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ3Nzc0MA==",
      "original_commit_id" : "614479450e911dba6938bb7feb85088229faf9b1",
      "original_line" : 1384,
      "original_position" : 94,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 506848576,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503477740",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503495197"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503495197"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In 4e6196e53109ab4ebcfe64a88be6fcf2e3d7e2a6 \"Implement Taproot validation (BIP 341)\"\r\n\r\nnit: move this change to the commit `ANNEX_TAG` was introduced.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-12T19:39:26Z",
      "diff_hunk" : "@@ -47,7 +47,7 @@ static const uint32_t LOCKTIME_MAX = 0xFFFFFFFFU;\n // Tag for input annex. If there are at least two witness elements for a transaction input,\n // and the first byte of the last element is 0x50, this last element is called annex, and\n // has meanings independent of the script\n-static const unsigned int ANNEX_TAG = 0x50;\n+static constexpr unsigned int ANNEX_TAG = 0x50;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503495197",
      "id" : 503495197,
      "line" : 50,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ5NTE5Nw==",
      "original_commit_id" : "4e6196e53109ab4ebcfe64a88be6fcf2e3d7e2a6",
      "original_line" : 50,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/script/script.h",
      "position" : 7,
      "pull_request_review_id" : 506848576,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503495197",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Code review ACK cc036c251c16eda1cdc558db2049e8db0f3a50b7\r\n\r\nHope I can get enough testing in soon to get to a full ACK.",
      "created_at" : "2020-10-13T00:17:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-707410196",
      "id" : 707410196,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwNzQxMDE5Ng==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-13T00:17:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/707410196",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1322187?v=4",
         "events_url" : "https://api.github.com/users/fjahr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fjahr/followers",
         "following_url" : "https://api.github.com/users/fjahr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fjahr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fjahr",
         "id" : 1322187,
         "login" : "fjahr",
         "node_id" : "MDQ6VXNlcjEzMjIxODc=",
         "organizations_url" : "https://api.github.com/users/fjahr/orgs",
         "received_events_url" : "https://api.github.com/users/fjahr/received_events",
         "repos_url" : "https://api.github.com/users/fjahr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fjahr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fjahr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fjahr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503600575"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503600575"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-13T00:21:17Z",
      "diff_hunk" : "@@ -1322,6 +1378,75 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, uint32_t in_pos, uint8_t hash_type, SigVersion sigversion, uint8_t key_version, const PrecomputedTransactionData& cache)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503600575",
      "id" : 503600575,
      "in_reply_to_id" : 503477740,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYwMDU3NQ==",
      "original_commit_id" : "614479450e911dba6938bb7feb85088229faf9b1",
      "original_line" : 1384,
      "original_position" : 94,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 506992327,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503600575",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503600601"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503600601"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-13T00:21:23Z",
      "diff_hunk" : "@@ -47,7 +47,7 @@ static const uint32_t LOCKTIME_MAX = 0xFFFFFFFFU;\n // Tag for input annex. If there are at least two witness elements for a transaction input,\n // and the first byte of the last element is 0x50, this last element is called annex, and\n // has meanings independent of the script\n-static const unsigned int ANNEX_TAG = 0x50;\n+static constexpr unsigned int ANNEX_TAG = 0x50;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503600601",
      "id" : 503600601,
      "in_reply_to_id" : 503495197,
      "line" : 50,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYwMDYwMQ==",
      "original_commit_id" : "4e6196e53109ab4ebcfe64a88be6fcf2e3d7e2a6",
      "original_line" : 50,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/script/script.h",
      "position" : 7,
      "pull_request_review_id" : 506992351,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503600601",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503600634"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503600634"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-13T00:21:33Z",
      "diff_hunk" : "@@ -1504,58 +1791,146 @@ bool GenericTransactionSignatureChecker<T>::CheckSequence(const CScriptNum& nSeq\n template class GenericTransactionSignatureChecker<CTransaction>;\n template class GenericTransactionSignatureChecker<CMutableTransaction>;\n \n-static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, ScriptExecutionData& execdata, ScriptError* serror)\n {\n     std::vector<valtype> stack{stack_span.begin(), stack_span.end()};\n \n+    if (sigversion == SigVersion::TAPSCRIPT) {\n+        // OP_SUCCESSx processing overrides everything, including stack element size limits\n+        CScript::const_iterator pc = scriptPubKey.begin();\n+        while (pc < scriptPubKey.end()) {\n+            opcodetype opcode;\n+            if (!scriptPubKey.GetOp(pc, opcode)) {\n+                // Note how this condition would not be reached if an unknown OP_SUCCESSx was found\n+                return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n+            }\n+            // New opcodes will be listed here. May use a different sigversion to modify existing opcodes.\n+            if (IsOpSuccess(opcode)) {\n+                if (flags & SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS) {\n+                    return set_error(serror, SCRIPT_ERR_DISCOURAGE_OP_SUCCESS);\n+                }\n+                return set_success(serror);\n+            }\n+        }\n+\n+        // Tapscript enforces initial stack size limits (altstack is empty here)\n+        if (stack.size() > MAX_STACK_SIZE) {\n+            return set_error(serror, SCRIPT_ERR_STACK_SIZE);\n+        }\n+    }\n+\n     // Disallow stack item size > MAX_SCRIPT_ELEMENT_SIZE in witness stack\n     for (const valtype& elem : stack) {\n         if (elem.size() > MAX_SCRIPT_ELEMENT_SIZE) return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n     }\n \n     // Run the script interpreter.\n-    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, serror)) return false;\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, execdata, serror)) return false;\n \n     // Scripts inside witness implicitly require cleanstack behaviour\n     if (stack.size() != 1) return set_error(serror, SCRIPT_ERR_CLEANSTACK);\n     if (!CastToBool(stack.back())) return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n     return true;\n }\n \n-static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, const std::vector<unsigned char>& program, const CScript& script, uint256* tapleaf_hash)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503600634",
      "id" : 503600634,
      "in_reply_to_id" : 502483744,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYwMDYzNA==",
      "original_commit_id" : "4a7e0171c0eec437c5de2b0eb316c5088e5b07b0",
      "original_line" : 1834,
      "original_position" : 548,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 506992392,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503600634",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503600678"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503600678"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-13T00:21:44Z",
      "diff_hunk" : "@@ -363,15 +360,75 @@ static bool EvalChecksig(const valtype& vchSig, const valtype& vchPubKey, CScrip\n         //serror is set\n         return false;\n     }\n-    fSuccess = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion);\n+    fSuccess = checker.CheckECDSASignature(vchSig, vchPubKey, scriptCode, sigversion);\n \n     if (!fSuccess && (flags & SCRIPT_VERIFY_NULLFAIL) && vchSig.size())\n         return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);\n \n     return true;\n }\n \n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)\n+static bool EvalChecksigTapscript(const valtype& sig, const valtype& pubkey, ScriptExecutionData& execdata, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& success)\n+{\n+    assert(sigversion == SigVersion::TAPSCRIPT);\n+\n+    /*\n+     *  The following validation sequence is consensus critical. Please note how --\n+     *    upgradable public key versions precede other rules;\n+     *    the script execution fails when using empty signature with invalid public key;\n+     *    the script execution fails when using non-empty invalid signature.\n+     */\n+    success = !sig.empty();\n+    if (success) {\n+        // Implement the sigops/witnesssize ratio test.\n+        // Passing with an upgradable public key version is also counted.\n+        assert(execdata.m_validation_weight_left_init);\n+        execdata.m_validation_weight_left -= VALIDATION_WEIGHT_PER_SIGOP_PASSED;\n+        if (execdata.m_validation_weight_left < 0) {\n+            return set_error(serror, SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT);\n+        }\n+    }\n+    if (pubkey.size() == 0) {\n+        return set_error(serror, SCRIPT_ERR_PUBKEYTYPE);\n+    } else if (pubkey.size() == 32) {\n+        if (success && !checker.CheckSchnorrSignature(sig, pubkey, sigversion, execdata, serror)) {\n+            return false; // serror is set\n+        }\n+    } else {\n+        /*\n+         *  New public key version softforks should be defined before this `else` block.\n+         *  Generally, the new code should not do anything but failing the script execution. To avoid\n+         *  consensus bugs, it should not modify any existing values (including `success`).\n+         */\n+        if ((flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE) != 0) {\n+            return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE);\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+/** Helper for OP_CHECKSIG, OP_CHECKSIGVERIFY, and (in Tapscript) OP_CHECKSIGADD.\n+ *\n+ * A return value of false means the script fails entirely. When true is returned, the\n+ * fuccess variable indicates whether the signature check itself succeeded.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r503600678",
      "id" : 503600678,
      "in_reply_to_id" : 503236815,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYwMDY3OA==",
      "original_commit_id" : "cc036c251c16eda1cdc558db2049e8db0f3a50b7",
      "original_line" : 414,
      "original_position" : 74,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 506992445,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T00:21:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/503600678",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I addressed comments by @jnewbery, @instagibbs, and @achow101 above. The changes to the final tree are listed in #19997.",
      "created_at" : "2020-10-13T00:25:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-707412343",
      "id" : 707412343,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwNzQxMjM0Mw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-13T00:25:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/707412343",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "reACK https://github.com/bitcoin/bitcoin/pull/19953/commits/0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-13T01:07:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-707423354",
      "id" : 707423354,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwNzQyMzM1NA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-13T01:07:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/707423354",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "reACK 0e2a5e4",
      "created_at" : "2020-10-13T01:26:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-707428439",
      "id" : 707428439,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwNzQyODQzOQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-13T01:26:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/707428439",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/15256660?v=4",
         "events_url" : "https://api.github.com/users/benthecarman/events{/privacy}",
         "followers_url" : "https://api.github.com/users/benthecarman/followers",
         "following_url" : "https://api.github.com/users/benthecarman/following{/other_user}",
         "gists_url" : "https://api.github.com/users/benthecarman/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/benthecarman",
         "id" : 15256660,
         "login" : "benthecarman",
         "node_id" : "MDQ6VXNlcjE1MjU2NjYw",
         "organizations_url" : "https://api.github.com/users/benthecarman/orgs",
         "received_events_url" : "https://api.github.com/users/benthecarman/received_events",
         "repos_url" : "https://api.github.com/users/benthecarman/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/benthecarman/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/benthecarman/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/benthecarman"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "reACK 0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-13T02:14:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-707441509",
      "id" : 707441509,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwNzQ0MTUwOQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-13T02:14:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/707441509",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "ACK 0e2a5e448f426219a6464b9aaadcc715534114e6 almost only looked at bip340/libsecp related code",
      "created_at" : "2020-10-13T07:06:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-707538417",
      "id" : 707538417,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwNzUzODQxNw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-13T07:06:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/707538417",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/2582071?v=4",
         "events_url" : "https://api.github.com/users/jonasnick/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasnick/followers",
         "following_url" : "https://api.github.com/users/jonasnick/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasnick/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasnick",
         "id" : 2582071,
         "login" : "jonasnick",
         "node_id" : "MDQ6VXNlcjI1ODIwNzE=",
         "organizations_url" : "https://api.github.com/users/jonasnick/orgs",
         "received_events_url" : "https://api.github.com/users/jonasnick/received_events",
         "repos_url" : "https://api.github.com/users/jonasnick/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasnick/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasnick/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasnick"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "ACK 0e2a5e448f426219a6464b9aaadcc715534114e6 modulo the last four commits (tests) that I plan to finish reviewing tomorrow\r\n",
      "created_at" : "2020-10-13T16:35:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-707864888",
      "id" : 707864888,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwNzg2NDg4OA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-13T16:35:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/707864888",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r504219510"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/504219510"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In 3c226639eb134314a0640d34e4ccb6148dbde22f \"tests: add BIP340 Schnorr signature support to test framework\"\r\n\r\nnit: The code here seems to be entirely unnecessary as `lift_x` ensures the evenness of `y` is correct. I commented out these 2 lines and no tests failed.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-13T19:57:56Z",
      "diff_hunk" : "@@ -223,7 +242,7 @@ def set(self, data):\n                 p = SECP256K1.lift_x(x)\n                 # if the oddness of the y co-ord isn't correct, find the other\n                 # valid y\n-                if (p[1] & 1) != (data[0] & 1):\n+                if data[0] & 1:\n                     p = SECP256K1.negate(p)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r504219510",
      "id" : 504219510,
      "line" : 246,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDIxOTUxMA==",
      "original_commit_id" : "3c226639eb134314a0640d34e4ccb6148dbde22f",
      "original_line" : 246,
      "original_position" : 74,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : 74,
      "pull_request_review_id" : 507781208,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T21:43:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/504219510",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r504240763"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/504240763"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In 3c226639eb134314a0640d34e4ccb6148dbde22f \"tests: add BIP340 Schnorr signature support to test framework\"\r\n\r\nnit: This should be `self.fail` rather than `assertFalse`.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-13T20:31:52Z",
      "diff_hunk" : "@@ -369,3 +392,161 @@ def sign_ecdsa(self, msg, low_s=True):\n         rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')\n         sb = s.to_bytes((s.bit_length() + 8) // 8, 'big')\n         return b'\\x30' + bytes([4 + len(rb) + len(sb), 2, len(rb)]) + rb + bytes([2, len(sb)]) + sb\n+\n+def compute_xonly_pubkey(key):\n+    \"\"\"Compute an x-only (32 byte) public key from a (32 byte) private key.\n+\n+    This also returns whether the resulting public key was negated.\n+    \"\"\"\n+\n+    assert len(key) == 32\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return (None, None)\n+    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, x)]))\n+    return (P[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(P))\n+\n+def tweak_add_privkey(key, tweak):\n+    \"\"\"Tweak a private key (after negating it if needed).\"\"\"\n+\n+    assert len(key) == 32\n+    assert len(tweak) == 32\n+\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return None\n+    if not SECP256K1.has_even_y(SECP256K1.mul([(SECP256K1_G, x)])):\n+       x = SECP256K1_ORDER - x\n+    t = int.from_bytes(tweak, 'big')\n+    if t >= SECP256K1_ORDER:\n+        return None\n+    x = (x + t) % SECP256K1_ORDER\n+    if x == 0:\n+        return None\n+    return x.to_bytes(32, 'big')\n+\n+def tweak_add_pubkey(key, tweak):\n+    \"\"\"Tweak a public key and return whether the result had to be negated.\"\"\"\n+\n+    assert len(key) == 32\n+    assert len(tweak) == 32\n+\n+    x_coord = int.from_bytes(key, 'big')\n+    if x_coord >= SECP256K1_FIELD_SIZE:\n+        return None\n+    P = SECP256K1.lift_x(x_coord)\n+    if P is None:\n+        return None\n+    t = int.from_bytes(tweak, 'big')\n+    if t >= SECP256K1_ORDER:\n+        return None\n+    Q = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, t), (P, 1)]))\n+    if Q is None:\n+        return None\n+    return (Q[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(Q))\n+\n+def verify_schnorr(key, sig, msg):\n+    \"\"\"Verify a Schnorr signature (see BIP 340).\n+\n+    - key is a 32-byte xonly pubkey (computed using compute_xonly_pubkey).\n+    - sig is a 64-byte Schnorr signature\n+    - msg is a 32-byte message\n+    \"\"\"\n+    assert len(key) == 32\n+    assert len(msg) == 32\n+    assert len(sig) == 64\n+\n+    x_coord = int.from_bytes(key, 'big')\n+    if x_coord == 0 or x_coord >= SECP256K1_FIELD_SIZE:\n+        return False\n+    P = SECP256K1.lift_x(x_coord)\n+    if P is None:\n+        return False\n+    r = int.from_bytes(sig[0:32], 'big')\n+    if r >= SECP256K1_FIELD_SIZE:\n+        return False\n+    s = int.from_bytes(sig[32:64], 'big')\n+    if s >= SECP256K1_ORDER:\n+        return False\n+    e = int.from_bytes(TaggedHash(\"BIP0340/challenge\", sig[0:32] + key + msg), 'big') % SECP256K1_ORDER\n+    R = SECP256K1.mul([(SECP256K1_G, s), (P, SECP256K1_ORDER - e)])\n+    if not SECP256K1.has_even_y(R):\n+        return False\n+    if ((r * R[2] * R[2]) % SECP256K1_FIELD_SIZE) != R[0]:\n+        return False\n+    return True\n+\n+def sign_schnorr(key, msg, aux=None):\n+    \"\"\"Create a Schnorr signature (see BIP 340).\"\"\"\n+\n+    if aux is None:\n+        aux = bytes(32)\n+\n+    assert len(key) == 32\n+    assert len(msg) == 32\n+    assert len(aux) == 32\n+\n+    sec = int.from_bytes(key, 'big')\n+    if sec == 0 or sec >= SECP256K1_ORDER:\n+        return None\n+    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, sec)]))\n+    if not SECP256K1.has_even_y(P):\n+        sec = SECP256K1_ORDER - sec\n+    t = (sec ^ int.from_bytes(TaggedHash(\"BIP0340/aux\", aux), 'big')).to_bytes(32, 'big')\n+    kp = int.from_bytes(TaggedHash(\"BIP0340/nonce\", t + P[0].to_bytes(32, 'big') + msg), 'big') % SECP256K1_ORDER\n+    assert kp != 0\n+    R = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, kp)]))\n+    k = kp if SECP256K1.has_even_y(R) else SECP256K1_ORDER - kp\n+    e = int.from_bytes(TaggedHash(\"BIP0340/challenge\", R[0].to_bytes(32, 'big') + P[0].to_bytes(32, 'big') + msg), 'big') % SECP256K1_ORDER\n+    return R[0].to_bytes(32, 'big') + ((k + e * sec) % SECP256K1_ORDER).to_bytes(32, 'big')\n+\n+class TestFrameworkKey(unittest.TestCase):\n+    def test_schnorr(self):\n+        \"\"\"Test the Python Schnorr implementation.\"\"\"\n+        byte_arrays = [generate_privkey() for _ in range(3)] + [v.to_bytes(32, 'big') for v in [0, SECP256K1_ORDER - 1, SECP256K1_ORDER, 2**256 - 1]]\n+        keys = {}\n+        for privkey in byte_arrays:  # build array of key/pubkey pairs\n+            pubkey, _ = compute_xonly_pubkey(privkey)\n+            if pubkey is not None:\n+                keys[privkey] = pubkey\n+        for msg in byte_arrays:  # test every combination of message, signing key, verification key\n+            for sign_privkey, sign_pubkey in keys.items():\n+                sig = sign_schnorr(sign_privkey, msg)\n+                for verify_privkey, verify_pubkey in keys.items():\n+                    if verify_privkey == sign_privkey:\n+                        self.assertTrue(verify_schnorr(verify_pubkey, sig, msg))\n+                        sig = list(sig)\n+                        sig[random.randrange(64)] ^= (1 << (random.randrange(8)))  # damaging signature should break things\n+                        sig = bytes(sig)\n+                    self.assertFalse(verify_schnorr(verify_pubkey, sig, msg))\n+\n+    def test_schnorr_testvectors(self):\n+        \"\"\"Implement the BIP340 test vectors (read from bip340_test_vectors.csv).\"\"\"\n+        num_tests = 0\n+        with open(os.path.join(sys.path[0], 'test_framework', 'bip340_test_vectors.csv'), newline='', encoding='utf8') as csvfile:\n+            reader = csv.reader(csvfile)\n+            next(reader)\n+            for row in reader:\n+                (i_str, seckey_hex, pubkey_hex, aux_rand_hex, msg_hex, sig_hex, result_str, comment) = row\n+                i = int(i_str)\n+                pubkey = bytes.fromhex(pubkey_hex)\n+                msg = bytes.fromhex(msg_hex)\n+                sig = bytes.fromhex(sig_hex)\n+                result = result_str == 'TRUE'\n+                if seckey_hex != '':\n+                    seckey = bytes.fromhex(seckey_hex)\n+                    pubkey_actual = compute_xonly_pubkey(seckey)[0]\n+                    self.assertEqual(pubkey.hex(), pubkey_actual.hex(), \"BIP340 test vector %i (%s): pubkey mismatch\" % (i, comment))\n+                    aux_rand = bytes.fromhex(aux_rand_hex)\n+                    try:\n+                        sig_actual = sign_schnorr(seckey, msg, aux_rand)\n+                        self.assertEqual(sig.hex(), sig_actual.hex(), \"BIP340 test vector %i (%s): sig mismatch\" % (i, comment))\n+                    except RuntimeError as e:\n+                        self.assertFalse(\"BIP340 test vector %i (%s): signing raised exception %s\" % (i, comment, e))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r504240763",
      "id" : 504240763,
      "line" : 545,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI0MDc2Mw==",
      "original_commit_id" : "3c226639eb134314a0640d34e4ccb6148dbde22f",
      "original_line" : 545,
      "original_position" : 251,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : 251,
      "pull_request_review_id" : 507781208,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T21:43:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/504240763",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "reACK 0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-13T22:28:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#issuecomment-708043623",
      "id" : 708043623,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19953",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwODA0MzYyMw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-13T22:28:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/708043623",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1322187?v=4",
         "events_url" : "https://api.github.com/users/fjahr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fjahr/followers",
         "following_url" : "https://api.github.com/users/fjahr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fjahr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fjahr",
         "id" : 1322187,
         "login" : "fjahr",
         "node_id" : "MDQ6VXNlcjEzMjIxODc=",
         "organizations_url" : "https://api.github.com/users/fjahr/orgs",
         "received_events_url" : "https://api.github.com/users/fjahr/received_events",
         "repos_url" : "https://api.github.com/users/fjahr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fjahr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fjahr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fjahr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r504306999"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/504306999"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think the only thing that's wrong here is the comment: with this change, it's not longer \"correcting\" the oddness; it's just negating if an odd Y coordinate is desired.\r\n\r\nThe code is necessary though, but possibly untested. It's what constructs a point from a compressed public key. It's only used for ECDSA (as BIP340 public keys are x-only, not compressed), and unused in the current tests (which only use the signing side of ECDSA).\r\n\r\nGoing to leave this for a follow-up, as it's not directly related to Taproot testing.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-13T23:02:43Z",
      "diff_hunk" : "@@ -223,7 +242,7 @@ def set(self, data):\n                 p = SECP256K1.lift_x(x)\n                 # if the oddness of the y co-ord isn't correct, find the other\n                 # valid y\n-                if (p[1] & 1) != (data[0] & 1):\n+                if data[0] & 1:\n                     p = SECP256K1.negate(p)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r504306999",
      "id" : 504306999,
      "in_reply_to_id" : 504219510,
      "line" : 246,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDMwNjk5OQ==",
      "original_commit_id" : "3c226639eb134314a0640d34e4ccb6148dbde22f",
      "original_line" : 246,
      "original_position" : 74,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : 74,
      "pull_request_review_id" : 507887588,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T23:02:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/504306999",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r504314957"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/504314957"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Indeed, will fix in a follow-up.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-13T23:27:31Z",
      "diff_hunk" : "@@ -369,3 +392,161 @@ def sign_ecdsa(self, msg, low_s=True):\n         rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')\n         sb = s.to_bytes((s.bit_length() + 8) // 8, 'big')\n         return b'\\x30' + bytes([4 + len(rb) + len(sb), 2, len(rb)]) + rb + bytes([2, len(sb)]) + sb\n+\n+def compute_xonly_pubkey(key):\n+    \"\"\"Compute an x-only (32 byte) public key from a (32 byte) private key.\n+\n+    This also returns whether the resulting public key was negated.\n+    \"\"\"\n+\n+    assert len(key) == 32\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return (None, None)\n+    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, x)]))\n+    return (P[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(P))\n+\n+def tweak_add_privkey(key, tweak):\n+    \"\"\"Tweak a private key (after negating it if needed).\"\"\"\n+\n+    assert len(key) == 32\n+    assert len(tweak) == 32\n+\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return None\n+    if not SECP256K1.has_even_y(SECP256K1.mul([(SECP256K1_G, x)])):\n+       x = SECP256K1_ORDER - x\n+    t = int.from_bytes(tweak, 'big')\n+    if t >= SECP256K1_ORDER:\n+        return None\n+    x = (x + t) % SECP256K1_ORDER\n+    if x == 0:\n+        return None\n+    return x.to_bytes(32, 'big')\n+\n+def tweak_add_pubkey(key, tweak):\n+    \"\"\"Tweak a public key and return whether the result had to be negated.\"\"\"\n+\n+    assert len(key) == 32\n+    assert len(tweak) == 32\n+\n+    x_coord = int.from_bytes(key, 'big')\n+    if x_coord >= SECP256K1_FIELD_SIZE:\n+        return None\n+    P = SECP256K1.lift_x(x_coord)\n+    if P is None:\n+        return None\n+    t = int.from_bytes(tweak, 'big')\n+    if t >= SECP256K1_ORDER:\n+        return None\n+    Q = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, t), (P, 1)]))\n+    if Q is None:\n+        return None\n+    return (Q[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(Q))\n+\n+def verify_schnorr(key, sig, msg):\n+    \"\"\"Verify a Schnorr signature (see BIP 340).\n+\n+    - key is a 32-byte xonly pubkey (computed using compute_xonly_pubkey).\n+    - sig is a 64-byte Schnorr signature\n+    - msg is a 32-byte message\n+    \"\"\"\n+    assert len(key) == 32\n+    assert len(msg) == 32\n+    assert len(sig) == 64\n+\n+    x_coord = int.from_bytes(key, 'big')\n+    if x_coord == 0 or x_coord >= SECP256K1_FIELD_SIZE:\n+        return False\n+    P = SECP256K1.lift_x(x_coord)\n+    if P is None:\n+        return False\n+    r = int.from_bytes(sig[0:32], 'big')\n+    if r >= SECP256K1_FIELD_SIZE:\n+        return False\n+    s = int.from_bytes(sig[32:64], 'big')\n+    if s >= SECP256K1_ORDER:\n+        return False\n+    e = int.from_bytes(TaggedHash(\"BIP0340/challenge\", sig[0:32] + key + msg), 'big') % SECP256K1_ORDER\n+    R = SECP256K1.mul([(SECP256K1_G, s), (P, SECP256K1_ORDER - e)])\n+    if not SECP256K1.has_even_y(R):\n+        return False\n+    if ((r * R[2] * R[2]) % SECP256K1_FIELD_SIZE) != R[0]:\n+        return False\n+    return True\n+\n+def sign_schnorr(key, msg, aux=None):\n+    \"\"\"Create a Schnorr signature (see BIP 340).\"\"\"\n+\n+    if aux is None:\n+        aux = bytes(32)\n+\n+    assert len(key) == 32\n+    assert len(msg) == 32\n+    assert len(aux) == 32\n+\n+    sec = int.from_bytes(key, 'big')\n+    if sec == 0 or sec >= SECP256K1_ORDER:\n+        return None\n+    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, sec)]))\n+    if not SECP256K1.has_even_y(P):\n+        sec = SECP256K1_ORDER - sec\n+    t = (sec ^ int.from_bytes(TaggedHash(\"BIP0340/aux\", aux), 'big')).to_bytes(32, 'big')\n+    kp = int.from_bytes(TaggedHash(\"BIP0340/nonce\", t + P[0].to_bytes(32, 'big') + msg), 'big') % SECP256K1_ORDER\n+    assert kp != 0\n+    R = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, kp)]))\n+    k = kp if SECP256K1.has_even_y(R) else SECP256K1_ORDER - kp\n+    e = int.from_bytes(TaggedHash(\"BIP0340/challenge\", R[0].to_bytes(32, 'big') + P[0].to_bytes(32, 'big') + msg), 'big') % SECP256K1_ORDER\n+    return R[0].to_bytes(32, 'big') + ((k + e * sec) % SECP256K1_ORDER).to_bytes(32, 'big')\n+\n+class TestFrameworkKey(unittest.TestCase):\n+    def test_schnorr(self):\n+        \"\"\"Test the Python Schnorr implementation.\"\"\"\n+        byte_arrays = [generate_privkey() for _ in range(3)] + [v.to_bytes(32, 'big') for v in [0, SECP256K1_ORDER - 1, SECP256K1_ORDER, 2**256 - 1]]\n+        keys = {}\n+        for privkey in byte_arrays:  # build array of key/pubkey pairs\n+            pubkey, _ = compute_xonly_pubkey(privkey)\n+            if pubkey is not None:\n+                keys[privkey] = pubkey\n+        for msg in byte_arrays:  # test every combination of message, signing key, verification key\n+            for sign_privkey, sign_pubkey in keys.items():\n+                sig = sign_schnorr(sign_privkey, msg)\n+                for verify_privkey, verify_pubkey in keys.items():\n+                    if verify_privkey == sign_privkey:\n+                        self.assertTrue(verify_schnorr(verify_pubkey, sig, msg))\n+                        sig = list(sig)\n+                        sig[random.randrange(64)] ^= (1 << (random.randrange(8)))  # damaging signature should break things\n+                        sig = bytes(sig)\n+                    self.assertFalse(verify_schnorr(verify_pubkey, sig, msg))\n+\n+    def test_schnorr_testvectors(self):\n+        \"\"\"Implement the BIP340 test vectors (read from bip340_test_vectors.csv).\"\"\"\n+        num_tests = 0\n+        with open(os.path.join(sys.path[0], 'test_framework', 'bip340_test_vectors.csv'), newline='', encoding='utf8') as csvfile:\n+            reader = csv.reader(csvfile)\n+            next(reader)\n+            for row in reader:\n+                (i_str, seckey_hex, pubkey_hex, aux_rand_hex, msg_hex, sig_hex, result_str, comment) = row\n+                i = int(i_str)\n+                pubkey = bytes.fromhex(pubkey_hex)\n+                msg = bytes.fromhex(msg_hex)\n+                sig = bytes.fromhex(sig_hex)\n+                result = result_str == 'TRUE'\n+                if seckey_hex != '':\n+                    seckey = bytes.fromhex(seckey_hex)\n+                    pubkey_actual = compute_xonly_pubkey(seckey)[0]\n+                    self.assertEqual(pubkey.hex(), pubkey_actual.hex(), \"BIP340 test vector %i (%s): pubkey mismatch\" % (i, comment))\n+                    aux_rand = bytes.fromhex(aux_rand_hex)\n+                    try:\n+                        sig_actual = sign_schnorr(seckey, msg, aux_rand)\n+                        self.assertEqual(sig.hex(), sig_actual.hex(), \"BIP340 test vector %i (%s): sig mismatch\" % (i, comment))\n+                    except RuntimeError as e:\n+                        self.assertFalse(\"BIP340 test vector %i (%s): signing raised exception %s\" % (i, comment, e))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r504314957",
      "id" : 504314957,
      "in_reply_to_id" : 504240763,
      "line" : 545,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDMxNDk1Nw==",
      "original_commit_id" : "3c226639eb134314a0640d34e4ccb6148dbde22f",
      "original_line" : 545,
      "original_position" : 251,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : 251,
      "pull_request_review_id" : 507896874,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-13T23:27:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/504314957",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r504758194"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/504758194"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Note to other reviewers: even though this is a move from existing code, I was still curious about whether this assert is safe. There are three call-sites for `CheckInputScripts()`; here they are with the various ways they ensure the input coins aren't already spent (and so this assert won't blow up): \r\n- `MemPoolAccept::PolicyScriptChecks()`: only ever called from `MemPoolAccept::AcceptSingleTransaction()`, which makes a call to `Consensus::CheckTxInputs()` via `MemPoolAccept::PreChecks()` beforehand,\r\n- `CheckInputsFromMempoolAndCache()`: only ever called from `MemPoolAccept::ConsensusScriptChecks()`, which is only ever called from `AcceptSingleTransaction()` (case above),\r\n- `CChainState::ConnectBlock()`: call to `Consensus::CheckTxInputs()` beforehand",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-14T15:11:02Z",
      "diff_hunk" : "@@ -1539,13 +1539,20 @@ bool CheckInputScripts(const CTransaction& tx, TxValidationState &state, const C\n     }\n \n     if (!txdata.m_ready) {\n-        txdata.Init(tx);\n+        std::vector<CTxOut> spent_outputs;\n+        spent_outputs.reserve(tx.vin.size());\n+\n+        for (const auto& txin : tx.vin) {\n+            const COutPoint& prevout = txin.prevout;\n+            const Coin& coin = inputs.AccessCoin(prevout);\n+            assert(!coin.IsSpent());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r504758194",
      "id" : 504758194,
      "line" : 1548,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc1ODE5NA==",
      "original_commit_id" : "5d62e3a68b6ea9bb03556ee1fbf5678f20be01a2",
      "original_line" : 1548,
      "original_position" : 11,
      "original_start_line" : null,
      "path" : "src/validation.cpp",
      "position" : 13,
      "pull_request_review_id" : 508453085,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-14T17:26:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/504758194",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r504835231"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/504835231"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Note to reviewers: serializes as `[hash][out_index]` per `COutPoint` ([c.f. BIP](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#common-signature-message)).",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-14T17:02:56Z",
      "diff_hunk" : "@@ -1322,6 +1378,75 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, uint32_t in_pos, uint8_t hash_type, SigVersion sigversion, const PrecomputedTransactionData& cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache.m_bip341_taproot_ready && cache.m_spent_outputs_ready);\n+\n+    CHashWriter ss = HASHER_TAPSIGHASH;\n+\n+    // Epoch\n+    static constexpr uint8_t EPOCH = 0;\n+    ss << EPOCH;\n+\n+    // Hash type\n+    const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n+    const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;\n+    if (!(hash_type <= 0x03 || (hash_type >= 0x81 && hash_type <= 0x83))) return false;\n+    ss << hash_type;\n+\n+    // Transaction level data\n+    ss << tx_to.nVersion;\n+    ss << tx_to.nLockTime;\n+    if (input_type != SIGHASH_ANYONECANPAY) {\n+        ss << cache.m_prevouts_single_hash;\n+        ss << cache.m_spent_amounts_single_hash;\n+        ss << cache.m_spent_scripts_single_hash;\n+        ss << cache.m_sequences_single_hash;\n+    }\n+    if (output_type == SIGHASH_ALL) {\n+        ss << cache.m_outputs_single_hash;\n+    }\n+\n+    // Data about the input/prevout being spent\n+    const auto& witstack = tx_to.vin[in_pos].scriptWitness.stack;\n+    bool have_annex = witstack.size() > 1 && witstack.back().size() > 0 && witstack.back()[0] == ANNEX_TAG;\n+    const uint8_t spend_type = (ext_flag << 1) + (have_annex ? 1 : 0); // The low bit indicates whether an annex is present.\n+    ss << spend_type;\n+    if (input_type == SIGHASH_ANYONECANPAY) {\n+        ss << tx_to.vin[in_pos].prevout;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r504835231",
      "id" : 504835231,
      "line" : 1545,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgzNTIzMQ==",
      "original_commit_id" : "5de246ca8159dcffaa4c136a60c8bfed2028e2ee",
      "original_line" : 1428,
      "original_position" : 138,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 392,
      "pull_request_review_id" : 508453085,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-14T17:26:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/504835231",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r504835738"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/504835738"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Note to reviewers: serializes as `[amount i.e. nValue][scriptPubKey]` per `CTxOut` ([c.f. BIP](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#common-signature-message)).",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-14T17:03:49Z",
      "diff_hunk" : "@@ -1322,6 +1378,75 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, uint32_t in_pos, uint8_t hash_type, SigVersion sigversion, const PrecomputedTransactionData& cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache.m_bip341_taproot_ready && cache.m_spent_outputs_ready);\n+\n+    CHashWriter ss = HASHER_TAPSIGHASH;\n+\n+    // Epoch\n+    static constexpr uint8_t EPOCH = 0;\n+    ss << EPOCH;\n+\n+    // Hash type\n+    const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n+    const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;\n+    if (!(hash_type <= 0x03 || (hash_type >= 0x81 && hash_type <= 0x83))) return false;\n+    ss << hash_type;\n+\n+    // Transaction level data\n+    ss << tx_to.nVersion;\n+    ss << tx_to.nLockTime;\n+    if (input_type != SIGHASH_ANYONECANPAY) {\n+        ss << cache.m_prevouts_single_hash;\n+        ss << cache.m_spent_amounts_single_hash;\n+        ss << cache.m_spent_scripts_single_hash;\n+        ss << cache.m_sequences_single_hash;\n+    }\n+    if (output_type == SIGHASH_ALL) {\n+        ss << cache.m_outputs_single_hash;\n+    }\n+\n+    // Data about the input/prevout being spent\n+    const auto& witstack = tx_to.vin[in_pos].scriptWitness.stack;\n+    bool have_annex = witstack.size() > 1 && witstack.back().size() > 0 && witstack.back()[0] == ANNEX_TAG;\n+    const uint8_t spend_type = (ext_flag << 1) + (have_annex ? 1 : 0); // The low bit indicates whether an annex is present.\n+    ss << spend_type;\n+    if (input_type == SIGHASH_ANYONECANPAY) {\n+        ss << tx_to.vin[in_pos].prevout;\n+        ss << cache.m_spent_outputs[in_pos];",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r504835738",
      "id" : 504835738,
      "line" : 1546,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgzNTczOA==",
      "original_commit_id" : "5de246ca8159dcffaa4c136a60c8bfed2028e2ee",
      "original_line" : 1429,
      "original_position" : 139,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 393,
      "pull_request_review_id" : 508453085,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-14T17:26:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/504835738",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r504840884"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/504840884"
         }
      },
      "author_association" : "MEMBER",
      "body" : "So far as I can tell, the [ordering of serialization](https://github.com/jamesob/bitcoin/blob/301959fa7482cf749504864789e6f9f4470b8bb6/src/serialize.h#L238) is reversed here relative to what [the BIP](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#common-signature-message) says (\"the SHA256 of *(compact_size(size of annex) || annex)*\"). Existing serialization looks like it has the size coming after the annex itself. Even if I'm right, not sure how much this matters.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-14T17:12:21Z",
      "diff_hunk" : "@@ -1322,6 +1378,75 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, uint32_t in_pos, uint8_t hash_type, SigVersion sigversion, const PrecomputedTransactionData& cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache.m_bip341_taproot_ready && cache.m_spent_outputs_ready);\n+\n+    CHashWriter ss = HASHER_TAPSIGHASH;\n+\n+    // Epoch\n+    static constexpr uint8_t EPOCH = 0;\n+    ss << EPOCH;\n+\n+    // Hash type\n+    const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n+    const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;\n+    if (!(hash_type <= 0x03 || (hash_type >= 0x81 && hash_type <= 0x83))) return false;\n+    ss << hash_type;\n+\n+    // Transaction level data\n+    ss << tx_to.nVersion;\n+    ss << tx_to.nLockTime;\n+    if (input_type != SIGHASH_ANYONECANPAY) {\n+        ss << cache.m_prevouts_single_hash;\n+        ss << cache.m_spent_amounts_single_hash;\n+        ss << cache.m_spent_scripts_single_hash;\n+        ss << cache.m_sequences_single_hash;\n+    }\n+    if (output_type == SIGHASH_ALL) {\n+        ss << cache.m_outputs_single_hash;\n+    }\n+\n+    // Data about the input/prevout being spent\n+    const auto& witstack = tx_to.vin[in_pos].scriptWitness.stack;\n+    bool have_annex = witstack.size() > 1 && witstack.back().size() > 0 && witstack.back()[0] == ANNEX_TAG;\n+    const uint8_t spend_type = (ext_flag << 1) + (have_annex ? 1 : 0); // The low bit indicates whether an annex is present.\n+    ss << spend_type;\n+    if (input_type == SIGHASH_ANYONECANPAY) {\n+        ss << tx_to.vin[in_pos].prevout;\n+        ss << cache.m_spent_outputs[in_pos];\n+        ss << tx_to.vin[in_pos].nSequence;\n+    } else {\n+        ss << in_pos;\n+    }\n+    if (have_annex) {\n+        ss << (CHashWriter(SER_GETHASH, 0) << witstack.back()).GetSHA256();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r504840884",
      "id" : 504840884,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg0MDg4NA==",
      "original_commit_id" : "5de246ca8159dcffaa4c136a60c8bfed2028e2ee",
      "original_line" : 1435,
      "original_position" : 145,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 508453085,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-14T17:26:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/504840884",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r504851774"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/504851774"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't understand. Why would the length go after the data? Nothing serializes that way, and the functional tests would fail if that was the case.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-14T17:30:49Z",
      "diff_hunk" : "@@ -1322,6 +1378,75 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, uint32_t in_pos, uint8_t hash_type, SigVersion sigversion, const PrecomputedTransactionData& cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache.m_bip341_taproot_ready && cache.m_spent_outputs_ready);\n+\n+    CHashWriter ss = HASHER_TAPSIGHASH;\n+\n+    // Epoch\n+    static constexpr uint8_t EPOCH = 0;\n+    ss << EPOCH;\n+\n+    // Hash type\n+    const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n+    const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;\n+    if (!(hash_type <= 0x03 || (hash_type >= 0x81 && hash_type <= 0x83))) return false;\n+    ss << hash_type;\n+\n+    // Transaction level data\n+    ss << tx_to.nVersion;\n+    ss << tx_to.nLockTime;\n+    if (input_type != SIGHASH_ANYONECANPAY) {\n+        ss << cache.m_prevouts_single_hash;\n+        ss << cache.m_spent_amounts_single_hash;\n+        ss << cache.m_spent_scripts_single_hash;\n+        ss << cache.m_sequences_single_hash;\n+    }\n+    if (output_type == SIGHASH_ALL) {\n+        ss << cache.m_outputs_single_hash;\n+    }\n+\n+    // Data about the input/prevout being spent\n+    const auto& witstack = tx_to.vin[in_pos].scriptWitness.stack;\n+    bool have_annex = witstack.size() > 1 && witstack.back().size() > 0 && witstack.back()[0] == ANNEX_TAG;\n+    const uint8_t spend_type = (ext_flag << 1) + (have_annex ? 1 : 0); // The low bit indicates whether an annex is present.\n+    ss << spend_type;\n+    if (input_type == SIGHASH_ANYONECANPAY) {\n+        ss << tx_to.vin[in_pos].prevout;\n+        ss << cache.m_spent_outputs[in_pos];\n+        ss << tx_to.vin[in_pos].nSequence;\n+    } else {\n+        ss << in_pos;\n+    }\n+    if (have_annex) {\n+        ss << (CHashWriter(SER_GETHASH, 0) << witstack.back()).GetSHA256();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r504851774",
      "id" : 504851774,
      "in_reply_to_id" : 504840884,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg1MTc3NA==",
      "original_commit_id" : "5de246ca8159dcffaa4c136a60c8bfed2028e2ee",
      "original_line" : 1435,
      "original_position" : 145,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 508575514,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-14T17:30:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/504851774",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r504860824"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/504860824"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Based on the serialization code I link to, it looks as though the size is being written after the data itself (which is the reverse of what the BIP says), but maybe I'm missing something?",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-14T17:46:21Z",
      "diff_hunk" : "@@ -1322,6 +1378,75 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, uint32_t in_pos, uint8_t hash_type, SigVersion sigversion, const PrecomputedTransactionData& cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache.m_bip341_taproot_ready && cache.m_spent_outputs_ready);\n+\n+    CHashWriter ss = HASHER_TAPSIGHASH;\n+\n+    // Epoch\n+    static constexpr uint8_t EPOCH = 0;\n+    ss << EPOCH;\n+\n+    // Hash type\n+    const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n+    const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;\n+    if (!(hash_type <= 0x03 || (hash_type >= 0x81 && hash_type <= 0x83))) return false;\n+    ss << hash_type;\n+\n+    // Transaction level data\n+    ss << tx_to.nVersion;\n+    ss << tx_to.nLockTime;\n+    if (input_type != SIGHASH_ANYONECANPAY) {\n+        ss << cache.m_prevouts_single_hash;\n+        ss << cache.m_spent_amounts_single_hash;\n+        ss << cache.m_spent_scripts_single_hash;\n+        ss << cache.m_sequences_single_hash;\n+    }\n+    if (output_type == SIGHASH_ALL) {\n+        ss << cache.m_outputs_single_hash;\n+    }\n+\n+    // Data about the input/prevout being spent\n+    const auto& witstack = tx_to.vin[in_pos].scriptWitness.stack;\n+    bool have_annex = witstack.size() > 1 && witstack.back().size() > 0 && witstack.back()[0] == ANNEX_TAG;\n+    const uint8_t spend_type = (ext_flag << 1) + (have_annex ? 1 : 0); // The low bit indicates whether an annex is present.\n+    ss << spend_type;\n+    if (input_type == SIGHASH_ANYONECANPAY) {\n+        ss << tx_to.vin[in_pos].prevout;\n+        ss << cache.m_spent_outputs[in_pos];\n+        ss << tx_to.vin[in_pos].nSequence;\n+    } else {\n+        ss << in_pos;\n+    }\n+    if (have_annex) {\n+        ss << (CHashWriter(SER_GETHASH, 0) << witstack.back()).GetSHA256();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r504860824",
      "id" : 504860824,
      "in_reply_to_id" : 504840884,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg2MDgyNA==",
      "original_commit_id" : "5de246ca8159dcffaa4c136a60c8bfed2028e2ee",
      "original_line" : 1435,
      "original_position" : 145,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 508587256,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-14T17:46:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/504860824",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r504865277"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/504865277"
         }
      },
      "author_association" : "MEMBER",
      "body" : "That serialization code you link to:\r\n* Is serializing a `Span<const unsigned char>` as a fixed length object, without any length at all. It's invoking the `Stream` function `write(const unsigned char* data, size_t length)`, which writes the `length` bytes starting at `data`. It doesn't write the length itself.\r\n* Isn't used here (witstack.back() is a `std::vector<unsigned char>`, not a `Span<const unsigned char>`), which has different serialization code a bit further down the file.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-14T17:53:36Z",
      "diff_hunk" : "@@ -1322,6 +1378,75 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, uint32_t in_pos, uint8_t hash_type, SigVersion sigversion, const PrecomputedTransactionData& cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache.m_bip341_taproot_ready && cache.m_spent_outputs_ready);\n+\n+    CHashWriter ss = HASHER_TAPSIGHASH;\n+\n+    // Epoch\n+    static constexpr uint8_t EPOCH = 0;\n+    ss << EPOCH;\n+\n+    // Hash type\n+    const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n+    const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;\n+    if (!(hash_type <= 0x03 || (hash_type >= 0x81 && hash_type <= 0x83))) return false;\n+    ss << hash_type;\n+\n+    // Transaction level data\n+    ss << tx_to.nVersion;\n+    ss << tx_to.nLockTime;\n+    if (input_type != SIGHASH_ANYONECANPAY) {\n+        ss << cache.m_prevouts_single_hash;\n+        ss << cache.m_spent_amounts_single_hash;\n+        ss << cache.m_spent_scripts_single_hash;\n+        ss << cache.m_sequences_single_hash;\n+    }\n+    if (output_type == SIGHASH_ALL) {\n+        ss << cache.m_outputs_single_hash;\n+    }\n+\n+    // Data about the input/prevout being spent\n+    const auto& witstack = tx_to.vin[in_pos].scriptWitness.stack;\n+    bool have_annex = witstack.size() > 1 && witstack.back().size() > 0 && witstack.back()[0] == ANNEX_TAG;\n+    const uint8_t spend_type = (ext_flag << 1) + (have_annex ? 1 : 0); // The low bit indicates whether an annex is present.\n+    ss << spend_type;\n+    if (input_type == SIGHASH_ANYONECANPAY) {\n+        ss << tx_to.vin[in_pos].prevout;\n+        ss << cache.m_spent_outputs[in_pos];\n+        ss << tx_to.vin[in_pos].nSequence;\n+    } else {\n+        ss << in_pos;\n+    }\n+    if (have_annex) {\n+        ss << (CHashWriter(SER_GETHASH, 0) << witstack.back()).GetSHA256();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r504865277",
      "id" : 504865277,
      "in_reply_to_id" : 504840884,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg2NTI3Nw==",
      "original_commit_id" : "5de246ca8159dcffaa4c136a60c8bfed2028e2ee",
      "original_line" : 1435,
      "original_position" : 145,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 508592613,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-14T17:54:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/504865277",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r504866309"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/504866309"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Hm yeah I guess I must be wrong because the tests encode in [the right order](https://github.com/bitcoin/bitcoin/pull/19953/commits/f06e6d03452cf5e0b1a0863afb08c9e6d3ef452e#diff-3f25b0e0fbc5dd36a62417827b38517c9c5bdbfc3f4787d5925527c344bda104R775) (per `ser_string`'s [definition](https://github.com/jamesob/bitcoin/blob/301959fa7482cf749504864789e6f9f4470b8bb6/test/functional/test_framework/messages.py#L106-L107)). Maybe I'm looking at the wrong serializer.\r\n\r\nEdit: yup, my mistake!",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-14T17:55:12Z",
      "diff_hunk" : "@@ -1322,6 +1378,75 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, uint32_t in_pos, uint8_t hash_type, SigVersion sigversion, const PrecomputedTransactionData& cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache.m_bip341_taproot_ready && cache.m_spent_outputs_ready);\n+\n+    CHashWriter ss = HASHER_TAPSIGHASH;\n+\n+    // Epoch\n+    static constexpr uint8_t EPOCH = 0;\n+    ss << EPOCH;\n+\n+    // Hash type\n+    const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n+    const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;\n+    if (!(hash_type <= 0x03 || (hash_type >= 0x81 && hash_type <= 0x83))) return false;\n+    ss << hash_type;\n+\n+    // Transaction level data\n+    ss << tx_to.nVersion;\n+    ss << tx_to.nLockTime;\n+    if (input_type != SIGHASH_ANYONECANPAY) {\n+        ss << cache.m_prevouts_single_hash;\n+        ss << cache.m_spent_amounts_single_hash;\n+        ss << cache.m_spent_scripts_single_hash;\n+        ss << cache.m_sequences_single_hash;\n+    }\n+    if (output_type == SIGHASH_ALL) {\n+        ss << cache.m_outputs_single_hash;\n+    }\n+\n+    // Data about the input/prevout being spent\n+    const auto& witstack = tx_to.vin[in_pos].scriptWitness.stack;\n+    bool have_annex = witstack.size() > 1 && witstack.back().size() > 0 && witstack.back()[0] == ANNEX_TAG;\n+    const uint8_t spend_type = (ext_flag << 1) + (have_annex ? 1 : 0); // The low bit indicates whether an annex is present.\n+    ss << spend_type;\n+    if (input_type == SIGHASH_ANYONECANPAY) {\n+        ss << tx_to.vin[in_pos].prevout;\n+        ss << cache.m_spent_outputs[in_pos];\n+        ss << tx_to.vin[in_pos].nSequence;\n+    } else {\n+        ss << in_pos;\n+    }\n+    if (have_annex) {\n+        ss << (CHashWriter(SER_GETHASH, 0) << witstack.back()).GetSHA256();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r504866309",
      "id" : 504866309,
      "in_reply_to_id" : 504840884,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg2NjMwOQ==",
      "original_commit_id" : "5de246ca8159dcffaa4c136a60c8bfed2028e2ee",
      "original_line" : 1435,
      "original_position" : 145,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 508593833,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-14T17:59:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/504866309",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r505234502"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/505234502"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Would have expected `VerifyTaprootCommitment` to take `script` as a `const valtype&` -- future taproot versions might not look like current script at all.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-15T07:01:53Z",
      "diff_hunk" : "@@ -1679,14 +1682,35 @@ static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CS\n     return true;\n }\n \n-static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, const std::vector<unsigned char>& program, const CScript& script)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r505234502",
      "id" : 505234502,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTIzNDUwMg==",
      "original_commit_id" : "8bbed4b7acf4c76eaea8c0e10f3cbf6ba4e53809",
      "original_line" : 1685,
      "original_position" : 15,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 509072495,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-15T08:58:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/505234502",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r505237399"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/505237399"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Could move declaration of `exec_script` closer to its assignment, and make it `const CScript exec_script(script_bytes.begin(), script_bytes.end());` for the p2wsh and p2tr cases.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-15T07:05:10Z",
      "diff_hunk" : "@@ -1679,14 +1682,35 @@ static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CS\n     return true;\n }\n \n-static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, const std::vector<unsigned char>& program, const CScript& script)\n {\n-    CScript exec_script; //!< Actually executed script (last stack item in P2WSH; implied P2PKH script in P2WPKH)\n+    const int path_len = (control.size() - TAPROOT_CONTROL_BASE_SIZE) / TAPROOT_CONTROL_NODE_SIZE;\n+    const XOnlyPubKey p{uint256(std::vector<unsigned char>(control.begin() + 1, control.begin() + TAPROOT_CONTROL_BASE_SIZE))};\n+    const XOnlyPubKey q{uint256(program)};\n+    uint256 tapleaf_hash = (CHashWriter(HASHER_TAPLEAF) << uint8_t(control[0] & TAPROOT_LEAF_MASK) << script).GetSHA256();\n+    uint256 k = tapleaf_hash;\n+    for (int i = 0; i < path_len; ++i) {\n+        CHashWriter ss_branch{HASHER_TAPBRANCH};\n+        Span<const unsigned char> node(control.data() + TAPROOT_CONTROL_BASE_SIZE + TAPROOT_CONTROL_NODE_SIZE * i, TAPROOT_CONTROL_NODE_SIZE);\n+        if (std::lexicographical_compare(k.begin(), k.end(), node.begin(), node.end())) {\n+            ss_branch << k << node;\n+        } else {\n+            ss_branch << node << k;\n+        }\n+        k = ss_branch.GetSHA256();\n+    }\n+    k = (CHashWriter(HASHER_TAPTWEAK) << MakeSpan(p) << k).GetSHA256();\n+    return q.CheckPayToContract(p, k, control[0] & 1);\n+}\n+\n+static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror, bool is_p2sh)\n+{\n+    CScript exec_script; //!< Actually executed script (last stack item in P2WSH; implied P2PKH script in P2WPKH; leaf script in P2TR)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r505237399",
      "id" : 505237399,
      "line" : 1857,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTIzNzM5OQ==",
      "original_commit_id" : "8bbed4b7acf4c76eaea8c0e10f3cbf6ba4e53809",
      "original_line" : 1708,
      "original_position" : 39,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 570,
      "pull_request_review_id" : 509072495,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-15T08:58:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/505237399",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r505887585"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/505887585"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Without #13062 that's annoying to do, as it means constructing both a `valtype` and a `CScript` with the same data. You're right that future version leafs may not want a script at all, but until then, little reason to add this complication.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-15T21:56:24Z",
      "diff_hunk" : "@@ -1679,14 +1682,35 @@ static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CS\n     return true;\n }\n \n-static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, const std::vector<unsigned char>& program, const CScript& script)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r505887585",
      "id" : 505887585,
      "in_reply_to_id" : 505234502,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg4NzU4NQ==",
      "original_commit_id" : "8bbed4b7acf4c76eaea8c0e10f3cbf6ba4e53809",
      "original_line" : 1685,
      "original_position" : 15,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 509837177,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-15T21:56:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/505887585",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r505888403"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/505888403"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yeah, not sure that's worth changing without other improvements though.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-15T21:58:34Z",
      "diff_hunk" : "@@ -1679,14 +1682,35 @@ static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CS\n     return true;\n }\n \n-static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, const std::vector<unsigned char>& program, const CScript& script)\n {\n-    CScript exec_script; //!< Actually executed script (last stack item in P2WSH; implied P2PKH script in P2WPKH)\n+    const int path_len = (control.size() - TAPROOT_CONTROL_BASE_SIZE) / TAPROOT_CONTROL_NODE_SIZE;\n+    const XOnlyPubKey p{uint256(std::vector<unsigned char>(control.begin() + 1, control.begin() + TAPROOT_CONTROL_BASE_SIZE))};\n+    const XOnlyPubKey q{uint256(program)};\n+    uint256 tapleaf_hash = (CHashWriter(HASHER_TAPLEAF) << uint8_t(control[0] & TAPROOT_LEAF_MASK) << script).GetSHA256();\n+    uint256 k = tapleaf_hash;\n+    for (int i = 0; i < path_len; ++i) {\n+        CHashWriter ss_branch{HASHER_TAPBRANCH};\n+        Span<const unsigned char> node(control.data() + TAPROOT_CONTROL_BASE_SIZE + TAPROOT_CONTROL_NODE_SIZE * i, TAPROOT_CONTROL_NODE_SIZE);\n+        if (std::lexicographical_compare(k.begin(), k.end(), node.begin(), node.end())) {\n+            ss_branch << k << node;\n+        } else {\n+            ss_branch << node << k;\n+        }\n+        k = ss_branch.GetSHA256();\n+    }\n+    k = (CHashWriter(HASHER_TAPTWEAK) << MakeSpan(p) << k).GetSHA256();\n+    return q.CheckPayToContract(p, k, control[0] & 1);\n+}\n+\n+static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror, bool is_p2sh)\n+{\n+    CScript exec_script; //!< Actually executed script (last stack item in P2WSH; implied P2PKH script in P2WPKH; leaf script in P2TR)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r505888403",
      "id" : 505888403,
      "in_reply_to_id" : 505237399,
      "line" : 1857,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg4ODQwMw==",
      "original_commit_id" : "8bbed4b7acf4c76eaea8c0e10f3cbf6ba4e53809",
      "original_line" : 1708,
      "original_position" : 39,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 570,
      "pull_request_review_id" : 509838226,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-15T21:58:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/505888403",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r506026632"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/506026632"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This is being addressed in #20161.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-16T03:33:30Z",
      "diff_hunk" : "@@ -369,3 +392,161 @@ def sign_ecdsa(self, msg, low_s=True):\n         rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')\n         sb = s.to_bytes((s.bit_length() + 8) // 8, 'big')\n         return b'\\x30' + bytes([4 + len(rb) + len(sb), 2, len(rb)]) + rb + bytes([2, len(sb)]) + sb\n+\n+def compute_xonly_pubkey(key):\n+    \"\"\"Compute an x-only (32 byte) public key from a (32 byte) private key.\n+\n+    This also returns whether the resulting public key was negated.\n+    \"\"\"\n+\n+    assert len(key) == 32\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return (None, None)\n+    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, x)]))\n+    return (P[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(P))\n+\n+def tweak_add_privkey(key, tweak):\n+    \"\"\"Tweak a private key (after negating it if needed).\"\"\"\n+\n+    assert len(key) == 32\n+    assert len(tweak) == 32\n+\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return None\n+    if not SECP256K1.has_even_y(SECP256K1.mul([(SECP256K1_G, x)])):\n+       x = SECP256K1_ORDER - x\n+    t = int.from_bytes(tweak, 'big')\n+    if t >= SECP256K1_ORDER:\n+        return None\n+    x = (x + t) % SECP256K1_ORDER\n+    if x == 0:\n+        return None\n+    return x.to_bytes(32, 'big')\n+\n+def tweak_add_pubkey(key, tweak):\n+    \"\"\"Tweak a public key and return whether the result had to be negated.\"\"\"\n+\n+    assert len(key) == 32\n+    assert len(tweak) == 32\n+\n+    x_coord = int.from_bytes(key, 'big')\n+    if x_coord >= SECP256K1_FIELD_SIZE:\n+        return None\n+    P = SECP256K1.lift_x(x_coord)\n+    if P is None:\n+        return None\n+    t = int.from_bytes(tweak, 'big')\n+    if t >= SECP256K1_ORDER:\n+        return None\n+    Q = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, t), (P, 1)]))\n+    if Q is None:\n+        return None\n+    return (Q[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(Q))\n+\n+def verify_schnorr(key, sig, msg):\n+    \"\"\"Verify a Schnorr signature (see BIP 340).\n+\n+    - key is a 32-byte xonly pubkey (computed using compute_xonly_pubkey).\n+    - sig is a 64-byte Schnorr signature\n+    - msg is a 32-byte message\n+    \"\"\"\n+    assert len(key) == 32\n+    assert len(msg) == 32\n+    assert len(sig) == 64\n+\n+    x_coord = int.from_bytes(key, 'big')\n+    if x_coord == 0 or x_coord >= SECP256K1_FIELD_SIZE:\n+        return False\n+    P = SECP256K1.lift_x(x_coord)\n+    if P is None:\n+        return False\n+    r = int.from_bytes(sig[0:32], 'big')\n+    if r >= SECP256K1_FIELD_SIZE:\n+        return False\n+    s = int.from_bytes(sig[32:64], 'big')\n+    if s >= SECP256K1_ORDER:\n+        return False\n+    e = int.from_bytes(TaggedHash(\"BIP0340/challenge\", sig[0:32] + key + msg), 'big') % SECP256K1_ORDER\n+    R = SECP256K1.mul([(SECP256K1_G, s), (P, SECP256K1_ORDER - e)])\n+    if not SECP256K1.has_even_y(R):\n+        return False\n+    if ((r * R[2] * R[2]) % SECP256K1_FIELD_SIZE) != R[0]:\n+        return False\n+    return True\n+\n+def sign_schnorr(key, msg, aux=None):\n+    \"\"\"Create a Schnorr signature (see BIP 340).\"\"\"\n+\n+    if aux is None:\n+        aux = bytes(32)\n+\n+    assert len(key) == 32\n+    assert len(msg) == 32\n+    assert len(aux) == 32\n+\n+    sec = int.from_bytes(key, 'big')\n+    if sec == 0 or sec >= SECP256K1_ORDER:\n+        return None\n+    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, sec)]))\n+    if not SECP256K1.has_even_y(P):\n+        sec = SECP256K1_ORDER - sec\n+    t = (sec ^ int.from_bytes(TaggedHash(\"BIP0340/aux\", aux), 'big')).to_bytes(32, 'big')\n+    kp = int.from_bytes(TaggedHash(\"BIP0340/nonce\", t + P[0].to_bytes(32, 'big') + msg), 'big') % SECP256K1_ORDER\n+    assert kp != 0\n+    R = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, kp)]))\n+    k = kp if SECP256K1.has_even_y(R) else SECP256K1_ORDER - kp\n+    e = int.from_bytes(TaggedHash(\"BIP0340/challenge\", R[0].to_bytes(32, 'big') + P[0].to_bytes(32, 'big') + msg), 'big') % SECP256K1_ORDER\n+    return R[0].to_bytes(32, 'big') + ((k + e * sec) % SECP256K1_ORDER).to_bytes(32, 'big')\n+\n+class TestFrameworkKey(unittest.TestCase):\n+    def test_schnorr(self):\n+        \"\"\"Test the Python Schnorr implementation.\"\"\"\n+        byte_arrays = [generate_privkey() for _ in range(3)] + [v.to_bytes(32, 'big') for v in [0, SECP256K1_ORDER - 1, SECP256K1_ORDER, 2**256 - 1]]\n+        keys = {}\n+        for privkey in byte_arrays:  # build array of key/pubkey pairs\n+            pubkey, _ = compute_xonly_pubkey(privkey)\n+            if pubkey is not None:\n+                keys[privkey] = pubkey\n+        for msg in byte_arrays:  # test every combination of message, signing key, verification key\n+            for sign_privkey, sign_pubkey in keys.items():\n+                sig = sign_schnorr(sign_privkey, msg)\n+                for verify_privkey, verify_pubkey in keys.items():\n+                    if verify_privkey == sign_privkey:\n+                        self.assertTrue(verify_schnorr(verify_pubkey, sig, msg))\n+                        sig = list(sig)\n+                        sig[random.randrange(64)] ^= (1 << (random.randrange(8)))  # damaging signature should break things\n+                        sig = bytes(sig)\n+                    self.assertFalse(verify_schnorr(verify_pubkey, sig, msg))\n+\n+    def test_schnorr_testvectors(self):\n+        \"\"\"Implement the BIP340 test vectors (read from bip340_test_vectors.csv).\"\"\"\n+        num_tests = 0\n+        with open(os.path.join(sys.path[0], 'test_framework', 'bip340_test_vectors.csv'), newline='', encoding='utf8') as csvfile:\n+            reader = csv.reader(csvfile)\n+            next(reader)\n+            for row in reader:\n+                (i_str, seckey_hex, pubkey_hex, aux_rand_hex, msg_hex, sig_hex, result_str, comment) = row\n+                i = int(i_str)\n+                pubkey = bytes.fromhex(pubkey_hex)\n+                msg = bytes.fromhex(msg_hex)\n+                sig = bytes.fromhex(sig_hex)\n+                result = result_str == 'TRUE'\n+                if seckey_hex != '':\n+                    seckey = bytes.fromhex(seckey_hex)\n+                    pubkey_actual = compute_xonly_pubkey(seckey)[0]\n+                    self.assertEqual(pubkey.hex(), pubkey_actual.hex(), \"BIP340 test vector %i (%s): pubkey mismatch\" % (i, comment))\n+                    aux_rand = bytes.fromhex(aux_rand_hex)\n+                    try:\n+                        sig_actual = sign_schnorr(seckey, msg, aux_rand)\n+                        self.assertEqual(sig.hex(), sig_actual.hex(), \"BIP340 test vector %i (%s): sig mismatch\" % (i, comment))\n+                    except RuntimeError as e:\n+                        self.assertFalse(\"BIP340 test vector %i (%s): signing raised exception %s\" % (i, comment, e))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r506026632",
      "id" : 506026632,
      "in_reply_to_id" : 504240763,
      "line" : 545,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjAyNjYzMg==",
      "original_commit_id" : "3c226639eb134314a0640d34e4ccb6148dbde22f",
      "original_line" : 545,
      "original_position" : 251,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : 251,
      "pull_request_review_id" : 509988119,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-16T03:33:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/506026632",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r506084829"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/506084829"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This comment is also being addressed in #20161.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-16T06:30:33Z",
      "diff_hunk" : "@@ -223,7 +242,7 @@ def set(self, data):\n                 p = SECP256K1.lift_x(x)\n                 # if the oddness of the y co-ord isn't correct, find the other\n                 # valid y\n-                if (p[1] & 1) != (data[0] & 1):\n+                if data[0] & 1:\n                     p = SECP256K1.negate(p)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r506084829",
      "id" : 506084829,
      "in_reply_to_id" : 504219510,
      "line" : 246,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjA4NDgyOQ==",
      "original_commit_id" : "3c226639eb134314a0640d34e4ccb6148dbde22f",
      "original_line" : 246,
      "original_position" : 74,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : 74,
      "pull_request_review_id" : 510186933,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-16T06:30:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/506084829",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r508128183"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/508128183"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm not sure how to read this description compared to  the effective return. `tweak` is returned in 4th position, after internal `pubkey` in 2nd and the negation flag in 3rd. Further it seems `leaves` are sorted on `(script, version, merklebranch)` and doesn't rely on `negation flag`/ `innerkey`.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-19T23:54:53Z",
      "diff_hunk" : "@@ -738,3 +741,113 @@ def test_cscriptnum_encoding(self):\n         values = [0, 1, -1, -2, 127, 128, -255, 256, (1 << 15) - 1, -(1 << 16), (1 << 24) - 1, (1 << 31), 1 - (1 << 32), 1 << 40, 1500, -1500]\n         for value in values:\n             self.assertEqual(CScriptNum.decode(CScriptNum.encode(CScriptNum(value))), value)\n+\n+def TaprootSignatureHash(txTo, spent_utxos, hash_type, input_index = 0, scriptpath = False, script = CScript(), codeseparator_pos = -1, annex = None, leaf_ver = LEAF_VERSION_TAPSCRIPT):\n+    assert (len(txTo.vin) == len(spent_utxos))\n+    assert (input_index < len(txTo.vin))\n+    out_type = SIGHASH_ALL if hash_type == 0 else hash_type & 3\n+    in_type = hash_type & SIGHASH_ANYONECANPAY\n+    spk = spent_utxos[input_index].scriptPubKey\n+    ss = bytes([0, hash_type]) # epoch, hash_type\n+    ss += struct.pack(\"<i\", txTo.nVersion)\n+    ss += struct.pack(\"<I\", txTo.nLockTime)\n+    if in_type != SIGHASH_ANYONECANPAY:\n+        ss += sha256(b\"\".join(i.prevout.serialize() for i in txTo.vin))\n+        ss += sha256(b\"\".join(struct.pack(\"<q\", u.nValue) for u in spent_utxos))\n+        ss += sha256(b\"\".join(ser_string(u.scriptPubKey) for u in spent_utxos))\n+        ss += sha256(b\"\".join(struct.pack(\"<I\", i.nSequence) for i in txTo.vin))\n+    if out_type == SIGHASH_ALL:\n+        ss += sha256(b\"\".join(o.serialize() for o in txTo.vout))\n+    spend_type = 0\n+    if annex is not None:\n+        spend_type |= 1\n+    if (scriptpath):\n+        spend_type |= 2\n+    ss += bytes([spend_type])\n+    if in_type == SIGHASH_ANYONECANPAY:\n+        ss += txTo.vin[input_index].prevout.serialize()\n+        ss += struct.pack(\"<q\", spent_utxos[input_index].nValue)\n+        ss += ser_string(spk)\n+        ss += struct.pack(\"<I\", txTo.vin[input_index].nSequence)\n+    else:\n+        ss += struct.pack(\"<I\", input_index)\n+    if (spend_type & 1):\n+        ss += sha256(ser_string(annex))\n+    if out_type == SIGHASH_SINGLE:\n+        if input_index < len(txTo.vout):\n+            ss += sha256(txTo.vout[input_index].serialize())\n+        else:\n+            ss += bytes(0 for _ in range(32))\n+    if (scriptpath):\n+        ss += TaggedHash(\"TapLeaf\", bytes([leaf_ver]) + ser_string(script))\n+        ss += bytes([0])\n+        ss += struct.pack(\"<i\", codeseparator_pos)\n+    assert len(ss) ==  175 - (in_type == SIGHASH_ANYONECANPAY) * 49 - (out_type != SIGHASH_ALL and out_type != SIGHASH_SINGLE) * 32 + (annex is not None) * 32 + scriptpath * 37\n+    return TaggedHash(\"TapSighash\", ss)\n+\n+def taproot_tree_helper(scripts):\n+    if len(scripts) == 0:\n+        return ([], bytes(0 for _ in range(32)))\n+    if len(scripts) == 1:\n+        # One entry: treat as a leaf\n+        script = scripts[0]\n+        assert(not callable(script))\n+        if isinstance(script, list):\n+            return taproot_tree_helper(script)\n+        assert(isinstance(script, tuple))\n+        version = LEAF_VERSION_TAPSCRIPT\n+        name = script[0]\n+        code = script[1]\n+        if len(script) == 3:\n+            version = script[2]\n+        assert version & 1 == 0\n+        assert isinstance(code, bytes)\n+        h = TaggedHash(\"TapLeaf\", bytes([version]) + ser_string(code))\n+        if name is None:\n+            return ([], h)\n+        return ([(name, version, code, bytes())], h)\n+    elif len(scripts) == 2 and callable(scripts[1]):\n+        # Two entries, and the right one is a function\n+        left, left_h = taproot_tree_helper(scripts[0:1])\n+        right_h = scripts[1](left_h)\n+        left = [(name, version, script, control + right_h) for name, version, script, control in left]\n+        right = []\n+    else:\n+        # Two or more entries: descend into each side\n+        split_pos = len(scripts) // 2\n+        left, left_h = taproot_tree_helper(scripts[0:split_pos])\n+        right, right_h = taproot_tree_helper(scripts[split_pos:])\n+        left = [(name, version, script, control + right_h) for name, version, script, control in left]\n+        right = [(name, version, script, control + left_h) for name, version, script, control in right]\n+    if right_h < left_h:\n+        right_h, left_h = left_h, right_h\n+    h = TaggedHash(\"TapBranch\", left_h + right_h)\n+    return (left + right, h)\n+\n+TaprootInfo = namedtuple(\"TaprootInfo\", \"scriptPubKey,inner_pubkey,negflag,tweak,leaves\")\n+TaprootLeafInfo = namedtuple(\"TaprootLeafInfo\", \"script,version,merklebranch\")\n+\n+def taproot_construct(pubkey, scripts=None):\n+    \"\"\"Construct a tree of Taproot spending conditions\n+\n+    pubkey: an ECPubKey object for the internal pubkey\n+    scripts: a list of items; each item is either:\n+             - a (name, CScript) tuple\n+             - a (name, CScript, leaf version) tuple\n+             - another list of items (with the same structure)\n+             - a function, which specifies how to compute the hashing partner\n+               in function of the hash of whatever it is combined with\n+\n+    Returns: script (sPK or redeemScript), tweak, {name:(script, leaf version, negation flag, innerkey, merklepath), ...}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r508128183",
      "id" : 508128183,
      "line" : 841,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEyODE4Mw==",
      "original_commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "original_line" : 841,
      "original_position" : 173,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/script.py",
      "position" : 173,
      "pull_request_review_id" : 512238027,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-20T01:31:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/508128183",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r508131987"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/508131987"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: `need_vin_vout_mismatch` isn't commented",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-20T00:07:45Z",
      "diff_hunk" : "@@ -0,0 +1,1458 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import OrderedDict, namedtuple\n+from io import BytesIO\n+import json\n+import hashlib\n+import os\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expression for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        return tweak_add_privkey(key, tweak)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    scriptsig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    witness_stack = flatten(get(ctx, \"witness\"))\n+    return (scriptsig, witness_stack)\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda returning (scriptsig, witness_stack), taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+# - Whether this test demands being placed in a txin with no corresponding txout (for testing SIGHASH_SINGLE behavior)\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail,need_vin_vout_mismatch\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, need_vin_vout_mismatch=False, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r508131987",
      "id" : 508131987,
      "line" : 445,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEzMTk4Nw==",
      "original_commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "original_line" : 445,
      "original_position" : 445,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : 445,
      "pull_request_review_id" : 512238027,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-20T01:31:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/508131987",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r508149564"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/508149564"
         }
      },
      "author_association" : "MEMBER",
      "body" : "A code comment to hint about the `+1` would be great. Like \"Exclude parity bit from internal pubkey\"",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-20T01:10:31Z",
      "diff_hunk" : "@@ -1504,58 +1791,144 @@ bool GenericTransactionSignatureChecker<T>::CheckSequence(const CScriptNum& nSeq\n template class GenericTransactionSignatureChecker<CTransaction>;\n template class GenericTransactionSignatureChecker<CMutableTransaction>;\n \n-static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, ScriptExecutionData& execdata, ScriptError* serror)\n {\n     std::vector<valtype> stack{stack_span.begin(), stack_span.end()};\n \n+    if (sigversion == SigVersion::TAPSCRIPT) {\n+        // OP_SUCCESSx processing overrides everything, including stack element size limits\n+        CScript::const_iterator pc = scriptPubKey.begin();\n+        while (pc < scriptPubKey.end()) {\n+            opcodetype opcode;\n+            if (!scriptPubKey.GetOp(pc, opcode)) {\n+                // Note how this condition would not be reached if an unknown OP_SUCCESSx was found\n+                return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n+            }\n+            // New opcodes will be listed here. May use a different sigversion to modify existing opcodes.\n+            if (IsOpSuccess(opcode)) {\n+                if (flags & SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS) {\n+                    return set_error(serror, SCRIPT_ERR_DISCOURAGE_OP_SUCCESS);\n+                }\n+                return set_success(serror);\n+            }\n+        }\n+\n+        // Tapscript enforces initial stack size limits (altstack is empty here)\n+        if (stack.size() > MAX_STACK_SIZE) return set_error(serror, SCRIPT_ERR_STACK_SIZE);\n+    }\n+\n     // Disallow stack item size > MAX_SCRIPT_ELEMENT_SIZE in witness stack\n     for (const valtype& elem : stack) {\n         if (elem.size() > MAX_SCRIPT_ELEMENT_SIZE) return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n     }\n \n     // Run the script interpreter.\n-    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, serror)) return false;\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, execdata, serror)) return false;\n \n     // Scripts inside witness implicitly require cleanstack behaviour\n     if (stack.size() != 1) return set_error(serror, SCRIPT_ERR_CLEANSTACK);\n     if (!CastToBool(stack.back())) return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n     return true;\n }\n \n-static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, const std::vector<unsigned char>& program, const CScript& script, uint256& tapleaf_hash)\n {\n-    CScript scriptPubKey;\n+    const int path_len = (control.size() - TAPROOT_CONTROL_BASE_SIZE) / TAPROOT_CONTROL_NODE_SIZE;\n+    const XOnlyPubKey p{uint256(std::vector<unsigned char>(control.begin() + 1, control.begin() + TAPROOT_CONTROL_BASE_SIZE))};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r508149564",
      "id" : 508149564,
      "line" : 1837,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE0OTU2NA==",
      "original_commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "original_line" : 1837,
      "original_position" : 550,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 550,
      "pull_request_review_id" : 512238027,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-20T01:31:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/508149564",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r508152499"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/508152499"
         }
      },
      "author_association" : "MEMBER",
      "body" : "As a side-note, it could be worthy to document what is meaned here by \"syntactic correctness\" if it's consensus criticial. AFAICT, pubkey must be superior to 0 ?",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-20T01:21:09Z",
      "diff_hunk" : "@@ -169,7 +170,7 @@ class CPubKey\n     /*\n      * Check syntactic correctness.\n      *\n-     * Note that this is consensus critical as CheckSig() calls it!\n+     * Note that this is consensus critical as CheckECDSASignature() calls it!",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r508152499",
      "id" : 508152499,
      "line" : 173,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE1MjQ5OQ==",
      "original_commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "original_line" : 173,
      "original_position" : 13,
      "original_start_line" : null,
      "path" : "src/pubkey.h",
      "position" : 13,
      "pull_request_review_id" : 512238027,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-20T01:31:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/508152499",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r508153060"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/508153060"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Can future upgradable public key define their own sigops rules without branching inside the `if (success)` branch ?",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-20T01:23:25Z",
      "diff_hunk" : "@@ -363,15 +360,75 @@ static bool EvalChecksig(const valtype& vchSig, const valtype& vchPubKey, CScrip\n         //serror is set\n         return false;\n     }\n-    fSuccess = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion);\n+    fSuccess = checker.CheckECDSASignature(vchSig, vchPubKey, scriptCode, sigversion);\n \n     if (!fSuccess && (flags & SCRIPT_VERIFY_NULLFAIL) && vchSig.size())\n         return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);\n \n     return true;\n }\n \n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)\n+static bool EvalChecksigTapscript(const valtype& sig, const valtype& pubkey, ScriptExecutionData& execdata, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& success)\n+{\n+    assert(sigversion == SigVersion::TAPSCRIPT);\n+\n+    /*\n+     *  The following validation sequence is consensus critical. Please note how --\n+     *    upgradable public key versions precede other rules;\n+     *    the script execution fails when using empty signature with invalid public key;\n+     *    the script execution fails when using non-empty invalid signature.\n+     */\n+    success = !sig.empty();\n+    if (success) {\n+        // Implement the sigops/witnesssize ratio test.\n+        // Passing with an upgradable public key version is also counted.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r508153060",
      "id" : 508153060,
      "line" : 384,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE1MzA2MA==",
      "original_commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "original_line" : 384,
      "original_position" : 44,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 44,
      "pull_request_review_id" : 512238027,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-20T01:31:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/508153060",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r508153422"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/508153422"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Can we enforce this assign-once property with either some cpp magic or compiler option ? I've no idea.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-20T01:24:41Z",
      "diff_hunk" : "@@ -363,15 +360,75 @@ static bool EvalChecksig(const valtype& vchSig, const valtype& vchPubKey, CScrip\n         //serror is set\n         return false;\n     }\n-    fSuccess = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion);\n+    fSuccess = checker.CheckECDSASignature(vchSig, vchPubKey, scriptCode, sigversion);\n \n     if (!fSuccess && (flags & SCRIPT_VERIFY_NULLFAIL) && vchSig.size())\n         return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);\n \n     return true;\n }\n \n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)\n+static bool EvalChecksigTapscript(const valtype& sig, const valtype& pubkey, ScriptExecutionData& execdata, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& success)\n+{\n+    assert(sigversion == SigVersion::TAPSCRIPT);\n+\n+    /*\n+     *  The following validation sequence is consensus critical. Please note how --\n+     *    upgradable public key versions precede other rules;\n+     *    the script execution fails when using empty signature with invalid public key;\n+     *    the script execution fails when using non-empty invalid signature.\n+     */\n+    success = !sig.empty();\n+    if (success) {\n+        // Implement the sigops/witnesssize ratio test.\n+        // Passing with an upgradable public key version is also counted.\n+        assert(execdata.m_validation_weight_left_init);\n+        execdata.m_validation_weight_left -= VALIDATION_WEIGHT_PER_SIGOP_PASSED;\n+        if (execdata.m_validation_weight_left < 0) {\n+            return set_error(serror, SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT);\n+        }\n+    }\n+    if (pubkey.size() == 0) {\n+        return set_error(serror, SCRIPT_ERR_PUBKEYTYPE);\n+    } else if (pubkey.size() == 32) {\n+        if (success && !checker.CheckSchnorrSignature(sig, pubkey, sigversion, execdata, serror)) {\n+            return false; // serror is set\n+        }\n+    } else {\n+        /*\n+         *  New public key version softforks should be defined before this `else` block.\n+         *  Generally, the new code should not do anything but failing the script execution. To avoid\n+         *  consensus bugs, it should not modify any existing values (including `success`).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r508153422",
      "id" : 508153422,
      "line" : 401,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE1MzQyMg==",
      "original_commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "original_line" : 401,
      "original_position" : 61,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 61,
      "pull_request_review_id" : 512238027,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-20T01:31:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/508153422",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r508877783"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/508877783"
         }
      },
      "author_association" : "MEMBER",
      "body" : "They can certainly define their own cost rules, as long as the cost is at least 50 vbytes per check. I'm not sure what you mean by \"without branching\".",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-20T22:28:46Z",
      "diff_hunk" : "@@ -363,15 +360,75 @@ static bool EvalChecksig(const valtype& vchSig, const valtype& vchPubKey, CScrip\n         //serror is set\n         return false;\n     }\n-    fSuccess = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion);\n+    fSuccess = checker.CheckECDSASignature(vchSig, vchPubKey, scriptCode, sigversion);\n \n     if (!fSuccess && (flags & SCRIPT_VERIFY_NULLFAIL) && vchSig.size())\n         return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);\n \n     return true;\n }\n \n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)\n+static bool EvalChecksigTapscript(const valtype& sig, const valtype& pubkey, ScriptExecutionData& execdata, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& success)\n+{\n+    assert(sigversion == SigVersion::TAPSCRIPT);\n+\n+    /*\n+     *  The following validation sequence is consensus critical. Please note how --\n+     *    upgradable public key versions precede other rules;\n+     *    the script execution fails when using empty signature with invalid public key;\n+     *    the script execution fails when using non-empty invalid signature.\n+     */\n+    success = !sig.empty();\n+    if (success) {\n+        // Implement the sigops/witnesssize ratio test.\n+        // Passing with an upgradable public key version is also counted.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r508877783",
      "id" : 508877783,
      "in_reply_to_id" : 508153060,
      "line" : 384,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg3Nzc4Mw==",
      "original_commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "original_line" : 384,
      "original_position" : 44,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 44,
      "pull_request_review_id" : 513181310,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-20T22:28:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/508877783",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r508879192"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/508879192"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm sure there are ways to solve these softforkability guarantees more generically by encapsulating modifiable properties in an object... but the risks from refactoring consensus code to allow that are probably far bigger than the risk a bug would be missed in future consensus logic (probably a very rare event).",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-20T22:32:23Z",
      "diff_hunk" : "@@ -363,15 +360,75 @@ static bool EvalChecksig(const valtype& vchSig, const valtype& vchPubKey, CScrip\n         //serror is set\n         return false;\n     }\n-    fSuccess = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion);\n+    fSuccess = checker.CheckECDSASignature(vchSig, vchPubKey, scriptCode, sigversion);\n \n     if (!fSuccess && (flags & SCRIPT_VERIFY_NULLFAIL) && vchSig.size())\n         return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);\n \n     return true;\n }\n \n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)\n+static bool EvalChecksigTapscript(const valtype& sig, const valtype& pubkey, ScriptExecutionData& execdata, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& success)\n+{\n+    assert(sigversion == SigVersion::TAPSCRIPT);\n+\n+    /*\n+     *  The following validation sequence is consensus critical. Please note how --\n+     *    upgradable public key versions precede other rules;\n+     *    the script execution fails when using empty signature with invalid public key;\n+     *    the script execution fails when using non-empty invalid signature.\n+     */\n+    success = !sig.empty();\n+    if (success) {\n+        // Implement the sigops/witnesssize ratio test.\n+        // Passing with an upgradable public key version is also counted.\n+        assert(execdata.m_validation_weight_left_init);\n+        execdata.m_validation_weight_left -= VALIDATION_WEIGHT_PER_SIGOP_PASSED;\n+        if (execdata.m_validation_weight_left < 0) {\n+            return set_error(serror, SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT);\n+        }\n+    }\n+    if (pubkey.size() == 0) {\n+        return set_error(serror, SCRIPT_ERR_PUBKEYTYPE);\n+    } else if (pubkey.size() == 32) {\n+        if (success && !checker.CheckSchnorrSignature(sig, pubkey, sigversion, execdata, serror)) {\n+            return false; // serror is set\n+        }\n+    } else {\n+        /*\n+         *  New public key version softforks should be defined before this `else` block.\n+         *  Generally, the new code should not do anything but failing the script execution. To avoid\n+         *  consensus bugs, it should not modify any existing values (including `success`).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r508879192",
      "id" : 508879192,
      "in_reply_to_id" : 508153422,
      "line" : 401,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg3OTE5Mg==",
      "original_commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "original_line" : 401,
      "original_position" : 61,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 61,
      "pull_request_review_id" : 513182980,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-20T22:32:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/508879192",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r508880630"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/508880630"
         }
      },
      "author_association" : "MEMBER",
      "body" : "See #20207. All of this was just outdated, thanks for noticing.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-20T22:36:27Z",
      "diff_hunk" : "@@ -738,3 +741,113 @@ def test_cscriptnum_encoding(self):\n         values = [0, 1, -1, -2, 127, 128, -255, 256, (1 << 15) - 1, -(1 << 16), (1 << 24) - 1, (1 << 31), 1 - (1 << 32), 1 << 40, 1500, -1500]\n         for value in values:\n             self.assertEqual(CScriptNum.decode(CScriptNum.encode(CScriptNum(value))), value)\n+\n+def TaprootSignatureHash(txTo, spent_utxos, hash_type, input_index = 0, scriptpath = False, script = CScript(), codeseparator_pos = -1, annex = None, leaf_ver = LEAF_VERSION_TAPSCRIPT):\n+    assert (len(txTo.vin) == len(spent_utxos))\n+    assert (input_index < len(txTo.vin))\n+    out_type = SIGHASH_ALL if hash_type == 0 else hash_type & 3\n+    in_type = hash_type & SIGHASH_ANYONECANPAY\n+    spk = spent_utxos[input_index].scriptPubKey\n+    ss = bytes([0, hash_type]) # epoch, hash_type\n+    ss += struct.pack(\"<i\", txTo.nVersion)\n+    ss += struct.pack(\"<I\", txTo.nLockTime)\n+    if in_type != SIGHASH_ANYONECANPAY:\n+        ss += sha256(b\"\".join(i.prevout.serialize() for i in txTo.vin))\n+        ss += sha256(b\"\".join(struct.pack(\"<q\", u.nValue) for u in spent_utxos))\n+        ss += sha256(b\"\".join(ser_string(u.scriptPubKey) for u in spent_utxos))\n+        ss += sha256(b\"\".join(struct.pack(\"<I\", i.nSequence) for i in txTo.vin))\n+    if out_type == SIGHASH_ALL:\n+        ss += sha256(b\"\".join(o.serialize() for o in txTo.vout))\n+    spend_type = 0\n+    if annex is not None:\n+        spend_type |= 1\n+    if (scriptpath):\n+        spend_type |= 2\n+    ss += bytes([spend_type])\n+    if in_type == SIGHASH_ANYONECANPAY:\n+        ss += txTo.vin[input_index].prevout.serialize()\n+        ss += struct.pack(\"<q\", spent_utxos[input_index].nValue)\n+        ss += ser_string(spk)\n+        ss += struct.pack(\"<I\", txTo.vin[input_index].nSequence)\n+    else:\n+        ss += struct.pack(\"<I\", input_index)\n+    if (spend_type & 1):\n+        ss += sha256(ser_string(annex))\n+    if out_type == SIGHASH_SINGLE:\n+        if input_index < len(txTo.vout):\n+            ss += sha256(txTo.vout[input_index].serialize())\n+        else:\n+            ss += bytes(0 for _ in range(32))\n+    if (scriptpath):\n+        ss += TaggedHash(\"TapLeaf\", bytes([leaf_ver]) + ser_string(script))\n+        ss += bytes([0])\n+        ss += struct.pack(\"<i\", codeseparator_pos)\n+    assert len(ss) ==  175 - (in_type == SIGHASH_ANYONECANPAY) * 49 - (out_type != SIGHASH_ALL and out_type != SIGHASH_SINGLE) * 32 + (annex is not None) * 32 + scriptpath * 37\n+    return TaggedHash(\"TapSighash\", ss)\n+\n+def taproot_tree_helper(scripts):\n+    if len(scripts) == 0:\n+        return ([], bytes(0 for _ in range(32)))\n+    if len(scripts) == 1:\n+        # One entry: treat as a leaf\n+        script = scripts[0]\n+        assert(not callable(script))\n+        if isinstance(script, list):\n+            return taproot_tree_helper(script)\n+        assert(isinstance(script, tuple))\n+        version = LEAF_VERSION_TAPSCRIPT\n+        name = script[0]\n+        code = script[1]\n+        if len(script) == 3:\n+            version = script[2]\n+        assert version & 1 == 0\n+        assert isinstance(code, bytes)\n+        h = TaggedHash(\"TapLeaf\", bytes([version]) + ser_string(code))\n+        if name is None:\n+            return ([], h)\n+        return ([(name, version, code, bytes())], h)\n+    elif len(scripts) == 2 and callable(scripts[1]):\n+        # Two entries, and the right one is a function\n+        left, left_h = taproot_tree_helper(scripts[0:1])\n+        right_h = scripts[1](left_h)\n+        left = [(name, version, script, control + right_h) for name, version, script, control in left]\n+        right = []\n+    else:\n+        # Two or more entries: descend into each side\n+        split_pos = len(scripts) // 2\n+        left, left_h = taproot_tree_helper(scripts[0:split_pos])\n+        right, right_h = taproot_tree_helper(scripts[split_pos:])\n+        left = [(name, version, script, control + right_h) for name, version, script, control in left]\n+        right = [(name, version, script, control + left_h) for name, version, script, control in right]\n+    if right_h < left_h:\n+        right_h, left_h = left_h, right_h\n+    h = TaggedHash(\"TapBranch\", left_h + right_h)\n+    return (left + right, h)\n+\n+TaprootInfo = namedtuple(\"TaprootInfo\", \"scriptPubKey,inner_pubkey,negflag,tweak,leaves\")\n+TaprootLeafInfo = namedtuple(\"TaprootLeafInfo\", \"script,version,merklebranch\")\n+\n+def taproot_construct(pubkey, scripts=None):\n+    \"\"\"Construct a tree of Taproot spending conditions\n+\n+    pubkey: an ECPubKey object for the internal pubkey\n+    scripts: a list of items; each item is either:\n+             - a (name, CScript) tuple\n+             - a (name, CScript, leaf version) tuple\n+             - another list of items (with the same structure)\n+             - a function, which specifies how to compute the hashing partner\n+               in function of the hash of whatever it is combined with\n+\n+    Returns: script (sPK or redeemScript), tweak, {name:(script, leaf version, negation flag, innerkey, merklepath), ...}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r508880630",
      "id" : 508880630,
      "in_reply_to_id" : 508128183,
      "line" : 841,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg4MDYzMA==",
      "original_commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "original_line" : 841,
      "original_position" : 173,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/script.py",
      "position" : 173,
      "pull_request_review_id" : 513184750,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-20T22:36:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/508880630",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r508880698"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/508880698"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Added in #20207. ",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-20T22:36:40Z",
      "diff_hunk" : "@@ -0,0 +1,1458 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import OrderedDict, namedtuple\n+from io import BytesIO\n+import json\n+import hashlib\n+import os\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expression for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        return tweak_add_privkey(key, tweak)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    scriptsig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    witness_stack = flatten(get(ctx, \"witness\"))\n+    return (scriptsig, witness_stack)\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda returning (scriptsig, witness_stack), taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+# - Whether this test demands being placed in a txin with no corresponding txout (for testing SIGHASH_SINGLE behavior)\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail,need_vin_vout_mismatch\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, need_vin_vout_mismatch=False, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r508880698",
      "id" : 508880698,
      "in_reply_to_id" : 508131987,
      "line" : 445,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg4MDY5OA==",
      "original_commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "original_line" : 445,
      "original_position" : 445,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : 445,
      "pull_request_review_id" : 513184848,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-20T22:36:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/508880698",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r508880919"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/508880919"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I added a bunch of comments around this in #20207. The first byte contains both the leaf version and the parity bit, btw.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-20T22:37:13Z",
      "diff_hunk" : "@@ -1504,58 +1791,144 @@ bool GenericTransactionSignatureChecker<T>::CheckSequence(const CScriptNum& nSeq\n template class GenericTransactionSignatureChecker<CTransaction>;\n template class GenericTransactionSignatureChecker<CMutableTransaction>;\n \n-static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, ScriptExecutionData& execdata, ScriptError* serror)\n {\n     std::vector<valtype> stack{stack_span.begin(), stack_span.end()};\n \n+    if (sigversion == SigVersion::TAPSCRIPT) {\n+        // OP_SUCCESSx processing overrides everything, including stack element size limits\n+        CScript::const_iterator pc = scriptPubKey.begin();\n+        while (pc < scriptPubKey.end()) {\n+            opcodetype opcode;\n+            if (!scriptPubKey.GetOp(pc, opcode)) {\n+                // Note how this condition would not be reached if an unknown OP_SUCCESSx was found\n+                return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n+            }\n+            // New opcodes will be listed here. May use a different sigversion to modify existing opcodes.\n+            if (IsOpSuccess(opcode)) {\n+                if (flags & SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS) {\n+                    return set_error(serror, SCRIPT_ERR_DISCOURAGE_OP_SUCCESS);\n+                }\n+                return set_success(serror);\n+            }\n+        }\n+\n+        // Tapscript enforces initial stack size limits (altstack is empty here)\n+        if (stack.size() > MAX_STACK_SIZE) return set_error(serror, SCRIPT_ERR_STACK_SIZE);\n+    }\n+\n     // Disallow stack item size > MAX_SCRIPT_ELEMENT_SIZE in witness stack\n     for (const valtype& elem : stack) {\n         if (elem.size() > MAX_SCRIPT_ELEMENT_SIZE) return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n     }\n \n     // Run the script interpreter.\n-    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, serror)) return false;\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, execdata, serror)) return false;\n \n     // Scripts inside witness implicitly require cleanstack behaviour\n     if (stack.size() != 1) return set_error(serror, SCRIPT_ERR_CLEANSTACK);\n     if (!CastToBool(stack.back())) return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n     return true;\n }\n \n-static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, const std::vector<unsigned char>& program, const CScript& script, uint256& tapleaf_hash)\n {\n-    CScript scriptPubKey;\n+    const int path_len = (control.size() - TAPROOT_CONTROL_BASE_SIZE) / TAPROOT_CONTROL_NODE_SIZE;\n+    const XOnlyPubKey p{uint256(std::vector<unsigned char>(control.begin() + 1, control.begin() + TAPROOT_CONTROL_BASE_SIZE))};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r508880919",
      "id" : 508880919,
      "in_reply_to_id" : 508149564,
      "line" : 1837,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg4MDkxOQ==",
      "original_commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "original_line" : 1837,
      "original_position" : 550,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 550,
      "pull_request_review_id" : 513185132,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-20T22:37:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/508880919",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r508880996"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/508880996"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Added comments in #20207.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-20T22:37:25Z",
      "diff_hunk" : "@@ -169,7 +170,7 @@ class CPubKey\n     /*\n      * Check syntactic correctness.\n      *\n-     * Note that this is consensus critical as CheckSig() calls it!\n+     * Note that this is consensus critical as CheckECDSASignature() calls it!",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r508880996",
      "id" : 508880996,
      "in_reply_to_id" : 508152499,
      "line" : 173,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg4MDk5Ng==",
      "original_commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "original_line" : 173,
      "original_position" : 13,
      "original_start_line" : null,
      "path" : "src/pubkey.h",
      "position" : 13,
      "pull_request_review_id" : 513185240,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-20T22:37:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/508880996",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r508934109"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/508934109"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I meaned that we do the sigops/witnesssize ratio test before the pubkey size one. If a future softforked new pubkey type comes with its own new ratio test, maybe the code structure isn't going to be adequate ?",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-21T01:24:56Z",
      "diff_hunk" : "@@ -363,15 +360,75 @@ static bool EvalChecksig(const valtype& vchSig, const valtype& vchPubKey, CScrip\n         //serror is set\n         return false;\n     }\n-    fSuccess = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion);\n+    fSuccess = checker.CheckECDSASignature(vchSig, vchPubKey, scriptCode, sigversion);\n \n     if (!fSuccess && (flags & SCRIPT_VERIFY_NULLFAIL) && vchSig.size())\n         return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);\n \n     return true;\n }\n \n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)\n+static bool EvalChecksigTapscript(const valtype& sig, const valtype& pubkey, ScriptExecutionData& execdata, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& success)\n+{\n+    assert(sigversion == SigVersion::TAPSCRIPT);\n+\n+    /*\n+     *  The following validation sequence is consensus critical. Please note how --\n+     *    upgradable public key versions precede other rules;\n+     *    the script execution fails when using empty signature with invalid public key;\n+     *    the script execution fails when using non-empty invalid signature.\n+     */\n+    success = !sig.empty();\n+    if (success) {\n+        // Implement the sigops/witnesssize ratio test.\n+        // Passing with an upgradable public key version is also counted.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r508934109",
      "id" : 508934109,
      "in_reply_to_id" : 508153060,
      "line" : 384,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkzNDEwOQ==",
      "original_commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "original_line" : 384,
      "original_position" : 44,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 44,
      "pull_request_review_id" : 513243171,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-21T01:24:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/508934109",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509143288"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509143288"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit in commit e9a021d7e6:\r\n\r\nWhy not directly assign this with the correct value?\r\n\r\n```cpp\r\nconst bool p2sh{prevScript.IsPayToScriptHash()};",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-21T09:49:33Z",
      "diff_hunk" : "@@ -206,6 +206,7 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n         // get the scriptPubKey corresponding to this input:\n         CScript prevScript = prev.scriptPubKey;\n \n+        bool p2sh = false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509143288",
      "id" : 509143288,
      "line" : 209,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE0MzI4OA==",
      "original_commit_id" : "e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6",
      "original_line" : 209,
      "original_position" : 13,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : 13,
      "pull_request_review_id" : 513499921,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-21T16:20:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509143288",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509149586"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509149586"
         }
      },
      "author_association" : "MEMBER",
      "body" : "same commit:\r\n\r\nYou are modifying what this function is doing, so the comment in validation is no longer applicable and should probably be adjusted.\r\n\r\n```\r\n    // Check for non-standard witness in P2WSH\r\n```",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-21T09:59:27Z",
      "diff_hunk" : "@@ -237,6 +239,36 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check policy limits for Taproot spends:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509149586",
      "id" : 509149586,
      "line" : 243,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE0OTU4Ng==",
      "original_commit_id" : "e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6",
      "original_line" : 243,
      "original_position" : 30,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : 30,
      "pull_request_review_id" : 513499921,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-21T16:20:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509149586",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509382262"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509382262"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I can't run the tests here:\r\n\r\n\r\n```\r\ntest]$ python -m unittest functional/test_framework/key.py \r\n.E\r\n======================================================================\r\nERROR: test_schnorr_testvectors (functional.test_framework.key.TestFrameworkKey)\r\nImplement the BIP340 test vectors (read from bip340_test_vectors.csv).\r\n----------------------------------------------------------------------\r\nTraceback (most recent call last):\r\n  File \"test/functional/test_framework/key.py\", line 526, in test_schnorr_testvectors\r\n    with open(os.path.join(sys.path[0], 'test_framework', 'bip340_test_vectors.csv'), newline='', encoding='utf8') as csvfile:\r\nFileNotFoundError: [Errno 2] No such file or directory: 'test/test_framework/bip340_test_vectors.csv'\r\n\r\n----------------------------------------------------------------------\r\nRan 2 tests in 0.775s\r\n\r\nFAILED (errors=1)\r\n```\r\n\r\nWhat about this diff:\r\n\r\n```diff\r\ndiff --git a/test/functional/test_framework/key.py b/test/functional/test_framework/key.py\r\nindex a6bc187985..ceaaa474ff 100644\r\n--- a/test/functional/test_framework/key.py\r\n+++ b/test/functional/test_framework/key.py\r\n@@ -523,7 +523,7 @@ class TestFrameworkKey(unittest.TestCase):\r\n     def test_schnorr_testvectors(self):\r\n         \"\"\"Implement the BIP340 test vectors (read from bip340_test_vectors.csv).\"\"\"\r\n         num_tests = 0\r\n-        with open(os.path.join(sys.path[0], 'test_framework', 'bip340_test_vectors.csv'), newline='', encoding='utf8') as csvfile:\r\n+        with open(os.path.join(os.path.dirname(os.path.realpath(__file__)), 'bip340_test_vectors.csv'), newline='', encoding='utf8') as csvfile:\r\n             reader = csv.reader(csvfile)\r\n             next(reader)\r\n             for row in reader:\r\n",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-21T15:23:41Z",
      "diff_hunk" : "@@ -369,3 +392,161 @@ def sign_ecdsa(self, msg, low_s=True):\n         rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')\n         sb = s.to_bytes((s.bit_length() + 8) // 8, 'big')\n         return b'\\x30' + bytes([4 + len(rb) + len(sb), 2, len(rb)]) + rb + bytes([2, len(sb)]) + sb\n+\n+def compute_xonly_pubkey(key):\n+    \"\"\"Compute an x-only (32 byte) public key from a (32 byte) private key.\n+\n+    This also returns whether the resulting public key was negated.\n+    \"\"\"\n+\n+    assert len(key) == 32\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return (None, None)\n+    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, x)]))\n+    return (P[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(P))\n+\n+def tweak_add_privkey(key, tweak):\n+    \"\"\"Tweak a private key (after negating it if needed).\"\"\"\n+\n+    assert len(key) == 32\n+    assert len(tweak) == 32\n+\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return None\n+    if not SECP256K1.has_even_y(SECP256K1.mul([(SECP256K1_G, x)])):\n+       x = SECP256K1_ORDER - x\n+    t = int.from_bytes(tweak, 'big')\n+    if t >= SECP256K1_ORDER:\n+        return None\n+    x = (x + t) % SECP256K1_ORDER\n+    if x == 0:\n+        return None\n+    return x.to_bytes(32, 'big')\n+\n+def tweak_add_pubkey(key, tweak):\n+    \"\"\"Tweak a public key and return whether the result had to be negated.\"\"\"\n+\n+    assert len(key) == 32\n+    assert len(tweak) == 32\n+\n+    x_coord = int.from_bytes(key, 'big')\n+    if x_coord >= SECP256K1_FIELD_SIZE:\n+        return None\n+    P = SECP256K1.lift_x(x_coord)\n+    if P is None:\n+        return None\n+    t = int.from_bytes(tweak, 'big')\n+    if t >= SECP256K1_ORDER:\n+        return None\n+    Q = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, t), (P, 1)]))\n+    if Q is None:\n+        return None\n+    return (Q[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(Q))\n+\n+def verify_schnorr(key, sig, msg):\n+    \"\"\"Verify a Schnorr signature (see BIP 340).\n+\n+    - key is a 32-byte xonly pubkey (computed using compute_xonly_pubkey).\n+    - sig is a 64-byte Schnorr signature\n+    - msg is a 32-byte message\n+    \"\"\"\n+    assert len(key) == 32\n+    assert len(msg) == 32\n+    assert len(sig) == 64\n+\n+    x_coord = int.from_bytes(key, 'big')\n+    if x_coord == 0 or x_coord >= SECP256K1_FIELD_SIZE:\n+        return False\n+    P = SECP256K1.lift_x(x_coord)\n+    if P is None:\n+        return False\n+    r = int.from_bytes(sig[0:32], 'big')\n+    if r >= SECP256K1_FIELD_SIZE:\n+        return False\n+    s = int.from_bytes(sig[32:64], 'big')\n+    if s >= SECP256K1_ORDER:\n+        return False\n+    e = int.from_bytes(TaggedHash(\"BIP0340/challenge\", sig[0:32] + key + msg), 'big') % SECP256K1_ORDER\n+    R = SECP256K1.mul([(SECP256K1_G, s), (P, SECP256K1_ORDER - e)])\n+    if not SECP256K1.has_even_y(R):\n+        return False\n+    if ((r * R[2] * R[2]) % SECP256K1_FIELD_SIZE) != R[0]:\n+        return False\n+    return True\n+\n+def sign_schnorr(key, msg, aux=None):\n+    \"\"\"Create a Schnorr signature (see BIP 340).\"\"\"\n+\n+    if aux is None:\n+        aux = bytes(32)\n+\n+    assert len(key) == 32\n+    assert len(msg) == 32\n+    assert len(aux) == 32\n+\n+    sec = int.from_bytes(key, 'big')\n+    if sec == 0 or sec >= SECP256K1_ORDER:\n+        return None\n+    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, sec)]))\n+    if not SECP256K1.has_even_y(P):\n+        sec = SECP256K1_ORDER - sec\n+    t = (sec ^ int.from_bytes(TaggedHash(\"BIP0340/aux\", aux), 'big')).to_bytes(32, 'big')\n+    kp = int.from_bytes(TaggedHash(\"BIP0340/nonce\", t + P[0].to_bytes(32, 'big') + msg), 'big') % SECP256K1_ORDER\n+    assert kp != 0\n+    R = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, kp)]))\n+    k = kp if SECP256K1.has_even_y(R) else SECP256K1_ORDER - kp\n+    e = int.from_bytes(TaggedHash(\"BIP0340/challenge\", R[0].to_bytes(32, 'big') + P[0].to_bytes(32, 'big') + msg), 'big') % SECP256K1_ORDER\n+    return R[0].to_bytes(32, 'big') + ((k + e * sec) % SECP256K1_ORDER).to_bytes(32, 'big')\n+\n+class TestFrameworkKey(unittest.TestCase):\n+    def test_schnorr(self):\n+        \"\"\"Test the Python Schnorr implementation.\"\"\"\n+        byte_arrays = [generate_privkey() for _ in range(3)] + [v.to_bytes(32, 'big') for v in [0, SECP256K1_ORDER - 1, SECP256K1_ORDER, 2**256 - 1]]\n+        keys = {}\n+        for privkey in byte_arrays:  # build array of key/pubkey pairs\n+            pubkey, _ = compute_xonly_pubkey(privkey)\n+            if pubkey is not None:\n+                keys[privkey] = pubkey\n+        for msg in byte_arrays:  # test every combination of message, signing key, verification key\n+            for sign_privkey, sign_pubkey in keys.items():\n+                sig = sign_schnorr(sign_privkey, msg)\n+                for verify_privkey, verify_pubkey in keys.items():\n+                    if verify_privkey == sign_privkey:\n+                        self.assertTrue(verify_schnorr(verify_pubkey, sig, msg))\n+                        sig = list(sig)\n+                        sig[random.randrange(64)] ^= (1 << (random.randrange(8)))  # damaging signature should break things\n+                        sig = bytes(sig)\n+                    self.assertFalse(verify_schnorr(verify_pubkey, sig, msg))\n+\n+    def test_schnorr_testvectors(self):\n+        \"\"\"Implement the BIP340 test vectors (read from bip340_test_vectors.csv).\"\"\"\n+        num_tests = 0\n+        with open(os.path.join(sys.path[0], 'test_framework', 'bip340_test_vectors.csv'), newline='', encoding='utf8') as csvfile:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509382262",
      "id" : 509382262,
      "line" : 526,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM4MjI2Mg==",
      "original_commit_id" : "3c226639eb134314a0640d34e4ccb6148dbde22f",
      "original_line" : 526,
      "original_position" : 232,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : 232,
      "pull_request_review_id" : 513499921,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-21T16:20:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509382262",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509383731"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509383731"
         }
      },
      "author_association" : "MEMBER",
      "body" : "should this assert that they are of the same length? Or at least comment that this will truncate the longer one",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-21T15:25:29Z",
      "diff_hunk" : "@@ -1,15 +1,29 @@\n-# Copyright (c) 2019 Pieter Wuille\n+# Copyright (c) 2019-2020 Pieter Wuille\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test-only secp256k1 elliptic curve implementation\n \n WARNING: This code is slow, uses bad randomness, does not properly protect\n keys, and is trivially vulnerable to side channel attacks. Do not use for\n anything but tests.\"\"\"\n+import csv\n+import hashlib\n+import os\n import random\n+import sys\n+import unittest\n \n from .util import modinv\n \n+def TaggedHash(tag, data):\n+    ss = hashlib.sha256(tag.encode('utf-8')).digest()\n+    ss += ss\n+    ss += data\n+    return hashlib.sha256(ss).digest()\n+\n+def xor_bytes(b0, b1):\n+    return bytes(x ^ y for (x, y) in zip(b0, b1))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509383731",
      "id" : 509383731,
      "line" : 25,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM4MzczMQ==",
      "original_commit_id" : "3c226639eb134314a0640d34e4ccb6148dbde22f",
      "original_line" : 25,
      "original_position" : 26,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : 26,
      "pull_request_review_id" : 513499921,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-21T16:20:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509383731",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509400019"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509400019"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Can you explain why legacy whitelist is needed for this test?",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-21T15:46:32Z",
      "diff_hunk" : "@@ -0,0 +1,1411 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expression for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        return tweak_add_privkey(key, tweak)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    scriptsig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    witness_stack = flatten(get(ctx, \"witness\"))\n+    return (scriptsig, witness_stack)\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda returning (scriptsig, witness_stack), taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+# - Whether this test demands being placed in a txin with no corresponding txout (for testing SIGHASH_SINGLE behavior)\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail,need_vin_vout_mismatch\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, need_vin_vout_mismatch=False, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert tap is None\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert script is None\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert script is None\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert script is None\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            return spend(tx, idx, utxos, **conf)\n+        else:\n+            assert failure is not None\n+            return spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None, need_vin_vout_mismatch=need_vin_vout_mismatch)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    return bytes(CScript([pubkey, OP_CHECKSIG]))\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+def zero_appender(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a zero added.\"\"\"\n+    return lambda ctx: deep_eval(ctx, expr) + b\"\\x00\"\n+\n+def byte_popper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with its last byte removed.\"\"\"\n+    return lambda ctx: deep_eval(ctx, expr)[:-1]\n+\n+# Expected error strings\n+\n+ERR_SIG_SIZE = {\"err_msg\": \"Invalid Schnorr signature size\"}\n+ERR_SIG_HASHTYPE = {\"err_msg\": \"Invalid Schnorr signature hash type\"}\n+ERR_SIG_SCHNORR = {\"err_msg\": \"Invalid Schnorr signature\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_TAPSCRIPT_CHECKMULTISIG = {\"err_msg\": \"OP_CHECKMULTISIG(VERIFY) is not available in tapscript\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal in tapscript\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Stack size must be exactly one after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+ERR_CHECKSIGVERIFY = {\"err_msg\": \"Script failed an OP_CHECKSIGVERIFY operation\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+VALID_SIGHASHES_TAPROOT_SINGLE = [\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT_NO_SINGLE = [h for h in VALID_SIGHASHES_TAPROOT if h not in VALID_SIGHASHES_TAPROOT_SINGLE]\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SIG_POP_BYTE = {\"failure\": {\"sign\": byte_popper(default_sign)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+SIG_ADD_ZERO = {\"failure\": {\"sign\": zero_appender(default_sign)}}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 50000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    secs = [generate_privkey() for _ in range(8)]\n+    pubs = [compute_xonly_pubkey(sec)[0] for sec in secs]\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    tap = taproot_construct(pubs[0])\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=secs[0], failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_SIG_SCHNORR)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=secs[0], failure={\"sighash\": bitflipper(default_sighash)}, **ERR_SIG_SCHNORR)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=secs[0], failure={\"flag_flip_r\": True}, **ERR_SIG_SCHNORR)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=secs[0], failure={\"flag_flip_p\": True}, **ERR_SIG_SCHNORR)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=secs[0], failure={\"signature\": bitflipper(default_signature)}, **ERR_SIG_SCHNORR)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pubs[0])\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pubs[1])))]\n+            tap = taproot_construct(pubs[0], scripts)\n+            add_spender(spenders, \"sighash/keypath_hashtype_%x\" % hashtype, tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+            add_spender(spenders, \"sighash/scriptpath_hashtype_%x\" % hashtype, tap=tap, leaf=\"s0\", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+\n+            # Test SIGHASH_SINGLE behavior in combination with mismatching outputs\n+            if hashtype in VALID_SIGHASHES_TAPROOT_SINGLE:\n+                add_spender(spenders, \"sighash/keypath_hashtype_mis_%x\" % hashtype, tap=tap, key=secs[0], annex=annex, standard=no_annex, hashtype_actual=random.choice(VALID_SIGHASHES_TAPROOT_NO_SINGLE), failure={\"hashtype_actual\": hashtype}, **ERR_SIG_HASHTYPE, need_vin_vout_mismatch=True)\n+                add_spender(spenders, \"sighash/scriptpath_hashtype_mis_%x\" % hashtype, tap=tap, leaf=\"s0\", key=secs[1], annex=annex, standard=no_annex, hashtype_actual=random.choice(VALID_SIGHASHES_TAPROOT_NO_SINGLE), **SINGLE_SIG, failure={\"hashtype_actual\": hashtype}, **ERR_SIG_HASHTYPE, need_vin_vout_mismatch=True)\n+\n+        # Test OP_CODESEPARATOR impact on sighashing.\n+        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+        common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+        scripts = [\n+            (\"pk_codesep\", CScript(random_checksig_style(pubs[1]) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig\n+            (\"codesep_pk\", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pubs[1]))),  # codesep before checksig\n+            (\"branched_codesep\", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pubs[0], OP_ELSE, OP_CODESEPARATOR, pubs[1], OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"sighash/pk_codesep\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+        add_spender(spenders, \"sighash/codesep_pk\", tap=tap, leaf=\"codesep_pk\", key=secs[1], codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+        add_spender(spenders, \"sighash/branched_codesep/left\", tap=tap, leaf=\"branched_codesep\", key=secs[0], codeseppos=3, **common, inputs=[getter(\"sign\"), b'\\x01'], **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+        add_spender(spenders, \"sighash/branched_codesep/right\", tap=tap, leaf=\"branched_codesep\", key=secs[1], codeseppos=6, **common, inputs=[getter(\"sign\"), b''], **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+\n+    # Reusing the scripts above, test that various features affect the sighash.\n+    add_spender(spenders, \"sighash/annex\", tap=tap, leaf=\"pk_codesep\", key=secs[1], hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={\"sighash\": override(default_sighash, annex=None)}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/script\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, script_taproot=tap.leaves[\"codesep_pk\"].script)}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/leafver\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leafversion=random.choice([x & 0xFE for x in range(0x100) if x & 0xFE != 0xC0]))}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leaf=None)}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/keypath\", tap=tap, key=secs[0], **common, failure={\"sighash\": override(default_sighash, leaf=\"pk_codesep\")}, **ERR_SIG_SCHNORR)\n+\n+    # Test that invalid hashtypes don't work, both in key path and script path spends\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for invalid_hashtype in [x for x in range(0x100) if x not in VALID_SIGHASHES_TAPROOT]:\n+        add_spender(spenders, \"sighash/keypath_unk_hashtype_%x\" % invalid_hashtype, tap=tap, key=secs[0], hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_SIG_HASHTYPE)\n+        add_spender(spenders, \"sighash/scriptpath_unk_hashtype_%x\" % invalid_hashtype, tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_SIG_HASHTYPE)\n+\n+    # Test that hashtype 0 cannot have a hashtype byte, and 1 must have one.\n+    add_spender(spenders, \"sighash/hashtype0_byte_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_SIG_HASHTYPE)\n+    add_spender(spenders, \"sighash/hashtype0_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_SIG_HASHTYPE)\n+    add_spender(spenders, \"sighash/hashtype1_byte_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/hashtype1_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SIG_SCHNORR)\n+    # Test that hashtype 0 and hashtype 1 cannot be transmuted into each other.\n+    add_spender(spenders, \"sighash/hashtype0to1_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/hashtype0to1_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/hashtype1to0_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/hashtype1to0_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SIG_SCHNORR)\n+\n+    # Test aspects of signatures with unusual lengths\n+    for hashtype in [SIGHASH_DEFAULT, random.choice(VALID_SIGHASHES_TAPROOT)]:\n+        scripts = [\n+            (\"csv\", CScript([pubs[2], OP_CHECKSIGVERIFY, OP_1])),\n+            (\"cs_pos\", CScript([pubs[2], OP_CHECKSIG])),\n+            (\"csa_pos\", CScript([OP_0, pubs[2], OP_CHECKSIGADD, OP_1, OP_EQUAL])),\n+            (\"cs_neg\", CScript([pubs[2], OP_CHECKSIG, OP_NOT])),\n+            (\"csa_neg\", CScript([OP_2, pubs[2], OP_CHECKSIGADD, OP_2, OP_EQUAL]))\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[3], scripts)\n+        # Empty signatures\n+        add_spender(spenders, \"siglen/empty_keypath\", tap=tap, key=secs[3], hashtype=hashtype, failure={\"sign\": b\"\"}, **ERR_SIG_SIZE)\n+        add_spender(spenders, \"siglen/empty_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_CHECKSIGVERIFY)\n+        add_spender(spenders, \"siglen/empty_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_NO_SUCCESS)\n+        add_spender(spenders, \"siglen/empty_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_NO_SUCCESS)\n+        add_spender(spenders, \"siglen/empty_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": lambda _: random_bytes(random.randrange(1, 63))}, **ERR_SIG_SIZE)\n+        add_spender(spenders, \"siglen/empty_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": lambda _: random_bytes(random.randrange(66, 100))}, **ERR_SIG_SIZE)\n+        # Appending a zero byte to signatures invalidates them\n+        add_spender(spenders, \"siglen/padzero_keypath\", tap=tap, key=secs[3], hashtype=hashtype, **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        add_spender(spenders, \"siglen/padzero_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        add_spender(spenders, \"siglen/padzero_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        add_spender(spenders, \"siglen/padzero_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        add_spender(spenders, \"siglen/padzero_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        add_spender(spenders, \"siglen/padzero_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        # Removing the last byte from signatures invalidates them\n+        add_spender(spenders, \"siglen/popbyte_keypath\", tap=tap, key=secs[3], hashtype=hashtype, **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        add_spender(spenders, \"siglen/popbyte_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        add_spender(spenders, \"siglen/popbyte_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        add_spender(spenders, \"siglen/popbyte_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        add_spender(spenders, \"siglen/popbyte_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        add_spender(spenders, \"siglen/popbyte_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        # Verify that an invalid signature is not allowed, not even when the CHECKSIG* is expected to fail.\n+        add_spender(spenders, \"siglen/invalid_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": default_sign, \"sighash\": bitflipper(default_sighash)}, **ERR_SIG_SCHNORR)\n+        add_spender(spenders, \"siglen/invalid_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": default_sign, \"sighash\": bitflipper(default_sighash)}, **ERR_SIG_SCHNORR)\n+\n+    # == Test that BIP341 spending only applies to witness version 1, program length 32, no P2SH ==\n+\n+    for p2sh in [False, True]:\n+        for witver in range(1, 17):\n+            for witlen in [20, 31, 32, 33]:\n+                def mutate(spk):\n+                    prog = spk[2:]\n+                    assert len(prog) == 32\n+                    if witlen < 32:\n+                        prog = prog[0:witlen]\n+                    elif witlen > 32:\n+                        prog += bytes([0 for _ in range(witlen - 32)])\n+                    return CScript([CScriptOp.encode_op_n(witver), prog])\n+                scripts = [(\"s0\", CScript([pubs[0], OP_CHECKSIG])), (\"dummy\", CScript([OP_RETURN]))]\n+                tap = taproot_construct(pubs[1], scripts)\n+                if not p2sh and witver == 1 and witlen == 32:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, failure={\"leaf\": \"dummy\"}, **ERR_OP_RETURN)\n+                else:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], standard=False)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, standard=False)\n+\n+    # == Test various aspects of BIP341 spending paths ==\n+\n+    # A set of functions that compute the hashing partner in a Merkle tree, designed to exercise\n+    # edge cases. This relies on the taproot_construct feature that a lambda can be passed in\n+    # instead of a subtree, to compute the partner to be hashed with.\n+    PARTNER_MERKLE_FN = [\n+        # Combine with itself\n+        lambda h: h,\n+        # Combine with hash 0\n+        lambda h: bytes([0 for _ in range(32)]),\n+        # Combine with hash 2^256-1\n+        lambda h: bytes([0xff for _ in range(32)]),\n+        # Combine with itself-1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') + 1).to_bytes(32, 'big'),\n+        # Combine with itself-1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') + 1).to_bytes(32, 'little'),\n+        # Combine with random bitflipped version of self.\n+        lambda h: (int.from_bytes(h, 'little') ^ (1 << random.randrange(256))).to_bytes(32, 'little')\n+    ]\n+    # Start with a tree of that has depth 1 for \"128deep\" and depth 2 for \"129deep\".\n+    scripts = [(\"128deep\", CScript([pubs[0], OP_CHECKSIG])), [(\"129deep\", CScript([pubs[0], OP_CHECKSIG])), random.choice(PARTNER_MERKLE_FN)]]\n+    # Add 127 nodes on top of that tree, so that \"128deep\" and \"129deep\" end up at their designated depths.\n+    for _ in range(127):\n+        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+    tap = taproot_construct(pubs[0], scripts)\n+    # Test that spends with a depth of 128 work, but 129 doesn't (even with a tree with weird Merkle branches in it).\n+    add_spender(spenders, \"spendpath/merklelimit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"leaf\": \"129deep\"}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that flipping the negation bit invalidates spends.\n+    add_spender(spenders, \"spendpath/negflag\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"negflag\": lambda ctx: 1 - default_negflag(ctx)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the Merkle branch invalidate it.\n+    add_spender(spenders, \"spendpath/bitflipmerkle\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"merklebranch\": bitflipper(default_merklebranch)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the inner pubkey invalidate it.\n+    add_spender(spenders, \"spendpath/bitflippubkey\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"pubkey_inner\": bitflipper(default_pubkey_inner)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that empty witnesses are invalid.\n+    add_spender(spenders, \"spendpath/emptywit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"witness\": []}, **ERR_EMPTY_WITNESS)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padlongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/trunclongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    scripts = [(\"s\", CScript([pubs[0], OP_CHECKSIG]))]\n+    tap = taproot_construct(pubs[1], scripts)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/truncshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block to 1 byte (\"-1 Merkle length\") invalidates it\n+    add_spender(spenders, \"spendpath/trunc1shortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:1]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    # == Test BIP342 edge cases ==\n+\n+    csa_low_val = random.randrange(0, 17) # Within range for OP_n\n+    csa_low_result = csa_low_val + 1\n+\n+    csa_high_val = random.randrange(17, 100) if random.getrandbits(1) else random.randrange(-100, -1) # Outside OP_n range\n+    csa_high_result = csa_high_val + 1\n+\n+    OVERSIZE_NUMBER = 2**31\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER))), 6)\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER-1))), 5)\n+\n+    big_choices = []\n+    big_scriptops = []\n+    for i in range(1000):\n+        r = random.randrange(len(pubs))\n+        big_choices.append(r)\n+        big_scriptops += [pubs[r], OP_CHECKSIGVERIFY]\n+\n+\n+    def big_spend_inputs(ctx):\n+        \"\"\"Helper function to construct the script input for t33/t34 below.\"\"\"\n+        # Instead of signing 999 times, precompute signatures for every (key, hashtype) combination\n+        sigs = {}\n+        for ht in VALID_SIGHASHES_TAPROOT:\n+            for k in range(len(pubs)):\n+                sigs[(k, ht)] = override(default_sign, hashtype=ht, key=secs[k])(ctx)\n+        num = get(ctx, \"num\")\n+        return [sigs[(big_choices[i], random.choice(VALID_SIGHASHES_TAPROOT))] for i in range(num - 1, -1, -1)]\n+\n+    # Various BIP342 features\n+    scripts = [\n+        # 0) drop stack element and OP_CHECKSIG\n+        (\"t0\", CScript([OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 1) normal OP_CHECKSIG\n+        (\"t1\", CScript([pubs[1], OP_CHECKSIG])),\n+        # 2) normal OP_CHECKSIGVERIFY\n+        (\"t2\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1])),\n+        # 3) Hypothetical OP_CHECKMULTISIG script that takes a single sig as input\n+        (\"t3\", CScript([OP_0, OP_SWAP, OP_1, pubs[1], OP_1, OP_CHECKMULTISIG])),\n+        # 4) Hypothetical OP_CHECKMULTISIGVERIFY script that takes a single sig as input\n+        (\"t4\", CScript([OP_0, OP_SWAP, OP_1, pubs[1], OP_1, OP_CHECKMULTISIGVERIFY, OP_1])),\n+        # 5) OP_IF script that needs a true input\n+        (\"t5\", CScript([OP_IF, pubs[1], OP_CHECKSIG, OP_ELSE, OP_RETURN, OP_ENDIF])),\n+        # 6) OP_NOTIF script that needs a true input\n+        (\"t6\", CScript([OP_NOTIF, OP_RETURN, OP_ELSE, pubs[1], OP_CHECKSIG, OP_ENDIF])),\n+        # 7) OP_CHECKSIG with an empty key\n+        (\"t7\", CScript([OP_0, OP_CHECKSIG])),\n+        # 8) OP_CHECKSIGVERIFY with an empty key\n+        (\"t8\", CScript([OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 9) normal OP_CHECKSIGADD that also ensures return value is correct\n+        (\"t9\", CScript([csa_low_val, pubs[1], OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 10) OP_CHECKSIGADD with empty key\n+        (\"t10\", CScript([csa_low_val, OP_0, OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 11) OP_CHECKSIGADD with missing counter stack element\n+        (\"t11\", CScript([pubs[1], OP_CHECKSIGADD, OP_1, OP_EQUAL])),\n+        # 12) OP_CHECKSIG that needs invalid signature\n+        (\"t12\", CScript([pubs[1], OP_CHECKSIGVERIFY, pubs[0], OP_CHECKSIG, OP_NOT])),\n+        # 13) OP_CHECKSIG with empty key that needs invalid signature\n+        (\"t13\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_CHECKSIG, OP_NOT])),\n+        # 14) OP_CHECKSIGADD that needs invalid signature\n+        (\"t14\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, pubs[0], OP_CHECKSIGADD, OP_NOT])),\n+        # 15) OP_CHECKSIGADD with empty key that needs invalid signature\n+        (\"t15\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGADD, OP_NOT])),\n+        # 16) OP_CHECKSIG with unknown pubkey type\n+        (\"t16\", CScript([OP_1, OP_CHECKSIG])),\n+        # 17) OP_CHECKSIGADD with unknown pubkey type\n+        (\"t17\", CScript([OP_0, OP_1, OP_CHECKSIGADD])),\n+        # 18) OP_CHECKSIGVERIFY with unknown pubkey type\n+        (\"t18\", CScript([OP_1, OP_CHECKSIGVERIFY, OP_1])),\n+        # 19) script longer than 10000 bytes and over 201 non-push opcodes\n+        (\"t19\", CScript([OP_0, OP_0, OP_2DROP] * 10001 + [pubs[1], OP_CHECKSIG])),\n+        # 20) OP_CHECKSIGVERIFY with empty key\n+        (\"t20\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 21) Script that grows the stack to 1000 elements\n+        (\"t21\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 999 + [OP_DROP] * 999)),\n+        # 22) Script that grows the stack to 1001 elements\n+        (\"t22\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 1000 + [OP_DROP] * 1000)),\n+        # 23) Script that expects an input stack of 1000 elements\n+        (\"t23\", CScript([OP_DROP] * 999 + [pubs[1], OP_CHECKSIG])),\n+        # 24) Script that expects an input stack of 1001 elements\n+        (\"t24\", CScript([OP_DROP] * 1000 + [pubs[1], OP_CHECKSIG])),\n+        # 25) Script that pushes a MAX_SCRIPT_ELEMENT_SIZE-bytes element\n+        (\"t25\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE), OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 26) Script that pushes a (MAX_SCRIPT_ELEMENT_SIZE+1)-bytes element\n+        (\"t26\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 27) CHECKSIGADD that must fail because numeric argument number is >4 bytes\n+        (\"t27\", CScript([CScriptNum(OVERSIZE_NUMBER), pubs[1], OP_CHECKSIGADD])),\n+        # 28) Pushes random CScriptNum value, checks OP_CHECKSIGADD result\n+        (\"t28\", CScript([csa_high_val, pubs[1], OP_CHECKSIGADD, csa_high_result, OP_EQUAL])),\n+        # 29) CHECKSIGADD that succeeds with proper sig because numeric argument number is <=4 bytes\n+        (\"t29\", CScript([CScriptNum(OVERSIZE_NUMBER-1), pubs[1], OP_CHECKSIGADD])),\n+        # 30) Variant of t1 with \"normal\" 33-byte pubkey\n+        (\"t30\", CScript([b'\\x03' + pubs[1], OP_CHECKSIG])),\n+        # 31) Variant of t2 with \"normal\" 33-byte pubkey\n+        (\"t31\", CScript([b'\\x02' + pubs[1], OP_CHECKSIGVERIFY, OP_1])),\n+        # 32) Variant of t28 with \"normal\" 33-byte pubkey\n+        (\"t32\", CScript([csa_high_val, b'\\x03' + pubs[1], OP_CHECKSIGADD, csa_high_result, OP_EQUAL])),\n+        # 33) 999-of-999 multisig\n+        (\"t33\", CScript(big_scriptops[:1998] + [OP_1])),\n+        # 34) 1000-of-1000 multisig\n+        (\"t34\", CScript(big_scriptops[:2000] + [OP_1])),\n+        # 35) Variant of t9 that uses a non-minimally encoded input arg\n+        (\"t35\", CScript([bytes([csa_low_val]), pubs[1], OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 36) Empty script\n+        (\"t36\", CScript([])),\n+    ]\n+    # Add many dummies to test huge trees\n+    for j in range(100000):\n+        scripts.append((None, CScript([OP_RETURN, random.randrange(100000)])))\n+    random.shuffle(scripts)\n+    tap = taproot_construct(pubs[0], scripts)\n+    common = {\n+        \"hashtype\": hashtype,\n+        \"key\": secs[1],\n+        \"tap\": tap,\n+    }\n+    # Test that MAX_SCRIPT_ELEMENT_SIZE byte stack element inputs are valid, but not one more (and 80 bytes is standard but 81 is not).\n+    add_spender(spenders, \"tapscript/inputmaxlimit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE)], failure={\"inputs\": [getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1)]}, **ERR_PUSH_LIMIT)\n+    add_spender(spenders, \"tapscript/input80limit\", leaf=\"t0\", **common, inputs=[getter(\"sign\"), random_bytes(80)])\n+    add_spender(spenders, \"tapscript/input81limit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(81)])\n+    # Test that OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY cause failure, but OP_CHECKSIG and OP_CHECKSIGVERIFY work.\n+    add_spender(spenders, \"tapscript/disabled_checkmultisig\", leaf=\"t1\", **common, **SINGLE_SIG, failure={\"leaf\": \"t3\"}, **ERR_TAPSCRIPT_CHECKMULTISIG)\n+    add_spender(spenders, \"tapscript/disabled_checkmultisigverify\", leaf=\"t2\", **common, **SINGLE_SIG, failure={\"leaf\": \"t4\"}, **ERR_TAPSCRIPT_CHECKMULTISIG)\n+    # Test that OP_IF and OP_NOTIF do not accept non-0x01 as truth value (the MINIMALIF rule is consensus in Tapscript)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x02']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x03']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0001']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0100']}, **ERR_MINIMALIF)\n+    # Test that 1-byte public keys (which are unknown) are acceptable but nonstandard with unrelated signatures, but 0-byte public keys are not valid.\n+    add_spender(spenders, \"tapscript/unkpk/checksig\", leaf=\"t16\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigadd\", leaf=\"t17\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigverify\", leaf=\"t18\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that 33-byte public keys (which are unknown) are acceptable but nonstandard with valid signatures, but normal pubkeys are not valid in that case.\n+    add_spender(spenders, \"tapscript/oldpk/checksig\", leaf=\"t30\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t1\"}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"tapscript/oldpk/checksigadd\", leaf=\"t31\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t2\"}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"tapscript/oldpk/checksigverify\", leaf=\"t32\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t28\"}, **ERR_SIG_SCHNORR)\n+    # Test that 0-byte public keys are not acceptable.\n+    add_spender(spenders, \"tapscript/emptypk/checksig\", leaf=\"t1\", **SINGLE_SIG, **common, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigverify\", leaf=\"t2\", **SINGLE_SIG, **common, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigadd\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigadd\", leaf=\"t35\", standard=False, **SINGLE_SIG, **common, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that OP_CHECKSIGADD results are as expected\n+    add_spender(spenders, \"tapscript/checksigaddresults\", leaf=\"t28\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    add_spender(spenders, \"tapscript/checksigaddoversize\", leaf=\"t29\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    # Test that OP_CHECKSIGADD requires 3 stack elements.\n+    add_spender(spenders, \"tapscript/checksigadd3args\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t11\"}, **ERR_STACK_EMPTY)\n+    # Test that empty signatures do not cause script failure in OP_CHECKSIG and OP_CHECKSIGADD (but do fail with empty pubkey, and do fail OP_CHECKSIGVERIFY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksig\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t13\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/nochecksigverify\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t20\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksigadd\", leaf=\"t14\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t15\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that scripts over 10000 bytes (and over 201 non-push ops) are acceptable.\n+    add_spender(spenders, \"tapscript/no10000limit\", leaf=\"t19\", **SINGLE_SIG, **common)\n+    # Test that a stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000stack\", leaf=\"t21\", **SINGLE_SIG, **common, failure={\"leaf\": \"t22\"}, **ERR_STACK_SIZE)\n+    # Test that an input stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000inputs\", leaf=\"t23\", **common, inputs=[getter(\"sign\")] + [b'' for _ in range(999)], failure={\"leaf\": \"t24\", \"inputs\": [getter(\"sign\")] + [b'' for _ in range(1000)]}, **ERR_STACK_SIZE)\n+    # Test that pushing a MAX_SCRIPT_ELEMENT_SIZE byte stack element is valid, but one longer is not.\n+    add_spender(spenders, \"tapscript/pushmaxlimit\", leaf=\"t25\", **common, **SINGLE_SIG, failure={\"leaf\": \"t26\"}, **ERR_PUSH_LIMIT)\n+    # Test that 999-of-999 multisig works (but 1000-of-1000 triggers stack size limits)\n+    add_spender(spenders, \"tapscript/bigmulti\", leaf=\"t33\", **common, inputs=big_spend_inputs, num=999, failure={\"leaf\": \"t34\", \"num\": 1000}, **ERR_STACK_SIZE)\n+    # Test that the CLEANSTACK rule is consensus critical in tapscript\n+    add_spender(spenders, \"tapscript/cleanstack\", leaf=\"t36\", tap=tap, inputs=[b'\\x01'], failure={\"inputs\": [b'\\x01', b'\\x01']}, **ERR_CLEANSTACK)\n+\n+    # == Test for sigops ratio limit ==\n+\n+    # Given a number n, and a public key pk, functions that produce a (CScript, sigops). Each script takes as\n+    # input a valid signature with the passed pk followed by a dummy push of bytes that are to be dropped, and\n+    # will execute sigops signature checks.\n+    SIGOPS_RATIO_SCRIPTS = [\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIG.\n+        lambda n, pk: (CScript([OP_DROP, pk] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGVERIFY.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_0, OP_IF, OP_2DUP, OP_CHECKSIGVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_2, OP_SWAP, OP_CHECKSIGADD, OP_3, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIG.\n+        lambda n, pk: (CScript([random_bytes(220), OP_2DROP, pk, OP_1, OP_NOTIF, OP_2DUP, OP_CHECKSIG, OP_VERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_4, OP_SWAP, OP_CHECKSIGADD, OP_5, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGADD.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_1, OP_IF, OP_ELSE, OP_2DUP, OP_6, OP_SWAP, OP_CHECKSIGADD, OP_7, OP_EQUALVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_8, OP_SWAP, OP_CHECKSIGADD, OP_9, OP_EQUAL]), n + 1),\n+        # n+1 OP_CHECKSIGs, but also one OP_CHECKSIG with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, pk, OP_CHECKSIG, OP_NOT, OP_VERIFY, pk] + [OP_2DUP, OP_CHECKSIG, OP_VERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGADDs and 1 OP_CHECKSIG, but also an OP_CHECKSIGADD with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, OP_10, pk, OP_CHECKSIGADD, OP_10, OP_EQUALVERIFY, pk] + [OP_2DUP, OP_16, OP_SWAP, OP_CHECKSIGADD, b'\\x11', OP_EQUALVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+    ]\n+    for annex in [None, bytes([ANNEX_TAG]) + random_bytes(random.randrange(1000))]:\n+        for hashtype in [SIGHASH_DEFAULT, SIGHASH_ALL]:\n+            for pubkey in [pubs[1], random_bytes(random.choice([x for x in range(2, 81) if x != 32]))]:\n+                for fn_num, fn in enumerate(SIGOPS_RATIO_SCRIPTS):\n+                    merkledepth = random.randrange(129)\n+\n+\n+                    def predict_sigops_ratio(n, dummy_size):\n+                        \"\"\"Predict whether spending fn(n, pubkey) with dummy_size will pass the ratio test.\"\"\"\n+                        script, sigops = fn(n, pubkey)\n+                        # Predict the size of the witness for a given choice of n\n+                        stacklen_size = 1\n+                        sig_size = 64 + (hashtype != SIGHASH_DEFAULT)\n+                        siglen_size = 1\n+                        dummylen_size = 1 + 2 * (dummy_size >= 253)\n+                        script_size = len(script)\n+                        scriptlen_size = 1 + 2 * (script_size >= 253)\n+                        control_size = 33 + 32 * merkledepth\n+                        controllen_size = 1 + 2 * (control_size >= 253)\n+                        annex_size = 0 if annex is None else len(annex)\n+                        annexlen_size = 0 if annex is None else 1 + 2 * (annex_size >= 253)\n+                        witsize = stacklen_size + sig_size + siglen_size + dummy_size + dummylen_size + script_size + scriptlen_size + control_size + controllen_size + annex_size + annexlen_size\n+                        # sigops ratio test\n+                        return witsize + 50 >= 50 * sigops\n+                    # Make sure n is high enough that with empty dummy, the script is not valid\n+                    n = 0\n+                    while predict_sigops_ratio(n, 0):\n+                        n += 1\n+                    # But allow picking a bit higher still\n+                    n += random.randrange(5)\n+                    # Now pick dummy size *just* large enough that the overall construction passes\n+                    dummylen = 0\n+                    while not predict_sigops_ratio(n, dummylen):\n+                        dummylen += 1\n+                    scripts = [(\"s\", fn(n, pubkey)[0])]\n+                    for _ in range(merkledepth):\n+                        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+                    tap = taproot_construct(pubs[0], scripts)\n+                    standard = annex is None and dummylen <= 80 and len(pubkey) == 32\n+                    add_spender(spenders, \"tapscript/sigopsratio_%i\" % fn_num, tap=tap, leaf=\"s\", annex=annex, hashtype=hashtype, key=secs[1], inputs=[getter(\"sign\"), random_bytes(dummylen)], standard=standard, failure={\"inputs\": [getter(\"sign\"), random_bytes(dummylen - 1)]}, **ERR_SIGOPS_RATIO)\n+\n+    # Future leaf versions\n+    for leafver in range(0, 0x100, 2):\n+        if leafver == LEAF_VERSION_TAPSCRIPT or leafver == ANNEX_TAG:\n+            # Skip the defined LEAF_VERSION_TAPSCRIPT, and the ANNEX_TAG which is not usable as leaf version\n+            continue\n+        scripts = [\n+            (\"bare_c0\", CScript([OP_NOP])),\n+            (\"bare_unkver\", CScript([OP_NOP]), leafver),\n+            (\"return_c0\", CScript([OP_RETURN])),\n+            (\"return_unkver\", CScript([OP_RETURN]), leafver),\n+            (\"undecodable_c0\", CScript([OP_PUSHDATA1])),\n+            (\"undecodable_unkver\", CScript([OP_PUSHDATA1]), leafver),\n+            (\"bigpush_c0\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP])),\n+            (\"bigpush_unkver\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP]), leafver),\n+            (\"1001push_c0\", CScript([OP_0] * 1001)),\n+            (\"1001push_unkver\", CScript([OP_0] * 1001), leafver),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"unkver/bare\", standard=False, tap=tap, leaf=\"bare_unkver\", failure={\"leaf\": \"bare_c0\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"unkver/return\", standard=False, tap=tap, leaf=\"return_unkver\", failure={\"leaf\": \"return_c0\"}, **ERR_OP_RETURN)\n+        add_spender(spenders, \"unkver/undecodable\", standard=False, tap=tap, leaf=\"undecodable_unkver\", failure={\"leaf\": \"undecodable_c0\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"unkver/bigpush\", standard=False, tap=tap, leaf=\"bigpush_unkver\", failure={\"leaf\": \"bigpush_c0\"}, **ERR_PUSH_LIMIT)\n+        add_spender(spenders, \"unkver/1001push\", standard=False, tap=tap, leaf=\"1001push_unkver\", failure={\"leaf\": \"1001push_c0\"}, **ERR_STACK_SIZE)\n+        add_spender(spenders, \"unkver/1001inputs\", standard=False, tap=tap, leaf=\"bare_unkver\", inputs=[b'']*1001, failure={\"leaf\": \"bare_c0\"}, **ERR_STACK_SIZE)\n+\n+    # OP_SUCCESSx tests.\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for opval in range(76, 0x100):\n+        opcode = CScriptOp(opval)\n+        if not is_op_success(opcode):\n+            continue\n+        scripts = [\n+            (\"bare_success\", CScript([opcode])),\n+            (\"bare_nop\", CScript([OP_NOP])),\n+            (\"unexecif_success\", CScript([OP_0, OP_IF, opcode, OP_ENDIF])),\n+            (\"unexecif_nop\", CScript([OP_0, OP_IF, OP_NOP, OP_ENDIF])),\n+            (\"return_success\", CScript([OP_RETURN, opcode])),\n+            (\"return_nop\", CScript([OP_RETURN, OP_NOP])),\n+            (\"undecodable_success\", CScript([opcode, OP_PUSHDATA1])),\n+            (\"undecodable_nop\", CScript([OP_NOP, OP_PUSHDATA1])),\n+            (\"undecodable_bypassed_success\", CScript([OP_PUSHDATA1, OP_2, opcode])),\n+            (\"bigpush_success\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, opcode])),\n+            (\"bigpush_nop\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, OP_NOP])),\n+            (\"1001push_success\", CScript([OP_0] * 1001 + [opcode])),\n+            (\"1001push_nop\", CScript([OP_0] * 1001 + [OP_NOP])),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"opsuccess/bare\", standard=False, tap=tap, leaf=\"bare_success\", failure={\"leaf\": \"bare_nop\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"opsuccess/unexecif\", standard=False, tap=tap, leaf=\"unexecif_success\", failure={\"leaf\": \"unexecif_nop\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"opsuccess/return\", standard=False, tap=tap, leaf=\"return_success\", failure={\"leaf\": \"return_nop\"}, **ERR_OP_RETURN)\n+        add_spender(spenders, \"opsuccess/undecodable\", standard=False, tap=tap, leaf=\"undecodable_success\", failure={\"leaf\": \"undecodable_nop\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"opsuccess/undecodable_bypass\", standard=False, tap=tap, leaf=\"undecodable_success\", failure={\"leaf\": \"undecodable_bypassed_success\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"opsuccess/bigpush\", standard=False, tap=tap, leaf=\"bigpush_success\", failure={\"leaf\": \"bigpush_nop\"}, **ERR_PUSH_LIMIT)\n+        add_spender(spenders, \"opsuccess/1001push\", standard=False, tap=tap, leaf=\"1001push_success\", failure={\"leaf\": \"1001push_nop\"}, **ERR_STACK_SIZE)\n+        add_spender(spenders, \"opsuccess/1001inputs\", standard=False, tap=tap, leaf=\"bare_success\", inputs=[b'']*1001, failure={\"leaf\": \"bare_nop\"}, **ERR_STACK_SIZE)\n+\n+    # Non-OP_SUCCESSx (verify that those aren't accidentally treated as OP_SUCCESSx)\n+    for opval in range(0, 0x100):\n+        opcode = CScriptOp(opval)\n+        if is_op_success(opcode):\n+            continue\n+        scripts = [\n+            (\"normal\", CScript([OP_RETURN, opcode] + [OP_NOP] * 75)),\n+            (\"op_success\", CScript([OP_RETURN, CScriptOp(0x50)]))\n+        ]\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"alwaysvalid/notsuccessx\", tap=tap, leaf=\"op_success\", inputs=[], standard=False, failure={\"leaf\": \"normal\"}) # err_msg differs based on opcode\n+\n+    # == Legacy tests ==\n+\n+    # Also add a few legacy spends into the mix, so that transactions which combine taproot and pre-taproot spends get tested too.\n+    for compressed in [False, True]:\n+        eckey1 = ECKey()\n+        eckey1.set(generate_privkey(), compressed)\n+        pubkey1 = eckey1.get_pubkey().get_bytes()\n+        eckey2 = ECKey()\n+        eckey2.set(generate_privkey(), compressed)\n+        for p2sh in [False, True]:\n+            for witv0 in [False, True]:\n+                for hashtype in VALID_SIGHASHES_ECDSA + [random.randrange(0x04, 0x80), random.randrange(0x84, 0x100)]:\n+                    standard = (hashtype in VALID_SIGHASHES_ECDSA) and (compressed or not witv0)\n+                    add_spender(spenders, \"legacy/pk-wrongkey\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, script=CScript([pubkey1, OP_CHECKSIG]), **SINGLE_SIG, key=eckey1, failure={\"key\": eckey2}, sigops_weight=4-3*witv0, **ERR_NO_SUCCESS)\n+                    add_spender(spenders, \"legacy/pkh-sighashflip\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, pkh=pubkey1, key=eckey1, **SIGHASH_BITFLIP, sigops_weight=4-3*witv0, **ERR_NO_SUCCESS)\n+\n+    # Verify that OP_CHECKSIGADD wasn't accidentally added to pre-taproot validation logic.\n+    for p2sh in [False, True]:\n+        for witv0 in [False, True]:\n+            for hashtype in VALID_SIGHASHES_ECDSA + [random.randrange(0x04, 0x80), random.randrange(0x84, 0x100)]:\n+                standard = hashtype in VALID_SIGHASHES_ECDSA and (p2sh or witv0)\n+                add_spender(spenders, \"compat/nocsa\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, script=CScript([OP_IF, OP_11, pubkey1, OP_CHECKSIGADD, OP_12, OP_EQUAL, OP_ELSE, pubkey1, OP_CHECKSIG, OP_ENDIF]), key=eckey1, sigops_weight=4-3*witv0, inputs=[getter(\"sign\"), b''], failure={\"inputs\": [getter(\"sign\"), b'\\x01']}, **ERR_UNDECODABLE)\n+\n+    return spenders\n+\n+def spenders_taproot_inactive():\n+    \"\"\"Spenders for testing that pre-activation Taproot rules don't apply.\"\"\"\n+\n+    spenders = []\n+\n+    sec = generate_privkey()\n+    pub, _ = compute_xonly_pubkey(sec)\n+    scripts = [\n+        (\"pk\", CScript([pub, OP_CHECKSIG])),\n+        (\"future_leaf\", CScript([pub, OP_CHECKSIG]), 0xc2),\n+        (\"op_success\", CScript([pub, OP_CHECKSIG, OP_0, OP_IF, CScriptOp(0x50), OP_ENDIF])),\n+    ]\n+    tap = taproot_construct(pub, scripts)\n+\n+    # Test that keypath spending is valid & standard if compliant, but valid and nonstandard otherwise.\n+    add_spender(spenders, \"inactive/keypath_valid\", key=sec, tap=tap)\n+    add_spender(spenders, \"inactive/keypath_invalidsig\", key=sec, tap=tap, standard=False, sighash=bitflipper(default_sighash))\n+    add_spender(spenders, \"inactive/keypath_empty\", key=sec, tap=tap, standard=False, witness=[])\n+\n+    # Same for scriptpath spending (but using future features like annex, leaf versions, or OP_SUCCESS is nonstandard).\n+    add_spender(spenders, \"inactive/scriptpath_valid\", key=sec, tap=tap, leaf=\"pk\", inputs=[getter(\"sign\")])\n+    add_spender(spenders, \"inactive/scriptpath_invalidsig\", key=sec, tap=tap, leaf=\"pk\", standard=False, inputs=[getter(\"sign\")], sighash=bitflipper(default_sighash))\n+    add_spender(spenders, \"inactive/scriptpath_invalidcb\", key=sec, tap=tap, leaf=\"pk\", standard=False, inputs=[getter(\"sign\")], controlblock=bitflipper(default_controlblock))\n+    add_spender(spenders, \"inactive/scriptpath_valid_unkleaf\", key=sec, tap=tap, leaf=\"future_leaf\", standard=False, inputs=[getter(\"sign\")])\n+    add_spender(spenders, \"inactive/scriptpath_invalid_unkleaf\", key=sec, tap=tap, leaf=\"future_leaf\", standard=False, inputs=[getter(\"sign\")], sighash=bitflipper(default_sighash))\n+    add_spender(spenders, \"inactive/scriptpath_valid_opsuccess\", key=sec, tap=tap, leaf=\"op_success\", standard=False, inputs=[getter(\"sign\")])\n+    add_spender(spenders, \"inactive/scriptpath_valid_opsuccess\", key=sec, tap=tap, leaf=\"op_success\", standard=False, inputs=[getter(\"sign\")], sighash=bitflipper(default_sighash))\n+\n+    return spenders\n+\n+# Data type to keep track of UTXOs, where they were created, and how to spend them.\n+UTXOData = namedtuple('UTXOData', 'outpoint,output,spender')\n+\n+class TaprootTest(BitcoinTestFramework):\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.setup_clean_chain = True\n+        # Node 0 has Taproot inactive, Node 1 active.\n+        self.extra_args = [[\"-whitelist=127.0.0.1\", \"-par=1\", \"-vbparams=taproot:1:1\"], [\"-whitelist=127.0.0.1\", \"-par=1\"]]",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509400019",
      "id" : 509400019,
      "line" : 1202,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQwMDAxOQ==",
      "original_commit_id" : "f06e6d03452cf5e0b1a0863afb08c9e6d3ef452e",
      "original_line" : 1157,
      "original_position" : 1157,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : 1202,
      "pull_request_review_id" : 513499921,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-21T16:20:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509400019",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509400473"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509400473"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The nodes are already connected. Can you explain why the nodes need to be connected twice?",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-21T15:47:07Z",
      "diff_hunk" : "@@ -0,0 +1,1411 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expression for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        return tweak_add_privkey(key, tweak)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    scriptsig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    witness_stack = flatten(get(ctx, \"witness\"))\n+    return (scriptsig, witness_stack)\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda returning (scriptsig, witness_stack), taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+# - Whether this test demands being placed in a txin with no corresponding txout (for testing SIGHASH_SINGLE behavior)\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail,need_vin_vout_mismatch\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, need_vin_vout_mismatch=False, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert tap is None\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert script is None\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert script is None\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert script is None\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            return spend(tx, idx, utxos, **conf)\n+        else:\n+            assert failure is not None\n+            return spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None, need_vin_vout_mismatch=need_vin_vout_mismatch)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    return bytes(CScript([pubkey, OP_CHECKSIG]))\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+def zero_appender(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a zero added.\"\"\"\n+    return lambda ctx: deep_eval(ctx, expr) + b\"\\x00\"\n+\n+def byte_popper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with its last byte removed.\"\"\"\n+    return lambda ctx: deep_eval(ctx, expr)[:-1]\n+\n+# Expected error strings\n+\n+ERR_SIG_SIZE = {\"err_msg\": \"Invalid Schnorr signature size\"}\n+ERR_SIG_HASHTYPE = {\"err_msg\": \"Invalid Schnorr signature hash type\"}\n+ERR_SIG_SCHNORR = {\"err_msg\": \"Invalid Schnorr signature\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_TAPSCRIPT_CHECKMULTISIG = {\"err_msg\": \"OP_CHECKMULTISIG(VERIFY) is not available in tapscript\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal in tapscript\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Stack size must be exactly one after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+ERR_CHECKSIGVERIFY = {\"err_msg\": \"Script failed an OP_CHECKSIGVERIFY operation\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+VALID_SIGHASHES_TAPROOT_SINGLE = [\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT_NO_SINGLE = [h for h in VALID_SIGHASHES_TAPROOT if h not in VALID_SIGHASHES_TAPROOT_SINGLE]\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SIG_POP_BYTE = {\"failure\": {\"sign\": byte_popper(default_sign)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+SIG_ADD_ZERO = {\"failure\": {\"sign\": zero_appender(default_sign)}}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 50000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    secs = [generate_privkey() for _ in range(8)]\n+    pubs = [compute_xonly_pubkey(sec)[0] for sec in secs]\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    tap = taproot_construct(pubs[0])\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=secs[0], failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_SIG_SCHNORR)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=secs[0], failure={\"sighash\": bitflipper(default_sighash)}, **ERR_SIG_SCHNORR)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=secs[0], failure={\"flag_flip_r\": True}, **ERR_SIG_SCHNORR)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=secs[0], failure={\"flag_flip_p\": True}, **ERR_SIG_SCHNORR)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=secs[0], failure={\"signature\": bitflipper(default_signature)}, **ERR_SIG_SCHNORR)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pubs[0])\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pubs[1])))]\n+            tap = taproot_construct(pubs[0], scripts)\n+            add_spender(spenders, \"sighash/keypath_hashtype_%x\" % hashtype, tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+            add_spender(spenders, \"sighash/scriptpath_hashtype_%x\" % hashtype, tap=tap, leaf=\"s0\", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+\n+            # Test SIGHASH_SINGLE behavior in combination with mismatching outputs\n+            if hashtype in VALID_SIGHASHES_TAPROOT_SINGLE:\n+                add_spender(spenders, \"sighash/keypath_hashtype_mis_%x\" % hashtype, tap=tap, key=secs[0], annex=annex, standard=no_annex, hashtype_actual=random.choice(VALID_SIGHASHES_TAPROOT_NO_SINGLE), failure={\"hashtype_actual\": hashtype}, **ERR_SIG_HASHTYPE, need_vin_vout_mismatch=True)\n+                add_spender(spenders, \"sighash/scriptpath_hashtype_mis_%x\" % hashtype, tap=tap, leaf=\"s0\", key=secs[1], annex=annex, standard=no_annex, hashtype_actual=random.choice(VALID_SIGHASHES_TAPROOT_NO_SINGLE), **SINGLE_SIG, failure={\"hashtype_actual\": hashtype}, **ERR_SIG_HASHTYPE, need_vin_vout_mismatch=True)\n+\n+        # Test OP_CODESEPARATOR impact on sighashing.\n+        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+        common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+        scripts = [\n+            (\"pk_codesep\", CScript(random_checksig_style(pubs[1]) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig\n+            (\"codesep_pk\", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pubs[1]))),  # codesep before checksig\n+            (\"branched_codesep\", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pubs[0], OP_ELSE, OP_CODESEPARATOR, pubs[1], OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"sighash/pk_codesep\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+        add_spender(spenders, \"sighash/codesep_pk\", tap=tap, leaf=\"codesep_pk\", key=secs[1], codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+        add_spender(spenders, \"sighash/branched_codesep/left\", tap=tap, leaf=\"branched_codesep\", key=secs[0], codeseppos=3, **common, inputs=[getter(\"sign\"), b'\\x01'], **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+        add_spender(spenders, \"sighash/branched_codesep/right\", tap=tap, leaf=\"branched_codesep\", key=secs[1], codeseppos=6, **common, inputs=[getter(\"sign\"), b''], **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+\n+    # Reusing the scripts above, test that various features affect the sighash.\n+    add_spender(spenders, \"sighash/annex\", tap=tap, leaf=\"pk_codesep\", key=secs[1], hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={\"sighash\": override(default_sighash, annex=None)}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/script\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, script_taproot=tap.leaves[\"codesep_pk\"].script)}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/leafver\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leafversion=random.choice([x & 0xFE for x in range(0x100) if x & 0xFE != 0xC0]))}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leaf=None)}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/keypath\", tap=tap, key=secs[0], **common, failure={\"sighash\": override(default_sighash, leaf=\"pk_codesep\")}, **ERR_SIG_SCHNORR)\n+\n+    # Test that invalid hashtypes don't work, both in key path and script path spends\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for invalid_hashtype in [x for x in range(0x100) if x not in VALID_SIGHASHES_TAPROOT]:\n+        add_spender(spenders, \"sighash/keypath_unk_hashtype_%x\" % invalid_hashtype, tap=tap, key=secs[0], hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_SIG_HASHTYPE)\n+        add_spender(spenders, \"sighash/scriptpath_unk_hashtype_%x\" % invalid_hashtype, tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_SIG_HASHTYPE)\n+\n+    # Test that hashtype 0 cannot have a hashtype byte, and 1 must have one.\n+    add_spender(spenders, \"sighash/hashtype0_byte_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_SIG_HASHTYPE)\n+    add_spender(spenders, \"sighash/hashtype0_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_SIG_HASHTYPE)\n+    add_spender(spenders, \"sighash/hashtype1_byte_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/hashtype1_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SIG_SCHNORR)\n+    # Test that hashtype 0 and hashtype 1 cannot be transmuted into each other.\n+    add_spender(spenders, \"sighash/hashtype0to1_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/hashtype0to1_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/hashtype1to0_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/hashtype1to0_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SIG_SCHNORR)\n+\n+    # Test aspects of signatures with unusual lengths\n+    for hashtype in [SIGHASH_DEFAULT, random.choice(VALID_SIGHASHES_TAPROOT)]:\n+        scripts = [\n+            (\"csv\", CScript([pubs[2], OP_CHECKSIGVERIFY, OP_1])),\n+            (\"cs_pos\", CScript([pubs[2], OP_CHECKSIG])),\n+            (\"csa_pos\", CScript([OP_0, pubs[2], OP_CHECKSIGADD, OP_1, OP_EQUAL])),\n+            (\"cs_neg\", CScript([pubs[2], OP_CHECKSIG, OP_NOT])),\n+            (\"csa_neg\", CScript([OP_2, pubs[2], OP_CHECKSIGADD, OP_2, OP_EQUAL]))\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[3], scripts)\n+        # Empty signatures\n+        add_spender(spenders, \"siglen/empty_keypath\", tap=tap, key=secs[3], hashtype=hashtype, failure={\"sign\": b\"\"}, **ERR_SIG_SIZE)\n+        add_spender(spenders, \"siglen/empty_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_CHECKSIGVERIFY)\n+        add_spender(spenders, \"siglen/empty_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_NO_SUCCESS)\n+        add_spender(spenders, \"siglen/empty_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_NO_SUCCESS)\n+        add_spender(spenders, \"siglen/empty_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": lambda _: random_bytes(random.randrange(1, 63))}, **ERR_SIG_SIZE)\n+        add_spender(spenders, \"siglen/empty_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": lambda _: random_bytes(random.randrange(66, 100))}, **ERR_SIG_SIZE)\n+        # Appending a zero byte to signatures invalidates them\n+        add_spender(spenders, \"siglen/padzero_keypath\", tap=tap, key=secs[3], hashtype=hashtype, **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        add_spender(spenders, \"siglen/padzero_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        add_spender(spenders, \"siglen/padzero_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        add_spender(spenders, \"siglen/padzero_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        add_spender(spenders, \"siglen/padzero_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        add_spender(spenders, \"siglen/padzero_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        # Removing the last byte from signatures invalidates them\n+        add_spender(spenders, \"siglen/popbyte_keypath\", tap=tap, key=secs[3], hashtype=hashtype, **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        add_spender(spenders, \"siglen/popbyte_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        add_spender(spenders, \"siglen/popbyte_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        add_spender(spenders, \"siglen/popbyte_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        add_spender(spenders, \"siglen/popbyte_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        add_spender(spenders, \"siglen/popbyte_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        # Verify that an invalid signature is not allowed, not even when the CHECKSIG* is expected to fail.\n+        add_spender(spenders, \"siglen/invalid_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": default_sign, \"sighash\": bitflipper(default_sighash)}, **ERR_SIG_SCHNORR)\n+        add_spender(spenders, \"siglen/invalid_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": default_sign, \"sighash\": bitflipper(default_sighash)}, **ERR_SIG_SCHNORR)\n+\n+    # == Test that BIP341 spending only applies to witness version 1, program length 32, no P2SH ==\n+\n+    for p2sh in [False, True]:\n+        for witver in range(1, 17):\n+            for witlen in [20, 31, 32, 33]:\n+                def mutate(spk):\n+                    prog = spk[2:]\n+                    assert len(prog) == 32\n+                    if witlen < 32:\n+                        prog = prog[0:witlen]\n+                    elif witlen > 32:\n+                        prog += bytes([0 for _ in range(witlen - 32)])\n+                    return CScript([CScriptOp.encode_op_n(witver), prog])\n+                scripts = [(\"s0\", CScript([pubs[0], OP_CHECKSIG])), (\"dummy\", CScript([OP_RETURN]))]\n+                tap = taproot_construct(pubs[1], scripts)\n+                if not p2sh and witver == 1 and witlen == 32:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, failure={\"leaf\": \"dummy\"}, **ERR_OP_RETURN)\n+                else:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], standard=False)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, standard=False)\n+\n+    # == Test various aspects of BIP341 spending paths ==\n+\n+    # A set of functions that compute the hashing partner in a Merkle tree, designed to exercise\n+    # edge cases. This relies on the taproot_construct feature that a lambda can be passed in\n+    # instead of a subtree, to compute the partner to be hashed with.\n+    PARTNER_MERKLE_FN = [\n+        # Combine with itself\n+        lambda h: h,\n+        # Combine with hash 0\n+        lambda h: bytes([0 for _ in range(32)]),\n+        # Combine with hash 2^256-1\n+        lambda h: bytes([0xff for _ in range(32)]),\n+        # Combine with itself-1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') + 1).to_bytes(32, 'big'),\n+        # Combine with itself-1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') + 1).to_bytes(32, 'little'),\n+        # Combine with random bitflipped version of self.\n+        lambda h: (int.from_bytes(h, 'little') ^ (1 << random.randrange(256))).to_bytes(32, 'little')\n+    ]\n+    # Start with a tree of that has depth 1 for \"128deep\" and depth 2 for \"129deep\".\n+    scripts = [(\"128deep\", CScript([pubs[0], OP_CHECKSIG])), [(\"129deep\", CScript([pubs[0], OP_CHECKSIG])), random.choice(PARTNER_MERKLE_FN)]]\n+    # Add 127 nodes on top of that tree, so that \"128deep\" and \"129deep\" end up at their designated depths.\n+    for _ in range(127):\n+        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+    tap = taproot_construct(pubs[0], scripts)\n+    # Test that spends with a depth of 128 work, but 129 doesn't (even with a tree with weird Merkle branches in it).\n+    add_spender(spenders, \"spendpath/merklelimit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"leaf\": \"129deep\"}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that flipping the negation bit invalidates spends.\n+    add_spender(spenders, \"spendpath/negflag\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"negflag\": lambda ctx: 1 - default_negflag(ctx)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the Merkle branch invalidate it.\n+    add_spender(spenders, \"spendpath/bitflipmerkle\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"merklebranch\": bitflipper(default_merklebranch)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the inner pubkey invalidate it.\n+    add_spender(spenders, \"spendpath/bitflippubkey\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"pubkey_inner\": bitflipper(default_pubkey_inner)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that empty witnesses are invalid.\n+    add_spender(spenders, \"spendpath/emptywit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"witness\": []}, **ERR_EMPTY_WITNESS)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padlongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/trunclongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    scripts = [(\"s\", CScript([pubs[0], OP_CHECKSIG]))]\n+    tap = taproot_construct(pubs[1], scripts)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/truncshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block to 1 byte (\"-1 Merkle length\") invalidates it\n+    add_spender(spenders, \"spendpath/trunc1shortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:1]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    # == Test BIP342 edge cases ==\n+\n+    csa_low_val = random.randrange(0, 17) # Within range for OP_n\n+    csa_low_result = csa_low_val + 1\n+\n+    csa_high_val = random.randrange(17, 100) if random.getrandbits(1) else random.randrange(-100, -1) # Outside OP_n range\n+    csa_high_result = csa_high_val + 1\n+\n+    OVERSIZE_NUMBER = 2**31\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER))), 6)\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER-1))), 5)\n+\n+    big_choices = []\n+    big_scriptops = []\n+    for i in range(1000):\n+        r = random.randrange(len(pubs))\n+        big_choices.append(r)\n+        big_scriptops += [pubs[r], OP_CHECKSIGVERIFY]\n+\n+\n+    def big_spend_inputs(ctx):\n+        \"\"\"Helper function to construct the script input for t33/t34 below.\"\"\"\n+        # Instead of signing 999 times, precompute signatures for every (key, hashtype) combination\n+        sigs = {}\n+        for ht in VALID_SIGHASHES_TAPROOT:\n+            for k in range(len(pubs)):\n+                sigs[(k, ht)] = override(default_sign, hashtype=ht, key=secs[k])(ctx)\n+        num = get(ctx, \"num\")\n+        return [sigs[(big_choices[i], random.choice(VALID_SIGHASHES_TAPROOT))] for i in range(num - 1, -1, -1)]\n+\n+    # Various BIP342 features\n+    scripts = [\n+        # 0) drop stack element and OP_CHECKSIG\n+        (\"t0\", CScript([OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 1) normal OP_CHECKSIG\n+        (\"t1\", CScript([pubs[1], OP_CHECKSIG])),\n+        # 2) normal OP_CHECKSIGVERIFY\n+        (\"t2\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1])),\n+        # 3) Hypothetical OP_CHECKMULTISIG script that takes a single sig as input\n+        (\"t3\", CScript([OP_0, OP_SWAP, OP_1, pubs[1], OP_1, OP_CHECKMULTISIG])),\n+        # 4) Hypothetical OP_CHECKMULTISIGVERIFY script that takes a single sig as input\n+        (\"t4\", CScript([OP_0, OP_SWAP, OP_1, pubs[1], OP_1, OP_CHECKMULTISIGVERIFY, OP_1])),\n+        # 5) OP_IF script that needs a true input\n+        (\"t5\", CScript([OP_IF, pubs[1], OP_CHECKSIG, OP_ELSE, OP_RETURN, OP_ENDIF])),\n+        # 6) OP_NOTIF script that needs a true input\n+        (\"t6\", CScript([OP_NOTIF, OP_RETURN, OP_ELSE, pubs[1], OP_CHECKSIG, OP_ENDIF])),\n+        # 7) OP_CHECKSIG with an empty key\n+        (\"t7\", CScript([OP_0, OP_CHECKSIG])),\n+        # 8) OP_CHECKSIGVERIFY with an empty key\n+        (\"t8\", CScript([OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 9) normal OP_CHECKSIGADD that also ensures return value is correct\n+        (\"t9\", CScript([csa_low_val, pubs[1], OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 10) OP_CHECKSIGADD with empty key\n+        (\"t10\", CScript([csa_low_val, OP_0, OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 11) OP_CHECKSIGADD with missing counter stack element\n+        (\"t11\", CScript([pubs[1], OP_CHECKSIGADD, OP_1, OP_EQUAL])),\n+        # 12) OP_CHECKSIG that needs invalid signature\n+        (\"t12\", CScript([pubs[1], OP_CHECKSIGVERIFY, pubs[0], OP_CHECKSIG, OP_NOT])),\n+        # 13) OP_CHECKSIG with empty key that needs invalid signature\n+        (\"t13\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_CHECKSIG, OP_NOT])),\n+        # 14) OP_CHECKSIGADD that needs invalid signature\n+        (\"t14\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, pubs[0], OP_CHECKSIGADD, OP_NOT])),\n+        # 15) OP_CHECKSIGADD with empty key that needs invalid signature\n+        (\"t15\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGADD, OP_NOT])),\n+        # 16) OP_CHECKSIG with unknown pubkey type\n+        (\"t16\", CScript([OP_1, OP_CHECKSIG])),\n+        # 17) OP_CHECKSIGADD with unknown pubkey type\n+        (\"t17\", CScript([OP_0, OP_1, OP_CHECKSIGADD])),\n+        # 18) OP_CHECKSIGVERIFY with unknown pubkey type\n+        (\"t18\", CScript([OP_1, OP_CHECKSIGVERIFY, OP_1])),\n+        # 19) script longer than 10000 bytes and over 201 non-push opcodes\n+        (\"t19\", CScript([OP_0, OP_0, OP_2DROP] * 10001 + [pubs[1], OP_CHECKSIG])),\n+        # 20) OP_CHECKSIGVERIFY with empty key\n+        (\"t20\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 21) Script that grows the stack to 1000 elements\n+        (\"t21\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 999 + [OP_DROP] * 999)),\n+        # 22) Script that grows the stack to 1001 elements\n+        (\"t22\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 1000 + [OP_DROP] * 1000)),\n+        # 23) Script that expects an input stack of 1000 elements\n+        (\"t23\", CScript([OP_DROP] * 999 + [pubs[1], OP_CHECKSIG])),\n+        # 24) Script that expects an input stack of 1001 elements\n+        (\"t24\", CScript([OP_DROP] * 1000 + [pubs[1], OP_CHECKSIG])),\n+        # 25) Script that pushes a MAX_SCRIPT_ELEMENT_SIZE-bytes element\n+        (\"t25\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE), OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 26) Script that pushes a (MAX_SCRIPT_ELEMENT_SIZE+1)-bytes element\n+        (\"t26\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 27) CHECKSIGADD that must fail because numeric argument number is >4 bytes\n+        (\"t27\", CScript([CScriptNum(OVERSIZE_NUMBER), pubs[1], OP_CHECKSIGADD])),\n+        # 28) Pushes random CScriptNum value, checks OP_CHECKSIGADD result\n+        (\"t28\", CScript([csa_high_val, pubs[1], OP_CHECKSIGADD, csa_high_result, OP_EQUAL])),\n+        # 29) CHECKSIGADD that succeeds with proper sig because numeric argument number is <=4 bytes\n+        (\"t29\", CScript([CScriptNum(OVERSIZE_NUMBER-1), pubs[1], OP_CHECKSIGADD])),\n+        # 30) Variant of t1 with \"normal\" 33-byte pubkey\n+        (\"t30\", CScript([b'\\x03' + pubs[1], OP_CHECKSIG])),\n+        # 31) Variant of t2 with \"normal\" 33-byte pubkey\n+        (\"t31\", CScript([b'\\x02' + pubs[1], OP_CHECKSIGVERIFY, OP_1])),\n+        # 32) Variant of t28 with \"normal\" 33-byte pubkey\n+        (\"t32\", CScript([csa_high_val, b'\\x03' + pubs[1], OP_CHECKSIGADD, csa_high_result, OP_EQUAL])),\n+        # 33) 999-of-999 multisig\n+        (\"t33\", CScript(big_scriptops[:1998] + [OP_1])),\n+        # 34) 1000-of-1000 multisig\n+        (\"t34\", CScript(big_scriptops[:2000] + [OP_1])),\n+        # 35) Variant of t9 that uses a non-minimally encoded input arg\n+        (\"t35\", CScript([bytes([csa_low_val]), pubs[1], OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 36) Empty script\n+        (\"t36\", CScript([])),\n+    ]\n+    # Add many dummies to test huge trees\n+    for j in range(100000):\n+        scripts.append((None, CScript([OP_RETURN, random.randrange(100000)])))\n+    random.shuffle(scripts)\n+    tap = taproot_construct(pubs[0], scripts)\n+    common = {\n+        \"hashtype\": hashtype,\n+        \"key\": secs[1],\n+        \"tap\": tap,\n+    }\n+    # Test that MAX_SCRIPT_ELEMENT_SIZE byte stack element inputs are valid, but not one more (and 80 bytes is standard but 81 is not).\n+    add_spender(spenders, \"tapscript/inputmaxlimit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE)], failure={\"inputs\": [getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1)]}, **ERR_PUSH_LIMIT)\n+    add_spender(spenders, \"tapscript/input80limit\", leaf=\"t0\", **common, inputs=[getter(\"sign\"), random_bytes(80)])\n+    add_spender(spenders, \"tapscript/input81limit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(81)])\n+    # Test that OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY cause failure, but OP_CHECKSIG and OP_CHECKSIGVERIFY work.\n+    add_spender(spenders, \"tapscript/disabled_checkmultisig\", leaf=\"t1\", **common, **SINGLE_SIG, failure={\"leaf\": \"t3\"}, **ERR_TAPSCRIPT_CHECKMULTISIG)\n+    add_spender(spenders, \"tapscript/disabled_checkmultisigverify\", leaf=\"t2\", **common, **SINGLE_SIG, failure={\"leaf\": \"t4\"}, **ERR_TAPSCRIPT_CHECKMULTISIG)\n+    # Test that OP_IF and OP_NOTIF do not accept non-0x01 as truth value (the MINIMALIF rule is consensus in Tapscript)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x02']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x03']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0001']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0100']}, **ERR_MINIMALIF)\n+    # Test that 1-byte public keys (which are unknown) are acceptable but nonstandard with unrelated signatures, but 0-byte public keys are not valid.\n+    add_spender(spenders, \"tapscript/unkpk/checksig\", leaf=\"t16\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigadd\", leaf=\"t17\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigverify\", leaf=\"t18\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that 33-byte public keys (which are unknown) are acceptable but nonstandard with valid signatures, but normal pubkeys are not valid in that case.\n+    add_spender(spenders, \"tapscript/oldpk/checksig\", leaf=\"t30\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t1\"}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"tapscript/oldpk/checksigadd\", leaf=\"t31\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t2\"}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"tapscript/oldpk/checksigverify\", leaf=\"t32\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t28\"}, **ERR_SIG_SCHNORR)\n+    # Test that 0-byte public keys are not acceptable.\n+    add_spender(spenders, \"tapscript/emptypk/checksig\", leaf=\"t1\", **SINGLE_SIG, **common, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigverify\", leaf=\"t2\", **SINGLE_SIG, **common, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigadd\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigadd\", leaf=\"t35\", standard=False, **SINGLE_SIG, **common, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that OP_CHECKSIGADD results are as expected\n+    add_spender(spenders, \"tapscript/checksigaddresults\", leaf=\"t28\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    add_spender(spenders, \"tapscript/checksigaddoversize\", leaf=\"t29\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    # Test that OP_CHECKSIGADD requires 3 stack elements.\n+    add_spender(spenders, \"tapscript/checksigadd3args\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t11\"}, **ERR_STACK_EMPTY)\n+    # Test that empty signatures do not cause script failure in OP_CHECKSIG and OP_CHECKSIGADD (but do fail with empty pubkey, and do fail OP_CHECKSIGVERIFY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksig\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t13\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/nochecksigverify\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t20\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksigadd\", leaf=\"t14\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t15\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that scripts over 10000 bytes (and over 201 non-push ops) are acceptable.\n+    add_spender(spenders, \"tapscript/no10000limit\", leaf=\"t19\", **SINGLE_SIG, **common)\n+    # Test that a stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000stack\", leaf=\"t21\", **SINGLE_SIG, **common, failure={\"leaf\": \"t22\"}, **ERR_STACK_SIZE)\n+    # Test that an input stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000inputs\", leaf=\"t23\", **common, inputs=[getter(\"sign\")] + [b'' for _ in range(999)], failure={\"leaf\": \"t24\", \"inputs\": [getter(\"sign\")] + [b'' for _ in range(1000)]}, **ERR_STACK_SIZE)\n+    # Test that pushing a MAX_SCRIPT_ELEMENT_SIZE byte stack element is valid, but one longer is not.\n+    add_spender(spenders, \"tapscript/pushmaxlimit\", leaf=\"t25\", **common, **SINGLE_SIG, failure={\"leaf\": \"t26\"}, **ERR_PUSH_LIMIT)\n+    # Test that 999-of-999 multisig works (but 1000-of-1000 triggers stack size limits)\n+    add_spender(spenders, \"tapscript/bigmulti\", leaf=\"t33\", **common, inputs=big_spend_inputs, num=999, failure={\"leaf\": \"t34\", \"num\": 1000}, **ERR_STACK_SIZE)\n+    # Test that the CLEANSTACK rule is consensus critical in tapscript\n+    add_spender(spenders, \"tapscript/cleanstack\", leaf=\"t36\", tap=tap, inputs=[b'\\x01'], failure={\"inputs\": [b'\\x01', b'\\x01']}, **ERR_CLEANSTACK)\n+\n+    # == Test for sigops ratio limit ==\n+\n+    # Given a number n, and a public key pk, functions that produce a (CScript, sigops). Each script takes as\n+    # input a valid signature with the passed pk followed by a dummy push of bytes that are to be dropped, and\n+    # will execute sigops signature checks.\n+    SIGOPS_RATIO_SCRIPTS = [\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIG.\n+        lambda n, pk: (CScript([OP_DROP, pk] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGVERIFY.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_0, OP_IF, OP_2DUP, OP_CHECKSIGVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_2, OP_SWAP, OP_CHECKSIGADD, OP_3, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIG.\n+        lambda n, pk: (CScript([random_bytes(220), OP_2DROP, pk, OP_1, OP_NOTIF, OP_2DUP, OP_CHECKSIG, OP_VERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_4, OP_SWAP, OP_CHECKSIGADD, OP_5, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGADD.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_1, OP_IF, OP_ELSE, OP_2DUP, OP_6, OP_SWAP, OP_CHECKSIGADD, OP_7, OP_EQUALVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_8, OP_SWAP, OP_CHECKSIGADD, OP_9, OP_EQUAL]), n + 1),\n+        # n+1 OP_CHECKSIGs, but also one OP_CHECKSIG with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, pk, OP_CHECKSIG, OP_NOT, OP_VERIFY, pk] + [OP_2DUP, OP_CHECKSIG, OP_VERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGADDs and 1 OP_CHECKSIG, but also an OP_CHECKSIGADD with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, OP_10, pk, OP_CHECKSIGADD, OP_10, OP_EQUALVERIFY, pk] + [OP_2DUP, OP_16, OP_SWAP, OP_CHECKSIGADD, b'\\x11', OP_EQUALVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+    ]\n+    for annex in [None, bytes([ANNEX_TAG]) + random_bytes(random.randrange(1000))]:\n+        for hashtype in [SIGHASH_DEFAULT, SIGHASH_ALL]:\n+            for pubkey in [pubs[1], random_bytes(random.choice([x for x in range(2, 81) if x != 32]))]:\n+                for fn_num, fn in enumerate(SIGOPS_RATIO_SCRIPTS):\n+                    merkledepth = random.randrange(129)\n+\n+\n+                    def predict_sigops_ratio(n, dummy_size):\n+                        \"\"\"Predict whether spending fn(n, pubkey) with dummy_size will pass the ratio test.\"\"\"\n+                        script, sigops = fn(n, pubkey)\n+                        # Predict the size of the witness for a given choice of n\n+                        stacklen_size = 1\n+                        sig_size = 64 + (hashtype != SIGHASH_DEFAULT)\n+                        siglen_size = 1\n+                        dummylen_size = 1 + 2 * (dummy_size >= 253)\n+                        script_size = len(script)\n+                        scriptlen_size = 1 + 2 * (script_size >= 253)\n+                        control_size = 33 + 32 * merkledepth\n+                        controllen_size = 1 + 2 * (control_size >= 253)\n+                        annex_size = 0 if annex is None else len(annex)\n+                        annexlen_size = 0 if annex is None else 1 + 2 * (annex_size >= 253)\n+                        witsize = stacklen_size + sig_size + siglen_size + dummy_size + dummylen_size + script_size + scriptlen_size + control_size + controllen_size + annex_size + annexlen_size\n+                        # sigops ratio test\n+                        return witsize + 50 >= 50 * sigops\n+                    # Make sure n is high enough that with empty dummy, the script is not valid\n+                    n = 0\n+                    while predict_sigops_ratio(n, 0):\n+                        n += 1\n+                    # But allow picking a bit higher still\n+                    n += random.randrange(5)\n+                    # Now pick dummy size *just* large enough that the overall construction passes\n+                    dummylen = 0\n+                    while not predict_sigops_ratio(n, dummylen):\n+                        dummylen += 1\n+                    scripts = [(\"s\", fn(n, pubkey)[0])]\n+                    for _ in range(merkledepth):\n+                        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+                    tap = taproot_construct(pubs[0], scripts)\n+                    standard = annex is None and dummylen <= 80 and len(pubkey) == 32\n+                    add_spender(spenders, \"tapscript/sigopsratio_%i\" % fn_num, tap=tap, leaf=\"s\", annex=annex, hashtype=hashtype, key=secs[1], inputs=[getter(\"sign\"), random_bytes(dummylen)], standard=standard, failure={\"inputs\": [getter(\"sign\"), random_bytes(dummylen - 1)]}, **ERR_SIGOPS_RATIO)\n+\n+    # Future leaf versions\n+    for leafver in range(0, 0x100, 2):\n+        if leafver == LEAF_VERSION_TAPSCRIPT or leafver == ANNEX_TAG:\n+            # Skip the defined LEAF_VERSION_TAPSCRIPT, and the ANNEX_TAG which is not usable as leaf version\n+            continue\n+        scripts = [\n+            (\"bare_c0\", CScript([OP_NOP])),\n+            (\"bare_unkver\", CScript([OP_NOP]), leafver),\n+            (\"return_c0\", CScript([OP_RETURN])),\n+            (\"return_unkver\", CScript([OP_RETURN]), leafver),\n+            (\"undecodable_c0\", CScript([OP_PUSHDATA1])),\n+            (\"undecodable_unkver\", CScript([OP_PUSHDATA1]), leafver),\n+            (\"bigpush_c0\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP])),\n+            (\"bigpush_unkver\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP]), leafver),\n+            (\"1001push_c0\", CScript([OP_0] * 1001)),\n+            (\"1001push_unkver\", CScript([OP_0] * 1001), leafver),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"unkver/bare\", standard=False, tap=tap, leaf=\"bare_unkver\", failure={\"leaf\": \"bare_c0\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"unkver/return\", standard=False, tap=tap, leaf=\"return_unkver\", failure={\"leaf\": \"return_c0\"}, **ERR_OP_RETURN)\n+        add_spender(spenders, \"unkver/undecodable\", standard=False, tap=tap, leaf=\"undecodable_unkver\", failure={\"leaf\": \"undecodable_c0\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"unkver/bigpush\", standard=False, tap=tap, leaf=\"bigpush_unkver\", failure={\"leaf\": \"bigpush_c0\"}, **ERR_PUSH_LIMIT)\n+        add_spender(spenders, \"unkver/1001push\", standard=False, tap=tap, leaf=\"1001push_unkver\", failure={\"leaf\": \"1001push_c0\"}, **ERR_STACK_SIZE)\n+        add_spender(spenders, \"unkver/1001inputs\", standard=False, tap=tap, leaf=\"bare_unkver\", inputs=[b'']*1001, failure={\"leaf\": \"bare_c0\"}, **ERR_STACK_SIZE)\n+\n+    # OP_SUCCESSx tests.\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for opval in range(76, 0x100):\n+        opcode = CScriptOp(opval)\n+        if not is_op_success(opcode):\n+            continue\n+        scripts = [\n+            (\"bare_success\", CScript([opcode])),\n+            (\"bare_nop\", CScript([OP_NOP])),\n+            (\"unexecif_success\", CScript([OP_0, OP_IF, opcode, OP_ENDIF])),\n+            (\"unexecif_nop\", CScript([OP_0, OP_IF, OP_NOP, OP_ENDIF])),\n+            (\"return_success\", CScript([OP_RETURN, opcode])),\n+            (\"return_nop\", CScript([OP_RETURN, OP_NOP])),\n+            (\"undecodable_success\", CScript([opcode, OP_PUSHDATA1])),\n+            (\"undecodable_nop\", CScript([OP_NOP, OP_PUSHDATA1])),\n+            (\"undecodable_bypassed_success\", CScript([OP_PUSHDATA1, OP_2, opcode])),\n+            (\"bigpush_success\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, opcode])),\n+            (\"bigpush_nop\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, OP_NOP])),\n+            (\"1001push_success\", CScript([OP_0] * 1001 + [opcode])),\n+            (\"1001push_nop\", CScript([OP_0] * 1001 + [OP_NOP])),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"opsuccess/bare\", standard=False, tap=tap, leaf=\"bare_success\", failure={\"leaf\": \"bare_nop\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"opsuccess/unexecif\", standard=False, tap=tap, leaf=\"unexecif_success\", failure={\"leaf\": \"unexecif_nop\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"opsuccess/return\", standard=False, tap=tap, leaf=\"return_success\", failure={\"leaf\": \"return_nop\"}, **ERR_OP_RETURN)\n+        add_spender(spenders, \"opsuccess/undecodable\", standard=False, tap=tap, leaf=\"undecodable_success\", failure={\"leaf\": \"undecodable_nop\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"opsuccess/undecodable_bypass\", standard=False, tap=tap, leaf=\"undecodable_success\", failure={\"leaf\": \"undecodable_bypassed_success\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"opsuccess/bigpush\", standard=False, tap=tap, leaf=\"bigpush_success\", failure={\"leaf\": \"bigpush_nop\"}, **ERR_PUSH_LIMIT)\n+        add_spender(spenders, \"opsuccess/1001push\", standard=False, tap=tap, leaf=\"1001push_success\", failure={\"leaf\": \"1001push_nop\"}, **ERR_STACK_SIZE)\n+        add_spender(spenders, \"opsuccess/1001inputs\", standard=False, tap=tap, leaf=\"bare_success\", inputs=[b'']*1001, failure={\"leaf\": \"bare_nop\"}, **ERR_STACK_SIZE)\n+\n+    # Non-OP_SUCCESSx (verify that those aren't accidentally treated as OP_SUCCESSx)\n+    for opval in range(0, 0x100):\n+        opcode = CScriptOp(opval)\n+        if is_op_success(opcode):\n+            continue\n+        scripts = [\n+            (\"normal\", CScript([OP_RETURN, opcode] + [OP_NOP] * 75)),\n+            (\"op_success\", CScript([OP_RETURN, CScriptOp(0x50)]))\n+        ]\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"alwaysvalid/notsuccessx\", tap=tap, leaf=\"op_success\", inputs=[], standard=False, failure={\"leaf\": \"normal\"}) # err_msg differs based on opcode\n+\n+    # == Legacy tests ==\n+\n+    # Also add a few legacy spends into the mix, so that transactions which combine taproot and pre-taproot spends get tested too.\n+    for compressed in [False, True]:\n+        eckey1 = ECKey()\n+        eckey1.set(generate_privkey(), compressed)\n+        pubkey1 = eckey1.get_pubkey().get_bytes()\n+        eckey2 = ECKey()\n+        eckey2.set(generate_privkey(), compressed)\n+        for p2sh in [False, True]:\n+            for witv0 in [False, True]:\n+                for hashtype in VALID_SIGHASHES_ECDSA + [random.randrange(0x04, 0x80), random.randrange(0x84, 0x100)]:\n+                    standard = (hashtype in VALID_SIGHASHES_ECDSA) and (compressed or not witv0)\n+                    add_spender(spenders, \"legacy/pk-wrongkey\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, script=CScript([pubkey1, OP_CHECKSIG]), **SINGLE_SIG, key=eckey1, failure={\"key\": eckey2}, sigops_weight=4-3*witv0, **ERR_NO_SUCCESS)\n+                    add_spender(spenders, \"legacy/pkh-sighashflip\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, pkh=pubkey1, key=eckey1, **SIGHASH_BITFLIP, sigops_weight=4-3*witv0, **ERR_NO_SUCCESS)\n+\n+    # Verify that OP_CHECKSIGADD wasn't accidentally added to pre-taproot validation logic.\n+    for p2sh in [False, True]:\n+        for witv0 in [False, True]:\n+            for hashtype in VALID_SIGHASHES_ECDSA + [random.randrange(0x04, 0x80), random.randrange(0x84, 0x100)]:\n+                standard = hashtype in VALID_SIGHASHES_ECDSA and (p2sh or witv0)\n+                add_spender(spenders, \"compat/nocsa\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, script=CScript([OP_IF, OP_11, pubkey1, OP_CHECKSIGADD, OP_12, OP_EQUAL, OP_ELSE, pubkey1, OP_CHECKSIG, OP_ENDIF]), key=eckey1, sigops_weight=4-3*witv0, inputs=[getter(\"sign\"), b''], failure={\"inputs\": [getter(\"sign\"), b'\\x01']}, **ERR_UNDECODABLE)\n+\n+    return spenders\n+\n+def spenders_taproot_inactive():\n+    \"\"\"Spenders for testing that pre-activation Taproot rules don't apply.\"\"\"\n+\n+    spenders = []\n+\n+    sec = generate_privkey()\n+    pub, _ = compute_xonly_pubkey(sec)\n+    scripts = [\n+        (\"pk\", CScript([pub, OP_CHECKSIG])),\n+        (\"future_leaf\", CScript([pub, OP_CHECKSIG]), 0xc2),\n+        (\"op_success\", CScript([pub, OP_CHECKSIG, OP_0, OP_IF, CScriptOp(0x50), OP_ENDIF])),\n+    ]\n+    tap = taproot_construct(pub, scripts)\n+\n+    # Test that keypath spending is valid & standard if compliant, but valid and nonstandard otherwise.\n+    add_spender(spenders, \"inactive/keypath_valid\", key=sec, tap=tap)\n+    add_spender(spenders, \"inactive/keypath_invalidsig\", key=sec, tap=tap, standard=False, sighash=bitflipper(default_sighash))\n+    add_spender(spenders, \"inactive/keypath_empty\", key=sec, tap=tap, standard=False, witness=[])\n+\n+    # Same for scriptpath spending (but using future features like annex, leaf versions, or OP_SUCCESS is nonstandard).\n+    add_spender(spenders, \"inactive/scriptpath_valid\", key=sec, tap=tap, leaf=\"pk\", inputs=[getter(\"sign\")])\n+    add_spender(spenders, \"inactive/scriptpath_invalidsig\", key=sec, tap=tap, leaf=\"pk\", standard=False, inputs=[getter(\"sign\")], sighash=bitflipper(default_sighash))\n+    add_spender(spenders, \"inactive/scriptpath_invalidcb\", key=sec, tap=tap, leaf=\"pk\", standard=False, inputs=[getter(\"sign\")], controlblock=bitflipper(default_controlblock))\n+    add_spender(spenders, \"inactive/scriptpath_valid_unkleaf\", key=sec, tap=tap, leaf=\"future_leaf\", standard=False, inputs=[getter(\"sign\")])\n+    add_spender(spenders, \"inactive/scriptpath_invalid_unkleaf\", key=sec, tap=tap, leaf=\"future_leaf\", standard=False, inputs=[getter(\"sign\")], sighash=bitflipper(default_sighash))\n+    add_spender(spenders, \"inactive/scriptpath_valid_opsuccess\", key=sec, tap=tap, leaf=\"op_success\", standard=False, inputs=[getter(\"sign\")])\n+    add_spender(spenders, \"inactive/scriptpath_valid_opsuccess\", key=sec, tap=tap, leaf=\"op_success\", standard=False, inputs=[getter(\"sign\")], sighash=bitflipper(default_sighash))\n+\n+    return spenders\n+\n+# Data type to keep track of UTXOs, where they were created, and how to spend them.\n+UTXOData = namedtuple('UTXOData', 'outpoint,output,spender')\n+\n+class TaprootTest(BitcoinTestFramework):\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.setup_clean_chain = True\n+        # Node 0 has Taproot inactive, Node 1 active.\n+        self.extra_args = [[\"-whitelist=127.0.0.1\", \"-par=1\", \"-vbparams=taproot:1:1\"], [\"-whitelist=127.0.0.1\", \"-par=1\"]]\n+\n+    def block_submit(self, node, txs, msg, err_msg, cb_pubkey=None, fees=0, sigops_weight=0, witness=False, accept=False):\n+\n+        # Deplete block of any non-tapscript sigops using a single additional 0-value coinbase output.\n+        # It is not impossible to fit enough tapscript sigops to hit the old 80k limit without\n+        # busting txin-level limits. We simply have to account for the p2pk outputs in all\n+        # transactions.\n+        extra_output_script = CScript([OP_CHECKSIG]*((MAX_BLOCK_SIGOPS_WEIGHT - sigops_weight) // WITNESS_SCALE_FACTOR))\n+\n+        block = create_block(self.tip, create_coinbase(self.lastblockheight + 1, pubkey=cb_pubkey, extra_output_script=extra_output_script, fees=fees), self.lastblocktime + 1)\n+        block.nVersion = 4\n+        for tx in txs:\n+            tx.rehash()\n+            block.vtx.append(tx)\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        witness and add_witness_commitment(block)\n+        block.rehash()\n+        block.solve()\n+        block_response = node.submitblock(block.serialize(True).hex())\n+        if err_msg is not None:\n+            assert block_response is not None and err_msg in block_response, \"Missing error message '%s' from block response '%s': %s\" % (err_msg, \"(None)\" if block_response is None else block_response, msg)\n+        if (accept):\n+            assert node.getbestblockhash() == block.hash, \"Failed to accept: %s (response: %s)\" % (msg, block_response)\n+            self.tip = block.sha256\n+            self.lastblockhash = block.hash\n+            self.lastblocktime += 1\n+            self.lastblockheight += 1\n+        else:\n+            assert node.getbestblockhash() == self.lastblockhash, \"Failed to reject: \" + msg\n+\n+    def test_spenders(self, node, spenders, input_counts):\n+        \"\"\"Run randomized tests with a number of \"spenders\".\n+\n+        Steps:\n+            1) Generate an appropriate UTXO for each spender to test spend conditions\n+            2) Generate 100 random addresses of all wallet types: pkh/sh_wpkh/wpkh\n+            3) Select random number of inputs from (1)\n+            4) Select random number of addresses from (2) as outputs\n+\n+        Each spender embodies a test; in a large randomized test, it is verified\n+        that toggling the valid argument to each lambda toggles the validity of\n+        the transaction. This is accomplished by constructing transactions consisting\n+        of all valid inputs, except one invalid one.\n+        \"\"\"\n+\n+        # Construct a bunch of sPKs that send coins back to the host wallet\n+        self.log.info(\"- Constructing addresses for returning coins\")\n+        host_spks = []\n+        host_pubkeys = []\n+        for i in range(16):\n+            addr = node.getnewaddress(address_type=random.choice([\"legacy\", \"p2sh-segwit\", \"bech32\"]))\n+            info = node.getaddressinfo(addr)\n+            spk = bytes.fromhex(info['scriptPubKey'])\n+            host_spks.append(spk)\n+            host_pubkeys.append(bytes.fromhex(info['pubkey']))\n+\n+        # Initialize variables used by block_submit().\n+        self.lastblockhash = node.getbestblockhash()\n+        self.tip = int(self.lastblockhash, 16)\n+        block = node.getblock(self.lastblockhash)\n+        self.lastblockheight = block['height']\n+        self.lastblocktime = block['time']\n+\n+        # Create transactions spending up to 50 of the wallet's inputs, with one output for each spender, and\n+        # one change output at the end. The transaction is constructed on the Python side to enable\n+        # having multiple outputs to the same address and outputs with no assigned address. The wallet\n+        # is then asked to sign it through signrawtransactionwithwallet, and then added to a block on the\n+        # Python side (to bypass standardness rules).\n+        self.log.info(\"- Creating test UTXOs...\")\n+        random.shuffle(spenders)\n+        normal_utxos = []\n+        mismatching_utxos = [] # UTXOs with input that requires mismatching output position\n+        done = 0\n+        while done < len(spenders):\n+            # Compute how many UTXOs to create with this transaction\n+            count_this_tx = min(len(spenders) - done, (len(spenders) + 4) // 5, 10000)\n+\n+            fund_tx = CTransaction()\n+            # Add the 50 highest-value inputs\n+            unspents = node.listunspent()\n+            random.shuffle(unspents)\n+            unspents.sort(key=lambda x: int(x[\"amount\"] * 100000000), reverse=True)\n+            if len(unspents) > 50:\n+                unspents = unspents[:50]\n+            random.shuffle(unspents)\n+            balance = 0\n+            for unspent in unspents:\n+                balance += int(unspent[\"amount\"] * 100000000)\n+                txid = int(unspent[\"txid\"], 16)\n+                fund_tx.vin.append(CTxIn(COutPoint(txid, int(unspent[\"vout\"])), CScript()))\n+            # Add outputs\n+            cur_progress = done / len(spenders)\n+            next_progress = (done + count_this_tx) / len(spenders)\n+            change_goal = (1.0 - 0.6 * next_progress) / (1.0 - 0.6 * cur_progress) * balance\n+            self.log.debug(\"Create %i UTXOs in a transaction spending %i inputs worth %.8f (sending ~%.8f to change)\" % (count_this_tx, len(unspents), balance * 0.00000001, change_goal * 0.00000001))\n+            for i in range(count_this_tx):\n+                avg = (balance - change_goal) / (count_this_tx - i)\n+                amount = int(random.randrange(int(avg*0.85 + 0.5), int(avg*1.15 + 0.5)) + 0.5)\n+                balance -= amount\n+                fund_tx.vout.append(CTxOut(amount, spenders[done + i].script))\n+            # Add change\n+            fund_tx.vout.append(CTxOut(balance - 10000, random.choice(host_spks)))\n+            # Ask the wallet to sign\n+            ss = BytesIO(bytes.fromhex(node.signrawtransactionwithwallet(ToHex(fund_tx))[\"hex\"]))\n+            fund_tx.deserialize(ss)\n+            # Construct UTXOData entries\n+            fund_tx.rehash()\n+            for i in range(count_this_tx):\n+                utxodata = UTXOData(outpoint=COutPoint(fund_tx.sha256, i), output=fund_tx.vout[i], spender=spenders[done])\n+                if utxodata.spender.need_vin_vout_mismatch:\n+                    mismatching_utxos.append(utxodata)\n+                else:\n+                    normal_utxos.append(utxodata)\n+                done += 1\n+            # Mine into a block\n+            self.block_submit(node, [fund_tx], \"Funding tx\", None, random.choice(host_pubkeys), 10000, MAX_BLOCK_SIGOPS_WEIGHT, True, True)\n+\n+        # Consume groups of choice(input_coins) from utxos in a tx, testing the spenders.\n+        self.log.info(\"- Running %i spending tests\" % done)\n+        random.shuffle(normal_utxos)\n+        random.shuffle(mismatching_utxos)\n+        assert done == len(normal_utxos) + len(mismatching_utxos)\n+\n+        left = done\n+        while left:\n+            # Construct CTransaction with random nVersion, nLocktime\n+            tx = CTransaction()\n+            tx.nVersion = random.choice([1, 2, random.randint(-0x80000000, 0x7fffffff)])\n+            min_sequence = (tx.nVersion != 1 and tx.nVersion != 0) * 0x80000000  # The minimum sequence number to disable relative locktime\n+            if random.choice([True, False]):\n+                tx.nLockTime = random.randrange(LOCKTIME_THRESHOLD, self.lastblocktime - 7200)  # all absolute locktimes in the past\n+            else:\n+                tx.nLockTime = random.randrange(self.lastblockheight + 1)  # all block heights in the past\n+\n+            # Decide how many UTXOs to test with.\n+            acceptable = [n for n in input_counts if n <= left and (left - n > max(input_counts) or (left - n) in [0] + input_counts)]\n+            num_inputs = random.choice(acceptable)\n+\n+            # If we have UTXOs that require mismatching inputs/outputs left, include exactly one of those\n+            # unless there is only one normal UTXO left (as tests with mismatching UTXOs require at least one\n+            # normal UTXO to go in the first position), and we don't want to run out of normal UTXOs.\n+            input_utxos = []\n+            while len(mismatching_utxos) and (len(input_utxos) == 0 or len(normal_utxos) == 1):\n+                input_utxos.append(mismatching_utxos.pop())\n+                left -= 1\n+\n+            # Top up until we hit num_inputs (but include at least one normal UTXO always).\n+            for _ in range(max(1, num_inputs - len(input_utxos))):\n+                input_utxos.append(normal_utxos.pop())\n+                left -= 1\n+\n+            # The first input cannot require a mismatching output (as there is at least one output).\n+            while True:\n+                random.shuffle(input_utxos)\n+                if not input_utxos[0].spender.need_vin_vout_mismatch:\n+                    break\n+            first_mismatch_input = None\n+            for i in range(len(input_utxos)):\n+                if input_utxos[i].spender.need_vin_vout_mismatch:\n+                    first_mismatch_input = i\n+            assert first_mismatch_input is None or first_mismatch_input > 0\n+\n+            # Decide fee, and add CTxIns to tx.\n+            amount = sum(utxo.output.nValue for utxo in input_utxos)\n+            fee = min(random.randrange(MIN_FEE * 2, MIN_FEE * 4), amount - DUST_LIMIT)  # 10000-20000 sat fee\n+            in_value = amount - fee\n+            tx.vin = [CTxIn(outpoint=utxo.outpoint, nSequence=random.randint(min_sequence, 0xffffffff)) for utxo in input_utxos]\n+            tx.wit.vtxinwit = [CTxInWitness() for _ in range(len(input_utxos))]\n+            sigops_weight = sum(utxo.spender.sigops_weight for utxo in input_utxos)\n+            self.log.debug(\"Test: %s\" % (\", \".join(utxo.spender.comment for utxo in input_utxos)))\n+\n+            # Add 1 to 4 random outputs (but constrained by inputs that require mismatching outputs)\n+            num_outputs = random.choice(range(1, 1 + min(4, 4 if first_mismatch_input is None else first_mismatch_input)))\n+            assert in_value >= 0 and fee - num_outputs * DUST_LIMIT >= MIN_FEE\n+            for i in range(num_outputs):\n+                tx.vout.append(CTxOut())\n+                if in_value <= DUST_LIMIT:\n+                    tx.vout[-1].nValue = DUST_LIMIT\n+                elif i < num_outputs - 1:\n+                    tx.vout[-1].nValue = in_value\n+                else:\n+                    tx.vout[-1].nValue = random.randint(DUST_LIMIT, in_value)\n+                in_value -= tx.vout[-1].nValue\n+                tx.vout[-1].scriptPubKey = random.choice(host_spks)\n+                sigops_weight += CScript(tx.vout[-1].scriptPubKey).GetSigOpCount(False) * WITNESS_SCALE_FACTOR\n+            fee += in_value\n+            assert fee >= 0\n+\n+            # Select coinbase pubkey\n+            cb_pubkey = random.choice(host_pubkeys)\n+            sigops_weight += 1 * WITNESS_SCALE_FACTOR\n+\n+            # Precompute one satisfying and one failing scriptSig/witness for each input.\n+            input_data = []\n+            for i in range(len(input_utxos)):\n+                fn = input_utxos[i].spender.sat_function\n+                fail = None\n+                success = fn(tx, i, [utxo.output for utxo in input_utxos], True)\n+                if not input_utxos[i].spender.no_fail:\n+                    fail = fn(tx, i, [utxo.output for utxo in input_utxos], False)\n+                input_data.append((fail, success))\n+\n+            # Sign each input incorrectly once on each complete signing pass, except the very last.\n+            for fail_input in list(range(len(input_utxos))) + [None]:\n+                # Skip trying to fail at spending something that can't be made to fail.\n+                if fail_input is not None and input_utxos[fail_input].spender.no_fail:\n+                    continue\n+                # Expected message with each input failure, may be None(which is ignored)\n+                expected_fail_msg = None if fail_input is None else input_utxos[fail_input].spender.err_msg\n+                # Fill inputs/witnesses\n+                for i in range(len(input_utxos)):\n+                    tx.vin[i].scriptSig = input_data[i][i != fail_input][0]\n+                    tx.wit.vtxinwit[i].scriptWitness.stack = input_data[i][i != fail_input][1]\n+                # Submit to mempool to check standardness\n+                is_standard_tx = fail_input is None and all(utxo.spender.is_standard for utxo in input_utxos) and tx.nVersion >= 1 and tx.nVersion <= 2\n+                tx.rehash()\n+                msg = ','.join(utxo.spender.comment + (\"*\" if n == fail_input else \"\") for n, utxo in enumerate(input_utxos))\n+                if is_standard_tx:\n+                    node.sendrawtransaction(tx.serialize().hex(), 0)\n+                    assert node.getmempoolentry(tx.hash) is not None, \"Failed to accept into mempool: \" + msg\n+                else:\n+                    assert_raises_rpc_error(-26, None, node.sendrawtransaction, tx.serialize().hex(), 0)\n+                # Submit in a block\n+                self.block_submit(node, [tx], msg, witness=True, accept=fail_input is None, cb_pubkey=cb_pubkey, fees=fee, sigops_weight=sigops_weight, err_msg=expected_fail_msg)\n+\n+            if (len(spenders) - left) // 200 > (len(spenders) - left - len(input_utxos)) // 200:\n+                self.log.info(\"  - %i tests done\" % (len(spenders) - left))\n+\n+        assert left == 0\n+        assert len(normal_utxos) == 0\n+        assert len(mismatching_utxos) == 0\n+        self.log.info(\"  - Done\")\n+\n+    def run_test(self):\n+        self.connect_nodes(0, 1)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509400473",
      "id" : 509400473,
      "line" : 1439,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQwMDQ3Mw==",
      "original_commit_id" : "f06e6d03452cf5e0b1a0863afb08c9e6d3ef452e",
      "original_line" : 1392,
      "original_position" : 1392,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : 1439,
      "pull_request_review_id" : 513499921,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-21T16:20:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509400473",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509420029"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509420029"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: FUZZ_SUITE_LDFLAGS_COMMON",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-21T16:13:59Z",
      "diff_hunk" : "@@ -1082,6 +1083,12 @@ test_fuzz_script_interpreter_LDADD = $(FUZZ_SUITE_LD_COMMON)\n test_fuzz_script_interpreter_LDFLAGS = $(FUZZ_SUITE_LDFLAGS_COMMON)\n test_fuzz_script_interpreter_SOURCES = test/fuzz/script_interpreter.cpp\n \n+test_fuzz_script_assets_test_minimizer_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n+test_fuzz_script_assets_test_minimizer_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n+test_fuzz_script_assets_test_minimizer_LDADD = $(FUZZ_SUITE_LD_COMMON)\n+test_fuzz_script_assets_test_minimizer_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509420029",
      "id" : 509420029,
      "line" : 1089,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQyMDAyOQ==",
      "original_commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "original_line" : 1089,
      "original_position" : 15,
      "original_start_line" : null,
      "path" : "src/Makefile.test.include",
      "position" : 15,
      "pull_request_review_id" : 513499921,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-21T16:20:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509420029",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509617693"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509617693"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Can you explain what the point of this unit test is? It seems that the python test is used to generate inputs for the fuzz test, which is used to minimize the corpus. The resulting corpus is fed into the unit test.\r\n\r\nHowever, the unit test and fuzz test do the same thing. If they didn't, the fuzz test couldn't be used to capture the coverage.\r\n\r\nI think the unit test (all changes in this commit) can be reverted if the fuzz asserts the `ret` return code directly.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-21T19:40:18Z",
      "diff_hunk" : "@@ -1610,5 +1640,104 @@ BOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_invalid_flags)\n     BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_INVALID_FLAGS);\n }\n \n+static std::vector<unsigned int> AllConsensusFlags()\n+{\n+    std::vector<unsigned int> ret;\n+\n+    for (unsigned int i = 0; i < 128; ++i) {\n+        unsigned int flag = 0;\n+        if (i & 1) flag |= SCRIPT_VERIFY_P2SH;\n+        if (i & 2) flag |= SCRIPT_VERIFY_DERSIG;\n+        if (i & 4) flag |= SCRIPT_VERIFY_NULLDUMMY;\n+        if (i & 8) flag |= SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY;\n+        if (i & 16) flag |= SCRIPT_VERIFY_CHECKSEQUENCEVERIFY;\n+        if (i & 32) flag |= SCRIPT_VERIFY_WITNESS;\n+        if (i & 64) flag |= SCRIPT_VERIFY_TAPROOT;\n+\n+        // SCRIPT_VERIFY_WITNESS requires SCRIPT_VERIFY_P2SH\n+        if (flag & SCRIPT_VERIFY_WITNESS && !(flag & SCRIPT_VERIFY_P2SH)) continue;\n+        // SCRIPT_VERIFY_TAPROOT requires SCRIPT_VERIFY_WITNESS\n+        if (flag & SCRIPT_VERIFY_TAPROOT && !(flag & SCRIPT_VERIFY_WITNESS)) continue;\n+\n+        ret.push_back(flag);\n+    }\n+\n+    return ret;\n+}\n+\n+/** Precomputed list of all valid combinations of consensus-relevant script validation flags. */\n+static const std::vector<unsigned int> ALL_CONSENSUS_FLAGS = AllConsensusFlags();\n+\n+static void AssetTest(const UniValue& test)\n+{\n+    BOOST_CHECK(test.isObject());\n+\n+    CMutableTransaction mtx = TxFromHex(test[\"tx\"].get_str());\n+    const std::vector<CTxOut> prevouts = TxOutsFromJSON(test[\"prevouts\"]);\n+    BOOST_CHECK(prevouts.size() == mtx.vin.size());\n+    size_t idx = test[\"index\"].get_int64();\n+    unsigned int test_flags = ParseScriptFlags(test[\"flags\"].get_str());\n+    bool fin = test.exists(\"final\") && test[\"final\"].get_bool();\n+\n+    if (test.exists(\"success\")) {\n+        mtx.vin[idx].scriptSig = ScriptFromHex(test[\"success\"][\"scriptSig\"].get_str());\n+        mtx.vin[idx].scriptWitness = ScriptWitnessFromJSON(test[\"success\"][\"witness\"]);\n+        CTransaction tx(mtx);\n+        PrecomputedTransactionData txdata;\n+        txdata.Init(tx, std::vector<CTxOut>(prevouts));\n+        CachingTransactionSignatureChecker txcheck(&tx, idx, prevouts[idx].nValue, true, txdata);\n+        for (const auto flags : ALL_CONSENSUS_FLAGS) {\n+            // \"final\": true tests are valid for all flags. Others are only valid with flags that are\n+            // a subset of test_flags.\n+            if (fin || ((flags & test_flags) == flags)) {\n+                bool ret = VerifyScript(tx.vin[idx].scriptSig, prevouts[idx].scriptPubKey, &tx.vin[idx].scriptWitness, flags, txcheck, nullptr);\n+                BOOST_CHECK(ret);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509617693",
      "id" : 509617693,
      "line" : 1694,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTYxNzY5Mw==",
      "original_commit_id" : "4567ba034c5ae6e6cc161360f7425c9e844738f0",
      "original_line" : 1694,
      "original_position" : 113,
      "original_start_line" : null,
      "path" : "src/test/script_tests.cpp",
      "position" : 113,
      "pull_request_review_id" : 514118790,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-21T19:40:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509617693",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509638288"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509638288"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Personal style, I guess. I don't think there is much of an objective difference.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-21T20:02:32Z",
      "diff_hunk" : "@@ -206,6 +206,7 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n         // get the scriptPubKey corresponding to this input:\n         CScript prevScript = prev.scriptPubKey;\n \n+        bool p2sh = false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509638288",
      "id" : 509638288,
      "in_reply_to_id" : 509143288,
      "line" : 209,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTYzODI4OA==",
      "original_commit_id" : "e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6",
      "original_line" : 209,
      "original_position" : 13,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : 13,
      "pull_request_review_id" : 514141332,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-21T20:02:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509638288",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509659095"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509659095"
         }
      },
      "author_association" : "MEMBER",
      "body" : "If the fuzz tests would assert the return code directly, they wouldn't be usable in fuzzing mode, and likely cause people to file bug reports if they'd try to run them. As is, the fuzz tests are just for assessing coverage, and can be used either as test directly (only covering things caught by sanitizers), or used to minimize a corpus generated externally (with known validity/invalidity). Only the latter can be used as a unit test.\r\n\r\nSo I think the differences are:\r\n* The unit test actually tests the script validation results against known valid/invalid things.\r\n* The unit test can be run without building in fuzz mode.\r\n",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-21T20:18:21Z",
      "diff_hunk" : "@@ -1610,5 +1640,104 @@ BOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_invalid_flags)\n     BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_INVALID_FLAGS);\n }\n \n+static std::vector<unsigned int> AllConsensusFlags()\n+{\n+    std::vector<unsigned int> ret;\n+\n+    for (unsigned int i = 0; i < 128; ++i) {\n+        unsigned int flag = 0;\n+        if (i & 1) flag |= SCRIPT_VERIFY_P2SH;\n+        if (i & 2) flag |= SCRIPT_VERIFY_DERSIG;\n+        if (i & 4) flag |= SCRIPT_VERIFY_NULLDUMMY;\n+        if (i & 8) flag |= SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY;\n+        if (i & 16) flag |= SCRIPT_VERIFY_CHECKSEQUENCEVERIFY;\n+        if (i & 32) flag |= SCRIPT_VERIFY_WITNESS;\n+        if (i & 64) flag |= SCRIPT_VERIFY_TAPROOT;\n+\n+        // SCRIPT_VERIFY_WITNESS requires SCRIPT_VERIFY_P2SH\n+        if (flag & SCRIPT_VERIFY_WITNESS && !(flag & SCRIPT_VERIFY_P2SH)) continue;\n+        // SCRIPT_VERIFY_TAPROOT requires SCRIPT_VERIFY_WITNESS\n+        if (flag & SCRIPT_VERIFY_TAPROOT && !(flag & SCRIPT_VERIFY_WITNESS)) continue;\n+\n+        ret.push_back(flag);\n+    }\n+\n+    return ret;\n+}\n+\n+/** Precomputed list of all valid combinations of consensus-relevant script validation flags. */\n+static const std::vector<unsigned int> ALL_CONSENSUS_FLAGS = AllConsensusFlags();\n+\n+static void AssetTest(const UniValue& test)\n+{\n+    BOOST_CHECK(test.isObject());\n+\n+    CMutableTransaction mtx = TxFromHex(test[\"tx\"].get_str());\n+    const std::vector<CTxOut> prevouts = TxOutsFromJSON(test[\"prevouts\"]);\n+    BOOST_CHECK(prevouts.size() == mtx.vin.size());\n+    size_t idx = test[\"index\"].get_int64();\n+    unsigned int test_flags = ParseScriptFlags(test[\"flags\"].get_str());\n+    bool fin = test.exists(\"final\") && test[\"final\"].get_bool();\n+\n+    if (test.exists(\"success\")) {\n+        mtx.vin[idx].scriptSig = ScriptFromHex(test[\"success\"][\"scriptSig\"].get_str());\n+        mtx.vin[idx].scriptWitness = ScriptWitnessFromJSON(test[\"success\"][\"witness\"]);\n+        CTransaction tx(mtx);\n+        PrecomputedTransactionData txdata;\n+        txdata.Init(tx, std::vector<CTxOut>(prevouts));\n+        CachingTransactionSignatureChecker txcheck(&tx, idx, prevouts[idx].nValue, true, txdata);\n+        for (const auto flags : ALL_CONSENSUS_FLAGS) {\n+            // \"final\": true tests are valid for all flags. Others are only valid with flags that are\n+            // a subset of test_flags.\n+            if (fin || ((flags & test_flags) == flags)) {\n+                bool ret = VerifyScript(tx.vin[idx].scriptSig, prevouts[idx].scriptPubKey, &tx.vin[idx].scriptWitness, flags, txcheck, nullptr);\n+                BOOST_CHECK(ret);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509659095",
      "id" : 509659095,
      "in_reply_to_id" : 509617693,
      "line" : 1694,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY1OTA5NQ==",
      "original_commit_id" : "4567ba034c5ae6e6cc161360f7425c9e844738f0",
      "original_line" : 1694,
      "original_position" : 113,
      "original_start_line" : null,
      "path" : "src/test/script_tests.cpp",
      "position" : 113,
      "pull_request_review_id" : 514152452,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-21T20:29:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509659095",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509663835"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509663835"
         }
      },
      "author_association" : "MEMBER",
      "body" : "See follow-up in https://github.com/bitcoin/bitcoin/pull/20207.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-21T20:23:13Z",
      "diff_hunk" : "@@ -237,6 +239,36 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check policy limits for Taproot spends:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509663835",
      "id" : 509663835,
      "in_reply_to_id" : 509149586,
      "line" : 243,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY2MzgzNQ==",
      "original_commit_id" : "e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6",
      "original_line" : 243,
      "original_position" : 30,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : 30,
      "pull_request_review_id" : 514155811,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-21T20:23:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509663835",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509664115"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509664115"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ok, I wasn't aware of that mode being supported. Added in #20207.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-21T20:23:34Z",
      "diff_hunk" : "@@ -369,3 +392,161 @@ def sign_ecdsa(self, msg, low_s=True):\n         rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')\n         sb = s.to_bytes((s.bit_length() + 8) // 8, 'big')\n         return b'\\x30' + bytes([4 + len(rb) + len(sb), 2, len(rb)]) + rb + bytes([2, len(sb)]) + sb\n+\n+def compute_xonly_pubkey(key):\n+    \"\"\"Compute an x-only (32 byte) public key from a (32 byte) private key.\n+\n+    This also returns whether the resulting public key was negated.\n+    \"\"\"\n+\n+    assert len(key) == 32\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return (None, None)\n+    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, x)]))\n+    return (P[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(P))\n+\n+def tweak_add_privkey(key, tweak):\n+    \"\"\"Tweak a private key (after negating it if needed).\"\"\"\n+\n+    assert len(key) == 32\n+    assert len(tweak) == 32\n+\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return None\n+    if not SECP256K1.has_even_y(SECP256K1.mul([(SECP256K1_G, x)])):\n+       x = SECP256K1_ORDER - x\n+    t = int.from_bytes(tweak, 'big')\n+    if t >= SECP256K1_ORDER:\n+        return None\n+    x = (x + t) % SECP256K1_ORDER\n+    if x == 0:\n+        return None\n+    return x.to_bytes(32, 'big')\n+\n+def tweak_add_pubkey(key, tweak):\n+    \"\"\"Tweak a public key and return whether the result had to be negated.\"\"\"\n+\n+    assert len(key) == 32\n+    assert len(tweak) == 32\n+\n+    x_coord = int.from_bytes(key, 'big')\n+    if x_coord >= SECP256K1_FIELD_SIZE:\n+        return None\n+    P = SECP256K1.lift_x(x_coord)\n+    if P is None:\n+        return None\n+    t = int.from_bytes(tweak, 'big')\n+    if t >= SECP256K1_ORDER:\n+        return None\n+    Q = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, t), (P, 1)]))\n+    if Q is None:\n+        return None\n+    return (Q[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(Q))\n+\n+def verify_schnorr(key, sig, msg):\n+    \"\"\"Verify a Schnorr signature (see BIP 340).\n+\n+    - key is a 32-byte xonly pubkey (computed using compute_xonly_pubkey).\n+    - sig is a 64-byte Schnorr signature\n+    - msg is a 32-byte message\n+    \"\"\"\n+    assert len(key) == 32\n+    assert len(msg) == 32\n+    assert len(sig) == 64\n+\n+    x_coord = int.from_bytes(key, 'big')\n+    if x_coord == 0 or x_coord >= SECP256K1_FIELD_SIZE:\n+        return False\n+    P = SECP256K1.lift_x(x_coord)\n+    if P is None:\n+        return False\n+    r = int.from_bytes(sig[0:32], 'big')\n+    if r >= SECP256K1_FIELD_SIZE:\n+        return False\n+    s = int.from_bytes(sig[32:64], 'big')\n+    if s >= SECP256K1_ORDER:\n+        return False\n+    e = int.from_bytes(TaggedHash(\"BIP0340/challenge\", sig[0:32] + key + msg), 'big') % SECP256K1_ORDER\n+    R = SECP256K1.mul([(SECP256K1_G, s), (P, SECP256K1_ORDER - e)])\n+    if not SECP256K1.has_even_y(R):\n+        return False\n+    if ((r * R[2] * R[2]) % SECP256K1_FIELD_SIZE) != R[0]:\n+        return False\n+    return True\n+\n+def sign_schnorr(key, msg, aux=None):\n+    \"\"\"Create a Schnorr signature (see BIP 340).\"\"\"\n+\n+    if aux is None:\n+        aux = bytes(32)\n+\n+    assert len(key) == 32\n+    assert len(msg) == 32\n+    assert len(aux) == 32\n+\n+    sec = int.from_bytes(key, 'big')\n+    if sec == 0 or sec >= SECP256K1_ORDER:\n+        return None\n+    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, sec)]))\n+    if not SECP256K1.has_even_y(P):\n+        sec = SECP256K1_ORDER - sec\n+    t = (sec ^ int.from_bytes(TaggedHash(\"BIP0340/aux\", aux), 'big')).to_bytes(32, 'big')\n+    kp = int.from_bytes(TaggedHash(\"BIP0340/nonce\", t + P[0].to_bytes(32, 'big') + msg), 'big') % SECP256K1_ORDER\n+    assert kp != 0\n+    R = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, kp)]))\n+    k = kp if SECP256K1.has_even_y(R) else SECP256K1_ORDER - kp\n+    e = int.from_bytes(TaggedHash(\"BIP0340/challenge\", R[0].to_bytes(32, 'big') + P[0].to_bytes(32, 'big') + msg), 'big') % SECP256K1_ORDER\n+    return R[0].to_bytes(32, 'big') + ((k + e * sec) % SECP256K1_ORDER).to_bytes(32, 'big')\n+\n+class TestFrameworkKey(unittest.TestCase):\n+    def test_schnorr(self):\n+        \"\"\"Test the Python Schnorr implementation.\"\"\"\n+        byte_arrays = [generate_privkey() for _ in range(3)] + [v.to_bytes(32, 'big') for v in [0, SECP256K1_ORDER - 1, SECP256K1_ORDER, 2**256 - 1]]\n+        keys = {}\n+        for privkey in byte_arrays:  # build array of key/pubkey pairs\n+            pubkey, _ = compute_xonly_pubkey(privkey)\n+            if pubkey is not None:\n+                keys[privkey] = pubkey\n+        for msg in byte_arrays:  # test every combination of message, signing key, verification key\n+            for sign_privkey, sign_pubkey in keys.items():\n+                sig = sign_schnorr(sign_privkey, msg)\n+                for verify_privkey, verify_pubkey in keys.items():\n+                    if verify_privkey == sign_privkey:\n+                        self.assertTrue(verify_schnorr(verify_pubkey, sig, msg))\n+                        sig = list(sig)\n+                        sig[random.randrange(64)] ^= (1 << (random.randrange(8)))  # damaging signature should break things\n+                        sig = bytes(sig)\n+                    self.assertFalse(verify_schnorr(verify_pubkey, sig, msg))\n+\n+    def test_schnorr_testvectors(self):\n+        \"\"\"Implement the BIP340 test vectors (read from bip340_test_vectors.csv).\"\"\"\n+        num_tests = 0\n+        with open(os.path.join(sys.path[0], 'test_framework', 'bip340_test_vectors.csv'), newline='', encoding='utf8') as csvfile:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509664115",
      "id" : 509664115,
      "in_reply_to_id" : 509382262,
      "line" : 526,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY2NDExNQ==",
      "original_commit_id" : "3c226639eb134314a0640d34e4ccb6148dbde22f",
      "original_line" : 526,
      "original_position" : 232,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : 232,
      "pull_request_review_id" : 514156048,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-21T20:23:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509664115",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509664224"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509664224"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-21T20:23:40Z",
      "diff_hunk" : "@@ -1,15 +1,29 @@\n-# Copyright (c) 2019 Pieter Wuille\n+# Copyright (c) 2019-2020 Pieter Wuille\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test-only secp256k1 elliptic curve implementation\n \n WARNING: This code is slow, uses bad randomness, does not properly protect\n keys, and is trivially vulnerable to side channel attacks. Do not use for\n anything but tests.\"\"\"\n+import csv\n+import hashlib\n+import os\n import random\n+import sys\n+import unittest\n \n from .util import modinv\n \n+def TaggedHash(tag, data):\n+    ss = hashlib.sha256(tag.encode('utf-8')).digest()\n+    ss += ss\n+    ss += data\n+    return hashlib.sha256(ss).digest()\n+\n+def xor_bytes(b0, b1):\n+    return bytes(x ^ y for (x, y) in zip(b0, b1))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509664224",
      "id" : 509664224,
      "in_reply_to_id" : 509383731,
      "line" : 25,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY2NDIyNA==",
      "original_commit_id" : "3c226639eb134314a0640d34e4ccb6148dbde22f",
      "original_line" : 25,
      "original_position" : 26,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : 26,
      "pull_request_review_id" : 514156129,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-21T20:23:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509664224",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509664858"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509664858"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm not sure, it may have been needed in an old version of this code. It doesn't seem needed anymore; addressed in #20207.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-21T20:24:34Z",
      "diff_hunk" : "@@ -0,0 +1,1411 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expression for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        return tweak_add_privkey(key, tweak)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    scriptsig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    witness_stack = flatten(get(ctx, \"witness\"))\n+    return (scriptsig, witness_stack)\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda returning (scriptsig, witness_stack), taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+# - Whether this test demands being placed in a txin with no corresponding txout (for testing SIGHASH_SINGLE behavior)\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail,need_vin_vout_mismatch\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, need_vin_vout_mismatch=False, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert tap is None\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert script is None\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert script is None\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert script is None\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            return spend(tx, idx, utxos, **conf)\n+        else:\n+            assert failure is not None\n+            return spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None, need_vin_vout_mismatch=need_vin_vout_mismatch)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    return bytes(CScript([pubkey, OP_CHECKSIG]))\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+def zero_appender(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a zero added.\"\"\"\n+    return lambda ctx: deep_eval(ctx, expr) + b\"\\x00\"\n+\n+def byte_popper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with its last byte removed.\"\"\"\n+    return lambda ctx: deep_eval(ctx, expr)[:-1]\n+\n+# Expected error strings\n+\n+ERR_SIG_SIZE = {\"err_msg\": \"Invalid Schnorr signature size\"}\n+ERR_SIG_HASHTYPE = {\"err_msg\": \"Invalid Schnorr signature hash type\"}\n+ERR_SIG_SCHNORR = {\"err_msg\": \"Invalid Schnorr signature\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_TAPSCRIPT_CHECKMULTISIG = {\"err_msg\": \"OP_CHECKMULTISIG(VERIFY) is not available in tapscript\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal in tapscript\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Stack size must be exactly one after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+ERR_CHECKSIGVERIFY = {\"err_msg\": \"Script failed an OP_CHECKSIGVERIFY operation\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+VALID_SIGHASHES_TAPROOT_SINGLE = [\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT_NO_SINGLE = [h for h in VALID_SIGHASHES_TAPROOT if h not in VALID_SIGHASHES_TAPROOT_SINGLE]\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SIG_POP_BYTE = {\"failure\": {\"sign\": byte_popper(default_sign)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+SIG_ADD_ZERO = {\"failure\": {\"sign\": zero_appender(default_sign)}}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 50000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    secs = [generate_privkey() for _ in range(8)]\n+    pubs = [compute_xonly_pubkey(sec)[0] for sec in secs]\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    tap = taproot_construct(pubs[0])\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=secs[0], failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_SIG_SCHNORR)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=secs[0], failure={\"sighash\": bitflipper(default_sighash)}, **ERR_SIG_SCHNORR)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=secs[0], failure={\"flag_flip_r\": True}, **ERR_SIG_SCHNORR)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=secs[0], failure={\"flag_flip_p\": True}, **ERR_SIG_SCHNORR)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=secs[0], failure={\"signature\": bitflipper(default_signature)}, **ERR_SIG_SCHNORR)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pubs[0])\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pubs[1])))]\n+            tap = taproot_construct(pubs[0], scripts)\n+            add_spender(spenders, \"sighash/keypath_hashtype_%x\" % hashtype, tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+            add_spender(spenders, \"sighash/scriptpath_hashtype_%x\" % hashtype, tap=tap, leaf=\"s0\", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+\n+            # Test SIGHASH_SINGLE behavior in combination with mismatching outputs\n+            if hashtype in VALID_SIGHASHES_TAPROOT_SINGLE:\n+                add_spender(spenders, \"sighash/keypath_hashtype_mis_%x\" % hashtype, tap=tap, key=secs[0], annex=annex, standard=no_annex, hashtype_actual=random.choice(VALID_SIGHASHES_TAPROOT_NO_SINGLE), failure={\"hashtype_actual\": hashtype}, **ERR_SIG_HASHTYPE, need_vin_vout_mismatch=True)\n+                add_spender(spenders, \"sighash/scriptpath_hashtype_mis_%x\" % hashtype, tap=tap, leaf=\"s0\", key=secs[1], annex=annex, standard=no_annex, hashtype_actual=random.choice(VALID_SIGHASHES_TAPROOT_NO_SINGLE), **SINGLE_SIG, failure={\"hashtype_actual\": hashtype}, **ERR_SIG_HASHTYPE, need_vin_vout_mismatch=True)\n+\n+        # Test OP_CODESEPARATOR impact on sighashing.\n+        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+        common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+        scripts = [\n+            (\"pk_codesep\", CScript(random_checksig_style(pubs[1]) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig\n+            (\"codesep_pk\", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pubs[1]))),  # codesep before checksig\n+            (\"branched_codesep\", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pubs[0], OP_ELSE, OP_CODESEPARATOR, pubs[1], OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"sighash/pk_codesep\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+        add_spender(spenders, \"sighash/codesep_pk\", tap=tap, leaf=\"codesep_pk\", key=secs[1], codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+        add_spender(spenders, \"sighash/branched_codesep/left\", tap=tap, leaf=\"branched_codesep\", key=secs[0], codeseppos=3, **common, inputs=[getter(\"sign\"), b'\\x01'], **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+        add_spender(spenders, \"sighash/branched_codesep/right\", tap=tap, leaf=\"branched_codesep\", key=secs[1], codeseppos=6, **common, inputs=[getter(\"sign\"), b''], **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+\n+    # Reusing the scripts above, test that various features affect the sighash.\n+    add_spender(spenders, \"sighash/annex\", tap=tap, leaf=\"pk_codesep\", key=secs[1], hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={\"sighash\": override(default_sighash, annex=None)}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/script\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, script_taproot=tap.leaves[\"codesep_pk\"].script)}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/leafver\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leafversion=random.choice([x & 0xFE for x in range(0x100) if x & 0xFE != 0xC0]))}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leaf=None)}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/keypath\", tap=tap, key=secs[0], **common, failure={\"sighash\": override(default_sighash, leaf=\"pk_codesep\")}, **ERR_SIG_SCHNORR)\n+\n+    # Test that invalid hashtypes don't work, both in key path and script path spends\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for invalid_hashtype in [x for x in range(0x100) if x not in VALID_SIGHASHES_TAPROOT]:\n+        add_spender(spenders, \"sighash/keypath_unk_hashtype_%x\" % invalid_hashtype, tap=tap, key=secs[0], hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_SIG_HASHTYPE)\n+        add_spender(spenders, \"sighash/scriptpath_unk_hashtype_%x\" % invalid_hashtype, tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_SIG_HASHTYPE)\n+\n+    # Test that hashtype 0 cannot have a hashtype byte, and 1 must have one.\n+    add_spender(spenders, \"sighash/hashtype0_byte_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_SIG_HASHTYPE)\n+    add_spender(spenders, \"sighash/hashtype0_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_SIG_HASHTYPE)\n+    add_spender(spenders, \"sighash/hashtype1_byte_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/hashtype1_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SIG_SCHNORR)\n+    # Test that hashtype 0 and hashtype 1 cannot be transmuted into each other.\n+    add_spender(spenders, \"sighash/hashtype0to1_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/hashtype0to1_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/hashtype1to0_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/hashtype1to0_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SIG_SCHNORR)\n+\n+    # Test aspects of signatures with unusual lengths\n+    for hashtype in [SIGHASH_DEFAULT, random.choice(VALID_SIGHASHES_TAPROOT)]:\n+        scripts = [\n+            (\"csv\", CScript([pubs[2], OP_CHECKSIGVERIFY, OP_1])),\n+            (\"cs_pos\", CScript([pubs[2], OP_CHECKSIG])),\n+            (\"csa_pos\", CScript([OP_0, pubs[2], OP_CHECKSIGADD, OP_1, OP_EQUAL])),\n+            (\"cs_neg\", CScript([pubs[2], OP_CHECKSIG, OP_NOT])),\n+            (\"csa_neg\", CScript([OP_2, pubs[2], OP_CHECKSIGADD, OP_2, OP_EQUAL]))\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[3], scripts)\n+        # Empty signatures\n+        add_spender(spenders, \"siglen/empty_keypath\", tap=tap, key=secs[3], hashtype=hashtype, failure={\"sign\": b\"\"}, **ERR_SIG_SIZE)\n+        add_spender(spenders, \"siglen/empty_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_CHECKSIGVERIFY)\n+        add_spender(spenders, \"siglen/empty_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_NO_SUCCESS)\n+        add_spender(spenders, \"siglen/empty_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_NO_SUCCESS)\n+        add_spender(spenders, \"siglen/empty_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": lambda _: random_bytes(random.randrange(1, 63))}, **ERR_SIG_SIZE)\n+        add_spender(spenders, \"siglen/empty_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": lambda _: random_bytes(random.randrange(66, 100))}, **ERR_SIG_SIZE)\n+        # Appending a zero byte to signatures invalidates them\n+        add_spender(spenders, \"siglen/padzero_keypath\", tap=tap, key=secs[3], hashtype=hashtype, **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        add_spender(spenders, \"siglen/padzero_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        add_spender(spenders, \"siglen/padzero_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        add_spender(spenders, \"siglen/padzero_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        add_spender(spenders, \"siglen/padzero_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        add_spender(spenders, \"siglen/padzero_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        # Removing the last byte from signatures invalidates them\n+        add_spender(spenders, \"siglen/popbyte_keypath\", tap=tap, key=secs[3], hashtype=hashtype, **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        add_spender(spenders, \"siglen/popbyte_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        add_spender(spenders, \"siglen/popbyte_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        add_spender(spenders, \"siglen/popbyte_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        add_spender(spenders, \"siglen/popbyte_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        add_spender(spenders, \"siglen/popbyte_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        # Verify that an invalid signature is not allowed, not even when the CHECKSIG* is expected to fail.\n+        add_spender(spenders, \"siglen/invalid_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": default_sign, \"sighash\": bitflipper(default_sighash)}, **ERR_SIG_SCHNORR)\n+        add_spender(spenders, \"siglen/invalid_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": default_sign, \"sighash\": bitflipper(default_sighash)}, **ERR_SIG_SCHNORR)\n+\n+    # == Test that BIP341 spending only applies to witness version 1, program length 32, no P2SH ==\n+\n+    for p2sh in [False, True]:\n+        for witver in range(1, 17):\n+            for witlen in [20, 31, 32, 33]:\n+                def mutate(spk):\n+                    prog = spk[2:]\n+                    assert len(prog) == 32\n+                    if witlen < 32:\n+                        prog = prog[0:witlen]\n+                    elif witlen > 32:\n+                        prog += bytes([0 for _ in range(witlen - 32)])\n+                    return CScript([CScriptOp.encode_op_n(witver), prog])\n+                scripts = [(\"s0\", CScript([pubs[0], OP_CHECKSIG])), (\"dummy\", CScript([OP_RETURN]))]\n+                tap = taproot_construct(pubs[1], scripts)\n+                if not p2sh and witver == 1 and witlen == 32:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, failure={\"leaf\": \"dummy\"}, **ERR_OP_RETURN)\n+                else:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], standard=False)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, standard=False)\n+\n+    # == Test various aspects of BIP341 spending paths ==\n+\n+    # A set of functions that compute the hashing partner in a Merkle tree, designed to exercise\n+    # edge cases. This relies on the taproot_construct feature that a lambda can be passed in\n+    # instead of a subtree, to compute the partner to be hashed with.\n+    PARTNER_MERKLE_FN = [\n+        # Combine with itself\n+        lambda h: h,\n+        # Combine with hash 0\n+        lambda h: bytes([0 for _ in range(32)]),\n+        # Combine with hash 2^256-1\n+        lambda h: bytes([0xff for _ in range(32)]),\n+        # Combine with itself-1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') + 1).to_bytes(32, 'big'),\n+        # Combine with itself-1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') + 1).to_bytes(32, 'little'),\n+        # Combine with random bitflipped version of self.\n+        lambda h: (int.from_bytes(h, 'little') ^ (1 << random.randrange(256))).to_bytes(32, 'little')\n+    ]\n+    # Start with a tree of that has depth 1 for \"128deep\" and depth 2 for \"129deep\".\n+    scripts = [(\"128deep\", CScript([pubs[0], OP_CHECKSIG])), [(\"129deep\", CScript([pubs[0], OP_CHECKSIG])), random.choice(PARTNER_MERKLE_FN)]]\n+    # Add 127 nodes on top of that tree, so that \"128deep\" and \"129deep\" end up at their designated depths.\n+    for _ in range(127):\n+        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+    tap = taproot_construct(pubs[0], scripts)\n+    # Test that spends with a depth of 128 work, but 129 doesn't (even with a tree with weird Merkle branches in it).\n+    add_spender(spenders, \"spendpath/merklelimit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"leaf\": \"129deep\"}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that flipping the negation bit invalidates spends.\n+    add_spender(spenders, \"spendpath/negflag\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"negflag\": lambda ctx: 1 - default_negflag(ctx)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the Merkle branch invalidate it.\n+    add_spender(spenders, \"spendpath/bitflipmerkle\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"merklebranch\": bitflipper(default_merklebranch)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the inner pubkey invalidate it.\n+    add_spender(spenders, \"spendpath/bitflippubkey\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"pubkey_inner\": bitflipper(default_pubkey_inner)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that empty witnesses are invalid.\n+    add_spender(spenders, \"spendpath/emptywit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"witness\": []}, **ERR_EMPTY_WITNESS)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padlongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/trunclongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    scripts = [(\"s\", CScript([pubs[0], OP_CHECKSIG]))]\n+    tap = taproot_construct(pubs[1], scripts)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/truncshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block to 1 byte (\"-1 Merkle length\") invalidates it\n+    add_spender(spenders, \"spendpath/trunc1shortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:1]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    # == Test BIP342 edge cases ==\n+\n+    csa_low_val = random.randrange(0, 17) # Within range for OP_n\n+    csa_low_result = csa_low_val + 1\n+\n+    csa_high_val = random.randrange(17, 100) if random.getrandbits(1) else random.randrange(-100, -1) # Outside OP_n range\n+    csa_high_result = csa_high_val + 1\n+\n+    OVERSIZE_NUMBER = 2**31\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER))), 6)\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER-1))), 5)\n+\n+    big_choices = []\n+    big_scriptops = []\n+    for i in range(1000):\n+        r = random.randrange(len(pubs))\n+        big_choices.append(r)\n+        big_scriptops += [pubs[r], OP_CHECKSIGVERIFY]\n+\n+\n+    def big_spend_inputs(ctx):\n+        \"\"\"Helper function to construct the script input for t33/t34 below.\"\"\"\n+        # Instead of signing 999 times, precompute signatures for every (key, hashtype) combination\n+        sigs = {}\n+        for ht in VALID_SIGHASHES_TAPROOT:\n+            for k in range(len(pubs)):\n+                sigs[(k, ht)] = override(default_sign, hashtype=ht, key=secs[k])(ctx)\n+        num = get(ctx, \"num\")\n+        return [sigs[(big_choices[i], random.choice(VALID_SIGHASHES_TAPROOT))] for i in range(num - 1, -1, -1)]\n+\n+    # Various BIP342 features\n+    scripts = [\n+        # 0) drop stack element and OP_CHECKSIG\n+        (\"t0\", CScript([OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 1) normal OP_CHECKSIG\n+        (\"t1\", CScript([pubs[1], OP_CHECKSIG])),\n+        # 2) normal OP_CHECKSIGVERIFY\n+        (\"t2\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1])),\n+        # 3) Hypothetical OP_CHECKMULTISIG script that takes a single sig as input\n+        (\"t3\", CScript([OP_0, OP_SWAP, OP_1, pubs[1], OP_1, OP_CHECKMULTISIG])),\n+        # 4) Hypothetical OP_CHECKMULTISIGVERIFY script that takes a single sig as input\n+        (\"t4\", CScript([OP_0, OP_SWAP, OP_1, pubs[1], OP_1, OP_CHECKMULTISIGVERIFY, OP_1])),\n+        # 5) OP_IF script that needs a true input\n+        (\"t5\", CScript([OP_IF, pubs[1], OP_CHECKSIG, OP_ELSE, OP_RETURN, OP_ENDIF])),\n+        # 6) OP_NOTIF script that needs a true input\n+        (\"t6\", CScript([OP_NOTIF, OP_RETURN, OP_ELSE, pubs[1], OP_CHECKSIG, OP_ENDIF])),\n+        # 7) OP_CHECKSIG with an empty key\n+        (\"t7\", CScript([OP_0, OP_CHECKSIG])),\n+        # 8) OP_CHECKSIGVERIFY with an empty key\n+        (\"t8\", CScript([OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 9) normal OP_CHECKSIGADD that also ensures return value is correct\n+        (\"t9\", CScript([csa_low_val, pubs[1], OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 10) OP_CHECKSIGADD with empty key\n+        (\"t10\", CScript([csa_low_val, OP_0, OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 11) OP_CHECKSIGADD with missing counter stack element\n+        (\"t11\", CScript([pubs[1], OP_CHECKSIGADD, OP_1, OP_EQUAL])),\n+        # 12) OP_CHECKSIG that needs invalid signature\n+        (\"t12\", CScript([pubs[1], OP_CHECKSIGVERIFY, pubs[0], OP_CHECKSIG, OP_NOT])),\n+        # 13) OP_CHECKSIG with empty key that needs invalid signature\n+        (\"t13\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_CHECKSIG, OP_NOT])),\n+        # 14) OP_CHECKSIGADD that needs invalid signature\n+        (\"t14\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, pubs[0], OP_CHECKSIGADD, OP_NOT])),\n+        # 15) OP_CHECKSIGADD with empty key that needs invalid signature\n+        (\"t15\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGADD, OP_NOT])),\n+        # 16) OP_CHECKSIG with unknown pubkey type\n+        (\"t16\", CScript([OP_1, OP_CHECKSIG])),\n+        # 17) OP_CHECKSIGADD with unknown pubkey type\n+        (\"t17\", CScript([OP_0, OP_1, OP_CHECKSIGADD])),\n+        # 18) OP_CHECKSIGVERIFY with unknown pubkey type\n+        (\"t18\", CScript([OP_1, OP_CHECKSIGVERIFY, OP_1])),\n+        # 19) script longer than 10000 bytes and over 201 non-push opcodes\n+        (\"t19\", CScript([OP_0, OP_0, OP_2DROP] * 10001 + [pubs[1], OP_CHECKSIG])),\n+        # 20) OP_CHECKSIGVERIFY with empty key\n+        (\"t20\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 21) Script that grows the stack to 1000 elements\n+        (\"t21\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 999 + [OP_DROP] * 999)),\n+        # 22) Script that grows the stack to 1001 elements\n+        (\"t22\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 1000 + [OP_DROP] * 1000)),\n+        # 23) Script that expects an input stack of 1000 elements\n+        (\"t23\", CScript([OP_DROP] * 999 + [pubs[1], OP_CHECKSIG])),\n+        # 24) Script that expects an input stack of 1001 elements\n+        (\"t24\", CScript([OP_DROP] * 1000 + [pubs[1], OP_CHECKSIG])),\n+        # 25) Script that pushes a MAX_SCRIPT_ELEMENT_SIZE-bytes element\n+        (\"t25\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE), OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 26) Script that pushes a (MAX_SCRIPT_ELEMENT_SIZE+1)-bytes element\n+        (\"t26\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 27) CHECKSIGADD that must fail because numeric argument number is >4 bytes\n+        (\"t27\", CScript([CScriptNum(OVERSIZE_NUMBER), pubs[1], OP_CHECKSIGADD])),\n+        # 28) Pushes random CScriptNum value, checks OP_CHECKSIGADD result\n+        (\"t28\", CScript([csa_high_val, pubs[1], OP_CHECKSIGADD, csa_high_result, OP_EQUAL])),\n+        # 29) CHECKSIGADD that succeeds with proper sig because numeric argument number is <=4 bytes\n+        (\"t29\", CScript([CScriptNum(OVERSIZE_NUMBER-1), pubs[1], OP_CHECKSIGADD])),\n+        # 30) Variant of t1 with \"normal\" 33-byte pubkey\n+        (\"t30\", CScript([b'\\x03' + pubs[1], OP_CHECKSIG])),\n+        # 31) Variant of t2 with \"normal\" 33-byte pubkey\n+        (\"t31\", CScript([b'\\x02' + pubs[1], OP_CHECKSIGVERIFY, OP_1])),\n+        # 32) Variant of t28 with \"normal\" 33-byte pubkey\n+        (\"t32\", CScript([csa_high_val, b'\\x03' + pubs[1], OP_CHECKSIGADD, csa_high_result, OP_EQUAL])),\n+        # 33) 999-of-999 multisig\n+        (\"t33\", CScript(big_scriptops[:1998] + [OP_1])),\n+        # 34) 1000-of-1000 multisig\n+        (\"t34\", CScript(big_scriptops[:2000] + [OP_1])),\n+        # 35) Variant of t9 that uses a non-minimally encoded input arg\n+        (\"t35\", CScript([bytes([csa_low_val]), pubs[1], OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 36) Empty script\n+        (\"t36\", CScript([])),\n+    ]\n+    # Add many dummies to test huge trees\n+    for j in range(100000):\n+        scripts.append((None, CScript([OP_RETURN, random.randrange(100000)])))\n+    random.shuffle(scripts)\n+    tap = taproot_construct(pubs[0], scripts)\n+    common = {\n+        \"hashtype\": hashtype,\n+        \"key\": secs[1],\n+        \"tap\": tap,\n+    }\n+    # Test that MAX_SCRIPT_ELEMENT_SIZE byte stack element inputs are valid, but not one more (and 80 bytes is standard but 81 is not).\n+    add_spender(spenders, \"tapscript/inputmaxlimit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE)], failure={\"inputs\": [getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1)]}, **ERR_PUSH_LIMIT)\n+    add_spender(spenders, \"tapscript/input80limit\", leaf=\"t0\", **common, inputs=[getter(\"sign\"), random_bytes(80)])\n+    add_spender(spenders, \"tapscript/input81limit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(81)])\n+    # Test that OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY cause failure, but OP_CHECKSIG and OP_CHECKSIGVERIFY work.\n+    add_spender(spenders, \"tapscript/disabled_checkmultisig\", leaf=\"t1\", **common, **SINGLE_SIG, failure={\"leaf\": \"t3\"}, **ERR_TAPSCRIPT_CHECKMULTISIG)\n+    add_spender(spenders, \"tapscript/disabled_checkmultisigverify\", leaf=\"t2\", **common, **SINGLE_SIG, failure={\"leaf\": \"t4\"}, **ERR_TAPSCRIPT_CHECKMULTISIG)\n+    # Test that OP_IF and OP_NOTIF do not accept non-0x01 as truth value (the MINIMALIF rule is consensus in Tapscript)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x02']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x03']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0001']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0100']}, **ERR_MINIMALIF)\n+    # Test that 1-byte public keys (which are unknown) are acceptable but nonstandard with unrelated signatures, but 0-byte public keys are not valid.\n+    add_spender(spenders, \"tapscript/unkpk/checksig\", leaf=\"t16\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigadd\", leaf=\"t17\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigverify\", leaf=\"t18\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that 33-byte public keys (which are unknown) are acceptable but nonstandard with valid signatures, but normal pubkeys are not valid in that case.\n+    add_spender(spenders, \"tapscript/oldpk/checksig\", leaf=\"t30\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t1\"}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"tapscript/oldpk/checksigadd\", leaf=\"t31\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t2\"}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"tapscript/oldpk/checksigverify\", leaf=\"t32\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t28\"}, **ERR_SIG_SCHNORR)\n+    # Test that 0-byte public keys are not acceptable.\n+    add_spender(spenders, \"tapscript/emptypk/checksig\", leaf=\"t1\", **SINGLE_SIG, **common, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigverify\", leaf=\"t2\", **SINGLE_SIG, **common, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigadd\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigadd\", leaf=\"t35\", standard=False, **SINGLE_SIG, **common, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that OP_CHECKSIGADD results are as expected\n+    add_spender(spenders, \"tapscript/checksigaddresults\", leaf=\"t28\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    add_spender(spenders, \"tapscript/checksigaddoversize\", leaf=\"t29\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    # Test that OP_CHECKSIGADD requires 3 stack elements.\n+    add_spender(spenders, \"tapscript/checksigadd3args\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t11\"}, **ERR_STACK_EMPTY)\n+    # Test that empty signatures do not cause script failure in OP_CHECKSIG and OP_CHECKSIGADD (but do fail with empty pubkey, and do fail OP_CHECKSIGVERIFY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksig\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t13\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/nochecksigverify\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t20\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksigadd\", leaf=\"t14\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t15\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that scripts over 10000 bytes (and over 201 non-push ops) are acceptable.\n+    add_spender(spenders, \"tapscript/no10000limit\", leaf=\"t19\", **SINGLE_SIG, **common)\n+    # Test that a stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000stack\", leaf=\"t21\", **SINGLE_SIG, **common, failure={\"leaf\": \"t22\"}, **ERR_STACK_SIZE)\n+    # Test that an input stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000inputs\", leaf=\"t23\", **common, inputs=[getter(\"sign\")] + [b'' for _ in range(999)], failure={\"leaf\": \"t24\", \"inputs\": [getter(\"sign\")] + [b'' for _ in range(1000)]}, **ERR_STACK_SIZE)\n+    # Test that pushing a MAX_SCRIPT_ELEMENT_SIZE byte stack element is valid, but one longer is not.\n+    add_spender(spenders, \"tapscript/pushmaxlimit\", leaf=\"t25\", **common, **SINGLE_SIG, failure={\"leaf\": \"t26\"}, **ERR_PUSH_LIMIT)\n+    # Test that 999-of-999 multisig works (but 1000-of-1000 triggers stack size limits)\n+    add_spender(spenders, \"tapscript/bigmulti\", leaf=\"t33\", **common, inputs=big_spend_inputs, num=999, failure={\"leaf\": \"t34\", \"num\": 1000}, **ERR_STACK_SIZE)\n+    # Test that the CLEANSTACK rule is consensus critical in tapscript\n+    add_spender(spenders, \"tapscript/cleanstack\", leaf=\"t36\", tap=tap, inputs=[b'\\x01'], failure={\"inputs\": [b'\\x01', b'\\x01']}, **ERR_CLEANSTACK)\n+\n+    # == Test for sigops ratio limit ==\n+\n+    # Given a number n, and a public key pk, functions that produce a (CScript, sigops). Each script takes as\n+    # input a valid signature with the passed pk followed by a dummy push of bytes that are to be dropped, and\n+    # will execute sigops signature checks.\n+    SIGOPS_RATIO_SCRIPTS = [\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIG.\n+        lambda n, pk: (CScript([OP_DROP, pk] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGVERIFY.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_0, OP_IF, OP_2DUP, OP_CHECKSIGVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_2, OP_SWAP, OP_CHECKSIGADD, OP_3, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIG.\n+        lambda n, pk: (CScript([random_bytes(220), OP_2DROP, pk, OP_1, OP_NOTIF, OP_2DUP, OP_CHECKSIG, OP_VERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_4, OP_SWAP, OP_CHECKSIGADD, OP_5, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGADD.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_1, OP_IF, OP_ELSE, OP_2DUP, OP_6, OP_SWAP, OP_CHECKSIGADD, OP_7, OP_EQUALVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_8, OP_SWAP, OP_CHECKSIGADD, OP_9, OP_EQUAL]), n + 1),\n+        # n+1 OP_CHECKSIGs, but also one OP_CHECKSIG with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, pk, OP_CHECKSIG, OP_NOT, OP_VERIFY, pk] + [OP_2DUP, OP_CHECKSIG, OP_VERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGADDs and 1 OP_CHECKSIG, but also an OP_CHECKSIGADD with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, OP_10, pk, OP_CHECKSIGADD, OP_10, OP_EQUALVERIFY, pk] + [OP_2DUP, OP_16, OP_SWAP, OP_CHECKSIGADD, b'\\x11', OP_EQUALVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+    ]\n+    for annex in [None, bytes([ANNEX_TAG]) + random_bytes(random.randrange(1000))]:\n+        for hashtype in [SIGHASH_DEFAULT, SIGHASH_ALL]:\n+            for pubkey in [pubs[1], random_bytes(random.choice([x for x in range(2, 81) if x != 32]))]:\n+                for fn_num, fn in enumerate(SIGOPS_RATIO_SCRIPTS):\n+                    merkledepth = random.randrange(129)\n+\n+\n+                    def predict_sigops_ratio(n, dummy_size):\n+                        \"\"\"Predict whether spending fn(n, pubkey) with dummy_size will pass the ratio test.\"\"\"\n+                        script, sigops = fn(n, pubkey)\n+                        # Predict the size of the witness for a given choice of n\n+                        stacklen_size = 1\n+                        sig_size = 64 + (hashtype != SIGHASH_DEFAULT)\n+                        siglen_size = 1\n+                        dummylen_size = 1 + 2 * (dummy_size >= 253)\n+                        script_size = len(script)\n+                        scriptlen_size = 1 + 2 * (script_size >= 253)\n+                        control_size = 33 + 32 * merkledepth\n+                        controllen_size = 1 + 2 * (control_size >= 253)\n+                        annex_size = 0 if annex is None else len(annex)\n+                        annexlen_size = 0 if annex is None else 1 + 2 * (annex_size >= 253)\n+                        witsize = stacklen_size + sig_size + siglen_size + dummy_size + dummylen_size + script_size + scriptlen_size + control_size + controllen_size + annex_size + annexlen_size\n+                        # sigops ratio test\n+                        return witsize + 50 >= 50 * sigops\n+                    # Make sure n is high enough that with empty dummy, the script is not valid\n+                    n = 0\n+                    while predict_sigops_ratio(n, 0):\n+                        n += 1\n+                    # But allow picking a bit higher still\n+                    n += random.randrange(5)\n+                    # Now pick dummy size *just* large enough that the overall construction passes\n+                    dummylen = 0\n+                    while not predict_sigops_ratio(n, dummylen):\n+                        dummylen += 1\n+                    scripts = [(\"s\", fn(n, pubkey)[0])]\n+                    for _ in range(merkledepth):\n+                        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+                    tap = taproot_construct(pubs[0], scripts)\n+                    standard = annex is None and dummylen <= 80 and len(pubkey) == 32\n+                    add_spender(spenders, \"tapscript/sigopsratio_%i\" % fn_num, tap=tap, leaf=\"s\", annex=annex, hashtype=hashtype, key=secs[1], inputs=[getter(\"sign\"), random_bytes(dummylen)], standard=standard, failure={\"inputs\": [getter(\"sign\"), random_bytes(dummylen - 1)]}, **ERR_SIGOPS_RATIO)\n+\n+    # Future leaf versions\n+    for leafver in range(0, 0x100, 2):\n+        if leafver == LEAF_VERSION_TAPSCRIPT or leafver == ANNEX_TAG:\n+            # Skip the defined LEAF_VERSION_TAPSCRIPT, and the ANNEX_TAG which is not usable as leaf version\n+            continue\n+        scripts = [\n+            (\"bare_c0\", CScript([OP_NOP])),\n+            (\"bare_unkver\", CScript([OP_NOP]), leafver),\n+            (\"return_c0\", CScript([OP_RETURN])),\n+            (\"return_unkver\", CScript([OP_RETURN]), leafver),\n+            (\"undecodable_c0\", CScript([OP_PUSHDATA1])),\n+            (\"undecodable_unkver\", CScript([OP_PUSHDATA1]), leafver),\n+            (\"bigpush_c0\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP])),\n+            (\"bigpush_unkver\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP]), leafver),\n+            (\"1001push_c0\", CScript([OP_0] * 1001)),\n+            (\"1001push_unkver\", CScript([OP_0] * 1001), leafver),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"unkver/bare\", standard=False, tap=tap, leaf=\"bare_unkver\", failure={\"leaf\": \"bare_c0\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"unkver/return\", standard=False, tap=tap, leaf=\"return_unkver\", failure={\"leaf\": \"return_c0\"}, **ERR_OP_RETURN)\n+        add_spender(spenders, \"unkver/undecodable\", standard=False, tap=tap, leaf=\"undecodable_unkver\", failure={\"leaf\": \"undecodable_c0\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"unkver/bigpush\", standard=False, tap=tap, leaf=\"bigpush_unkver\", failure={\"leaf\": \"bigpush_c0\"}, **ERR_PUSH_LIMIT)\n+        add_spender(spenders, \"unkver/1001push\", standard=False, tap=tap, leaf=\"1001push_unkver\", failure={\"leaf\": \"1001push_c0\"}, **ERR_STACK_SIZE)\n+        add_spender(spenders, \"unkver/1001inputs\", standard=False, tap=tap, leaf=\"bare_unkver\", inputs=[b'']*1001, failure={\"leaf\": \"bare_c0\"}, **ERR_STACK_SIZE)\n+\n+    # OP_SUCCESSx tests.\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for opval in range(76, 0x100):\n+        opcode = CScriptOp(opval)\n+        if not is_op_success(opcode):\n+            continue\n+        scripts = [\n+            (\"bare_success\", CScript([opcode])),\n+            (\"bare_nop\", CScript([OP_NOP])),\n+            (\"unexecif_success\", CScript([OP_0, OP_IF, opcode, OP_ENDIF])),\n+            (\"unexecif_nop\", CScript([OP_0, OP_IF, OP_NOP, OP_ENDIF])),\n+            (\"return_success\", CScript([OP_RETURN, opcode])),\n+            (\"return_nop\", CScript([OP_RETURN, OP_NOP])),\n+            (\"undecodable_success\", CScript([opcode, OP_PUSHDATA1])),\n+            (\"undecodable_nop\", CScript([OP_NOP, OP_PUSHDATA1])),\n+            (\"undecodable_bypassed_success\", CScript([OP_PUSHDATA1, OP_2, opcode])),\n+            (\"bigpush_success\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, opcode])),\n+            (\"bigpush_nop\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, OP_NOP])),\n+            (\"1001push_success\", CScript([OP_0] * 1001 + [opcode])),\n+            (\"1001push_nop\", CScript([OP_0] * 1001 + [OP_NOP])),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"opsuccess/bare\", standard=False, tap=tap, leaf=\"bare_success\", failure={\"leaf\": \"bare_nop\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"opsuccess/unexecif\", standard=False, tap=tap, leaf=\"unexecif_success\", failure={\"leaf\": \"unexecif_nop\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"opsuccess/return\", standard=False, tap=tap, leaf=\"return_success\", failure={\"leaf\": \"return_nop\"}, **ERR_OP_RETURN)\n+        add_spender(spenders, \"opsuccess/undecodable\", standard=False, tap=tap, leaf=\"undecodable_success\", failure={\"leaf\": \"undecodable_nop\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"opsuccess/undecodable_bypass\", standard=False, tap=tap, leaf=\"undecodable_success\", failure={\"leaf\": \"undecodable_bypassed_success\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"opsuccess/bigpush\", standard=False, tap=tap, leaf=\"bigpush_success\", failure={\"leaf\": \"bigpush_nop\"}, **ERR_PUSH_LIMIT)\n+        add_spender(spenders, \"opsuccess/1001push\", standard=False, tap=tap, leaf=\"1001push_success\", failure={\"leaf\": \"1001push_nop\"}, **ERR_STACK_SIZE)\n+        add_spender(spenders, \"opsuccess/1001inputs\", standard=False, tap=tap, leaf=\"bare_success\", inputs=[b'']*1001, failure={\"leaf\": \"bare_nop\"}, **ERR_STACK_SIZE)\n+\n+    # Non-OP_SUCCESSx (verify that those aren't accidentally treated as OP_SUCCESSx)\n+    for opval in range(0, 0x100):\n+        opcode = CScriptOp(opval)\n+        if is_op_success(opcode):\n+            continue\n+        scripts = [\n+            (\"normal\", CScript([OP_RETURN, opcode] + [OP_NOP] * 75)),\n+            (\"op_success\", CScript([OP_RETURN, CScriptOp(0x50)]))\n+        ]\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"alwaysvalid/notsuccessx\", tap=tap, leaf=\"op_success\", inputs=[], standard=False, failure={\"leaf\": \"normal\"}) # err_msg differs based on opcode\n+\n+    # == Legacy tests ==\n+\n+    # Also add a few legacy spends into the mix, so that transactions which combine taproot and pre-taproot spends get tested too.\n+    for compressed in [False, True]:\n+        eckey1 = ECKey()\n+        eckey1.set(generate_privkey(), compressed)\n+        pubkey1 = eckey1.get_pubkey().get_bytes()\n+        eckey2 = ECKey()\n+        eckey2.set(generate_privkey(), compressed)\n+        for p2sh in [False, True]:\n+            for witv0 in [False, True]:\n+                for hashtype in VALID_SIGHASHES_ECDSA + [random.randrange(0x04, 0x80), random.randrange(0x84, 0x100)]:\n+                    standard = (hashtype in VALID_SIGHASHES_ECDSA) and (compressed or not witv0)\n+                    add_spender(spenders, \"legacy/pk-wrongkey\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, script=CScript([pubkey1, OP_CHECKSIG]), **SINGLE_SIG, key=eckey1, failure={\"key\": eckey2}, sigops_weight=4-3*witv0, **ERR_NO_SUCCESS)\n+                    add_spender(spenders, \"legacy/pkh-sighashflip\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, pkh=pubkey1, key=eckey1, **SIGHASH_BITFLIP, sigops_weight=4-3*witv0, **ERR_NO_SUCCESS)\n+\n+    # Verify that OP_CHECKSIGADD wasn't accidentally added to pre-taproot validation logic.\n+    for p2sh in [False, True]:\n+        for witv0 in [False, True]:\n+            for hashtype in VALID_SIGHASHES_ECDSA + [random.randrange(0x04, 0x80), random.randrange(0x84, 0x100)]:\n+                standard = hashtype in VALID_SIGHASHES_ECDSA and (p2sh or witv0)\n+                add_spender(spenders, \"compat/nocsa\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, script=CScript([OP_IF, OP_11, pubkey1, OP_CHECKSIGADD, OP_12, OP_EQUAL, OP_ELSE, pubkey1, OP_CHECKSIG, OP_ENDIF]), key=eckey1, sigops_weight=4-3*witv0, inputs=[getter(\"sign\"), b''], failure={\"inputs\": [getter(\"sign\"), b'\\x01']}, **ERR_UNDECODABLE)\n+\n+    return spenders\n+\n+def spenders_taproot_inactive():\n+    \"\"\"Spenders for testing that pre-activation Taproot rules don't apply.\"\"\"\n+\n+    spenders = []\n+\n+    sec = generate_privkey()\n+    pub, _ = compute_xonly_pubkey(sec)\n+    scripts = [\n+        (\"pk\", CScript([pub, OP_CHECKSIG])),\n+        (\"future_leaf\", CScript([pub, OP_CHECKSIG]), 0xc2),\n+        (\"op_success\", CScript([pub, OP_CHECKSIG, OP_0, OP_IF, CScriptOp(0x50), OP_ENDIF])),\n+    ]\n+    tap = taproot_construct(pub, scripts)\n+\n+    # Test that keypath spending is valid & standard if compliant, but valid and nonstandard otherwise.\n+    add_spender(spenders, \"inactive/keypath_valid\", key=sec, tap=tap)\n+    add_spender(spenders, \"inactive/keypath_invalidsig\", key=sec, tap=tap, standard=False, sighash=bitflipper(default_sighash))\n+    add_spender(spenders, \"inactive/keypath_empty\", key=sec, tap=tap, standard=False, witness=[])\n+\n+    # Same for scriptpath spending (but using future features like annex, leaf versions, or OP_SUCCESS is nonstandard).\n+    add_spender(spenders, \"inactive/scriptpath_valid\", key=sec, tap=tap, leaf=\"pk\", inputs=[getter(\"sign\")])\n+    add_spender(spenders, \"inactive/scriptpath_invalidsig\", key=sec, tap=tap, leaf=\"pk\", standard=False, inputs=[getter(\"sign\")], sighash=bitflipper(default_sighash))\n+    add_spender(spenders, \"inactive/scriptpath_invalidcb\", key=sec, tap=tap, leaf=\"pk\", standard=False, inputs=[getter(\"sign\")], controlblock=bitflipper(default_controlblock))\n+    add_spender(spenders, \"inactive/scriptpath_valid_unkleaf\", key=sec, tap=tap, leaf=\"future_leaf\", standard=False, inputs=[getter(\"sign\")])\n+    add_spender(spenders, \"inactive/scriptpath_invalid_unkleaf\", key=sec, tap=tap, leaf=\"future_leaf\", standard=False, inputs=[getter(\"sign\")], sighash=bitflipper(default_sighash))\n+    add_spender(spenders, \"inactive/scriptpath_valid_opsuccess\", key=sec, tap=tap, leaf=\"op_success\", standard=False, inputs=[getter(\"sign\")])\n+    add_spender(spenders, \"inactive/scriptpath_valid_opsuccess\", key=sec, tap=tap, leaf=\"op_success\", standard=False, inputs=[getter(\"sign\")], sighash=bitflipper(default_sighash))\n+\n+    return spenders\n+\n+# Data type to keep track of UTXOs, where they were created, and how to spend them.\n+UTXOData = namedtuple('UTXOData', 'outpoint,output,spender')\n+\n+class TaprootTest(BitcoinTestFramework):\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.setup_clean_chain = True\n+        # Node 0 has Taproot inactive, Node 1 active.\n+        self.extra_args = [[\"-whitelist=127.0.0.1\", \"-par=1\", \"-vbparams=taproot:1:1\"], [\"-whitelist=127.0.0.1\", \"-par=1\"]]",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509664858",
      "id" : 509664858,
      "in_reply_to_id" : 509400019,
      "line" : 1202,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY2NDg1OA==",
      "original_commit_id" : "f06e6d03452cf5e0b1a0863afb08c9e6d3ef452e",
      "original_line" : 1157,
      "original_position" : 1157,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : 1202,
      "pull_request_review_id" : 514157064,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-21T20:24:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509664858",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509666184"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509666184"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I probably copied it from somewhere \\\\_()_/\r\n\r\nFixed in #20207.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-21T20:25:48Z",
      "diff_hunk" : "@@ -0,0 +1,1411 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expression for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        return tweak_add_privkey(key, tweak)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    scriptsig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    witness_stack = flatten(get(ctx, \"witness\"))\n+    return (scriptsig, witness_stack)\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda returning (scriptsig, witness_stack), taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+# - Whether this test demands being placed in a txin with no corresponding txout (for testing SIGHASH_SINGLE behavior)\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail,need_vin_vout_mismatch\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, need_vin_vout_mismatch=False, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert tap is None\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert script is None\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert script is None\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert script is None\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            return spend(tx, idx, utxos, **conf)\n+        else:\n+            assert failure is not None\n+            return spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None, need_vin_vout_mismatch=need_vin_vout_mismatch)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    return bytes(CScript([pubkey, OP_CHECKSIG]))\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+def zero_appender(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a zero added.\"\"\"\n+    return lambda ctx: deep_eval(ctx, expr) + b\"\\x00\"\n+\n+def byte_popper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with its last byte removed.\"\"\"\n+    return lambda ctx: deep_eval(ctx, expr)[:-1]\n+\n+# Expected error strings\n+\n+ERR_SIG_SIZE = {\"err_msg\": \"Invalid Schnorr signature size\"}\n+ERR_SIG_HASHTYPE = {\"err_msg\": \"Invalid Schnorr signature hash type\"}\n+ERR_SIG_SCHNORR = {\"err_msg\": \"Invalid Schnorr signature\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_TAPSCRIPT_CHECKMULTISIG = {\"err_msg\": \"OP_CHECKMULTISIG(VERIFY) is not available in tapscript\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal in tapscript\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Stack size must be exactly one after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+ERR_CHECKSIGVERIFY = {\"err_msg\": \"Script failed an OP_CHECKSIGVERIFY operation\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+VALID_SIGHASHES_TAPROOT_SINGLE = [\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT_NO_SINGLE = [h for h in VALID_SIGHASHES_TAPROOT if h not in VALID_SIGHASHES_TAPROOT_SINGLE]\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SIG_POP_BYTE = {\"failure\": {\"sign\": byte_popper(default_sign)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+SIG_ADD_ZERO = {\"failure\": {\"sign\": zero_appender(default_sign)}}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 50000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    secs = [generate_privkey() for _ in range(8)]\n+    pubs = [compute_xonly_pubkey(sec)[0] for sec in secs]\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    tap = taproot_construct(pubs[0])\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=secs[0], failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_SIG_SCHNORR)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=secs[0], failure={\"sighash\": bitflipper(default_sighash)}, **ERR_SIG_SCHNORR)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=secs[0], failure={\"flag_flip_r\": True}, **ERR_SIG_SCHNORR)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=secs[0], failure={\"flag_flip_p\": True}, **ERR_SIG_SCHNORR)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=secs[0], failure={\"signature\": bitflipper(default_signature)}, **ERR_SIG_SCHNORR)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pubs[0])\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pubs[1])))]\n+            tap = taproot_construct(pubs[0], scripts)\n+            add_spender(spenders, \"sighash/keypath_hashtype_%x\" % hashtype, tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+            add_spender(spenders, \"sighash/scriptpath_hashtype_%x\" % hashtype, tap=tap, leaf=\"s0\", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+\n+            # Test SIGHASH_SINGLE behavior in combination with mismatching outputs\n+            if hashtype in VALID_SIGHASHES_TAPROOT_SINGLE:\n+                add_spender(spenders, \"sighash/keypath_hashtype_mis_%x\" % hashtype, tap=tap, key=secs[0], annex=annex, standard=no_annex, hashtype_actual=random.choice(VALID_SIGHASHES_TAPROOT_NO_SINGLE), failure={\"hashtype_actual\": hashtype}, **ERR_SIG_HASHTYPE, need_vin_vout_mismatch=True)\n+                add_spender(spenders, \"sighash/scriptpath_hashtype_mis_%x\" % hashtype, tap=tap, leaf=\"s0\", key=secs[1], annex=annex, standard=no_annex, hashtype_actual=random.choice(VALID_SIGHASHES_TAPROOT_NO_SINGLE), **SINGLE_SIG, failure={\"hashtype_actual\": hashtype}, **ERR_SIG_HASHTYPE, need_vin_vout_mismatch=True)\n+\n+        # Test OP_CODESEPARATOR impact on sighashing.\n+        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+        common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+        scripts = [\n+            (\"pk_codesep\", CScript(random_checksig_style(pubs[1]) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig\n+            (\"codesep_pk\", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pubs[1]))),  # codesep before checksig\n+            (\"branched_codesep\", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pubs[0], OP_ELSE, OP_CODESEPARATOR, pubs[1], OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"sighash/pk_codesep\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+        add_spender(spenders, \"sighash/codesep_pk\", tap=tap, leaf=\"codesep_pk\", key=secs[1], codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+        add_spender(spenders, \"sighash/branched_codesep/left\", tap=tap, leaf=\"branched_codesep\", key=secs[0], codeseppos=3, **common, inputs=[getter(\"sign\"), b'\\x01'], **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+        add_spender(spenders, \"sighash/branched_codesep/right\", tap=tap, leaf=\"branched_codesep\", key=secs[1], codeseppos=6, **common, inputs=[getter(\"sign\"), b''], **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+\n+    # Reusing the scripts above, test that various features affect the sighash.\n+    add_spender(spenders, \"sighash/annex\", tap=tap, leaf=\"pk_codesep\", key=secs[1], hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={\"sighash\": override(default_sighash, annex=None)}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/script\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, script_taproot=tap.leaves[\"codesep_pk\"].script)}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/leafver\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leafversion=random.choice([x & 0xFE for x in range(0x100) if x & 0xFE != 0xC0]))}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leaf=None)}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/keypath\", tap=tap, key=secs[0], **common, failure={\"sighash\": override(default_sighash, leaf=\"pk_codesep\")}, **ERR_SIG_SCHNORR)\n+\n+    # Test that invalid hashtypes don't work, both in key path and script path spends\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for invalid_hashtype in [x for x in range(0x100) if x not in VALID_SIGHASHES_TAPROOT]:\n+        add_spender(spenders, \"sighash/keypath_unk_hashtype_%x\" % invalid_hashtype, tap=tap, key=secs[0], hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_SIG_HASHTYPE)\n+        add_spender(spenders, \"sighash/scriptpath_unk_hashtype_%x\" % invalid_hashtype, tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_SIG_HASHTYPE)\n+\n+    # Test that hashtype 0 cannot have a hashtype byte, and 1 must have one.\n+    add_spender(spenders, \"sighash/hashtype0_byte_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_SIG_HASHTYPE)\n+    add_spender(spenders, \"sighash/hashtype0_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_SIG_HASHTYPE)\n+    add_spender(spenders, \"sighash/hashtype1_byte_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/hashtype1_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SIG_SCHNORR)\n+    # Test that hashtype 0 and hashtype 1 cannot be transmuted into each other.\n+    add_spender(spenders, \"sighash/hashtype0to1_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/hashtype0to1_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/hashtype1to0_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/hashtype1to0_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SIG_SCHNORR)\n+\n+    # Test aspects of signatures with unusual lengths\n+    for hashtype in [SIGHASH_DEFAULT, random.choice(VALID_SIGHASHES_TAPROOT)]:\n+        scripts = [\n+            (\"csv\", CScript([pubs[2], OP_CHECKSIGVERIFY, OP_1])),\n+            (\"cs_pos\", CScript([pubs[2], OP_CHECKSIG])),\n+            (\"csa_pos\", CScript([OP_0, pubs[2], OP_CHECKSIGADD, OP_1, OP_EQUAL])),\n+            (\"cs_neg\", CScript([pubs[2], OP_CHECKSIG, OP_NOT])),\n+            (\"csa_neg\", CScript([OP_2, pubs[2], OP_CHECKSIGADD, OP_2, OP_EQUAL]))\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[3], scripts)\n+        # Empty signatures\n+        add_spender(spenders, \"siglen/empty_keypath\", tap=tap, key=secs[3], hashtype=hashtype, failure={\"sign\": b\"\"}, **ERR_SIG_SIZE)\n+        add_spender(spenders, \"siglen/empty_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_CHECKSIGVERIFY)\n+        add_spender(spenders, \"siglen/empty_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_NO_SUCCESS)\n+        add_spender(spenders, \"siglen/empty_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_NO_SUCCESS)\n+        add_spender(spenders, \"siglen/empty_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": lambda _: random_bytes(random.randrange(1, 63))}, **ERR_SIG_SIZE)\n+        add_spender(spenders, \"siglen/empty_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": lambda _: random_bytes(random.randrange(66, 100))}, **ERR_SIG_SIZE)\n+        # Appending a zero byte to signatures invalidates them\n+        add_spender(spenders, \"siglen/padzero_keypath\", tap=tap, key=secs[3], hashtype=hashtype, **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        add_spender(spenders, \"siglen/padzero_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        add_spender(spenders, \"siglen/padzero_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        add_spender(spenders, \"siglen/padzero_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        add_spender(spenders, \"siglen/padzero_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        add_spender(spenders, \"siglen/padzero_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        # Removing the last byte from signatures invalidates them\n+        add_spender(spenders, \"siglen/popbyte_keypath\", tap=tap, key=secs[3], hashtype=hashtype, **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        add_spender(spenders, \"siglen/popbyte_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        add_spender(spenders, \"siglen/popbyte_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        add_spender(spenders, \"siglen/popbyte_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        add_spender(spenders, \"siglen/popbyte_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        add_spender(spenders, \"siglen/popbyte_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        # Verify that an invalid signature is not allowed, not even when the CHECKSIG* is expected to fail.\n+        add_spender(spenders, \"siglen/invalid_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": default_sign, \"sighash\": bitflipper(default_sighash)}, **ERR_SIG_SCHNORR)\n+        add_spender(spenders, \"siglen/invalid_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": default_sign, \"sighash\": bitflipper(default_sighash)}, **ERR_SIG_SCHNORR)\n+\n+    # == Test that BIP341 spending only applies to witness version 1, program length 32, no P2SH ==\n+\n+    for p2sh in [False, True]:\n+        for witver in range(1, 17):\n+            for witlen in [20, 31, 32, 33]:\n+                def mutate(spk):\n+                    prog = spk[2:]\n+                    assert len(prog) == 32\n+                    if witlen < 32:\n+                        prog = prog[0:witlen]\n+                    elif witlen > 32:\n+                        prog += bytes([0 for _ in range(witlen - 32)])\n+                    return CScript([CScriptOp.encode_op_n(witver), prog])\n+                scripts = [(\"s0\", CScript([pubs[0], OP_CHECKSIG])), (\"dummy\", CScript([OP_RETURN]))]\n+                tap = taproot_construct(pubs[1], scripts)\n+                if not p2sh and witver == 1 and witlen == 32:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, failure={\"leaf\": \"dummy\"}, **ERR_OP_RETURN)\n+                else:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], standard=False)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, standard=False)\n+\n+    # == Test various aspects of BIP341 spending paths ==\n+\n+    # A set of functions that compute the hashing partner in a Merkle tree, designed to exercise\n+    # edge cases. This relies on the taproot_construct feature that a lambda can be passed in\n+    # instead of a subtree, to compute the partner to be hashed with.\n+    PARTNER_MERKLE_FN = [\n+        # Combine with itself\n+        lambda h: h,\n+        # Combine with hash 0\n+        lambda h: bytes([0 for _ in range(32)]),\n+        # Combine with hash 2^256-1\n+        lambda h: bytes([0xff for _ in range(32)]),\n+        # Combine with itself-1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') + 1).to_bytes(32, 'big'),\n+        # Combine with itself-1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') + 1).to_bytes(32, 'little'),\n+        # Combine with random bitflipped version of self.\n+        lambda h: (int.from_bytes(h, 'little') ^ (1 << random.randrange(256))).to_bytes(32, 'little')\n+    ]\n+    # Start with a tree of that has depth 1 for \"128deep\" and depth 2 for \"129deep\".\n+    scripts = [(\"128deep\", CScript([pubs[0], OP_CHECKSIG])), [(\"129deep\", CScript([pubs[0], OP_CHECKSIG])), random.choice(PARTNER_MERKLE_FN)]]\n+    # Add 127 nodes on top of that tree, so that \"128deep\" and \"129deep\" end up at their designated depths.\n+    for _ in range(127):\n+        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+    tap = taproot_construct(pubs[0], scripts)\n+    # Test that spends with a depth of 128 work, but 129 doesn't (even with a tree with weird Merkle branches in it).\n+    add_spender(spenders, \"spendpath/merklelimit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"leaf\": \"129deep\"}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that flipping the negation bit invalidates spends.\n+    add_spender(spenders, \"spendpath/negflag\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"negflag\": lambda ctx: 1 - default_negflag(ctx)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the Merkle branch invalidate it.\n+    add_spender(spenders, \"spendpath/bitflipmerkle\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"merklebranch\": bitflipper(default_merklebranch)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the inner pubkey invalidate it.\n+    add_spender(spenders, \"spendpath/bitflippubkey\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"pubkey_inner\": bitflipper(default_pubkey_inner)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that empty witnesses are invalid.\n+    add_spender(spenders, \"spendpath/emptywit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"witness\": []}, **ERR_EMPTY_WITNESS)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padlongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/trunclongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    scripts = [(\"s\", CScript([pubs[0], OP_CHECKSIG]))]\n+    tap = taproot_construct(pubs[1], scripts)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/truncshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block to 1 byte (\"-1 Merkle length\") invalidates it\n+    add_spender(spenders, \"spendpath/trunc1shortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:1]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    # == Test BIP342 edge cases ==\n+\n+    csa_low_val = random.randrange(0, 17) # Within range for OP_n\n+    csa_low_result = csa_low_val + 1\n+\n+    csa_high_val = random.randrange(17, 100) if random.getrandbits(1) else random.randrange(-100, -1) # Outside OP_n range\n+    csa_high_result = csa_high_val + 1\n+\n+    OVERSIZE_NUMBER = 2**31\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER))), 6)\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER-1))), 5)\n+\n+    big_choices = []\n+    big_scriptops = []\n+    for i in range(1000):\n+        r = random.randrange(len(pubs))\n+        big_choices.append(r)\n+        big_scriptops += [pubs[r], OP_CHECKSIGVERIFY]\n+\n+\n+    def big_spend_inputs(ctx):\n+        \"\"\"Helper function to construct the script input for t33/t34 below.\"\"\"\n+        # Instead of signing 999 times, precompute signatures for every (key, hashtype) combination\n+        sigs = {}\n+        for ht in VALID_SIGHASHES_TAPROOT:\n+            for k in range(len(pubs)):\n+                sigs[(k, ht)] = override(default_sign, hashtype=ht, key=secs[k])(ctx)\n+        num = get(ctx, \"num\")\n+        return [sigs[(big_choices[i], random.choice(VALID_SIGHASHES_TAPROOT))] for i in range(num - 1, -1, -1)]\n+\n+    # Various BIP342 features\n+    scripts = [\n+        # 0) drop stack element and OP_CHECKSIG\n+        (\"t0\", CScript([OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 1) normal OP_CHECKSIG\n+        (\"t1\", CScript([pubs[1], OP_CHECKSIG])),\n+        # 2) normal OP_CHECKSIGVERIFY\n+        (\"t2\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1])),\n+        # 3) Hypothetical OP_CHECKMULTISIG script that takes a single sig as input\n+        (\"t3\", CScript([OP_0, OP_SWAP, OP_1, pubs[1], OP_1, OP_CHECKMULTISIG])),\n+        # 4) Hypothetical OP_CHECKMULTISIGVERIFY script that takes a single sig as input\n+        (\"t4\", CScript([OP_0, OP_SWAP, OP_1, pubs[1], OP_1, OP_CHECKMULTISIGVERIFY, OP_1])),\n+        # 5) OP_IF script that needs a true input\n+        (\"t5\", CScript([OP_IF, pubs[1], OP_CHECKSIG, OP_ELSE, OP_RETURN, OP_ENDIF])),\n+        # 6) OP_NOTIF script that needs a true input\n+        (\"t6\", CScript([OP_NOTIF, OP_RETURN, OP_ELSE, pubs[1], OP_CHECKSIG, OP_ENDIF])),\n+        # 7) OP_CHECKSIG with an empty key\n+        (\"t7\", CScript([OP_0, OP_CHECKSIG])),\n+        # 8) OP_CHECKSIGVERIFY with an empty key\n+        (\"t8\", CScript([OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 9) normal OP_CHECKSIGADD that also ensures return value is correct\n+        (\"t9\", CScript([csa_low_val, pubs[1], OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 10) OP_CHECKSIGADD with empty key\n+        (\"t10\", CScript([csa_low_val, OP_0, OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 11) OP_CHECKSIGADD with missing counter stack element\n+        (\"t11\", CScript([pubs[1], OP_CHECKSIGADD, OP_1, OP_EQUAL])),\n+        # 12) OP_CHECKSIG that needs invalid signature\n+        (\"t12\", CScript([pubs[1], OP_CHECKSIGVERIFY, pubs[0], OP_CHECKSIG, OP_NOT])),\n+        # 13) OP_CHECKSIG with empty key that needs invalid signature\n+        (\"t13\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_CHECKSIG, OP_NOT])),\n+        # 14) OP_CHECKSIGADD that needs invalid signature\n+        (\"t14\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, pubs[0], OP_CHECKSIGADD, OP_NOT])),\n+        # 15) OP_CHECKSIGADD with empty key that needs invalid signature\n+        (\"t15\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGADD, OP_NOT])),\n+        # 16) OP_CHECKSIG with unknown pubkey type\n+        (\"t16\", CScript([OP_1, OP_CHECKSIG])),\n+        # 17) OP_CHECKSIGADD with unknown pubkey type\n+        (\"t17\", CScript([OP_0, OP_1, OP_CHECKSIGADD])),\n+        # 18) OP_CHECKSIGVERIFY with unknown pubkey type\n+        (\"t18\", CScript([OP_1, OP_CHECKSIGVERIFY, OP_1])),\n+        # 19) script longer than 10000 bytes and over 201 non-push opcodes\n+        (\"t19\", CScript([OP_0, OP_0, OP_2DROP] * 10001 + [pubs[1], OP_CHECKSIG])),\n+        # 20) OP_CHECKSIGVERIFY with empty key\n+        (\"t20\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 21) Script that grows the stack to 1000 elements\n+        (\"t21\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 999 + [OP_DROP] * 999)),\n+        # 22) Script that grows the stack to 1001 elements\n+        (\"t22\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 1000 + [OP_DROP] * 1000)),\n+        # 23) Script that expects an input stack of 1000 elements\n+        (\"t23\", CScript([OP_DROP] * 999 + [pubs[1], OP_CHECKSIG])),\n+        # 24) Script that expects an input stack of 1001 elements\n+        (\"t24\", CScript([OP_DROP] * 1000 + [pubs[1], OP_CHECKSIG])),\n+        # 25) Script that pushes a MAX_SCRIPT_ELEMENT_SIZE-bytes element\n+        (\"t25\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE), OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 26) Script that pushes a (MAX_SCRIPT_ELEMENT_SIZE+1)-bytes element\n+        (\"t26\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 27) CHECKSIGADD that must fail because numeric argument number is >4 bytes\n+        (\"t27\", CScript([CScriptNum(OVERSIZE_NUMBER), pubs[1], OP_CHECKSIGADD])),\n+        # 28) Pushes random CScriptNum value, checks OP_CHECKSIGADD result\n+        (\"t28\", CScript([csa_high_val, pubs[1], OP_CHECKSIGADD, csa_high_result, OP_EQUAL])),\n+        # 29) CHECKSIGADD that succeeds with proper sig because numeric argument number is <=4 bytes\n+        (\"t29\", CScript([CScriptNum(OVERSIZE_NUMBER-1), pubs[1], OP_CHECKSIGADD])),\n+        # 30) Variant of t1 with \"normal\" 33-byte pubkey\n+        (\"t30\", CScript([b'\\x03' + pubs[1], OP_CHECKSIG])),\n+        # 31) Variant of t2 with \"normal\" 33-byte pubkey\n+        (\"t31\", CScript([b'\\x02' + pubs[1], OP_CHECKSIGVERIFY, OP_1])),\n+        # 32) Variant of t28 with \"normal\" 33-byte pubkey\n+        (\"t32\", CScript([csa_high_val, b'\\x03' + pubs[1], OP_CHECKSIGADD, csa_high_result, OP_EQUAL])),\n+        # 33) 999-of-999 multisig\n+        (\"t33\", CScript(big_scriptops[:1998] + [OP_1])),\n+        # 34) 1000-of-1000 multisig\n+        (\"t34\", CScript(big_scriptops[:2000] + [OP_1])),\n+        # 35) Variant of t9 that uses a non-minimally encoded input arg\n+        (\"t35\", CScript([bytes([csa_low_val]), pubs[1], OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 36) Empty script\n+        (\"t36\", CScript([])),\n+    ]\n+    # Add many dummies to test huge trees\n+    for j in range(100000):\n+        scripts.append((None, CScript([OP_RETURN, random.randrange(100000)])))\n+    random.shuffle(scripts)\n+    tap = taproot_construct(pubs[0], scripts)\n+    common = {\n+        \"hashtype\": hashtype,\n+        \"key\": secs[1],\n+        \"tap\": tap,\n+    }\n+    # Test that MAX_SCRIPT_ELEMENT_SIZE byte stack element inputs are valid, but not one more (and 80 bytes is standard but 81 is not).\n+    add_spender(spenders, \"tapscript/inputmaxlimit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE)], failure={\"inputs\": [getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1)]}, **ERR_PUSH_LIMIT)\n+    add_spender(spenders, \"tapscript/input80limit\", leaf=\"t0\", **common, inputs=[getter(\"sign\"), random_bytes(80)])\n+    add_spender(spenders, \"tapscript/input81limit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(81)])\n+    # Test that OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY cause failure, but OP_CHECKSIG and OP_CHECKSIGVERIFY work.\n+    add_spender(spenders, \"tapscript/disabled_checkmultisig\", leaf=\"t1\", **common, **SINGLE_SIG, failure={\"leaf\": \"t3\"}, **ERR_TAPSCRIPT_CHECKMULTISIG)\n+    add_spender(spenders, \"tapscript/disabled_checkmultisigverify\", leaf=\"t2\", **common, **SINGLE_SIG, failure={\"leaf\": \"t4\"}, **ERR_TAPSCRIPT_CHECKMULTISIG)\n+    # Test that OP_IF and OP_NOTIF do not accept non-0x01 as truth value (the MINIMALIF rule is consensus in Tapscript)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x02']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x03']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0001']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0100']}, **ERR_MINIMALIF)\n+    # Test that 1-byte public keys (which are unknown) are acceptable but nonstandard with unrelated signatures, but 0-byte public keys are not valid.\n+    add_spender(spenders, \"tapscript/unkpk/checksig\", leaf=\"t16\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigadd\", leaf=\"t17\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigverify\", leaf=\"t18\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that 33-byte public keys (which are unknown) are acceptable but nonstandard with valid signatures, but normal pubkeys are not valid in that case.\n+    add_spender(spenders, \"tapscript/oldpk/checksig\", leaf=\"t30\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t1\"}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"tapscript/oldpk/checksigadd\", leaf=\"t31\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t2\"}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"tapscript/oldpk/checksigverify\", leaf=\"t32\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t28\"}, **ERR_SIG_SCHNORR)\n+    # Test that 0-byte public keys are not acceptable.\n+    add_spender(spenders, \"tapscript/emptypk/checksig\", leaf=\"t1\", **SINGLE_SIG, **common, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigverify\", leaf=\"t2\", **SINGLE_SIG, **common, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigadd\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigadd\", leaf=\"t35\", standard=False, **SINGLE_SIG, **common, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that OP_CHECKSIGADD results are as expected\n+    add_spender(spenders, \"tapscript/checksigaddresults\", leaf=\"t28\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    add_spender(spenders, \"tapscript/checksigaddoversize\", leaf=\"t29\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    # Test that OP_CHECKSIGADD requires 3 stack elements.\n+    add_spender(spenders, \"tapscript/checksigadd3args\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t11\"}, **ERR_STACK_EMPTY)\n+    # Test that empty signatures do not cause script failure in OP_CHECKSIG and OP_CHECKSIGADD (but do fail with empty pubkey, and do fail OP_CHECKSIGVERIFY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksig\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t13\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/nochecksigverify\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t20\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksigadd\", leaf=\"t14\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t15\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that scripts over 10000 bytes (and over 201 non-push ops) are acceptable.\n+    add_spender(spenders, \"tapscript/no10000limit\", leaf=\"t19\", **SINGLE_SIG, **common)\n+    # Test that a stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000stack\", leaf=\"t21\", **SINGLE_SIG, **common, failure={\"leaf\": \"t22\"}, **ERR_STACK_SIZE)\n+    # Test that an input stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000inputs\", leaf=\"t23\", **common, inputs=[getter(\"sign\")] + [b'' for _ in range(999)], failure={\"leaf\": \"t24\", \"inputs\": [getter(\"sign\")] + [b'' for _ in range(1000)]}, **ERR_STACK_SIZE)\n+    # Test that pushing a MAX_SCRIPT_ELEMENT_SIZE byte stack element is valid, but one longer is not.\n+    add_spender(spenders, \"tapscript/pushmaxlimit\", leaf=\"t25\", **common, **SINGLE_SIG, failure={\"leaf\": \"t26\"}, **ERR_PUSH_LIMIT)\n+    # Test that 999-of-999 multisig works (but 1000-of-1000 triggers stack size limits)\n+    add_spender(spenders, \"tapscript/bigmulti\", leaf=\"t33\", **common, inputs=big_spend_inputs, num=999, failure={\"leaf\": \"t34\", \"num\": 1000}, **ERR_STACK_SIZE)\n+    # Test that the CLEANSTACK rule is consensus critical in tapscript\n+    add_spender(spenders, \"tapscript/cleanstack\", leaf=\"t36\", tap=tap, inputs=[b'\\x01'], failure={\"inputs\": [b'\\x01', b'\\x01']}, **ERR_CLEANSTACK)\n+\n+    # == Test for sigops ratio limit ==\n+\n+    # Given a number n, and a public key pk, functions that produce a (CScript, sigops). Each script takes as\n+    # input a valid signature with the passed pk followed by a dummy push of bytes that are to be dropped, and\n+    # will execute sigops signature checks.\n+    SIGOPS_RATIO_SCRIPTS = [\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIG.\n+        lambda n, pk: (CScript([OP_DROP, pk] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGVERIFY.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_0, OP_IF, OP_2DUP, OP_CHECKSIGVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_2, OP_SWAP, OP_CHECKSIGADD, OP_3, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIG.\n+        lambda n, pk: (CScript([random_bytes(220), OP_2DROP, pk, OP_1, OP_NOTIF, OP_2DUP, OP_CHECKSIG, OP_VERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_4, OP_SWAP, OP_CHECKSIGADD, OP_5, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGADD.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_1, OP_IF, OP_ELSE, OP_2DUP, OP_6, OP_SWAP, OP_CHECKSIGADD, OP_7, OP_EQUALVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_8, OP_SWAP, OP_CHECKSIGADD, OP_9, OP_EQUAL]), n + 1),\n+        # n+1 OP_CHECKSIGs, but also one OP_CHECKSIG with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, pk, OP_CHECKSIG, OP_NOT, OP_VERIFY, pk] + [OP_2DUP, OP_CHECKSIG, OP_VERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGADDs and 1 OP_CHECKSIG, but also an OP_CHECKSIGADD with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, OP_10, pk, OP_CHECKSIGADD, OP_10, OP_EQUALVERIFY, pk] + [OP_2DUP, OP_16, OP_SWAP, OP_CHECKSIGADD, b'\\x11', OP_EQUALVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+    ]\n+    for annex in [None, bytes([ANNEX_TAG]) + random_bytes(random.randrange(1000))]:\n+        for hashtype in [SIGHASH_DEFAULT, SIGHASH_ALL]:\n+            for pubkey in [pubs[1], random_bytes(random.choice([x for x in range(2, 81) if x != 32]))]:\n+                for fn_num, fn in enumerate(SIGOPS_RATIO_SCRIPTS):\n+                    merkledepth = random.randrange(129)\n+\n+\n+                    def predict_sigops_ratio(n, dummy_size):\n+                        \"\"\"Predict whether spending fn(n, pubkey) with dummy_size will pass the ratio test.\"\"\"\n+                        script, sigops = fn(n, pubkey)\n+                        # Predict the size of the witness for a given choice of n\n+                        stacklen_size = 1\n+                        sig_size = 64 + (hashtype != SIGHASH_DEFAULT)\n+                        siglen_size = 1\n+                        dummylen_size = 1 + 2 * (dummy_size >= 253)\n+                        script_size = len(script)\n+                        scriptlen_size = 1 + 2 * (script_size >= 253)\n+                        control_size = 33 + 32 * merkledepth\n+                        controllen_size = 1 + 2 * (control_size >= 253)\n+                        annex_size = 0 if annex is None else len(annex)\n+                        annexlen_size = 0 if annex is None else 1 + 2 * (annex_size >= 253)\n+                        witsize = stacklen_size + sig_size + siglen_size + dummy_size + dummylen_size + script_size + scriptlen_size + control_size + controllen_size + annex_size + annexlen_size\n+                        # sigops ratio test\n+                        return witsize + 50 >= 50 * sigops\n+                    # Make sure n is high enough that with empty dummy, the script is not valid\n+                    n = 0\n+                    while predict_sigops_ratio(n, 0):\n+                        n += 1\n+                    # But allow picking a bit higher still\n+                    n += random.randrange(5)\n+                    # Now pick dummy size *just* large enough that the overall construction passes\n+                    dummylen = 0\n+                    while not predict_sigops_ratio(n, dummylen):\n+                        dummylen += 1\n+                    scripts = [(\"s\", fn(n, pubkey)[0])]\n+                    for _ in range(merkledepth):\n+                        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+                    tap = taproot_construct(pubs[0], scripts)\n+                    standard = annex is None and dummylen <= 80 and len(pubkey) == 32\n+                    add_spender(spenders, \"tapscript/sigopsratio_%i\" % fn_num, tap=tap, leaf=\"s\", annex=annex, hashtype=hashtype, key=secs[1], inputs=[getter(\"sign\"), random_bytes(dummylen)], standard=standard, failure={\"inputs\": [getter(\"sign\"), random_bytes(dummylen - 1)]}, **ERR_SIGOPS_RATIO)\n+\n+    # Future leaf versions\n+    for leafver in range(0, 0x100, 2):\n+        if leafver == LEAF_VERSION_TAPSCRIPT or leafver == ANNEX_TAG:\n+            # Skip the defined LEAF_VERSION_TAPSCRIPT, and the ANNEX_TAG which is not usable as leaf version\n+            continue\n+        scripts = [\n+            (\"bare_c0\", CScript([OP_NOP])),\n+            (\"bare_unkver\", CScript([OP_NOP]), leafver),\n+            (\"return_c0\", CScript([OP_RETURN])),\n+            (\"return_unkver\", CScript([OP_RETURN]), leafver),\n+            (\"undecodable_c0\", CScript([OP_PUSHDATA1])),\n+            (\"undecodable_unkver\", CScript([OP_PUSHDATA1]), leafver),\n+            (\"bigpush_c0\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP])),\n+            (\"bigpush_unkver\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP]), leafver),\n+            (\"1001push_c0\", CScript([OP_0] * 1001)),\n+            (\"1001push_unkver\", CScript([OP_0] * 1001), leafver),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"unkver/bare\", standard=False, tap=tap, leaf=\"bare_unkver\", failure={\"leaf\": \"bare_c0\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"unkver/return\", standard=False, tap=tap, leaf=\"return_unkver\", failure={\"leaf\": \"return_c0\"}, **ERR_OP_RETURN)\n+        add_spender(spenders, \"unkver/undecodable\", standard=False, tap=tap, leaf=\"undecodable_unkver\", failure={\"leaf\": \"undecodable_c0\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"unkver/bigpush\", standard=False, tap=tap, leaf=\"bigpush_unkver\", failure={\"leaf\": \"bigpush_c0\"}, **ERR_PUSH_LIMIT)\n+        add_spender(spenders, \"unkver/1001push\", standard=False, tap=tap, leaf=\"1001push_unkver\", failure={\"leaf\": \"1001push_c0\"}, **ERR_STACK_SIZE)\n+        add_spender(spenders, \"unkver/1001inputs\", standard=False, tap=tap, leaf=\"bare_unkver\", inputs=[b'']*1001, failure={\"leaf\": \"bare_c0\"}, **ERR_STACK_SIZE)\n+\n+    # OP_SUCCESSx tests.\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for opval in range(76, 0x100):\n+        opcode = CScriptOp(opval)\n+        if not is_op_success(opcode):\n+            continue\n+        scripts = [\n+            (\"bare_success\", CScript([opcode])),\n+            (\"bare_nop\", CScript([OP_NOP])),\n+            (\"unexecif_success\", CScript([OP_0, OP_IF, opcode, OP_ENDIF])),\n+            (\"unexecif_nop\", CScript([OP_0, OP_IF, OP_NOP, OP_ENDIF])),\n+            (\"return_success\", CScript([OP_RETURN, opcode])),\n+            (\"return_nop\", CScript([OP_RETURN, OP_NOP])),\n+            (\"undecodable_success\", CScript([opcode, OP_PUSHDATA1])),\n+            (\"undecodable_nop\", CScript([OP_NOP, OP_PUSHDATA1])),\n+            (\"undecodable_bypassed_success\", CScript([OP_PUSHDATA1, OP_2, opcode])),\n+            (\"bigpush_success\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, opcode])),\n+            (\"bigpush_nop\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, OP_NOP])),\n+            (\"1001push_success\", CScript([OP_0] * 1001 + [opcode])),\n+            (\"1001push_nop\", CScript([OP_0] * 1001 + [OP_NOP])),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"opsuccess/bare\", standard=False, tap=tap, leaf=\"bare_success\", failure={\"leaf\": \"bare_nop\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"opsuccess/unexecif\", standard=False, tap=tap, leaf=\"unexecif_success\", failure={\"leaf\": \"unexecif_nop\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"opsuccess/return\", standard=False, tap=tap, leaf=\"return_success\", failure={\"leaf\": \"return_nop\"}, **ERR_OP_RETURN)\n+        add_spender(spenders, \"opsuccess/undecodable\", standard=False, tap=tap, leaf=\"undecodable_success\", failure={\"leaf\": \"undecodable_nop\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"opsuccess/undecodable_bypass\", standard=False, tap=tap, leaf=\"undecodable_success\", failure={\"leaf\": \"undecodable_bypassed_success\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"opsuccess/bigpush\", standard=False, tap=tap, leaf=\"bigpush_success\", failure={\"leaf\": \"bigpush_nop\"}, **ERR_PUSH_LIMIT)\n+        add_spender(spenders, \"opsuccess/1001push\", standard=False, tap=tap, leaf=\"1001push_success\", failure={\"leaf\": \"1001push_nop\"}, **ERR_STACK_SIZE)\n+        add_spender(spenders, \"opsuccess/1001inputs\", standard=False, tap=tap, leaf=\"bare_success\", inputs=[b'']*1001, failure={\"leaf\": \"bare_nop\"}, **ERR_STACK_SIZE)\n+\n+    # Non-OP_SUCCESSx (verify that those aren't accidentally treated as OP_SUCCESSx)\n+    for opval in range(0, 0x100):\n+        opcode = CScriptOp(opval)\n+        if is_op_success(opcode):\n+            continue\n+        scripts = [\n+            (\"normal\", CScript([OP_RETURN, opcode] + [OP_NOP] * 75)),\n+            (\"op_success\", CScript([OP_RETURN, CScriptOp(0x50)]))\n+        ]\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"alwaysvalid/notsuccessx\", tap=tap, leaf=\"op_success\", inputs=[], standard=False, failure={\"leaf\": \"normal\"}) # err_msg differs based on opcode\n+\n+    # == Legacy tests ==\n+\n+    # Also add a few legacy spends into the mix, so that transactions which combine taproot and pre-taproot spends get tested too.\n+    for compressed in [False, True]:\n+        eckey1 = ECKey()\n+        eckey1.set(generate_privkey(), compressed)\n+        pubkey1 = eckey1.get_pubkey().get_bytes()\n+        eckey2 = ECKey()\n+        eckey2.set(generate_privkey(), compressed)\n+        for p2sh in [False, True]:\n+            for witv0 in [False, True]:\n+                for hashtype in VALID_SIGHASHES_ECDSA + [random.randrange(0x04, 0x80), random.randrange(0x84, 0x100)]:\n+                    standard = (hashtype in VALID_SIGHASHES_ECDSA) and (compressed or not witv0)\n+                    add_spender(spenders, \"legacy/pk-wrongkey\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, script=CScript([pubkey1, OP_CHECKSIG]), **SINGLE_SIG, key=eckey1, failure={\"key\": eckey2}, sigops_weight=4-3*witv0, **ERR_NO_SUCCESS)\n+                    add_spender(spenders, \"legacy/pkh-sighashflip\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, pkh=pubkey1, key=eckey1, **SIGHASH_BITFLIP, sigops_weight=4-3*witv0, **ERR_NO_SUCCESS)\n+\n+    # Verify that OP_CHECKSIGADD wasn't accidentally added to pre-taproot validation logic.\n+    for p2sh in [False, True]:\n+        for witv0 in [False, True]:\n+            for hashtype in VALID_SIGHASHES_ECDSA + [random.randrange(0x04, 0x80), random.randrange(0x84, 0x100)]:\n+                standard = hashtype in VALID_SIGHASHES_ECDSA and (p2sh or witv0)\n+                add_spender(spenders, \"compat/nocsa\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, script=CScript([OP_IF, OP_11, pubkey1, OP_CHECKSIGADD, OP_12, OP_EQUAL, OP_ELSE, pubkey1, OP_CHECKSIG, OP_ENDIF]), key=eckey1, sigops_weight=4-3*witv0, inputs=[getter(\"sign\"), b''], failure={\"inputs\": [getter(\"sign\"), b'\\x01']}, **ERR_UNDECODABLE)\n+\n+    return spenders\n+\n+def spenders_taproot_inactive():\n+    \"\"\"Spenders for testing that pre-activation Taproot rules don't apply.\"\"\"\n+\n+    spenders = []\n+\n+    sec = generate_privkey()\n+    pub, _ = compute_xonly_pubkey(sec)\n+    scripts = [\n+        (\"pk\", CScript([pub, OP_CHECKSIG])),\n+        (\"future_leaf\", CScript([pub, OP_CHECKSIG]), 0xc2),\n+        (\"op_success\", CScript([pub, OP_CHECKSIG, OP_0, OP_IF, CScriptOp(0x50), OP_ENDIF])),\n+    ]\n+    tap = taproot_construct(pub, scripts)\n+\n+    # Test that keypath spending is valid & standard if compliant, but valid and nonstandard otherwise.\n+    add_spender(spenders, \"inactive/keypath_valid\", key=sec, tap=tap)\n+    add_spender(spenders, \"inactive/keypath_invalidsig\", key=sec, tap=tap, standard=False, sighash=bitflipper(default_sighash))\n+    add_spender(spenders, \"inactive/keypath_empty\", key=sec, tap=tap, standard=False, witness=[])\n+\n+    # Same for scriptpath spending (but using future features like annex, leaf versions, or OP_SUCCESS is nonstandard).\n+    add_spender(spenders, \"inactive/scriptpath_valid\", key=sec, tap=tap, leaf=\"pk\", inputs=[getter(\"sign\")])\n+    add_spender(spenders, \"inactive/scriptpath_invalidsig\", key=sec, tap=tap, leaf=\"pk\", standard=False, inputs=[getter(\"sign\")], sighash=bitflipper(default_sighash))\n+    add_spender(spenders, \"inactive/scriptpath_invalidcb\", key=sec, tap=tap, leaf=\"pk\", standard=False, inputs=[getter(\"sign\")], controlblock=bitflipper(default_controlblock))\n+    add_spender(spenders, \"inactive/scriptpath_valid_unkleaf\", key=sec, tap=tap, leaf=\"future_leaf\", standard=False, inputs=[getter(\"sign\")])\n+    add_spender(spenders, \"inactive/scriptpath_invalid_unkleaf\", key=sec, tap=tap, leaf=\"future_leaf\", standard=False, inputs=[getter(\"sign\")], sighash=bitflipper(default_sighash))\n+    add_spender(spenders, \"inactive/scriptpath_valid_opsuccess\", key=sec, tap=tap, leaf=\"op_success\", standard=False, inputs=[getter(\"sign\")])\n+    add_spender(spenders, \"inactive/scriptpath_valid_opsuccess\", key=sec, tap=tap, leaf=\"op_success\", standard=False, inputs=[getter(\"sign\")], sighash=bitflipper(default_sighash))\n+\n+    return spenders\n+\n+# Data type to keep track of UTXOs, where they were created, and how to spend them.\n+UTXOData = namedtuple('UTXOData', 'outpoint,output,spender')\n+\n+class TaprootTest(BitcoinTestFramework):\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.setup_clean_chain = True\n+        # Node 0 has Taproot inactive, Node 1 active.\n+        self.extra_args = [[\"-whitelist=127.0.0.1\", \"-par=1\", \"-vbparams=taproot:1:1\"], [\"-whitelist=127.0.0.1\", \"-par=1\"]]\n+\n+    def block_submit(self, node, txs, msg, err_msg, cb_pubkey=None, fees=0, sigops_weight=0, witness=False, accept=False):\n+\n+        # Deplete block of any non-tapscript sigops using a single additional 0-value coinbase output.\n+        # It is not impossible to fit enough tapscript sigops to hit the old 80k limit without\n+        # busting txin-level limits. We simply have to account for the p2pk outputs in all\n+        # transactions.\n+        extra_output_script = CScript([OP_CHECKSIG]*((MAX_BLOCK_SIGOPS_WEIGHT - sigops_weight) // WITNESS_SCALE_FACTOR))\n+\n+        block = create_block(self.tip, create_coinbase(self.lastblockheight + 1, pubkey=cb_pubkey, extra_output_script=extra_output_script, fees=fees), self.lastblocktime + 1)\n+        block.nVersion = 4\n+        for tx in txs:\n+            tx.rehash()\n+            block.vtx.append(tx)\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        witness and add_witness_commitment(block)\n+        block.rehash()\n+        block.solve()\n+        block_response = node.submitblock(block.serialize(True).hex())\n+        if err_msg is not None:\n+            assert block_response is not None and err_msg in block_response, \"Missing error message '%s' from block response '%s': %s\" % (err_msg, \"(None)\" if block_response is None else block_response, msg)\n+        if (accept):\n+            assert node.getbestblockhash() == block.hash, \"Failed to accept: %s (response: %s)\" % (msg, block_response)\n+            self.tip = block.sha256\n+            self.lastblockhash = block.hash\n+            self.lastblocktime += 1\n+            self.lastblockheight += 1\n+        else:\n+            assert node.getbestblockhash() == self.lastblockhash, \"Failed to reject: \" + msg\n+\n+    def test_spenders(self, node, spenders, input_counts):\n+        \"\"\"Run randomized tests with a number of \"spenders\".\n+\n+        Steps:\n+            1) Generate an appropriate UTXO for each spender to test spend conditions\n+            2) Generate 100 random addresses of all wallet types: pkh/sh_wpkh/wpkh\n+            3) Select random number of inputs from (1)\n+            4) Select random number of addresses from (2) as outputs\n+\n+        Each spender embodies a test; in a large randomized test, it is verified\n+        that toggling the valid argument to each lambda toggles the validity of\n+        the transaction. This is accomplished by constructing transactions consisting\n+        of all valid inputs, except one invalid one.\n+        \"\"\"\n+\n+        # Construct a bunch of sPKs that send coins back to the host wallet\n+        self.log.info(\"- Constructing addresses for returning coins\")\n+        host_spks = []\n+        host_pubkeys = []\n+        for i in range(16):\n+            addr = node.getnewaddress(address_type=random.choice([\"legacy\", \"p2sh-segwit\", \"bech32\"]))\n+            info = node.getaddressinfo(addr)\n+            spk = bytes.fromhex(info['scriptPubKey'])\n+            host_spks.append(spk)\n+            host_pubkeys.append(bytes.fromhex(info['pubkey']))\n+\n+        # Initialize variables used by block_submit().\n+        self.lastblockhash = node.getbestblockhash()\n+        self.tip = int(self.lastblockhash, 16)\n+        block = node.getblock(self.lastblockhash)\n+        self.lastblockheight = block['height']\n+        self.lastblocktime = block['time']\n+\n+        # Create transactions spending up to 50 of the wallet's inputs, with one output for each spender, and\n+        # one change output at the end. The transaction is constructed on the Python side to enable\n+        # having multiple outputs to the same address and outputs with no assigned address. The wallet\n+        # is then asked to sign it through signrawtransactionwithwallet, and then added to a block on the\n+        # Python side (to bypass standardness rules).\n+        self.log.info(\"- Creating test UTXOs...\")\n+        random.shuffle(spenders)\n+        normal_utxos = []\n+        mismatching_utxos = [] # UTXOs with input that requires mismatching output position\n+        done = 0\n+        while done < len(spenders):\n+            # Compute how many UTXOs to create with this transaction\n+            count_this_tx = min(len(spenders) - done, (len(spenders) + 4) // 5, 10000)\n+\n+            fund_tx = CTransaction()\n+            # Add the 50 highest-value inputs\n+            unspents = node.listunspent()\n+            random.shuffle(unspents)\n+            unspents.sort(key=lambda x: int(x[\"amount\"] * 100000000), reverse=True)\n+            if len(unspents) > 50:\n+                unspents = unspents[:50]\n+            random.shuffle(unspents)\n+            balance = 0\n+            for unspent in unspents:\n+                balance += int(unspent[\"amount\"] * 100000000)\n+                txid = int(unspent[\"txid\"], 16)\n+                fund_tx.vin.append(CTxIn(COutPoint(txid, int(unspent[\"vout\"])), CScript()))\n+            # Add outputs\n+            cur_progress = done / len(spenders)\n+            next_progress = (done + count_this_tx) / len(spenders)\n+            change_goal = (1.0 - 0.6 * next_progress) / (1.0 - 0.6 * cur_progress) * balance\n+            self.log.debug(\"Create %i UTXOs in a transaction spending %i inputs worth %.8f (sending ~%.8f to change)\" % (count_this_tx, len(unspents), balance * 0.00000001, change_goal * 0.00000001))\n+            for i in range(count_this_tx):\n+                avg = (balance - change_goal) / (count_this_tx - i)\n+                amount = int(random.randrange(int(avg*0.85 + 0.5), int(avg*1.15 + 0.5)) + 0.5)\n+                balance -= amount\n+                fund_tx.vout.append(CTxOut(amount, spenders[done + i].script))\n+            # Add change\n+            fund_tx.vout.append(CTxOut(balance - 10000, random.choice(host_spks)))\n+            # Ask the wallet to sign\n+            ss = BytesIO(bytes.fromhex(node.signrawtransactionwithwallet(ToHex(fund_tx))[\"hex\"]))\n+            fund_tx.deserialize(ss)\n+            # Construct UTXOData entries\n+            fund_tx.rehash()\n+            for i in range(count_this_tx):\n+                utxodata = UTXOData(outpoint=COutPoint(fund_tx.sha256, i), output=fund_tx.vout[i], spender=spenders[done])\n+                if utxodata.spender.need_vin_vout_mismatch:\n+                    mismatching_utxos.append(utxodata)\n+                else:\n+                    normal_utxos.append(utxodata)\n+                done += 1\n+            # Mine into a block\n+            self.block_submit(node, [fund_tx], \"Funding tx\", None, random.choice(host_pubkeys), 10000, MAX_BLOCK_SIGOPS_WEIGHT, True, True)\n+\n+        # Consume groups of choice(input_coins) from utxos in a tx, testing the spenders.\n+        self.log.info(\"- Running %i spending tests\" % done)\n+        random.shuffle(normal_utxos)\n+        random.shuffle(mismatching_utxos)\n+        assert done == len(normal_utxos) + len(mismatching_utxos)\n+\n+        left = done\n+        while left:\n+            # Construct CTransaction with random nVersion, nLocktime\n+            tx = CTransaction()\n+            tx.nVersion = random.choice([1, 2, random.randint(-0x80000000, 0x7fffffff)])\n+            min_sequence = (tx.nVersion != 1 and tx.nVersion != 0) * 0x80000000  # The minimum sequence number to disable relative locktime\n+            if random.choice([True, False]):\n+                tx.nLockTime = random.randrange(LOCKTIME_THRESHOLD, self.lastblocktime - 7200)  # all absolute locktimes in the past\n+            else:\n+                tx.nLockTime = random.randrange(self.lastblockheight + 1)  # all block heights in the past\n+\n+            # Decide how many UTXOs to test with.\n+            acceptable = [n for n in input_counts if n <= left and (left - n > max(input_counts) or (left - n) in [0] + input_counts)]\n+            num_inputs = random.choice(acceptable)\n+\n+            # If we have UTXOs that require mismatching inputs/outputs left, include exactly one of those\n+            # unless there is only one normal UTXO left (as tests with mismatching UTXOs require at least one\n+            # normal UTXO to go in the first position), and we don't want to run out of normal UTXOs.\n+            input_utxos = []\n+            while len(mismatching_utxos) and (len(input_utxos) == 0 or len(normal_utxos) == 1):\n+                input_utxos.append(mismatching_utxos.pop())\n+                left -= 1\n+\n+            # Top up until we hit num_inputs (but include at least one normal UTXO always).\n+            for _ in range(max(1, num_inputs - len(input_utxos))):\n+                input_utxos.append(normal_utxos.pop())\n+                left -= 1\n+\n+            # The first input cannot require a mismatching output (as there is at least one output).\n+            while True:\n+                random.shuffle(input_utxos)\n+                if not input_utxos[0].spender.need_vin_vout_mismatch:\n+                    break\n+            first_mismatch_input = None\n+            for i in range(len(input_utxos)):\n+                if input_utxos[i].spender.need_vin_vout_mismatch:\n+                    first_mismatch_input = i\n+            assert first_mismatch_input is None or first_mismatch_input > 0\n+\n+            # Decide fee, and add CTxIns to tx.\n+            amount = sum(utxo.output.nValue for utxo in input_utxos)\n+            fee = min(random.randrange(MIN_FEE * 2, MIN_FEE * 4), amount - DUST_LIMIT)  # 10000-20000 sat fee\n+            in_value = amount - fee\n+            tx.vin = [CTxIn(outpoint=utxo.outpoint, nSequence=random.randint(min_sequence, 0xffffffff)) for utxo in input_utxos]\n+            tx.wit.vtxinwit = [CTxInWitness() for _ in range(len(input_utxos))]\n+            sigops_weight = sum(utxo.spender.sigops_weight for utxo in input_utxos)\n+            self.log.debug(\"Test: %s\" % (\", \".join(utxo.spender.comment for utxo in input_utxos)))\n+\n+            # Add 1 to 4 random outputs (but constrained by inputs that require mismatching outputs)\n+            num_outputs = random.choice(range(1, 1 + min(4, 4 if first_mismatch_input is None else first_mismatch_input)))\n+            assert in_value >= 0 and fee - num_outputs * DUST_LIMIT >= MIN_FEE\n+            for i in range(num_outputs):\n+                tx.vout.append(CTxOut())\n+                if in_value <= DUST_LIMIT:\n+                    tx.vout[-1].nValue = DUST_LIMIT\n+                elif i < num_outputs - 1:\n+                    tx.vout[-1].nValue = in_value\n+                else:\n+                    tx.vout[-1].nValue = random.randint(DUST_LIMIT, in_value)\n+                in_value -= tx.vout[-1].nValue\n+                tx.vout[-1].scriptPubKey = random.choice(host_spks)\n+                sigops_weight += CScript(tx.vout[-1].scriptPubKey).GetSigOpCount(False) * WITNESS_SCALE_FACTOR\n+            fee += in_value\n+            assert fee >= 0\n+\n+            # Select coinbase pubkey\n+            cb_pubkey = random.choice(host_pubkeys)\n+            sigops_weight += 1 * WITNESS_SCALE_FACTOR\n+\n+            # Precompute one satisfying and one failing scriptSig/witness for each input.\n+            input_data = []\n+            for i in range(len(input_utxos)):\n+                fn = input_utxos[i].spender.sat_function\n+                fail = None\n+                success = fn(tx, i, [utxo.output for utxo in input_utxos], True)\n+                if not input_utxos[i].spender.no_fail:\n+                    fail = fn(tx, i, [utxo.output for utxo in input_utxos], False)\n+                input_data.append((fail, success))\n+\n+            # Sign each input incorrectly once on each complete signing pass, except the very last.\n+            for fail_input in list(range(len(input_utxos))) + [None]:\n+                # Skip trying to fail at spending something that can't be made to fail.\n+                if fail_input is not None and input_utxos[fail_input].spender.no_fail:\n+                    continue\n+                # Expected message with each input failure, may be None(which is ignored)\n+                expected_fail_msg = None if fail_input is None else input_utxos[fail_input].spender.err_msg\n+                # Fill inputs/witnesses\n+                for i in range(len(input_utxos)):\n+                    tx.vin[i].scriptSig = input_data[i][i != fail_input][0]\n+                    tx.wit.vtxinwit[i].scriptWitness.stack = input_data[i][i != fail_input][1]\n+                # Submit to mempool to check standardness\n+                is_standard_tx = fail_input is None and all(utxo.spender.is_standard for utxo in input_utxos) and tx.nVersion >= 1 and tx.nVersion <= 2\n+                tx.rehash()\n+                msg = ','.join(utxo.spender.comment + (\"*\" if n == fail_input else \"\") for n, utxo in enumerate(input_utxos))\n+                if is_standard_tx:\n+                    node.sendrawtransaction(tx.serialize().hex(), 0)\n+                    assert node.getmempoolentry(tx.hash) is not None, \"Failed to accept into mempool: \" + msg\n+                else:\n+                    assert_raises_rpc_error(-26, None, node.sendrawtransaction, tx.serialize().hex(), 0)\n+                # Submit in a block\n+                self.block_submit(node, [tx], msg, witness=True, accept=fail_input is None, cb_pubkey=cb_pubkey, fees=fee, sigops_weight=sigops_weight, err_msg=expected_fail_msg)\n+\n+            if (len(spenders) - left) // 200 > (len(spenders) - left - len(input_utxos)) // 200:\n+                self.log.info(\"  - %i tests done\" % (len(spenders) - left))\n+\n+        assert left == 0\n+        assert len(normal_utxos) == 0\n+        assert len(mismatching_utxos) == 0\n+        self.log.info(\"  - Done\")\n+\n+    def run_test(self):\n+        self.connect_nodes(0, 1)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509666184",
      "id" : 509666184,
      "in_reply_to_id" : 509400473,
      "line" : 1439,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY2NjE4NA==",
      "original_commit_id" : "f06e6d03452cf5e0b1a0863afb08c9e6d3ef452e",
      "original_line" : 1392,
      "original_position" : 1392,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : 1439,
      "pull_request_review_id" : 514157882,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-21T20:26:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509666184",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509666790"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509666790"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done, in #20207.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-21T20:26:24Z",
      "diff_hunk" : "@@ -1082,6 +1083,12 @@ test_fuzz_script_interpreter_LDADD = $(FUZZ_SUITE_LD_COMMON)\n test_fuzz_script_interpreter_LDFLAGS = $(FUZZ_SUITE_LDFLAGS_COMMON)\n test_fuzz_script_interpreter_SOURCES = test/fuzz/script_interpreter.cpp\n \n+test_fuzz_script_assets_test_minimizer_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n+test_fuzz_script_assets_test_minimizer_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n+test_fuzz_script_assets_test_minimizer_LDADD = $(FUZZ_SUITE_LD_COMMON)\n+test_fuzz_script_assets_test_minimizer_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509666790",
      "id" : 509666790,
      "in_reply_to_id" : 509420029,
      "line" : 1089,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY2Njc5MA==",
      "original_commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "original_line" : 1089,
      "original_position" : 15,
      "original_start_line" : null,
      "path" : "src/Makefile.test.include",
      "position" : 15,
      "pull_request_review_id" : 514158331,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-21T20:26:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509666790",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509667995"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509667995"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Overall less verbose and one less LOC, but obviously a style question. Resolving.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-21T20:27:49Z",
      "diff_hunk" : "@@ -206,6 +206,7 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n         // get the scriptPubKey corresponding to this input:\n         CScript prevScript = prev.scriptPubKey;\n \n+        bool p2sh = false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509667995",
      "id" : 509667995,
      "in_reply_to_id" : 509143288,
      "line" : 209,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY2Nzk5NQ==",
      "original_commit_id" : "e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6",
      "original_line" : 209,
      "original_position" : 13,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : 13,
      "pull_request_review_id" : 514159361,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-21T20:27:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509667995",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509668512"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509668512"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Which commit? I can't seem to find the one that touches validation.cpp",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-21T20:28:45Z",
      "diff_hunk" : "@@ -237,6 +239,36 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check policy limits for Taproot spends:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509668512",
      "id" : 509668512,
      "in_reply_to_id" : 509149586,
      "line" : 243,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY2ODUxMg==",
      "original_commit_id" : "e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6",
      "original_line" : 243,
      "original_position" : 30,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : 30,
      "pull_request_review_id" : 514160046,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-21T20:28:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509668512",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509672176"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509672176"
         }
      },
      "author_association" : "MEMBER",
      "body" : "One side-effect is that it speeds up tx-relay, but tx relay isn't tested in this script, so seems good to remove",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-21T20:34:44Z",
      "diff_hunk" : "@@ -0,0 +1,1411 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expression for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        return tweak_add_privkey(key, tweak)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    scriptsig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    witness_stack = flatten(get(ctx, \"witness\"))\n+    return (scriptsig, witness_stack)\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda returning (scriptsig, witness_stack), taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+# - Whether this test demands being placed in a txin with no corresponding txout (for testing SIGHASH_SINGLE behavior)\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail,need_vin_vout_mismatch\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, need_vin_vout_mismatch=False, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert tap is None\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert script is None\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert script is None\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert script is None\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            return spend(tx, idx, utxos, **conf)\n+        else:\n+            assert failure is not None\n+            return spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None, need_vin_vout_mismatch=need_vin_vout_mismatch)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    return bytes(CScript([pubkey, OP_CHECKSIG]))\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+def zero_appender(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a zero added.\"\"\"\n+    return lambda ctx: deep_eval(ctx, expr) + b\"\\x00\"\n+\n+def byte_popper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with its last byte removed.\"\"\"\n+    return lambda ctx: deep_eval(ctx, expr)[:-1]\n+\n+# Expected error strings\n+\n+ERR_SIG_SIZE = {\"err_msg\": \"Invalid Schnorr signature size\"}\n+ERR_SIG_HASHTYPE = {\"err_msg\": \"Invalid Schnorr signature hash type\"}\n+ERR_SIG_SCHNORR = {\"err_msg\": \"Invalid Schnorr signature\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_TAPSCRIPT_CHECKMULTISIG = {\"err_msg\": \"OP_CHECKMULTISIG(VERIFY) is not available in tapscript\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal in tapscript\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Stack size must be exactly one after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+ERR_CHECKSIGVERIFY = {\"err_msg\": \"Script failed an OP_CHECKSIGVERIFY operation\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+VALID_SIGHASHES_TAPROOT_SINGLE = [\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT_NO_SINGLE = [h for h in VALID_SIGHASHES_TAPROOT if h not in VALID_SIGHASHES_TAPROOT_SINGLE]\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SIG_POP_BYTE = {\"failure\": {\"sign\": byte_popper(default_sign)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+SIG_ADD_ZERO = {\"failure\": {\"sign\": zero_appender(default_sign)}}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 50000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    secs = [generate_privkey() for _ in range(8)]\n+    pubs = [compute_xonly_pubkey(sec)[0] for sec in secs]\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    tap = taproot_construct(pubs[0])\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=secs[0], failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_SIG_SCHNORR)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=secs[0], failure={\"sighash\": bitflipper(default_sighash)}, **ERR_SIG_SCHNORR)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=secs[0], failure={\"flag_flip_r\": True}, **ERR_SIG_SCHNORR)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=secs[0], failure={\"flag_flip_p\": True}, **ERR_SIG_SCHNORR)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=secs[0], failure={\"signature\": bitflipper(default_signature)}, **ERR_SIG_SCHNORR)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pubs[0])\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pubs[1])))]\n+            tap = taproot_construct(pubs[0], scripts)\n+            add_spender(spenders, \"sighash/keypath_hashtype_%x\" % hashtype, tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+            add_spender(spenders, \"sighash/scriptpath_hashtype_%x\" % hashtype, tap=tap, leaf=\"s0\", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+\n+            # Test SIGHASH_SINGLE behavior in combination with mismatching outputs\n+            if hashtype in VALID_SIGHASHES_TAPROOT_SINGLE:\n+                add_spender(spenders, \"sighash/keypath_hashtype_mis_%x\" % hashtype, tap=tap, key=secs[0], annex=annex, standard=no_annex, hashtype_actual=random.choice(VALID_SIGHASHES_TAPROOT_NO_SINGLE), failure={\"hashtype_actual\": hashtype}, **ERR_SIG_HASHTYPE, need_vin_vout_mismatch=True)\n+                add_spender(spenders, \"sighash/scriptpath_hashtype_mis_%x\" % hashtype, tap=tap, leaf=\"s0\", key=secs[1], annex=annex, standard=no_annex, hashtype_actual=random.choice(VALID_SIGHASHES_TAPROOT_NO_SINGLE), **SINGLE_SIG, failure={\"hashtype_actual\": hashtype}, **ERR_SIG_HASHTYPE, need_vin_vout_mismatch=True)\n+\n+        # Test OP_CODESEPARATOR impact on sighashing.\n+        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+        common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+        scripts = [\n+            (\"pk_codesep\", CScript(random_checksig_style(pubs[1]) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig\n+            (\"codesep_pk\", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pubs[1]))),  # codesep before checksig\n+            (\"branched_codesep\", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pubs[0], OP_ELSE, OP_CODESEPARATOR, pubs[1], OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"sighash/pk_codesep\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+        add_spender(spenders, \"sighash/codesep_pk\", tap=tap, leaf=\"codesep_pk\", key=secs[1], codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+        add_spender(spenders, \"sighash/branched_codesep/left\", tap=tap, leaf=\"branched_codesep\", key=secs[0], codeseppos=3, **common, inputs=[getter(\"sign\"), b'\\x01'], **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+        add_spender(spenders, \"sighash/branched_codesep/right\", tap=tap, leaf=\"branched_codesep\", key=secs[1], codeseppos=6, **common, inputs=[getter(\"sign\"), b''], **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+\n+    # Reusing the scripts above, test that various features affect the sighash.\n+    add_spender(spenders, \"sighash/annex\", tap=tap, leaf=\"pk_codesep\", key=secs[1], hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={\"sighash\": override(default_sighash, annex=None)}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/script\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, script_taproot=tap.leaves[\"codesep_pk\"].script)}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/leafver\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leafversion=random.choice([x & 0xFE for x in range(0x100) if x & 0xFE != 0xC0]))}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leaf=None)}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/keypath\", tap=tap, key=secs[0], **common, failure={\"sighash\": override(default_sighash, leaf=\"pk_codesep\")}, **ERR_SIG_SCHNORR)\n+\n+    # Test that invalid hashtypes don't work, both in key path and script path spends\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for invalid_hashtype in [x for x in range(0x100) if x not in VALID_SIGHASHES_TAPROOT]:\n+        add_spender(spenders, \"sighash/keypath_unk_hashtype_%x\" % invalid_hashtype, tap=tap, key=secs[0], hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_SIG_HASHTYPE)\n+        add_spender(spenders, \"sighash/scriptpath_unk_hashtype_%x\" % invalid_hashtype, tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_SIG_HASHTYPE)\n+\n+    # Test that hashtype 0 cannot have a hashtype byte, and 1 must have one.\n+    add_spender(spenders, \"sighash/hashtype0_byte_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_SIG_HASHTYPE)\n+    add_spender(spenders, \"sighash/hashtype0_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_SIG_HASHTYPE)\n+    add_spender(spenders, \"sighash/hashtype1_byte_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/hashtype1_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SIG_SCHNORR)\n+    # Test that hashtype 0 and hashtype 1 cannot be transmuted into each other.\n+    add_spender(spenders, \"sighash/hashtype0to1_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/hashtype0to1_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/hashtype1to0_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"sighash/hashtype1to0_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SIG_SCHNORR)\n+\n+    # Test aspects of signatures with unusual lengths\n+    for hashtype in [SIGHASH_DEFAULT, random.choice(VALID_SIGHASHES_TAPROOT)]:\n+        scripts = [\n+            (\"csv\", CScript([pubs[2], OP_CHECKSIGVERIFY, OP_1])),\n+            (\"cs_pos\", CScript([pubs[2], OP_CHECKSIG])),\n+            (\"csa_pos\", CScript([OP_0, pubs[2], OP_CHECKSIGADD, OP_1, OP_EQUAL])),\n+            (\"cs_neg\", CScript([pubs[2], OP_CHECKSIG, OP_NOT])),\n+            (\"csa_neg\", CScript([OP_2, pubs[2], OP_CHECKSIGADD, OP_2, OP_EQUAL]))\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[3], scripts)\n+        # Empty signatures\n+        add_spender(spenders, \"siglen/empty_keypath\", tap=tap, key=secs[3], hashtype=hashtype, failure={\"sign\": b\"\"}, **ERR_SIG_SIZE)\n+        add_spender(spenders, \"siglen/empty_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_CHECKSIGVERIFY)\n+        add_spender(spenders, \"siglen/empty_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_NO_SUCCESS)\n+        add_spender(spenders, \"siglen/empty_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, failure={\"sign\": b\"\"}, **ERR_NO_SUCCESS)\n+        add_spender(spenders, \"siglen/empty_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": lambda _: random_bytes(random.randrange(1, 63))}, **ERR_SIG_SIZE)\n+        add_spender(spenders, \"siglen/empty_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": lambda _: random_bytes(random.randrange(66, 100))}, **ERR_SIG_SIZE)\n+        # Appending a zero byte to signatures invalidates them\n+        add_spender(spenders, \"siglen/padzero_keypath\", tap=tap, key=secs[3], hashtype=hashtype, **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        add_spender(spenders, \"siglen/padzero_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        add_spender(spenders, \"siglen/padzero_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        add_spender(spenders, \"siglen/padzero_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        add_spender(spenders, \"siglen/padzero_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        add_spender(spenders, \"siglen/padzero_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))\n+        # Removing the last byte from signatures invalidates them\n+        add_spender(spenders, \"siglen/popbyte_keypath\", tap=tap, key=secs[3], hashtype=hashtype, **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        add_spender(spenders, \"siglen/popbyte_csv\", tap=tap, key=secs[2], leaf=\"csv\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        add_spender(spenders, \"siglen/popbyte_cs\", tap=tap, key=secs[2], leaf=\"cs_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        add_spender(spenders, \"siglen/popbyte_csa\", tap=tap, key=secs[2], leaf=\"csa_pos\", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        add_spender(spenders, \"siglen/popbyte_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        add_spender(spenders, \"siglen/popbyte_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))\n+        # Verify that an invalid signature is not allowed, not even when the CHECKSIG* is expected to fail.\n+        add_spender(spenders, \"siglen/invalid_cs_neg\", tap=tap, key=secs[2], leaf=\"cs_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": default_sign, \"sighash\": bitflipper(default_sighash)}, **ERR_SIG_SCHNORR)\n+        add_spender(spenders, \"siglen/invalid_csa_neg\", tap=tap, key=secs[2], leaf=\"csa_neg\", hashtype=hashtype, **SINGLE_SIG, sign=b\"\", failure={\"sign\": default_sign, \"sighash\": bitflipper(default_sighash)}, **ERR_SIG_SCHNORR)\n+\n+    # == Test that BIP341 spending only applies to witness version 1, program length 32, no P2SH ==\n+\n+    for p2sh in [False, True]:\n+        for witver in range(1, 17):\n+            for witlen in [20, 31, 32, 33]:\n+                def mutate(spk):\n+                    prog = spk[2:]\n+                    assert len(prog) == 32\n+                    if witlen < 32:\n+                        prog = prog[0:witlen]\n+                    elif witlen > 32:\n+                        prog += bytes([0 for _ in range(witlen - 32)])\n+                    return CScript([CScriptOp.encode_op_n(witver), prog])\n+                scripts = [(\"s0\", CScript([pubs[0], OP_CHECKSIG])), (\"dummy\", CScript([OP_RETURN]))]\n+                tap = taproot_construct(pubs[1], scripts)\n+                if not p2sh and witver == 1 and witlen == 32:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, failure={\"leaf\": \"dummy\"}, **ERR_OP_RETURN)\n+                else:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], standard=False)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, standard=False)\n+\n+    # == Test various aspects of BIP341 spending paths ==\n+\n+    # A set of functions that compute the hashing partner in a Merkle tree, designed to exercise\n+    # edge cases. This relies on the taproot_construct feature that a lambda can be passed in\n+    # instead of a subtree, to compute the partner to be hashed with.\n+    PARTNER_MERKLE_FN = [\n+        # Combine with itself\n+        lambda h: h,\n+        # Combine with hash 0\n+        lambda h: bytes([0 for _ in range(32)]),\n+        # Combine with hash 2^256-1\n+        lambda h: bytes([0xff for _ in range(32)]),\n+        # Combine with itself-1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') + 1).to_bytes(32, 'big'),\n+        # Combine with itself-1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') + 1).to_bytes(32, 'little'),\n+        # Combine with random bitflipped version of self.\n+        lambda h: (int.from_bytes(h, 'little') ^ (1 << random.randrange(256))).to_bytes(32, 'little')\n+    ]\n+    # Start with a tree of that has depth 1 for \"128deep\" and depth 2 for \"129deep\".\n+    scripts = [(\"128deep\", CScript([pubs[0], OP_CHECKSIG])), [(\"129deep\", CScript([pubs[0], OP_CHECKSIG])), random.choice(PARTNER_MERKLE_FN)]]\n+    # Add 127 nodes on top of that tree, so that \"128deep\" and \"129deep\" end up at their designated depths.\n+    for _ in range(127):\n+        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+    tap = taproot_construct(pubs[0], scripts)\n+    # Test that spends with a depth of 128 work, but 129 doesn't (even with a tree with weird Merkle branches in it).\n+    add_spender(spenders, \"spendpath/merklelimit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"leaf\": \"129deep\"}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that flipping the negation bit invalidates spends.\n+    add_spender(spenders, \"spendpath/negflag\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"negflag\": lambda ctx: 1 - default_negflag(ctx)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the Merkle branch invalidate it.\n+    add_spender(spenders, \"spendpath/bitflipmerkle\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"merklebranch\": bitflipper(default_merklebranch)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the inner pubkey invalidate it.\n+    add_spender(spenders, \"spendpath/bitflippubkey\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"pubkey_inner\": bitflipper(default_pubkey_inner)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that empty witnesses are invalid.\n+    add_spender(spenders, \"spendpath/emptywit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"witness\": []}, **ERR_EMPTY_WITNESS)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padlongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/trunclongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    scripts = [(\"s\", CScript([pubs[0], OP_CHECKSIG]))]\n+    tap = taproot_construct(pubs[1], scripts)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/truncshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block to 1 byte (\"-1 Merkle length\") invalidates it\n+    add_spender(spenders, \"spendpath/trunc1shortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:1]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    # == Test BIP342 edge cases ==\n+\n+    csa_low_val = random.randrange(0, 17) # Within range for OP_n\n+    csa_low_result = csa_low_val + 1\n+\n+    csa_high_val = random.randrange(17, 100) if random.getrandbits(1) else random.randrange(-100, -1) # Outside OP_n range\n+    csa_high_result = csa_high_val + 1\n+\n+    OVERSIZE_NUMBER = 2**31\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER))), 6)\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER-1))), 5)\n+\n+    big_choices = []\n+    big_scriptops = []\n+    for i in range(1000):\n+        r = random.randrange(len(pubs))\n+        big_choices.append(r)\n+        big_scriptops += [pubs[r], OP_CHECKSIGVERIFY]\n+\n+\n+    def big_spend_inputs(ctx):\n+        \"\"\"Helper function to construct the script input for t33/t34 below.\"\"\"\n+        # Instead of signing 999 times, precompute signatures for every (key, hashtype) combination\n+        sigs = {}\n+        for ht in VALID_SIGHASHES_TAPROOT:\n+            for k in range(len(pubs)):\n+                sigs[(k, ht)] = override(default_sign, hashtype=ht, key=secs[k])(ctx)\n+        num = get(ctx, \"num\")\n+        return [sigs[(big_choices[i], random.choice(VALID_SIGHASHES_TAPROOT))] for i in range(num - 1, -1, -1)]\n+\n+    # Various BIP342 features\n+    scripts = [\n+        # 0) drop stack element and OP_CHECKSIG\n+        (\"t0\", CScript([OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 1) normal OP_CHECKSIG\n+        (\"t1\", CScript([pubs[1], OP_CHECKSIG])),\n+        # 2) normal OP_CHECKSIGVERIFY\n+        (\"t2\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1])),\n+        # 3) Hypothetical OP_CHECKMULTISIG script that takes a single sig as input\n+        (\"t3\", CScript([OP_0, OP_SWAP, OP_1, pubs[1], OP_1, OP_CHECKMULTISIG])),\n+        # 4) Hypothetical OP_CHECKMULTISIGVERIFY script that takes a single sig as input\n+        (\"t4\", CScript([OP_0, OP_SWAP, OP_1, pubs[1], OP_1, OP_CHECKMULTISIGVERIFY, OP_1])),\n+        # 5) OP_IF script that needs a true input\n+        (\"t5\", CScript([OP_IF, pubs[1], OP_CHECKSIG, OP_ELSE, OP_RETURN, OP_ENDIF])),\n+        # 6) OP_NOTIF script that needs a true input\n+        (\"t6\", CScript([OP_NOTIF, OP_RETURN, OP_ELSE, pubs[1], OP_CHECKSIG, OP_ENDIF])),\n+        # 7) OP_CHECKSIG with an empty key\n+        (\"t7\", CScript([OP_0, OP_CHECKSIG])),\n+        # 8) OP_CHECKSIGVERIFY with an empty key\n+        (\"t8\", CScript([OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 9) normal OP_CHECKSIGADD that also ensures return value is correct\n+        (\"t9\", CScript([csa_low_val, pubs[1], OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 10) OP_CHECKSIGADD with empty key\n+        (\"t10\", CScript([csa_low_val, OP_0, OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 11) OP_CHECKSIGADD with missing counter stack element\n+        (\"t11\", CScript([pubs[1], OP_CHECKSIGADD, OP_1, OP_EQUAL])),\n+        # 12) OP_CHECKSIG that needs invalid signature\n+        (\"t12\", CScript([pubs[1], OP_CHECKSIGVERIFY, pubs[0], OP_CHECKSIG, OP_NOT])),\n+        # 13) OP_CHECKSIG with empty key that needs invalid signature\n+        (\"t13\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_CHECKSIG, OP_NOT])),\n+        # 14) OP_CHECKSIGADD that needs invalid signature\n+        (\"t14\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, pubs[0], OP_CHECKSIGADD, OP_NOT])),\n+        # 15) OP_CHECKSIGADD with empty key that needs invalid signature\n+        (\"t15\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGADD, OP_NOT])),\n+        # 16) OP_CHECKSIG with unknown pubkey type\n+        (\"t16\", CScript([OP_1, OP_CHECKSIG])),\n+        # 17) OP_CHECKSIGADD with unknown pubkey type\n+        (\"t17\", CScript([OP_0, OP_1, OP_CHECKSIGADD])),\n+        # 18) OP_CHECKSIGVERIFY with unknown pubkey type\n+        (\"t18\", CScript([OP_1, OP_CHECKSIGVERIFY, OP_1])),\n+        # 19) script longer than 10000 bytes and over 201 non-push opcodes\n+        (\"t19\", CScript([OP_0, OP_0, OP_2DROP] * 10001 + [pubs[1], OP_CHECKSIG])),\n+        # 20) OP_CHECKSIGVERIFY with empty key\n+        (\"t20\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 21) Script that grows the stack to 1000 elements\n+        (\"t21\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 999 + [OP_DROP] * 999)),\n+        # 22) Script that grows the stack to 1001 elements\n+        (\"t22\", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 1000 + [OP_DROP] * 1000)),\n+        # 23) Script that expects an input stack of 1000 elements\n+        (\"t23\", CScript([OP_DROP] * 999 + [pubs[1], OP_CHECKSIG])),\n+        # 24) Script that expects an input stack of 1001 elements\n+        (\"t24\", CScript([OP_DROP] * 1000 + [pubs[1], OP_CHECKSIG])),\n+        # 25) Script that pushes a MAX_SCRIPT_ELEMENT_SIZE-bytes element\n+        (\"t25\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE), OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 26) Script that pushes a (MAX_SCRIPT_ELEMENT_SIZE+1)-bytes element\n+        (\"t26\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, pubs[1], OP_CHECKSIG])),\n+        # 27) CHECKSIGADD that must fail because numeric argument number is >4 bytes\n+        (\"t27\", CScript([CScriptNum(OVERSIZE_NUMBER), pubs[1], OP_CHECKSIGADD])),\n+        # 28) Pushes random CScriptNum value, checks OP_CHECKSIGADD result\n+        (\"t28\", CScript([csa_high_val, pubs[1], OP_CHECKSIGADD, csa_high_result, OP_EQUAL])),\n+        # 29) CHECKSIGADD that succeeds with proper sig because numeric argument number is <=4 bytes\n+        (\"t29\", CScript([CScriptNum(OVERSIZE_NUMBER-1), pubs[1], OP_CHECKSIGADD])),\n+        # 30) Variant of t1 with \"normal\" 33-byte pubkey\n+        (\"t30\", CScript([b'\\x03' + pubs[1], OP_CHECKSIG])),\n+        # 31) Variant of t2 with \"normal\" 33-byte pubkey\n+        (\"t31\", CScript([b'\\x02' + pubs[1], OP_CHECKSIGVERIFY, OP_1])),\n+        # 32) Variant of t28 with \"normal\" 33-byte pubkey\n+        (\"t32\", CScript([csa_high_val, b'\\x03' + pubs[1], OP_CHECKSIGADD, csa_high_result, OP_EQUAL])),\n+        # 33) 999-of-999 multisig\n+        (\"t33\", CScript(big_scriptops[:1998] + [OP_1])),\n+        # 34) 1000-of-1000 multisig\n+        (\"t34\", CScript(big_scriptops[:2000] + [OP_1])),\n+        # 35) Variant of t9 that uses a non-minimally encoded input arg\n+        (\"t35\", CScript([bytes([csa_low_val]), pubs[1], OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),\n+        # 36) Empty script\n+        (\"t36\", CScript([])),\n+    ]\n+    # Add many dummies to test huge trees\n+    for j in range(100000):\n+        scripts.append((None, CScript([OP_RETURN, random.randrange(100000)])))\n+    random.shuffle(scripts)\n+    tap = taproot_construct(pubs[0], scripts)\n+    common = {\n+        \"hashtype\": hashtype,\n+        \"key\": secs[1],\n+        \"tap\": tap,\n+    }\n+    # Test that MAX_SCRIPT_ELEMENT_SIZE byte stack element inputs are valid, but not one more (and 80 bytes is standard but 81 is not).\n+    add_spender(spenders, \"tapscript/inputmaxlimit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE)], failure={\"inputs\": [getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1)]}, **ERR_PUSH_LIMIT)\n+    add_spender(spenders, \"tapscript/input80limit\", leaf=\"t0\", **common, inputs=[getter(\"sign\"), random_bytes(80)])\n+    add_spender(spenders, \"tapscript/input81limit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(81)])\n+    # Test that OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY cause failure, but OP_CHECKSIG and OP_CHECKSIGVERIFY work.\n+    add_spender(spenders, \"tapscript/disabled_checkmultisig\", leaf=\"t1\", **common, **SINGLE_SIG, failure={\"leaf\": \"t3\"}, **ERR_TAPSCRIPT_CHECKMULTISIG)\n+    add_spender(spenders, \"tapscript/disabled_checkmultisigverify\", leaf=\"t2\", **common, **SINGLE_SIG, failure={\"leaf\": \"t4\"}, **ERR_TAPSCRIPT_CHECKMULTISIG)\n+    # Test that OP_IF and OP_NOTIF do not accept non-0x01 as truth value (the MINIMALIF rule is consensus in Tapscript)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x02']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x03']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0001']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0100']}, **ERR_MINIMALIF)\n+    # Test that 1-byte public keys (which are unknown) are acceptable but nonstandard with unrelated signatures, but 0-byte public keys are not valid.\n+    add_spender(spenders, \"tapscript/unkpk/checksig\", leaf=\"t16\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigadd\", leaf=\"t17\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigverify\", leaf=\"t18\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that 33-byte public keys (which are unknown) are acceptable but nonstandard with valid signatures, but normal pubkeys are not valid in that case.\n+    add_spender(spenders, \"tapscript/oldpk/checksig\", leaf=\"t30\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t1\"}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"tapscript/oldpk/checksigadd\", leaf=\"t31\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t2\"}, **ERR_SIG_SCHNORR)\n+    add_spender(spenders, \"tapscript/oldpk/checksigverify\", leaf=\"t32\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t28\"}, **ERR_SIG_SCHNORR)\n+    # Test that 0-byte public keys are not acceptable.\n+    add_spender(spenders, \"tapscript/emptypk/checksig\", leaf=\"t1\", **SINGLE_SIG, **common, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigverify\", leaf=\"t2\", **SINGLE_SIG, **common, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigadd\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigadd\", leaf=\"t35\", standard=False, **SINGLE_SIG, **common, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that OP_CHECKSIGADD results are as expected\n+    add_spender(spenders, \"tapscript/checksigaddresults\", leaf=\"t28\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    add_spender(spenders, \"tapscript/checksigaddoversize\", leaf=\"t29\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    # Test that OP_CHECKSIGADD requires 3 stack elements.\n+    add_spender(spenders, \"tapscript/checksigadd3args\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t11\"}, **ERR_STACK_EMPTY)\n+    # Test that empty signatures do not cause script failure in OP_CHECKSIG and OP_CHECKSIGADD (but do fail with empty pubkey, and do fail OP_CHECKSIGVERIFY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksig\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t13\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/nochecksigverify\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t20\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksigadd\", leaf=\"t14\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t15\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that scripts over 10000 bytes (and over 201 non-push ops) are acceptable.\n+    add_spender(spenders, \"tapscript/no10000limit\", leaf=\"t19\", **SINGLE_SIG, **common)\n+    # Test that a stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000stack\", leaf=\"t21\", **SINGLE_SIG, **common, failure={\"leaf\": \"t22\"}, **ERR_STACK_SIZE)\n+    # Test that an input stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000inputs\", leaf=\"t23\", **common, inputs=[getter(\"sign\")] + [b'' for _ in range(999)], failure={\"leaf\": \"t24\", \"inputs\": [getter(\"sign\")] + [b'' for _ in range(1000)]}, **ERR_STACK_SIZE)\n+    # Test that pushing a MAX_SCRIPT_ELEMENT_SIZE byte stack element is valid, but one longer is not.\n+    add_spender(spenders, \"tapscript/pushmaxlimit\", leaf=\"t25\", **common, **SINGLE_SIG, failure={\"leaf\": \"t26\"}, **ERR_PUSH_LIMIT)\n+    # Test that 999-of-999 multisig works (but 1000-of-1000 triggers stack size limits)\n+    add_spender(spenders, \"tapscript/bigmulti\", leaf=\"t33\", **common, inputs=big_spend_inputs, num=999, failure={\"leaf\": \"t34\", \"num\": 1000}, **ERR_STACK_SIZE)\n+    # Test that the CLEANSTACK rule is consensus critical in tapscript\n+    add_spender(spenders, \"tapscript/cleanstack\", leaf=\"t36\", tap=tap, inputs=[b'\\x01'], failure={\"inputs\": [b'\\x01', b'\\x01']}, **ERR_CLEANSTACK)\n+\n+    # == Test for sigops ratio limit ==\n+\n+    # Given a number n, and a public key pk, functions that produce a (CScript, sigops). Each script takes as\n+    # input a valid signature with the passed pk followed by a dummy push of bytes that are to be dropped, and\n+    # will execute sigops signature checks.\n+    SIGOPS_RATIO_SCRIPTS = [\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIG.\n+        lambda n, pk: (CScript([OP_DROP, pk] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGVERIFY.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_0, OP_IF, OP_2DUP, OP_CHECKSIGVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_2, OP_SWAP, OP_CHECKSIGADD, OP_3, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIG.\n+        lambda n, pk: (CScript([random_bytes(220), OP_2DROP, pk, OP_1, OP_NOTIF, OP_2DUP, OP_CHECKSIG, OP_VERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_4, OP_SWAP, OP_CHECKSIGADD, OP_5, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGADD.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_1, OP_IF, OP_ELSE, OP_2DUP, OP_6, OP_SWAP, OP_CHECKSIGADD, OP_7, OP_EQUALVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_8, OP_SWAP, OP_CHECKSIGADD, OP_9, OP_EQUAL]), n + 1),\n+        # n+1 OP_CHECKSIGs, but also one OP_CHECKSIG with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, pk, OP_CHECKSIG, OP_NOT, OP_VERIFY, pk] + [OP_2DUP, OP_CHECKSIG, OP_VERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGADDs and 1 OP_CHECKSIG, but also an OP_CHECKSIGADD with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, OP_10, pk, OP_CHECKSIGADD, OP_10, OP_EQUALVERIFY, pk] + [OP_2DUP, OP_16, OP_SWAP, OP_CHECKSIGADD, b'\\x11', OP_EQUALVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+    ]\n+    for annex in [None, bytes([ANNEX_TAG]) + random_bytes(random.randrange(1000))]:\n+        for hashtype in [SIGHASH_DEFAULT, SIGHASH_ALL]:\n+            for pubkey in [pubs[1], random_bytes(random.choice([x for x in range(2, 81) if x != 32]))]:\n+                for fn_num, fn in enumerate(SIGOPS_RATIO_SCRIPTS):\n+                    merkledepth = random.randrange(129)\n+\n+\n+                    def predict_sigops_ratio(n, dummy_size):\n+                        \"\"\"Predict whether spending fn(n, pubkey) with dummy_size will pass the ratio test.\"\"\"\n+                        script, sigops = fn(n, pubkey)\n+                        # Predict the size of the witness for a given choice of n\n+                        stacklen_size = 1\n+                        sig_size = 64 + (hashtype != SIGHASH_DEFAULT)\n+                        siglen_size = 1\n+                        dummylen_size = 1 + 2 * (dummy_size >= 253)\n+                        script_size = len(script)\n+                        scriptlen_size = 1 + 2 * (script_size >= 253)\n+                        control_size = 33 + 32 * merkledepth\n+                        controllen_size = 1 + 2 * (control_size >= 253)\n+                        annex_size = 0 if annex is None else len(annex)\n+                        annexlen_size = 0 if annex is None else 1 + 2 * (annex_size >= 253)\n+                        witsize = stacklen_size + sig_size + siglen_size + dummy_size + dummylen_size + script_size + scriptlen_size + control_size + controllen_size + annex_size + annexlen_size\n+                        # sigops ratio test\n+                        return witsize + 50 >= 50 * sigops\n+                    # Make sure n is high enough that with empty dummy, the script is not valid\n+                    n = 0\n+                    while predict_sigops_ratio(n, 0):\n+                        n += 1\n+                    # But allow picking a bit higher still\n+                    n += random.randrange(5)\n+                    # Now pick dummy size *just* large enough that the overall construction passes\n+                    dummylen = 0\n+                    while not predict_sigops_ratio(n, dummylen):\n+                        dummylen += 1\n+                    scripts = [(\"s\", fn(n, pubkey)[0])]\n+                    for _ in range(merkledepth):\n+                        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+                    tap = taproot_construct(pubs[0], scripts)\n+                    standard = annex is None and dummylen <= 80 and len(pubkey) == 32\n+                    add_spender(spenders, \"tapscript/sigopsratio_%i\" % fn_num, tap=tap, leaf=\"s\", annex=annex, hashtype=hashtype, key=secs[1], inputs=[getter(\"sign\"), random_bytes(dummylen)], standard=standard, failure={\"inputs\": [getter(\"sign\"), random_bytes(dummylen - 1)]}, **ERR_SIGOPS_RATIO)\n+\n+    # Future leaf versions\n+    for leafver in range(0, 0x100, 2):\n+        if leafver == LEAF_VERSION_TAPSCRIPT or leafver == ANNEX_TAG:\n+            # Skip the defined LEAF_VERSION_TAPSCRIPT, and the ANNEX_TAG which is not usable as leaf version\n+            continue\n+        scripts = [\n+            (\"bare_c0\", CScript([OP_NOP])),\n+            (\"bare_unkver\", CScript([OP_NOP]), leafver),\n+            (\"return_c0\", CScript([OP_RETURN])),\n+            (\"return_unkver\", CScript([OP_RETURN]), leafver),\n+            (\"undecodable_c0\", CScript([OP_PUSHDATA1])),\n+            (\"undecodable_unkver\", CScript([OP_PUSHDATA1]), leafver),\n+            (\"bigpush_c0\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP])),\n+            (\"bigpush_unkver\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP]), leafver),\n+            (\"1001push_c0\", CScript([OP_0] * 1001)),\n+            (\"1001push_unkver\", CScript([OP_0] * 1001), leafver),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"unkver/bare\", standard=False, tap=tap, leaf=\"bare_unkver\", failure={\"leaf\": \"bare_c0\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"unkver/return\", standard=False, tap=tap, leaf=\"return_unkver\", failure={\"leaf\": \"return_c0\"}, **ERR_OP_RETURN)\n+        add_spender(spenders, \"unkver/undecodable\", standard=False, tap=tap, leaf=\"undecodable_unkver\", failure={\"leaf\": \"undecodable_c0\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"unkver/bigpush\", standard=False, tap=tap, leaf=\"bigpush_unkver\", failure={\"leaf\": \"bigpush_c0\"}, **ERR_PUSH_LIMIT)\n+        add_spender(spenders, \"unkver/1001push\", standard=False, tap=tap, leaf=\"1001push_unkver\", failure={\"leaf\": \"1001push_c0\"}, **ERR_STACK_SIZE)\n+        add_spender(spenders, \"unkver/1001inputs\", standard=False, tap=tap, leaf=\"bare_unkver\", inputs=[b'']*1001, failure={\"leaf\": \"bare_c0\"}, **ERR_STACK_SIZE)\n+\n+    # OP_SUCCESSx tests.\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for opval in range(76, 0x100):\n+        opcode = CScriptOp(opval)\n+        if not is_op_success(opcode):\n+            continue\n+        scripts = [\n+            (\"bare_success\", CScript([opcode])),\n+            (\"bare_nop\", CScript([OP_NOP])),\n+            (\"unexecif_success\", CScript([OP_0, OP_IF, opcode, OP_ENDIF])),\n+            (\"unexecif_nop\", CScript([OP_0, OP_IF, OP_NOP, OP_ENDIF])),\n+            (\"return_success\", CScript([OP_RETURN, opcode])),\n+            (\"return_nop\", CScript([OP_RETURN, OP_NOP])),\n+            (\"undecodable_success\", CScript([opcode, OP_PUSHDATA1])),\n+            (\"undecodable_nop\", CScript([OP_NOP, OP_PUSHDATA1])),\n+            (\"undecodable_bypassed_success\", CScript([OP_PUSHDATA1, OP_2, opcode])),\n+            (\"bigpush_success\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, opcode])),\n+            (\"bigpush_nop\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, OP_NOP])),\n+            (\"1001push_success\", CScript([OP_0] * 1001 + [opcode])),\n+            (\"1001push_nop\", CScript([OP_0] * 1001 + [OP_NOP])),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"opsuccess/bare\", standard=False, tap=tap, leaf=\"bare_success\", failure={\"leaf\": \"bare_nop\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"opsuccess/unexecif\", standard=False, tap=tap, leaf=\"unexecif_success\", failure={\"leaf\": \"unexecif_nop\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"opsuccess/return\", standard=False, tap=tap, leaf=\"return_success\", failure={\"leaf\": \"return_nop\"}, **ERR_OP_RETURN)\n+        add_spender(spenders, \"opsuccess/undecodable\", standard=False, tap=tap, leaf=\"undecodable_success\", failure={\"leaf\": \"undecodable_nop\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"opsuccess/undecodable_bypass\", standard=False, tap=tap, leaf=\"undecodable_success\", failure={\"leaf\": \"undecodable_bypassed_success\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"opsuccess/bigpush\", standard=False, tap=tap, leaf=\"bigpush_success\", failure={\"leaf\": \"bigpush_nop\"}, **ERR_PUSH_LIMIT)\n+        add_spender(spenders, \"opsuccess/1001push\", standard=False, tap=tap, leaf=\"1001push_success\", failure={\"leaf\": \"1001push_nop\"}, **ERR_STACK_SIZE)\n+        add_spender(spenders, \"opsuccess/1001inputs\", standard=False, tap=tap, leaf=\"bare_success\", inputs=[b'']*1001, failure={\"leaf\": \"bare_nop\"}, **ERR_STACK_SIZE)\n+\n+    # Non-OP_SUCCESSx (verify that those aren't accidentally treated as OP_SUCCESSx)\n+    for opval in range(0, 0x100):\n+        opcode = CScriptOp(opval)\n+        if is_op_success(opcode):\n+            continue\n+        scripts = [\n+            (\"normal\", CScript([OP_RETURN, opcode] + [OP_NOP] * 75)),\n+            (\"op_success\", CScript([OP_RETURN, CScriptOp(0x50)]))\n+        ]\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"alwaysvalid/notsuccessx\", tap=tap, leaf=\"op_success\", inputs=[], standard=False, failure={\"leaf\": \"normal\"}) # err_msg differs based on opcode\n+\n+    # == Legacy tests ==\n+\n+    # Also add a few legacy spends into the mix, so that transactions which combine taproot and pre-taproot spends get tested too.\n+    for compressed in [False, True]:\n+        eckey1 = ECKey()\n+        eckey1.set(generate_privkey(), compressed)\n+        pubkey1 = eckey1.get_pubkey().get_bytes()\n+        eckey2 = ECKey()\n+        eckey2.set(generate_privkey(), compressed)\n+        for p2sh in [False, True]:\n+            for witv0 in [False, True]:\n+                for hashtype in VALID_SIGHASHES_ECDSA + [random.randrange(0x04, 0x80), random.randrange(0x84, 0x100)]:\n+                    standard = (hashtype in VALID_SIGHASHES_ECDSA) and (compressed or not witv0)\n+                    add_spender(spenders, \"legacy/pk-wrongkey\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, script=CScript([pubkey1, OP_CHECKSIG]), **SINGLE_SIG, key=eckey1, failure={\"key\": eckey2}, sigops_weight=4-3*witv0, **ERR_NO_SUCCESS)\n+                    add_spender(spenders, \"legacy/pkh-sighashflip\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, pkh=pubkey1, key=eckey1, **SIGHASH_BITFLIP, sigops_weight=4-3*witv0, **ERR_NO_SUCCESS)\n+\n+    # Verify that OP_CHECKSIGADD wasn't accidentally added to pre-taproot validation logic.\n+    for p2sh in [False, True]:\n+        for witv0 in [False, True]:\n+            for hashtype in VALID_SIGHASHES_ECDSA + [random.randrange(0x04, 0x80), random.randrange(0x84, 0x100)]:\n+                standard = hashtype in VALID_SIGHASHES_ECDSA and (p2sh or witv0)\n+                add_spender(spenders, \"compat/nocsa\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, script=CScript([OP_IF, OP_11, pubkey1, OP_CHECKSIGADD, OP_12, OP_EQUAL, OP_ELSE, pubkey1, OP_CHECKSIG, OP_ENDIF]), key=eckey1, sigops_weight=4-3*witv0, inputs=[getter(\"sign\"), b''], failure={\"inputs\": [getter(\"sign\"), b'\\x01']}, **ERR_UNDECODABLE)\n+\n+    return spenders\n+\n+def spenders_taproot_inactive():\n+    \"\"\"Spenders for testing that pre-activation Taproot rules don't apply.\"\"\"\n+\n+    spenders = []\n+\n+    sec = generate_privkey()\n+    pub, _ = compute_xonly_pubkey(sec)\n+    scripts = [\n+        (\"pk\", CScript([pub, OP_CHECKSIG])),\n+        (\"future_leaf\", CScript([pub, OP_CHECKSIG]), 0xc2),\n+        (\"op_success\", CScript([pub, OP_CHECKSIG, OP_0, OP_IF, CScriptOp(0x50), OP_ENDIF])),\n+    ]\n+    tap = taproot_construct(pub, scripts)\n+\n+    # Test that keypath spending is valid & standard if compliant, but valid and nonstandard otherwise.\n+    add_spender(spenders, \"inactive/keypath_valid\", key=sec, tap=tap)\n+    add_spender(spenders, \"inactive/keypath_invalidsig\", key=sec, tap=tap, standard=False, sighash=bitflipper(default_sighash))\n+    add_spender(spenders, \"inactive/keypath_empty\", key=sec, tap=tap, standard=False, witness=[])\n+\n+    # Same for scriptpath spending (but using future features like annex, leaf versions, or OP_SUCCESS is nonstandard).\n+    add_spender(spenders, \"inactive/scriptpath_valid\", key=sec, tap=tap, leaf=\"pk\", inputs=[getter(\"sign\")])\n+    add_spender(spenders, \"inactive/scriptpath_invalidsig\", key=sec, tap=tap, leaf=\"pk\", standard=False, inputs=[getter(\"sign\")], sighash=bitflipper(default_sighash))\n+    add_spender(spenders, \"inactive/scriptpath_invalidcb\", key=sec, tap=tap, leaf=\"pk\", standard=False, inputs=[getter(\"sign\")], controlblock=bitflipper(default_controlblock))\n+    add_spender(spenders, \"inactive/scriptpath_valid_unkleaf\", key=sec, tap=tap, leaf=\"future_leaf\", standard=False, inputs=[getter(\"sign\")])\n+    add_spender(spenders, \"inactive/scriptpath_invalid_unkleaf\", key=sec, tap=tap, leaf=\"future_leaf\", standard=False, inputs=[getter(\"sign\")], sighash=bitflipper(default_sighash))\n+    add_spender(spenders, \"inactive/scriptpath_valid_opsuccess\", key=sec, tap=tap, leaf=\"op_success\", standard=False, inputs=[getter(\"sign\")])\n+    add_spender(spenders, \"inactive/scriptpath_valid_opsuccess\", key=sec, tap=tap, leaf=\"op_success\", standard=False, inputs=[getter(\"sign\")], sighash=bitflipper(default_sighash))\n+\n+    return spenders\n+\n+# Data type to keep track of UTXOs, where they were created, and how to spend them.\n+UTXOData = namedtuple('UTXOData', 'outpoint,output,spender')\n+\n+class TaprootTest(BitcoinTestFramework):\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.setup_clean_chain = True\n+        # Node 0 has Taproot inactive, Node 1 active.\n+        self.extra_args = [[\"-whitelist=127.0.0.1\", \"-par=1\", \"-vbparams=taproot:1:1\"], [\"-whitelist=127.0.0.1\", \"-par=1\"]]",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509672176",
      "id" : 509672176,
      "in_reply_to_id" : 509400019,
      "line" : 1202,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY3MjE3Ng==",
      "original_commit_id" : "f06e6d03452cf5e0b1a0863afb08c9e6d3ef452e",
      "original_line" : 1157,
      "original_position" : 1157,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : 1202,
      "pull_request_review_id" : 514164191,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-21T20:34:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509672176",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509677397"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509677397"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> with known validity/invalidity\r\n\r\nOh, I missed that the validity flag is included in the seed itself. Makes sense now.\r\n\r\n> The unit test can be run without building in fuzz mode.\r\n\r\nHeh, I am pretty sure the developers that have the seed dir cloned, run the unit tests, but not the fuzz tests is an empty set.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-21T20:40:53Z",
      "diff_hunk" : "@@ -1610,5 +1640,104 @@ BOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_invalid_flags)\n     BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_INVALID_FLAGS);\n }\n \n+static std::vector<unsigned int> AllConsensusFlags()\n+{\n+    std::vector<unsigned int> ret;\n+\n+    for (unsigned int i = 0; i < 128; ++i) {\n+        unsigned int flag = 0;\n+        if (i & 1) flag |= SCRIPT_VERIFY_P2SH;\n+        if (i & 2) flag |= SCRIPT_VERIFY_DERSIG;\n+        if (i & 4) flag |= SCRIPT_VERIFY_NULLDUMMY;\n+        if (i & 8) flag |= SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY;\n+        if (i & 16) flag |= SCRIPT_VERIFY_CHECKSEQUENCEVERIFY;\n+        if (i & 32) flag |= SCRIPT_VERIFY_WITNESS;\n+        if (i & 64) flag |= SCRIPT_VERIFY_TAPROOT;\n+\n+        // SCRIPT_VERIFY_WITNESS requires SCRIPT_VERIFY_P2SH\n+        if (flag & SCRIPT_VERIFY_WITNESS && !(flag & SCRIPT_VERIFY_P2SH)) continue;\n+        // SCRIPT_VERIFY_TAPROOT requires SCRIPT_VERIFY_WITNESS\n+        if (flag & SCRIPT_VERIFY_TAPROOT && !(flag & SCRIPT_VERIFY_WITNESS)) continue;\n+\n+        ret.push_back(flag);\n+    }\n+\n+    return ret;\n+}\n+\n+/** Precomputed list of all valid combinations of consensus-relevant script validation flags. */\n+static const std::vector<unsigned int> ALL_CONSENSUS_FLAGS = AllConsensusFlags();\n+\n+static void AssetTest(const UniValue& test)\n+{\n+    BOOST_CHECK(test.isObject());\n+\n+    CMutableTransaction mtx = TxFromHex(test[\"tx\"].get_str());\n+    const std::vector<CTxOut> prevouts = TxOutsFromJSON(test[\"prevouts\"]);\n+    BOOST_CHECK(prevouts.size() == mtx.vin.size());\n+    size_t idx = test[\"index\"].get_int64();\n+    unsigned int test_flags = ParseScriptFlags(test[\"flags\"].get_str());\n+    bool fin = test.exists(\"final\") && test[\"final\"].get_bool();\n+\n+    if (test.exists(\"success\")) {\n+        mtx.vin[idx].scriptSig = ScriptFromHex(test[\"success\"][\"scriptSig\"].get_str());\n+        mtx.vin[idx].scriptWitness = ScriptWitnessFromJSON(test[\"success\"][\"witness\"]);\n+        CTransaction tx(mtx);\n+        PrecomputedTransactionData txdata;\n+        txdata.Init(tx, std::vector<CTxOut>(prevouts));\n+        CachingTransactionSignatureChecker txcheck(&tx, idx, prevouts[idx].nValue, true, txdata);\n+        for (const auto flags : ALL_CONSENSUS_FLAGS) {\n+            // \"final\": true tests are valid for all flags. Others are only valid with flags that are\n+            // a subset of test_flags.\n+            if (fin || ((flags & test_flags) == flags)) {\n+                bool ret = VerifyScript(tx.vin[idx].scriptSig, prevouts[idx].scriptPubKey, &tx.vin[idx].scriptWitness, flags, txcheck, nullptr);\n+                BOOST_CHECK(ret);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509677397",
      "id" : 509677397,
      "in_reply_to_id" : 509617693,
      "line" : 1694,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY3NzM5Nw==",
      "original_commit_id" : "4567ba034c5ae6e6cc161360f7425c9e844738f0",
      "original_line" : 1694,
      "original_position" : 113,
      "original_start_line" : null,
      "path" : "src/test/script_tests.cpp",
      "position" : 113,
      "pull_request_review_id" : 514168435,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-21T20:40:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509677397",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509681391"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509681391"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Oops, done for real now.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-21T20:45:25Z",
      "diff_hunk" : "@@ -237,6 +239,36 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check policy limits for Taproot spends:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509681391",
      "id" : 509681391,
      "in_reply_to_id" : 509149586,
      "line" : 243,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY4MTM5MQ==",
      "original_commit_id" : "e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6",
      "original_line" : 243,
      "original_position" : 30,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : 30,
      "pull_request_review_id" : 514171627,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-21T20:45:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509681391",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509682026"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509682026"
         }
      },
      "author_association" : "MEMBER",
      "body" : "heh, thanks!",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2020-10-21T20:46:21Z",
      "diff_hunk" : "@@ -237,6 +239,36 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check policy limits for Taproot spends:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r509682026",
      "id" : 509682026,
      "in_reply_to_id" : 509149586,
      "line" : 243,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY4MjAyNg==",
      "original_commit_id" : "e9a021d7e6a454d610a45cb9b3995f0d96a5fbb6",
      "original_line" : 243,
      "original_position" : 30,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : 30,
      "pull_request_review_id" : 514172301,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-10-21T20:46:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/509682026",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r657988147"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/657988147"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "https://github.com/bitcoin/bitcoin/blob/b2f5c38333fd2ec03fd1299a1bce507b25753f45/src/pubkey.h#L253 - is the asterisk in `*this` intentional?",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2021-06-24T14:14:57Z",
      "diff_hunk" : "@@ -169,7 +170,7 @@ class CPubKey\n     /*\n      * Check syntactic correctness.\n      *\n-     * Note that this is consensus critical as CheckSig() calls it!\n+     * Note that this is consensus critical as CheckECDSASignature() calls it!",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r657988147",
      "id" : 657988147,
      "in_reply_to_id" : 508152499,
      "line" : 173,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1Nzk4ODE0Nw==",
      "original_commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "original_line" : 173,
      "original_position" : 13,
      "original_start_line" : null,
      "path" : "src/pubkey.h",
      "position" : 13,
      "pull_request_review_id" : 691808628,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-06-24T14:14:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/657988147",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/58662979?v=4",
         "events_url" : "https://api.github.com/users/kiminuo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kiminuo/followers",
         "following_url" : "https://api.github.com/users/kiminuo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kiminuo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kiminuo",
         "id" : 58662979,
         "login" : "kiminuo",
         "node_id" : "MDQ6VXNlcjU4NjYyOTc5",
         "organizations_url" : "https://api.github.com/users/kiminuo/orgs",
         "received_events_url" : "https://api.github.com/users/kiminuo/received_events",
         "repos_url" : "https://api.github.com/users/kiminuo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kiminuo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kiminuo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kiminuo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r699444745"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/699444745"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Post-merge comment/question after stumbling upon this while looking at the test framework code:\r\n\r\nIs using 32 zero bytes instead of correct BIP341 behaviour (i.e. failing) intentional here ?\r\n\r\nThe code does not seem accidental, as it is not copied from legacy sighash function, and if I stick `assert 0` here, the test/functional/feature_taproot.py test fails, but it is not clear from the backtrace where exactly, a lot of `deep_eval()` in that backtrace.\r\n\r\nIf this is intentional, I think that a comment with explanation was in order here, to avoid confusion for the readers of the code.\r\n\r\nIf this was not intentional, then even if does not cause problems now, it might result in incorrect test behaviour in the future",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2021-08-31T15:34:49Z",
      "diff_hunk" : "@@ -738,3 +741,113 @@ def test_cscriptnum_encoding(self):\n         values = [0, 1, -1, -2, 127, 128, -255, 256, (1 << 15) - 1, -(1 << 16), (1 << 24) - 1, (1 << 31), 1 - (1 << 32), 1 << 40, 1500, -1500]\n         for value in values:\n             self.assertEqual(CScriptNum.decode(CScriptNum.encode(CScriptNum(value))), value)\n+\n+def TaprootSignatureHash(txTo, spent_utxos, hash_type, input_index = 0, scriptpath = False, script = CScript(), codeseparator_pos = -1, annex = None, leaf_ver = LEAF_VERSION_TAPSCRIPT):\n+    assert (len(txTo.vin) == len(spent_utxos))\n+    assert (input_index < len(txTo.vin))\n+    out_type = SIGHASH_ALL if hash_type == 0 else hash_type & 3\n+    in_type = hash_type & SIGHASH_ANYONECANPAY\n+    spk = spent_utxos[input_index].scriptPubKey\n+    ss = bytes([0, hash_type]) # epoch, hash_type\n+    ss += struct.pack(\"<i\", txTo.nVersion)\n+    ss += struct.pack(\"<I\", txTo.nLockTime)\n+    if in_type != SIGHASH_ANYONECANPAY:\n+        ss += sha256(b\"\".join(i.prevout.serialize() for i in txTo.vin))\n+        ss += sha256(b\"\".join(struct.pack(\"<q\", u.nValue) for u in spent_utxos))\n+        ss += sha256(b\"\".join(ser_string(u.scriptPubKey) for u in spent_utxos))\n+        ss += sha256(b\"\".join(struct.pack(\"<I\", i.nSequence) for i in txTo.vin))\n+    if out_type == SIGHASH_ALL:\n+        ss += sha256(b\"\".join(o.serialize() for o in txTo.vout))\n+    spend_type = 0\n+    if annex is not None:\n+        spend_type |= 1\n+    if (scriptpath):\n+        spend_type |= 2\n+    ss += bytes([spend_type])\n+    if in_type == SIGHASH_ANYONECANPAY:\n+        ss += txTo.vin[input_index].prevout.serialize()\n+        ss += struct.pack(\"<q\", spent_utxos[input_index].nValue)\n+        ss += ser_string(spk)\n+        ss += struct.pack(\"<I\", txTo.vin[input_index].nSequence)\n+    else:\n+        ss += struct.pack(\"<I\", input_index)\n+    if (spend_type & 1):\n+        ss += sha256(ser_string(annex))\n+    if out_type == SIGHASH_SINGLE:\n+        if input_index < len(txTo.vout):\n+            ss += sha256(txTo.vout[input_index].serialize())\n+        else:\n+            ss += bytes(0 for _ in range(32))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r699444745",
      "id" : 699444745,
      "line" : 780,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5OTQ0NDc0NQ==",
      "original_commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "original_line" : 780,
      "original_position" : 112,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/script.py",
      "position" : 112,
      "pull_request_review_id" : 742891715,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-31T15:34:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/699444745",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/43240089?v=4",
         "events_url" : "https://api.github.com/users/dgpv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dgpv/followers",
         "following_url" : "https://api.github.com/users/dgpv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dgpv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dgpv",
         "id" : 43240089,
         "login" : "dgpv",
         "node_id" : "MDQ6VXNlcjQzMjQwMDg5",
         "organizations_url" : "https://api.github.com/users/dgpv/orgs",
         "received_events_url" : "https://api.github.com/users/dgpv/received_events",
         "repos_url" : "https://api.github.com/users/dgpv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dgpv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dgpv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dgpv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r699594466"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/699594466"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "@sipa, can you please comment on this ?",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2021-08-31T18:57:47Z",
      "diff_hunk" : "@@ -738,3 +741,113 @@ def test_cscriptnum_encoding(self):\n         values = [0, 1, -1, -2, 127, 128, -255, 256, (1 << 15) - 1, -(1 << 16), (1 << 24) - 1, (1 << 31), 1 - (1 << 32), 1 << 40, 1500, -1500]\n         for value in values:\n             self.assertEqual(CScriptNum.decode(CScriptNum.encode(CScriptNum(value))), value)\n+\n+def TaprootSignatureHash(txTo, spent_utxos, hash_type, input_index = 0, scriptpath = False, script = CScript(), codeseparator_pos = -1, annex = None, leaf_ver = LEAF_VERSION_TAPSCRIPT):\n+    assert (len(txTo.vin) == len(spent_utxos))\n+    assert (input_index < len(txTo.vin))\n+    out_type = SIGHASH_ALL if hash_type == 0 else hash_type & 3\n+    in_type = hash_type & SIGHASH_ANYONECANPAY\n+    spk = spent_utxos[input_index].scriptPubKey\n+    ss = bytes([0, hash_type]) # epoch, hash_type\n+    ss += struct.pack(\"<i\", txTo.nVersion)\n+    ss += struct.pack(\"<I\", txTo.nLockTime)\n+    if in_type != SIGHASH_ANYONECANPAY:\n+        ss += sha256(b\"\".join(i.prevout.serialize() for i in txTo.vin))\n+        ss += sha256(b\"\".join(struct.pack(\"<q\", u.nValue) for u in spent_utxos))\n+        ss += sha256(b\"\".join(ser_string(u.scriptPubKey) for u in spent_utxos))\n+        ss += sha256(b\"\".join(struct.pack(\"<I\", i.nSequence) for i in txTo.vin))\n+    if out_type == SIGHASH_ALL:\n+        ss += sha256(b\"\".join(o.serialize() for o in txTo.vout))\n+    spend_type = 0\n+    if annex is not None:\n+        spend_type |= 1\n+    if (scriptpath):\n+        spend_type |= 2\n+    ss += bytes([spend_type])\n+    if in_type == SIGHASH_ANYONECANPAY:\n+        ss += txTo.vin[input_index].prevout.serialize()\n+        ss += struct.pack(\"<q\", spent_utxos[input_index].nValue)\n+        ss += ser_string(spk)\n+        ss += struct.pack(\"<I\", txTo.vin[input_index].nSequence)\n+    else:\n+        ss += struct.pack(\"<I\", input_index)\n+    if (spend_type & 1):\n+        ss += sha256(ser_string(annex))\n+    if out_type == SIGHASH_SINGLE:\n+        if input_index < len(txTo.vout):\n+            ss += sha256(txTo.vout[input_index].serialize())\n+        else:\n+            ss += bytes(0 for _ in range(32))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r699594466",
      "id" : 699594466,
      "in_reply_to_id" : 699444745,
      "line" : 780,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5OTU5NDQ2Ng==",
      "original_commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "original_line" : 780,
      "original_position" : 112,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/script.py",
      "position" : 112,
      "pull_request_review_id" : 743090610,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-31T18:57:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/699594466",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/43240089?v=4",
         "events_url" : "https://api.github.com/users/dgpv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dgpv/followers",
         "following_url" : "https://api.github.com/users/dgpv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dgpv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dgpv",
         "id" : 43240089,
         "login" : "dgpv",
         "node_id" : "MDQ6VXNlcjQzMjQwMDg5",
         "organizations_url" : "https://api.github.com/users/dgpv/orgs",
         "received_events_url" : "https://api.github.com/users/dgpv/received_events",
         "repos_url" : "https://api.github.com/users/dgpv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dgpv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dgpv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dgpv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r699774939"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/699774939"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think it's testing that a SIGHASH_SINGLE signature without a corresponding output will fail, even if you generate an otherwise reasonable looking signature. If you change it to `bytes(42 for _ in range(32))` rather than an `assert 0`, the tests will still pass, demonstrating the exact value used isn't important. (If you change the length to something other than 32, you'll get an assertion failure slightly later when the length of hashed data is tested)\r\n\r\nSee the `need_vin_vout_mismatch` argument to `make_spender()`, which is set to `True` in the \"Test SIGHASH_SINGLE behavior in combination with mismatching outputs\" section. If you disable those two spenders, then adding the `assert 0` when there isn't a corresponding output works fine.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2021-09-01T01:19:44Z",
      "diff_hunk" : "@@ -738,3 +741,113 @@ def test_cscriptnum_encoding(self):\n         values = [0, 1, -1, -2, 127, 128, -255, 256, (1 << 15) - 1, -(1 << 16), (1 << 24) - 1, (1 << 31), 1 - (1 << 32), 1 << 40, 1500, -1500]\n         for value in values:\n             self.assertEqual(CScriptNum.decode(CScriptNum.encode(CScriptNum(value))), value)\n+\n+def TaprootSignatureHash(txTo, spent_utxos, hash_type, input_index = 0, scriptpath = False, script = CScript(), codeseparator_pos = -1, annex = None, leaf_ver = LEAF_VERSION_TAPSCRIPT):\n+    assert (len(txTo.vin) == len(spent_utxos))\n+    assert (input_index < len(txTo.vin))\n+    out_type = SIGHASH_ALL if hash_type == 0 else hash_type & 3\n+    in_type = hash_type & SIGHASH_ANYONECANPAY\n+    spk = spent_utxos[input_index].scriptPubKey\n+    ss = bytes([0, hash_type]) # epoch, hash_type\n+    ss += struct.pack(\"<i\", txTo.nVersion)\n+    ss += struct.pack(\"<I\", txTo.nLockTime)\n+    if in_type != SIGHASH_ANYONECANPAY:\n+        ss += sha256(b\"\".join(i.prevout.serialize() for i in txTo.vin))\n+        ss += sha256(b\"\".join(struct.pack(\"<q\", u.nValue) for u in spent_utxos))\n+        ss += sha256(b\"\".join(ser_string(u.scriptPubKey) for u in spent_utxos))\n+        ss += sha256(b\"\".join(struct.pack(\"<I\", i.nSequence) for i in txTo.vin))\n+    if out_type == SIGHASH_ALL:\n+        ss += sha256(b\"\".join(o.serialize() for o in txTo.vout))\n+    spend_type = 0\n+    if annex is not None:\n+        spend_type |= 1\n+    if (scriptpath):\n+        spend_type |= 2\n+    ss += bytes([spend_type])\n+    if in_type == SIGHASH_ANYONECANPAY:\n+        ss += txTo.vin[input_index].prevout.serialize()\n+        ss += struct.pack(\"<q\", spent_utxos[input_index].nValue)\n+        ss += ser_string(spk)\n+        ss += struct.pack(\"<I\", txTo.vin[input_index].nSequence)\n+    else:\n+        ss += struct.pack(\"<I\", input_index)\n+    if (spend_type & 1):\n+        ss += sha256(ser_string(annex))\n+    if out_type == SIGHASH_SINGLE:\n+        if input_index < len(txTo.vout):\n+            ss += sha256(txTo.vout[input_index].serialize())\n+        else:\n+            ss += bytes(0 for _ in range(32))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r699774939",
      "id" : 699774939,
      "in_reply_to_id" : 699444745,
      "line" : 780,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5OTc3NDkzOQ==",
      "original_commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "original_line" : 780,
      "original_position" : 112,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/script.py",
      "position" : 112,
      "pull_request_review_id" : 743316702,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-09-01T01:19:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/699774939",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r699885812"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/699885812"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "It is very much looks like you are correct, these two tests depend on this behavior of `TaprootSignatureHash`.\r\n\r\nWithout any comment explaining this, It will confuse people who read only a part of the code. Some people might copy that code and have problems later. I only cross-referenced this code with C++ implementation in Core while writing my own implementation in python, but I think it is definitely a possibility that someone may just copy the whole `TaprootSignatureHash`, and maybe even without looking at the comments. Other possibility might be that `TaprootSignatureHash` is reused for some another purpose inside the test framework without taking this behavior into account.\r\n\r\nMight it be better to just do `add_spender( ... , failure={\"hashtype_actual\": hashtype, \"sighash\": lambda(ctx): b\"\\x00\"*32}, ... )` for these two tests ? It is not that `TaprootSignatureHash` itself is tested here, AFAIU, and expected behavior is incorrect hash returned, so why not just return it right away ? Alternative might be a special flag in the context \"invalid sighash expected instead of failure\". Or at least a comment with explanation inside `TaprootSignatureHash`, to spare readers from confusion.",
      "commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "created_at" : "2021-09-01T06:35:53Z",
      "diff_hunk" : "@@ -738,3 +741,113 @@ def test_cscriptnum_encoding(self):\n         values = [0, 1, -1, -2, 127, 128, -255, 256, (1 << 15) - 1, -(1 << 16), (1 << 24) - 1, (1 << 31), 1 - (1 << 32), 1 << 40, 1500, -1500]\n         for value in values:\n             self.assertEqual(CScriptNum.decode(CScriptNum.encode(CScriptNum(value))), value)\n+\n+def TaprootSignatureHash(txTo, spent_utxos, hash_type, input_index = 0, scriptpath = False, script = CScript(), codeseparator_pos = -1, annex = None, leaf_ver = LEAF_VERSION_TAPSCRIPT):\n+    assert (len(txTo.vin) == len(spent_utxos))\n+    assert (input_index < len(txTo.vin))\n+    out_type = SIGHASH_ALL if hash_type == 0 else hash_type & 3\n+    in_type = hash_type & SIGHASH_ANYONECANPAY\n+    spk = spent_utxos[input_index].scriptPubKey\n+    ss = bytes([0, hash_type]) # epoch, hash_type\n+    ss += struct.pack(\"<i\", txTo.nVersion)\n+    ss += struct.pack(\"<I\", txTo.nLockTime)\n+    if in_type != SIGHASH_ANYONECANPAY:\n+        ss += sha256(b\"\".join(i.prevout.serialize() for i in txTo.vin))\n+        ss += sha256(b\"\".join(struct.pack(\"<q\", u.nValue) for u in spent_utxos))\n+        ss += sha256(b\"\".join(ser_string(u.scriptPubKey) for u in spent_utxos))\n+        ss += sha256(b\"\".join(struct.pack(\"<I\", i.nSequence) for i in txTo.vin))\n+    if out_type == SIGHASH_ALL:\n+        ss += sha256(b\"\".join(o.serialize() for o in txTo.vout))\n+    spend_type = 0\n+    if annex is not None:\n+        spend_type |= 1\n+    if (scriptpath):\n+        spend_type |= 2\n+    ss += bytes([spend_type])\n+    if in_type == SIGHASH_ANYONECANPAY:\n+        ss += txTo.vin[input_index].prevout.serialize()\n+        ss += struct.pack(\"<q\", spent_utxos[input_index].nValue)\n+        ss += ser_string(spk)\n+        ss += struct.pack(\"<I\", txTo.vin[input_index].nSequence)\n+    else:\n+        ss += struct.pack(\"<I\", input_index)\n+    if (spend_type & 1):\n+        ss += sha256(ser_string(annex))\n+    if out_type == SIGHASH_SINGLE:\n+        if input_index < len(txTo.vout):\n+            ss += sha256(txTo.vout[input_index].serialize())\n+        else:\n+            ss += bytes(0 for _ in range(32))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19953#discussion_r699885812",
      "id" : 699885812,
      "in_reply_to_id" : 699444745,
      "line" : 780,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5OTg4NTgxMg==",
      "original_commit_id" : "0e2a5e448f426219a6464b9aaadcc715534114e6",
      "original_line" : 780,
      "original_position" : 112,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/script.py",
      "position" : 112,
      "pull_request_review_id" : 743517815,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19953",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-09-01T07:25:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/699885812",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/43240089?v=4",
         "events_url" : "https://api.github.com/users/dgpv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dgpv/followers",
         "following_url" : "https://api.github.com/users/dgpv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dgpv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dgpv",
         "id" : 43240089,
         "login" : "dgpv",
         "node_id" : "MDQ6VXNlcjQzMjQwMDg5",
         "organizations_url" : "https://api.github.com/users/dgpv/orgs",
         "received_events_url" : "https://api.github.com/users/dgpv/received_events",
         "repos_url" : "https://api.github.com/users/dgpv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dgpv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dgpv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dgpv"
      }
   }
]
