[
   {
      "body" : "Nice!\r\nconceptual ACK.\r\nHave plans to test this soon.",
      "created_at" : "2015-04-07T18:29:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/5981#issuecomment-90690851",
      "id" : 90690851,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/5981",
      "updated_at" : "2015-04-07T18:29:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/90690851",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "Nice work!\r\n\r\n> I forgot to mention that I use py-leveldb in blockstore.py\r\n\r\nI'd rather not add any external dependencies for the tests. Do we need any kind of persistent block storage in the tests? If we really do, I'd rather hack something together with python.\r\n",
      "created_at" : "2015-04-08T06:24:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/5981#issuecomment-90818710",
      "id" : 90818710,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/5981",
      "updated_at" : "2015-04-08T06:24:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/90818710",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "@laanwj I'd prefer to leave the disk-backed storage there, even though it's probably not needed for the existing tests I've included in this pull, because it will be needed to write longer tests like the comparison test which currently runs in the pull-tester.  \r\n\r\nI pushed up a commit that replaces leveldb with dbm, which I believe is a standard python package; does that seem like an acceptable option?\r\n\r\n\r\n",
      "created_at" : "2015-04-09T14:38:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/5981#issuecomment-91250482",
      "id" : 91250482,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/5981",
      "updated_at" : "2015-04-09T14:38:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/91250482",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "body" : "Sure, using a python standard package is fine, my gripe was with using an external dependency. Using disk-backed storage is no problem as long as subsequent tests don't interfere with each other.",
      "created_at" : "2015-04-09T15:42:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/5981#issuecomment-91267882",
      "id" : 91267882,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/5981",
      "updated_at" : "2015-04-09T15:42:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/91267882",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "Maybe add the new tests (whenever they don't take too long) to the pull tester e.g. `qa/pull-tester/rpc-tests.sh`. For example `invalidblockrequest.py` seems to finish quickly.\r\n\r\nThe `bipdersig-p2p.py` test seems to hang indefinitely here at:\r\n```\r\nInitializing test directory /tmp/testBxTNIB\r\nMiniNode: Connecting to Bitcoin Node IP # 127.0.0.1:11916\r\nTest 1: PASS [98]\r\n```",
      "created_at" : "2015-04-16T09:33:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/5981#issuecomment-93691785",
      "id" : 93691785,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/5981",
      "updated_at" : "2015-04-16T09:34:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/93691785",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "@laanwj  The ```bipdersig-p2p.py``` test was failing because this needed rebase, due to the ```setgenerate ()```/```generate()``` regtest rpc change (now fixed).\r\n\r\nI've also shortened ```maxblocksinflight.py```, and added both it and ```invalidblockrequest.py``` to the pull tester's rpc tests.\r\n\r\nEDIT: I see that this errored out in travis; will investigate.",
      "created_at" : "2015-04-17T17:39:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/5981#issuecomment-94035406",
      "id" : 94035406,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/5981",
      "updated_at" : "2015-04-17T23:48:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/94035406",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "body" : "Ah yes, the `generate` switcharoo. I think we should add an explicit error when setgenerate() is used on regtest, so that bugs like this are tripped up immediately instead of through vague timeouts.\r\n\r\nThe travis error seems to occur on 64-bit Linux - no detailed information unfortunately\r\n```\r\nRunning testscript maxblocksinflight.py...\r\n\r\nInitializing test directory /tmp/testIyXJqc\r\n\r\nNo output has been received in the last 10 minutes, this potentially indicates a stalled build or something wrong with the build itself.\r\n```\r\n",
      "created_at" : "2015-04-21T08:05:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/5981#issuecomment-94693113",
      "id" : 94693113,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/5981",
      "updated_at" : "2015-04-21T08:05:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/94693113",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "I'd really like to merge this. Do you have trouble solving the travis error? If so, maybe @theuni can help.",
      "created_at" : "2015-04-28T08:24:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/5981#issuecomment-96971436",
      "id" : 96971436,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/5981",
      "updated_at" : "2015-04-28T08:24:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/96971436",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "This needed to be rebased anyway, so I did that and now travis succeeds.  I'm not sure what to make of that, since I didn't actually fix anything, and it seems odd to think that this was just a spurious travis failure that happened to only affect a new test I've introduced in this pull.\r\n\r\nI'll try rebasing again, since I wanted to fold the 4th and 5th commits in anyway, and when I push we'll get one more data point about how travis does with the new tests.",
      "created_at" : "2015-04-28T16:35:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/5981#issuecomment-97129316",
      "id" : 97129316,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/5981",
      "updated_at" : "2015-04-28T16:35:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/97129316",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "body" : "Well, on the first attempt, travis failed again with the 10-minute no-data-received timeout, but this time it was not involving the new p2p tests (it died while the java comparison tool was running).  I amended the last commit to force a re-run, and it ran successfully, so now I am a little more willing to believe that these may just be random travis failures that I'm encountering, and not a problem in the code introduced here.",
      "created_at" : "2015-04-28T19:56:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/5981#issuecomment-97187422",
      "id" : 97187422,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/5981",
      "updated_at" : "2015-04-28T19:56:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/97187422",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "body" : "I came too late.. what was the original error?\r\nEdit: nevermind, posted same time.",
      "created_at" : "2015-04-28T20:00:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/5981#issuecomment-97188898",
      "id" : 97188898,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/5981",
      "updated_at" : "2015-04-28T20:01:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/97188898",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "body" : "After discussing with @theuni on IRC, I added a commit that adds some optional debugging (which I enabled for travis) to calls to bitcoin-cli -rpcwait (inside util.py), and then another addressing the bug he caught with the default binary names.",
      "created_at" : "2015-04-29T14:57:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/5981#issuecomment-97456630",
      "id" : 97456630,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/5981",
      "updated_at" : "2015-04-29T14:57:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/97456630",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "body" : "ACK",
      "created_at" : "2015-04-29T16:03:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/5981#issuecomment-97481378",
      "id" : 97481378,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/5981",
      "updated_at" : "2015-04-29T16:03:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/97481378",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "1st: this is impressive work. Nice!\r\nI think the quick merge honors this job.\r\n\r\nNevertheless here are some first post-ACK reports (more detailed report will follow):\r\n\r\nRunning `maxblocksinflight.py` does fail on my local machine:\r\n```\r\nRunning testscript maxblocksinflight.py...\r\nInitializing test directory /var/folders/hp/kb9p9q8x4k3_z_ccy588hxrc0000gn/T/testVtWBqX\r\nMiniNode: Connecting to Bitcoin Node IP # 127.0.0.1:11650\r\nRound 0: success (total requests: 8)\r\nRound 1: success (total requests: 16)\r\nRound 2: success (total requests: 16)\r\nRound 3: success (total requests: 16)\r\nStopping nodes\r\nException in thread Thread-1:\r\nTraceback (most recent call last):\r\n  File \"/usr/local/Cellar/python/2.7.8_2/Frameworks/Python.framework/Versions/2.7/lib/python2.7/threading.py\", line 810, in __bootstrap_inner\r\n    self.run()\r\n  File \"/Users/jonasschnelli/Documents/bitcoin/_bitcoin/qa/rpc-tests/mininode.py\", line 1237, in run\r\n    asyncore.loop(0.1, True)\r\n  File \"/usr/local/Cellar/python/2.7.8_2/Frameworks/Python.framework/Versions/2.7/lib/python2.7/asyncore.py\", line 216, in loop\r\n    poll_fun(timeout, map)\r\n  File \"/usr/local/Cellar/python/2.7.8_2/Frameworks/Python.framework/Versions/2.7/lib/python2.7/asyncore.py\", line 145, in poll\r\n    r, w, e = select.select(r, w, e, timeout)\r\nerror: (9, 'Bad file descriptor')\r\n```\r\n\r\nsame for invalidblockrequest.py\r\n```\r\nRunning testscript invalidblockrequest.py...\r\nInitializing test directory /var/folders/hp/kb9p9q8x4k3_z_ccy588hxrc0000gn/T/testqJOevS\r\nMiniNode: Connecting to Bitcoin Node IP # 127.0.0.1:11506\r\nTest 1: PASS [1]\r\nTest 2: PASS [101]\r\nAssertion failed: Test failed at test 3\r\n  File \"/Users/jonasschnelli/Documents/bitcoin/_bitcoin/qa/rpc-tests/test_framework.py\", line 119, in main\r\n    self.run_test()\r\n  File \"/Users/jonasschnelli/Documents/bitcoin/_bitcoin/qa/rpc-tests/invalidblockrequest.py\", line 39, in run_test\r\n    test.run()\r\n  File \"/Users/jonasschnelli/Documents/bitcoin/_bitcoin/qa/rpc-tests/comptool.py\", line 284, in run\r\n    raise AssertionError(\"Test failed at test %d\" % test_number)\r\nStopping nodes\r\n```",
      "created_at" : "2015-04-30T13:06:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/5981#issuecomment-97767685",
      "id" : 97767685,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/5981",
      "updated_at" : "2015-04-30T13:06:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/97767685",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/5981#discussion_r29428834"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/5981"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/29428834"
         }
      },
      "body" : "Is it somehow possible to set this to 2 if `--refbinary` is set?",
      "commit_id" : "2703412a39c95c811a40c3fff6929e4ce59c3c62",
      "created_at" : "2015-04-30T13:31:39Z",
      "diff_hunk" : "@@ -0,0 +1,115 @@\n+#!/usr/bin/env python2\n+#\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+\n+from test_framework import ComparisonTestFramework\n+from util import *\n+from comptool import TestManager, TestInstance\n+from mininode import *\n+from blocktools import *\n+import logging\n+import copy\n+import time\n+\n+\n+'''\n+In this test we connect to one node over p2p, and test block requests:\n+1) Valid blocks should be requested and become chain tip.\n+2) Invalid block with duplicated transaction should be re-requested.\n+3) Invalid block with bad coinbase value should be rejected and not\n+re-requested.\n+'''\n+\n+# Use the ComparisonTestFramework with 1 node: only use --testbinary.\n+class InvalidBlockRequestTest(ComparisonTestFramework):\n+\n+    ''' Can either run this test as 1 node with expected answers, or two and compare them. \n+        Change the \"outcome\" variable from each TestInstance object to only do the comparison. '''\n+    def __init__(self):\n+        self.num_nodes = 1",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/5981#discussion_r29428834",
      "id" : 29428834,
      "original_commit_id" : "2703412a39c95c811a40c3fff6929e4ce59c3c62",
      "original_position" : 31,
      "path" : "qa/rpc-tests/invalidblockrequest.py",
      "position" : 31,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/5981",
      "updated_at" : "2015-04-30T13:31:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/29428834",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "@jonasschnelli  Thanks, and thanks for running the tests too.  Looks to me like the first error message is happening in how the test cleans up, that probably just needs to be made more robust; I'll take a look.  The second error message is more concerning though, as the substantive part of the test is failing.  \r\n\r\nCould you run ```invalidblockrequest.py --tracerpc``` (which will produce a lot of debug output, basically every p2p message sent or received, along with the rpc calls) and upload it somewhere for me to analyze?   That should help me debug what's going on here.",
      "created_at" : "2015-04-30T13:38:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/5981#issuecomment-97793718",
      "id" : 97793718,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/5981",
      "updated_at" : "2015-04-30T13:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/97793718",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/5981#discussion_r29433660"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/5981"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/29433660"
         }
      },
      "body" : "After discussion this on IRC it turned out, that OSes without polling support (OSX) have problems with timeouts below 1 because they always use `select.select()`.\r\nShould be changed to `asyncore.loop(1, True)`",
      "commit_id" : "2703412a39c95c811a40c3fff6929e4ce59c3c62",
      "created_at" : "2015-04-30T14:25:21Z",
      "diff_hunk" : "@@ -0,0 +1,1247 @@\n+# mininode.py - Bitcoin P2P network half-a-node\n+#\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#\n+# This python code was modified from ArtForz' public domain  half-a-node, as\n+# found in the mini-node branch of http://github.com/jgarzik/pynode.\n+#\n+# NodeConn: an object which manages p2p connectivity to a bitcoin node\n+# NodeConnCB: a base class that describes the interface for receiving\n+#             callbacks with network messages from a NodeConn\n+# CBlock, CTransaction, CBlockHeader, CTxIn, CTxOut, etc....:\n+#     data structures that should map to corresponding structures in\n+#     bitcoin/primitives\n+# msg_block, msg_tx, msg_headers, etc.:\n+#     data structures that represent network messages\n+# ser_*, deser_*: functions that handle serialization/deserialization\n+\n+\n+import struct\n+import socket\n+import asyncore\n+import binascii\n+import time\n+import sys\n+import random\n+import cStringIO\n+import hashlib\n+from threading import Lock\n+from threading import Thread\n+import logging\n+import copy\n+\n+BIP0031_VERSION = 60000\n+MY_VERSION = 60001  # past bip-31 for ping/pong\n+MY_SUBVERSION = \"/python-mininode-tester:0.0.1/\"\n+\n+MAX_INV_SZ = 50000\n+\n+# Serialization/deserialization tools\n+def sha256(s):\n+    return hashlib.new('sha256', s).digest()\n+\n+\n+def hash256(s):\n+    return sha256(sha256(s))\n+\n+\n+def deser_string(f):\n+    nit = struct.unpack(\"<B\", f.read(1))[0]\n+    if nit == 253:\n+        nit = struct.unpack(\"<H\", f.read(2))[0]\n+    elif nit == 254:\n+        nit = struct.unpack(\"<I\", f.read(4))[0]\n+    elif nit == 255:\n+        nit = struct.unpack(\"<Q\", f.read(8))[0]\n+    return f.read(nit)\n+\n+\n+def ser_string(s):\n+    if len(s) < 253:\n+        return chr(len(s)) + s\n+    elif len(s) < 0x10000:\n+        return chr(253) + struct.pack(\"<H\", len(s)) + s\n+    elif len(s) < 0x100000000L:\n+        return chr(254) + struct.pack(\"<I\", len(s)) + s\n+    return chr(255) + struct.pack(\"<Q\", len(s)) + s\n+\n+\n+def deser_uint256(f):\n+    r = 0L\n+    for i in xrange(8):\n+        t = struct.unpack(\"<I\", f.read(4))[0]\n+        r += t << (i * 32)\n+    return r\n+\n+\n+def ser_uint256(u):\n+    rs = \"\"\n+    for i in xrange(8):\n+        rs += struct.pack(\"<I\", u & 0xFFFFFFFFL)\n+        u >>= 32\n+    return rs\n+\n+\n+def uint256_from_str(s):\n+    r = 0L\n+    t = struct.unpack(\"<IIIIIIII\", s[:32])\n+    for i in xrange(8):\n+        r += t[i] << (i * 32)\n+    return r\n+\n+\n+def uint256_from_compact(c):\n+    nbytes = (c >> 24) & 0xFF\n+    v = (c & 0xFFFFFFL) << (8 * (nbytes - 3))\n+    return v\n+\n+\n+def deser_vector(f, c):\n+    nit = struct.unpack(\"<B\", f.read(1))[0]\n+    if nit == 253:\n+        nit = struct.unpack(\"<H\", f.read(2))[0]\n+    elif nit == 254:\n+        nit = struct.unpack(\"<I\", f.read(4))[0]\n+    elif nit == 255:\n+        nit = struct.unpack(\"<Q\", f.read(8))[0]\n+    r = []\n+    for i in xrange(nit):\n+        t = c()\n+        t.deserialize(f)\n+        r.append(t)\n+    return r\n+\n+\n+def ser_vector(l):\n+    r = \"\"\n+    if len(l) < 253:\n+        r = chr(len(l))\n+    elif len(l) < 0x10000:\n+        r = chr(253) + struct.pack(\"<H\", len(l))\n+    elif len(l) < 0x100000000L:\n+        r = chr(254) + struct.pack(\"<I\", len(l))\n+    else:\n+        r = chr(255) + struct.pack(\"<Q\", len(l))\n+    for i in l:\n+        r += i.serialize()\n+    return r\n+\n+\n+def deser_uint256_vector(f):\n+    nit = struct.unpack(\"<B\", f.read(1))[0]\n+    if nit == 253:\n+        nit = struct.unpack(\"<H\", f.read(2))[0]\n+    elif nit == 254:\n+        nit = struct.unpack(\"<I\", f.read(4))[0]\n+    elif nit == 255:\n+        nit = struct.unpack(\"<Q\", f.read(8))[0]\n+    r = []\n+    for i in xrange(nit):\n+        t = deser_uint256(f)\n+        r.append(t)\n+    return r\n+\n+\n+def ser_uint256_vector(l):\n+    r = \"\"\n+    if len(l) < 253:\n+        r = chr(len(l))\n+    elif len(l) < 0x10000:\n+        r = chr(253) + struct.pack(\"<H\", len(l))\n+    elif len(l) < 0x100000000L:\n+        r = chr(254) + struct.pack(\"<I\", len(l))\n+    else:\n+        r = chr(255) + struct.pack(\"<Q\", len(l))\n+    for i in l:\n+        r += ser_uint256(i)\n+    return r\n+\n+\n+def deser_string_vector(f):\n+    nit = struct.unpack(\"<B\", f.read(1))[0]\n+    if nit == 253:\n+        nit = struct.unpack(\"<H\", f.read(2))[0]\n+    elif nit == 254:\n+        nit = struct.unpack(\"<I\", f.read(4))[0]\n+    elif nit == 255:\n+        nit = struct.unpack(\"<Q\", f.read(8))[0]\n+    r = []\n+    for i in xrange(nit):\n+        t = deser_string(f)\n+        r.append(t)\n+    return r\n+\n+\n+def ser_string_vector(l):\n+    r = \"\"\n+    if len(l) < 253:\n+        r = chr(len(l))\n+    elif len(l) < 0x10000:\n+        r = chr(253) + struct.pack(\"<H\", len(l))\n+    elif len(l) < 0x100000000L:\n+        r = chr(254) + struct.pack(\"<I\", len(l))\n+    else:\n+        r = chr(255) + struct.pack(\"<Q\", len(l))\n+    for sv in l:\n+        r += ser_string(sv)\n+    return r\n+\n+\n+def deser_int_vector(f):\n+    nit = struct.unpack(\"<B\", f.read(1))[0]\n+    if nit == 253:\n+        nit = struct.unpack(\"<H\", f.read(2))[0]\n+    elif nit == 254:\n+        nit = struct.unpack(\"<I\", f.read(4))[0]\n+    elif nit == 255:\n+        nit = struct.unpack(\"<Q\", f.read(8))[0]\n+    r = []\n+    for i in xrange(nit):\n+        t = struct.unpack(\"<i\", f.read(4))[0]\n+        r.append(t)\n+    return r\n+\n+\n+def ser_int_vector(l):\n+    r = \"\"\n+    if len(l) < 253:\n+        r = chr(len(l))\n+    elif len(l) < 0x10000:\n+        r = chr(253) + struct.pack(\"<H\", len(l))\n+    elif len(l) < 0x100000000L:\n+        r = chr(254) + struct.pack(\"<I\", len(l))\n+    else:\n+        r = chr(255) + struct.pack(\"<Q\", len(l))\n+    for i in l:\n+        r += struct.pack(\"<i\", i)\n+    return r\n+\n+\n+# Objects that map to bitcoind objects, which can be serialized/deserialized\n+\n+class CAddress(object):\n+    def __init__(self):\n+        self.nServices = 1\n+        self.pchReserved = \"\\x00\" * 10 + \"\\xff\" * 2\n+        self.ip = \"0.0.0.0\"\n+        self.port = 0\n+\n+    def deserialize(self, f):\n+        self.nServices = struct.unpack(\"<Q\", f.read(8))[0]\n+        self.pchReserved = f.read(12)\n+        self.ip = socket.inet_ntoa(f.read(4))\n+        self.port = struct.unpack(\">H\", f.read(2))[0]\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += struct.pack(\"<Q\", self.nServices)\n+        r += self.pchReserved\n+        r += socket.inet_aton(self.ip)\n+        r += struct.pack(\">H\", self.port)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CAddress(nServices=%i ip=%s port=%i)\" % (self.nServices,\n+                                                         self.ip, self.port)\n+\n+\n+class CInv(object):\n+    typemap = {\n+        0: \"Error\",\n+        1: \"TX\",\n+        2: \"Block\"}\n+\n+    def __init__(self, t=0, h=0L):\n+        self.type = t\n+        self.hash = h\n+\n+    def deserialize(self, f):\n+        self.type = struct.unpack(\"<i\", f.read(4))[0]\n+        self.hash = deser_uint256(f)\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += struct.pack(\"<i\", self.type)\n+        r += ser_uint256(self.hash)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CInv(type=%s hash=%064x)\" \\\n+            % (self.typemap[self.type], self.hash)\n+\n+\n+class CBlockLocator(object):\n+    def __init__(self):\n+        self.nVersion = MY_VERSION\n+        self.vHave = []\n+\n+    def deserialize(self, f):\n+        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n+        self.vHave = deser_uint256_vector(f)\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += struct.pack(\"<i\", self.nVersion)\n+        r += ser_uint256_vector(self.vHave)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CBlockLocator(nVersion=%i vHave=%s)\" \\\n+            % (self.nVersion, repr(self.vHave))\n+\n+\n+class COutPoint(object):\n+    def __init__(self, hash=0, n=0):\n+        self.hash = hash\n+        self.n = n\n+\n+    def deserialize(self, f):\n+        self.hash = deser_uint256(f)\n+        self.n = struct.unpack(\"<I\", f.read(4))[0]\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += ser_uint256(self.hash)\n+        r += struct.pack(\"<I\", self.n)\n+        return r\n+\n+    def __repr__(self):\n+        return \"COutPoint(hash=%064x n=%i)\" % (self.hash, self.n)\n+\n+\n+class CTxIn(object):\n+    def __init__(self, outpoint=None, scriptSig=\"\", nSequence=0):\n+        if outpoint is None:\n+            self.prevout = COutPoint()\n+        else:\n+            self.prevout = outpoint\n+        self.scriptSig = scriptSig\n+        self.nSequence = nSequence\n+\n+    def deserialize(self, f):\n+        self.prevout = COutPoint()\n+        self.prevout.deserialize(f)\n+        self.scriptSig = deser_string(f)\n+        self.nSequence = struct.unpack(\"<I\", f.read(4))[0]\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += self.prevout.serialize()\n+        r += ser_string(self.scriptSig)\n+        r += struct.pack(\"<I\", self.nSequence)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CTxIn(prevout=%s scriptSig=%s nSequence=%i)\" \\\n+            % (repr(self.prevout), binascii.hexlify(self.scriptSig),\n+               self.nSequence)\n+\n+\n+class CTxOut(object):\n+    def __init__(self, nValue=0, scriptPubKey=\"\"):\n+        self.nValue = nValue\n+        self.scriptPubKey = scriptPubKey\n+\n+    def deserialize(self, f):\n+        self.nValue = struct.unpack(\"<q\", f.read(8))[0]\n+        self.scriptPubKey = deser_string(f)\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += struct.pack(\"<q\", self.nValue)\n+        r += ser_string(self.scriptPubKey)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CTxOut(nValue=%i.%08i scriptPubKey=%s)\" \\\n+            % (self.nValue // 100000000, self.nValue % 100000000,\n+               binascii.hexlify(self.scriptPubKey))\n+\n+\n+class CTransaction(object):\n+    def __init__(self, tx=None):\n+        if tx is None:\n+            self.nVersion = 1\n+            self.vin = []\n+            self.vout = []\n+            self.nLockTime = 0\n+            self.sha256 = None\n+            self.hash = None\n+        else:\n+            self.nVersion = tx.nVersion\n+            self.vin = copy.deepcopy(tx.vin)\n+            self.vout = copy.deepcopy(tx.vout)\n+            self.nLockTime = tx.nLockTime\n+            self.sha256 = None\n+            self.hash = None\n+\n+    def deserialize(self, f):\n+        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n+        self.vin = deser_vector(f, CTxIn)\n+        self.vout = deser_vector(f, CTxOut)\n+        self.nLockTime = struct.unpack(\"<I\", f.read(4))[0]\n+        self.sha256 = None\n+        self.hash = None\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += struct.pack(\"<i\", self.nVersion)\n+        r += ser_vector(self.vin)\n+        r += ser_vector(self.vout)\n+        r += struct.pack(\"<I\", self.nLockTime)\n+        return r\n+\n+    def rehash(self):\n+        self.sha256 = None\n+        self.calc_sha256()\n+\n+    def calc_sha256(self):\n+        if self.sha256 is None:\n+            self.sha256 = uint256_from_str(hash256(self.serialize()))\n+        self.hash = hash256(self.serialize())[::-1].encode('hex_codec')\n+\n+    def is_valid(self):\n+        self.calc_sha256()\n+        for tout in self.vout:\n+            if tout.nValue < 0 or tout.nValue > 21000000L * 100000000L:\n+                return False\n+        return True\n+\n+    def __repr__(self):\n+        return \"CTransaction(nVersion=%i vin=%s vout=%s nLockTime=%i)\" \\\n+            % (self.nVersion, repr(self.vin), repr(self.vout), self.nLockTime)\n+\n+\n+class CBlockHeader(object):\n+    def __init__(self, header=None):\n+        if header is None:\n+            self.set_null()\n+        else:\n+            self.nVersion = header.nVersion\n+            self.hashPrevBlock = header.hashPrevBlock\n+            self.hashMerkleRoot = header.hashMerkleRoot\n+            self.nTime = header.nTime\n+            self.nBits = header.nBits\n+            self.nNonce = header.nNonce\n+            self.sha256 = header.sha256\n+            self.hash = header.hash\n+            self.calc_sha256()\n+\n+    def set_null(self):\n+        self.nVersion = 1\n+        self.hashPrevBlock = 0\n+        self.hashMerkleRoot = 0\n+        self.nTime = 0\n+        self.nBits = 0\n+        self.nNonce = 0\n+        self.sha256 = None\n+        self.hash = None\n+\n+    def deserialize(self, f):\n+        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n+        self.hashPrevBlock = deser_uint256(f)\n+        self.hashMerkleRoot = deser_uint256(f)\n+        self.nTime = struct.unpack(\"<I\", f.read(4))[0]\n+        self.nBits = struct.unpack(\"<I\", f.read(4))[0]\n+        self.nNonce = struct.unpack(\"<I\", f.read(4))[0]\n+        self.sha256 = None\n+        self.hash = None\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += struct.pack(\"<i\", self.nVersion)\n+        r += ser_uint256(self.hashPrevBlock)\n+        r += ser_uint256(self.hashMerkleRoot)\n+        r += struct.pack(\"<I\", self.nTime)\n+        r += struct.pack(\"<I\", self.nBits)\n+        r += struct.pack(\"<I\", self.nNonce)\n+        return r\n+\n+    def calc_sha256(self):\n+        if self.sha256 is None:\n+            r = \"\"\n+            r += struct.pack(\"<i\", self.nVersion)\n+            r += ser_uint256(self.hashPrevBlock)\n+            r += ser_uint256(self.hashMerkleRoot)\n+            r += struct.pack(\"<I\", self.nTime)\n+            r += struct.pack(\"<I\", self.nBits)\n+            r += struct.pack(\"<I\", self.nNonce)\n+            self.sha256 = uint256_from_str(hash256(r))\n+            self.hash = hash256(r)[::-1].encode('hex_codec')\n+\n+    def rehash(self):\n+        self.sha256 = None\n+        self.calc_sha256()\n+        return self.sha256\n+\n+    def __repr__(self):\n+        return \"CBlockHeader(nVersion=%i hashPrevBlock=%064x hashMerkleRoot=%064x nTime=%s nBits=%08x nNonce=%08x)\" \\\n+            % (self.nVersion, self.hashPrevBlock, self.hashMerkleRoot,\n+               time.ctime(self.nTime), self.nBits, self.nNonce)\n+\n+\n+class CBlock(CBlockHeader):\n+    def __init__(self, header=None):\n+        super(CBlock, self).__init__(header)\n+        self.vtx = []\n+\n+    def deserialize(self, f):\n+        super(CBlock, self).deserialize(f)\n+        self.vtx = deser_vector(f, CTransaction)\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += super(CBlock, self).serialize()\n+        r += ser_vector(self.vtx)\n+        return r\n+\n+    def calc_merkle_root(self):\n+        hashes = []\n+        for tx in self.vtx:\n+            tx.calc_sha256()\n+            hashes.append(ser_uint256(tx.sha256))\n+        while len(hashes) > 1:\n+            newhashes = []\n+            for i in xrange(0, len(hashes), 2):\n+                i2 = min(i+1, len(hashes)-1)\n+                newhashes.append(hash256(hashes[i] + hashes[i2]))\n+            hashes = newhashes\n+        return uint256_from_str(hashes[0])\n+\n+    def is_valid(self):\n+        self.calc_sha256()\n+        target = uint256_from_compact(self.nBits)\n+        if self.sha256 > target:\n+            return False\n+        for tx in self.vtx:\n+            if not tx.is_valid():\n+                return False\n+        if self.calc_merkle_root() != self.hashMerkleRoot:\n+            return False\n+        return True\n+\n+    def solve(self):\n+        self.calc_sha256()\n+        target = uint256_from_compact(self.nBits)\n+        while self.sha256 > target:\n+            self.nNonce += 1\n+            self.rehash()\n+\n+    def __repr__(self):\n+        return \"CBlock(nVersion=%i hashPrevBlock=%064x hashMerkleRoot=%064x nTime=%s nBits=%08x nNonce=%08x vtx=%s)\" \\\n+            % (self.nVersion, self.hashPrevBlock, self.hashMerkleRoot,\n+               time.ctime(self.nTime), self.nBits, self.nNonce, repr(self.vtx))\n+\n+\n+class CUnsignedAlert(object):\n+    def __init__(self):\n+        self.nVersion = 1\n+        self.nRelayUntil = 0\n+        self.nExpiration = 0\n+        self.nID = 0\n+        self.nCancel = 0\n+        self.setCancel = []\n+        self.nMinVer = 0\n+        self.nMaxVer = 0\n+        self.setSubVer = []\n+        self.nPriority = 0\n+        self.strComment = \"\"\n+        self.strStatusBar = \"\"\n+        self.strReserved = \"\"\n+\n+    def deserialize(self, f):\n+        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n+        self.nRelayUntil = struct.unpack(\"<q\", f.read(8))[0]\n+        self.nExpiration = struct.unpack(\"<q\", f.read(8))[0]\n+        self.nID = struct.unpack(\"<i\", f.read(4))[0]\n+        self.nCancel = struct.unpack(\"<i\", f.read(4))[0]\n+        self.setCancel = deser_int_vector(f)\n+        self.nMinVer = struct.unpack(\"<i\", f.read(4))[0]\n+        self.nMaxVer = struct.unpack(\"<i\", f.read(4))[0]\n+        self.setSubVer = deser_string_vector(f)\n+        self.nPriority = struct.unpack(\"<i\", f.read(4))[0]\n+        self.strComment = deser_string(f)\n+        self.strStatusBar = deser_string(f)\n+        self.strReserved = deser_string(f)\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += struct.pack(\"<i\", self.nVersion)\n+        r += struct.pack(\"<q\", self.nRelayUntil)\n+        r += struct.pack(\"<q\", self.nExpiration)\n+        r += struct.pack(\"<i\", self.nID)\n+        r += struct.pack(\"<i\", self.nCancel)\n+        r += ser_int_vector(self.setCancel)\n+        r += struct.pack(\"<i\", self.nMinVer)\n+        r += struct.pack(\"<i\", self.nMaxVer)\n+        r += ser_string_vector(self.setSubVer)\n+        r += struct.pack(\"<i\", self.nPriority)\n+        r += ser_string(self.strComment)\n+        r += ser_string(self.strStatusBar)\n+        r += ser_string(self.strReserved)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CUnsignedAlert(nVersion %d, nRelayUntil %d, nExpiration %d, nID %d, nCancel %d, nMinVer %d, nMaxVer %d, nPriority %d, strComment %s, strStatusBar %s, strReserved %s)\" \\\n+            % (self.nVersion, self.nRelayUntil, self.nExpiration, self.nID,\n+               self.nCancel, self.nMinVer, self.nMaxVer, self.nPriority,\n+               self.strComment, self.strStatusBar, self.strReserved)\n+\n+\n+class CAlert(object):\n+    def __init__(self):\n+        self.vchMsg = \"\"\n+        self.vchSig = \"\"\n+\n+    def deserialize(self, f):\n+        self.vchMsg = deser_string(f)\n+        self.vchSig = deser_string(f)\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += ser_string(self.vchMsg)\n+        r += ser_string(self.vchSig)\n+        return r\n+\n+    def __repr__(self):\n+        return \"CAlert(vchMsg.sz %d, vchSig.sz %d)\" \\\n+            % (len(self.vchMsg), len(self.vchSig))\n+\n+\n+# Objects that correspond to messages on the wire\n+class msg_version(object):\n+    command = \"version\"\n+\n+    def __init__(self):\n+        self.nVersion = MY_VERSION\n+        self.nServices = 1\n+        self.nTime = time.time()\n+        self.addrTo = CAddress()\n+        self.addrFrom = CAddress()\n+        self.nNonce = random.getrandbits(64)\n+        self.strSubVer = MY_SUBVERSION\n+        self.nStartingHeight = -1\n+\n+    def deserialize(self, f):\n+        self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n+        if self.nVersion == 10300:\n+            self.nVersion = 300\n+        self.nServices = struct.unpack(\"<Q\", f.read(8))[0]\n+        self.nTime = struct.unpack(\"<q\", f.read(8))[0]\n+        self.addrTo = CAddress()\n+        self.addrTo.deserialize(f)\n+        if self.nVersion >= 106:\n+            self.addrFrom = CAddress()\n+            self.addrFrom.deserialize(f)\n+            self.nNonce = struct.unpack(\"<Q\", f.read(8))[0]\n+            self.strSubVer = deser_string(f)\n+            if self.nVersion >= 209:\n+                self.nStartingHeight = struct.unpack(\"<i\", f.read(4))[0]\n+            else:\n+                self.nStartingHeight = None\n+        else:\n+            self.addrFrom = None\n+            self.nNonce = None\n+            self.strSubVer = None\n+            self.nStartingHeight = None\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += struct.pack(\"<i\", self.nVersion)\n+        r += struct.pack(\"<Q\", self.nServices)\n+        r += struct.pack(\"<q\", self.nTime)\n+        r += self.addrTo.serialize()\n+        r += self.addrFrom.serialize()\n+        r += struct.pack(\"<Q\", self.nNonce)\n+        r += ser_string(self.strSubVer)\n+        r += struct.pack(\"<i\", self.nStartingHeight)\n+        return r\n+\n+    def __repr__(self):\n+        return 'msg_version(nVersion=%i nServices=%i nTime=%s addrTo=%s addrFrom=%s nNonce=0x%016X strSubVer=%s nStartingHeight=%i)' \\\n+            % (self.nVersion, self.nServices, time.ctime(self.nTime),\n+               repr(self.addrTo), repr(self.addrFrom), self.nNonce,\n+               self.strSubVer, self.nStartingHeight)\n+\n+\n+class msg_verack(object):\n+    command = \"verack\"\n+\n+    def __init__(self):\n+        pass\n+\n+    def deserialize(self, f):\n+        pass\n+\n+    def serialize(self):\n+        return \"\"\n+\n+    def __repr__(self):\n+        return \"msg_verack()\"\n+\n+\n+class msg_addr(object):\n+    command = \"addr\"\n+\n+    def __init__(self):\n+        self.addrs = []\n+\n+    def deserialize(self, f):\n+        self.addrs = deser_vector(f, CAddress)\n+\n+    def serialize(self):\n+        return ser_vector(self.addrs)\n+\n+    def __repr__(self):\n+        return \"msg_addr(addrs=%s)\" % (repr(self.addrs))\n+\n+\n+class msg_alert(object):\n+    command = \"alert\"\n+\n+    def __init__(self):\n+        self.alert = CAlert()\n+\n+    def deserialize(self, f):\n+        self.alert = CAlert()\n+        self.alert.deserialize(f)\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += self.alert.serialize()\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_alert(alert=%s)\" % (repr(self.alert), )\n+\n+\n+class msg_inv(object):\n+    command = \"inv\"\n+\n+    def __init__(self, inv=None):\n+        if inv is None:\n+            self.inv = []\n+        else:\n+            self.inv = inv\n+\n+    def deserialize(self, f):\n+        self.inv = deser_vector(f, CInv)\n+\n+    def serialize(self):\n+        return ser_vector(self.inv)\n+\n+    def __repr__(self):\n+        return \"msg_inv(inv=%s)\" % (repr(self.inv))\n+\n+\n+class msg_getdata(object):\n+    command = \"getdata\"\n+\n+    def __init__(self):\n+        self.inv = []\n+\n+    def deserialize(self, f):\n+        self.inv = deser_vector(f, CInv)\n+\n+    def serialize(self):\n+        return ser_vector(self.inv)\n+\n+    def __repr__(self):\n+        return \"msg_getdata(inv=%s)\" % (repr(self.inv))\n+\n+\n+class msg_getblocks(object):\n+    command = \"getblocks\"\n+\n+    def __init__(self):\n+        self.locator = CBlockLocator()\n+        self.hashstop = 0L\n+\n+    def deserialize(self, f):\n+        self.locator = CBlockLocator()\n+        self.locator.deserialize(f)\n+        self.hashstop = deser_uint256(f)\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += self.locator.serialize()\n+        r += ser_uint256(self.hashstop)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_getblocks(locator=%s hashstop=%064x)\" \\\n+            % (repr(self.locator), self.hashstop)\n+\n+\n+class msg_tx(object):\n+    command = \"tx\"\n+\n+    def __init__(self, tx=CTransaction()):\n+        self.tx = tx\n+\n+    def deserialize(self, f):\n+        self.tx.deserialize(f)\n+\n+    def serialize(self):\n+        return self.tx.serialize()\n+\n+    def __repr__(self):\n+        return \"msg_tx(tx=%s)\" % (repr(self.tx))\n+\n+\n+class msg_block(object):\n+    command = \"block\"\n+\n+    def __init__(self, block=None):\n+        if block is None:\n+            self.block = CBlock()\n+        else:\n+            self.block = block\n+\n+    def deserialize(self, f):\n+        self.block.deserialize(f)\n+\n+    def serialize(self):\n+        return self.block.serialize()\n+\n+    def __repr__(self):\n+        return \"msg_block(block=%s)\" % (repr(self.block))\n+\n+\n+class msg_getaddr(object):\n+    command = \"getaddr\"\n+\n+    def __init__(self):\n+        pass\n+\n+    def deserialize(self, f):\n+        pass\n+\n+    def serialize(self):\n+        return \"\"\n+\n+    def __repr__(self):\n+        return \"msg_getaddr()\"\n+\n+\n+class msg_ping_prebip31(object):\n+    command = \"ping\"\n+\n+    def __init__(self):\n+        pass\n+\n+    def deserialize(self, f):\n+        pass\n+\n+    def serialize(self):\n+        return \"\"\n+\n+    def __repr__(self):\n+        return \"msg_ping() (pre-bip31)\"\n+\n+\n+class msg_ping(object):\n+    command = \"ping\"\n+\n+    def __init__(self, nonce=0L):\n+        self.nonce = nonce\n+\n+    def deserialize(self, f):\n+        self.nonce = struct.unpack(\"<Q\", f.read(8))[0]\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += struct.pack(\"<Q\", self.nonce)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_ping(nonce=%08x)\" % self.nonce\n+\n+\n+class msg_pong(object):\n+    command = \"pong\"\n+\n+    def __init__(self, nonce=0L):\n+        self.nonce = nonce\n+\n+    def deserialize(self, f):\n+        self.nonce = struct.unpack(\"<Q\", f.read(8))[0]\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += struct.pack(\"<Q\", self.nonce)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_pong(nonce=%08x)\" % self.nonce\n+\n+\n+class msg_mempool(object):\n+    command = \"mempool\"\n+\n+    def __init__(self):\n+        pass\n+\n+    def deserialize(self, f):\n+        pass\n+\n+    def serialize(self):\n+        return \"\"\n+\n+    def __repr__(self):\n+        return \"msg_mempool()\"\n+\n+\n+# getheaders message has\n+# number of entries\n+# vector of hashes\n+# hash_stop (hash of last desired block header, 0 to get as many as possible)\n+class msg_getheaders(object):\n+    command = \"getheaders\"\n+\n+    def __init__(self):\n+        self.locator = CBlockLocator()\n+        self.hashstop = 0L\n+\n+    def deserialize(self, f):\n+        self.locator = CBlockLocator()\n+        self.locator.deserialize(f)\n+        self.hashstop = deser_uint256(f)\n+\n+    def serialize(self):\n+        r = \"\"\n+        r += self.locator.serialize()\n+        r += ser_uint256(self.hashstop)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_getheaders(locator=%s, stop=%064x)\" \\\n+            % (repr(self.locator), self.hashstop)\n+\n+\n+# headers message has\n+# <count> <vector of block headers>\n+class msg_headers(object):\n+    command = \"headers\"\n+\n+    def __init__(self):\n+        self.headers = []\n+\n+    def deserialize(self, f):\n+        # comment in bitcoind indicates these should be deserialized as blocks\n+        blocks = deser_vector(f, CBlock)\n+        for x in blocks:\n+            self.headers.append(CBlockHeader(x))\n+\n+    def serialize(self):\n+        blocks = [CBlock(x) for x in self.headers]\n+        return ser_vector(blocks)\n+\n+    def __repr__(self):\n+        return \"msg_headers(headers=%s)\" % repr(self.headers)\n+\n+\n+class msg_reject(object):\n+    command = \"reject\"\n+\n+    def __init__(self):\n+        self.message = \"\"\n+        self.code = \"\"\n+        self.reason = \"\"\n+        self.data = 0L\n+\n+    def deserialize(self, f):\n+        self.message = deser_string(f)\n+        self.code = struct.unpack(\"<B\", f.read(1))[0]\n+        self.reason = deser_string(f)\n+        if (self.message == \"block\" or self.message == \"tx\"):\n+            self.data = deser_uint256(f)\n+\n+    def serialize(self):\n+        r = ser_string(self.message)\n+        r += struct.pack(\"<B\", self.code)\n+        r += ser_string(self.reason)\n+        if (self.message == \"block\" or self.message == \"tx\"):\n+            r += ser_uint256(self.data)\n+        return r\n+\n+    def __repr__(self):\n+        return \"msg_reject: %s %d %s [%064x]\" \\\n+            % (self.message, self.code, self.reason, self.data)\n+\n+\n+# This is what a callback should look like for NodeConn\n+# Reimplement the on_* functions to provide handling for events\n+class NodeConnCB(object):\n+    def __init__(self):\n+        # Acquire on all callbacks -- overkill for now since asyncore is\n+        # single-threaded, but may be useful for synchronizing access to\n+        # member variables in derived classes.\n+        self.cbLock = Lock()\n+        self.verack_received = False\n+\n+    # Derived classes should call this function once to set the message map\n+    # which associates the derived classes' functions to incoming messages\n+    def create_callback_map(self):\n+        self.cbmap = {\n+            \"version\": self.on_version,\n+            \"verack\": self.on_verack,\n+            \"addr\": self.on_addr,\n+            \"alert\": self.on_alert,\n+            \"inv\": self.on_inv,\n+            \"getdata\": self.on_getdata,\n+            \"getblocks\": self.on_getblocks,\n+            \"tx\": self.on_tx,\n+            \"block\": self.on_block,\n+            \"getaddr\": self.on_getaddr,\n+            \"ping\": self.on_ping,\n+            \"pong\": self.on_pong,\n+            \"headers\": self.on_headers,\n+            \"getheaders\": self.on_getheaders,\n+            \"reject\": self.on_reject,\n+            \"mempool\": self.on_mempool\n+        }\n+\n+    def deliver(self, conn, message):\n+        with self.cbLock:\n+            try:\n+                self.cbmap[message.command](conn, message)\n+            except:\n+                print \"ERROR delivering %s (%s)\" % (repr(message),\n+                                                    sys.exc_info()[0])\n+\n+    def on_version(self, conn, message):\n+        if message.nVersion >= 209:\n+            conn.send_message(msg_verack())\n+        conn.ver_send = min(MY_VERSION, message.nVersion)\n+        if message.nVersion < 209:\n+            conn.ver_recv = conn.ver_send\n+\n+    def on_verack(self, conn, message):\n+        conn.ver_recv = conn.ver_send\n+        self.verack_received = True\n+\n+    def on_inv(self, conn, message):\n+        want = msg_getdata()\n+        for i in message.inv:\n+            if i.type != 0:\n+                want.inv.append(i)\n+        if len(want.inv):\n+            conn.send_message(want)\n+\n+    def on_addr(self, conn, message): pass\n+    def on_alert(self, conn, message): pass\n+    def on_getdata(self, conn, message): pass\n+    def on_getblocks(self, conn, message): pass\n+    def on_tx(self, conn, message): pass\n+    def on_block(self, conn, message): pass\n+    def on_getaddr(self, conn, message): pass\n+    def on_headers(self, conn, message): pass\n+    def on_getheaders(self, conn, message): pass\n+    def on_ping(self, conn, message):\n+        if conn.ver_send > BIP0031_VERSION:\n+            conn.send_message(msg_pong(message.nonce))\n+    def on_reject(self, conn, message): pass\n+    def on_close(self, conn): pass\n+    def on_mempool(self, conn): pass\n+    def on_pong(self, conn, message): pass\n+\n+\n+# The actual NodeConn class\n+# This class provides an interface for a p2p connection to a specified node\n+class NodeConn(asyncore.dispatcher):\n+    messagemap = {\n+        \"version\": msg_version,\n+        \"verack\": msg_verack,\n+        \"addr\": msg_addr,\n+        \"alert\": msg_alert,\n+        \"inv\": msg_inv,\n+        \"getdata\": msg_getdata,\n+        \"getblocks\": msg_getblocks,\n+        \"tx\": msg_tx,\n+        \"block\": msg_block,\n+        \"getaddr\": msg_getaddr,\n+        \"ping\": msg_ping,\n+        \"pong\": msg_pong,\n+        \"headers\": msg_headers,\n+        \"getheaders\": msg_getheaders,\n+        \"reject\": msg_reject,\n+        \"mempool\": msg_mempool\n+    }\n+    MAGIC_BYTES = {\n+        \"mainnet\": \"\\xf9\\xbe\\xb4\\xd9\",   # mainnet\n+        \"testnet3\": \"\\x0b\\x11\\x09\\x07\",  # testnet3\n+        \"regtest\": \"\\xfa\\xbf\\xb5\\xda\"    # regtest\n+    }\n+\n+    def __init__(self, dstaddr, dstport, rpc, callback, net=\"regtest\"):\n+        asyncore.dispatcher.__init__(self)\n+        self.log = logging.getLogger(\"NodeConn(%s:%d)\" % (dstaddr, dstport))\n+        self.dstaddr = dstaddr\n+        self.dstport = dstport\n+        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)\n+        self.sendbuf = \"\"\n+        self.recvbuf = \"\"\n+        self.ver_send = 209\n+        self.ver_recv = 209\n+        self.last_sent = 0\n+        self.state = \"connecting\"\n+        self.network = net\n+        self.cb = callback\n+        self.sendbufLock = Lock()  # for protecting the sendbuffer\n+        self.disconnect = False\n+\n+        # stuff version msg into sendbuf\n+        vt = msg_version()\n+        vt.addrTo.ip = self.dstaddr\n+        vt.addrTo.port = self.dstport\n+        vt.addrFrom.ip = \"0.0.0.0\"\n+        vt.addrFrom.port = 0\n+        self.send_message(vt, True)\n+        print 'MiniNode: Connecting to Bitcoin Node IP # ' + dstaddr + ':' \\\n+            + str(dstport)\n+\n+        try:\n+            self.connect((dstaddr, dstport))\n+        except:\n+            self.handle_close()\n+        self.rpc = rpc\n+\n+    def show_debug_msg(self, msg):\n+        self.log.debug(msg)\n+\n+    def handle_connect(self):\n+        self.show_debug_msg(\"MiniNode: Connected & Listening: \\n\")\n+        self.state = \"connected\"\n+\n+    def handle_close(self):\n+        self.show_debug_msg(\"MiniNode: Closing Connection to %s:%d... \"\n+                            % (self.dstaddr, self.dstport))\n+        self.state = \"closed\"\n+        self.recvbuf = \"\"\n+        self.sendbuf = \"\"\n+        try:\n+            self.close()\n+        except:\n+            pass\n+        self.cb.on_close(self)\n+\n+    def handle_read(self):\n+        try:\n+            t = self.recv(8192)\n+            if len(t) > 0:\n+                self.recvbuf += t\n+                self.got_data()\n+        except:\n+            pass\n+\n+    def readable(self):\n+        return True\n+\n+    def writable(self):\n+        if self.disconnect:\n+            self.handle_close()\n+            return False\n+        else:\n+            self.sendbufLock.acquire()\n+            length = len(self.sendbuf)\n+            self.sendbufLock.release()\n+            return (length > 0)\n+\n+    def handle_write(self):\n+        self.sendbufLock.acquire()\n+        try:\n+            sent = self.send(self.sendbuf)\n+        except:\n+            self.handle_close()\n+            return\n+        self.sendbuf = self.sendbuf[sent:]\n+        self.sendbufLock.release()\n+\n+    def got_data(self):\n+        while True:\n+            if len(self.recvbuf) < 4:\n+                return\n+            if self.recvbuf[:4] != self.MAGIC_BYTES[self.network]:\n+                raise ValueError(\"got garbage %s\" % repr(self.recvbuf))\n+            if self.ver_recv < 209:\n+                if len(self.recvbuf) < 4 + 12 + 4:\n+                    return\n+                command = self.recvbuf[4:4+12].split(\"\\x00\", 1)[0]\n+                msglen = struct.unpack(\"<i\", self.recvbuf[4+12:4+12+4])[0]\n+                checksum = None\n+                if len(self.recvbuf) < 4 + 12 + 4 + msglen:\n+                    return\n+                msg = self.recvbuf[4+12+4:4+12+4+msglen]\n+                self.recvbuf = self.recvbuf[4+12+4+msglen:]\n+            else:\n+                if len(self.recvbuf) < 4 + 12 + 4 + 4:\n+                    return\n+                command = self.recvbuf[4:4+12].split(\"\\x00\", 1)[0]\n+                msglen = struct.unpack(\"<i\", self.recvbuf[4+12:4+12+4])[0]\n+                checksum = self.recvbuf[4+12+4:4+12+4+4]\n+                if len(self.recvbuf) < 4 + 12 + 4 + 4 + msglen:\n+                    return\n+                msg = self.recvbuf[4+12+4+4:4+12+4+4+msglen]\n+                th = sha256(msg)\n+                h = sha256(th)\n+                if checksum != h[:4]:\n+                    raise ValueError(\"got bad checksum \" + repr(self.recvbuf))\n+                self.recvbuf = self.recvbuf[4+12+4+4+msglen:]\n+            if command in self.messagemap:\n+                f = cStringIO.StringIO(msg)\n+                t = self.messagemap[command]()\n+                t.deserialize(f)\n+                self.got_message(t)\n+            else:\n+                self.show_debug_msg(\"Unknown command: '\" + command + \"' \" +\n+                                    repr(msg))\n+\n+    def send_message(self, message, pushbuf=False):\n+        if self.state != \"connected\" and not pushbuf:\n+            return\n+        self.sendbufLock.acquire()\n+        self.show_debug_msg(\"Send %s\" % repr(message))\n+        command = message.command\n+        data = message.serialize()\n+        tmsg = self.MAGIC_BYTES[self.network]\n+        tmsg += command\n+        tmsg += \"\\x00\" * (12 - len(command))\n+        tmsg += struct.pack(\"<I\", len(data))\n+        if self.ver_send >= 209:\n+            th = sha256(data)\n+            h = sha256(th)\n+            tmsg += h[:4]\n+        tmsg += data\n+        self.sendbuf += tmsg\n+        self.last_sent = time.time()\n+        self.sendbufLock.release()\n+\n+    def got_message(self, message):\n+        if message.command == \"version\":\n+            if message.nVersion <= BIP0031_VERSION:\n+                self.messagemap['ping'] = msg_ping_prebip31\n+        if self.last_sent + 30 * 60 < time.time():\n+            self.send_message(self.messagemap['ping']())\n+        self.show_debug_msg(\"Recv %s\" % repr(message))\n+        self.cb.deliver(self, message)\n+\n+    def disconnect_node(self):\n+        self.disconnect = True\n+        self.send_message(self.messagemap['ping']())\n+\n+\n+class NetworkThread(Thread):\n+    def run(self):\n+        asyncore.loop(0.1, True)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/5981#discussion_r29433660",
      "id" : 29433660,
      "original_commit_id" : "2703412a39c95c811a40c3fff6929e4ce59c3c62",
      "original_position" : 1237,
      "path" : "qa/rpc-tests/mininode.py",
      "position" : 1237,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/5981",
      "updated_at" : "2015-04-30T14:25:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/29433660",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "Post merge ACK",
      "created_at" : "2015-04-30T14:32:54Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/5981#issuecomment-97819466",
      "id" : 97819466,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/5981",
      "updated_at" : "2015-04-30T14:32:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/97819466",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   }
]
