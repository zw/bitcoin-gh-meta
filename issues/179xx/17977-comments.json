[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #19792 (rpc: Add dumpcoinstats by fjahr)\n* #19695 ([do not merge] Test impact of secp256k1 endianness detection change by sipa)\n* #19521 (Coinstats Index (without UTXO set hash) by fjahr)\n* #19438 (Introduce deploymentstatus by ajtowns)\n* #18788 (tests: Update more tests to work with descriptor wallets by achow101)\n* #16546 (External signer support - Wallet Box edition by Sjors)\n* #13533 ([tests] Reduced number of validations in tx_validationcache_tests by lucash-dev)\n* #13062 (Make script interpreter independent from storage type CScript by sipa)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2020-01-21T23:47:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-576940388",
      "id" : 576940388,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU3Njk0MDM4OA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-04T15:27:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/576940388",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369389626"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369389626"
         }
      },
      "author_association" : "NONE",
      "body" : "Slightly confusing name... `HashAgainSHA256`?\r\n\r\nI understand why it exists, and I can't think of a much better name... but having something in the name to denote we're hashing with SHA256 might make it a tiny bit more readable.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T06:35:06Z",
      "diff_hunk" : "@@ -1189,7 +1358,14 @@ uint256 GetPrevoutHash(const T& txTo)\n     for (const auto& txin : txTo.vin) {\n         ss << txin.prevout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n+}\n+\n+uint256 HashAgain(const uint256& hash)\n+{\n+    uint256 result;\n+    CSHA256().Write(hash.begin(), 32).Finalize(result.begin());\n+    return result;\n }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369389626",
      "id" : 369389626,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM4OTYyNg==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 1369,
      "original_position" : 314,
      "original_start_line" : 1364,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 346369769,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369389626",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/11246316?v=4",
         "events_url" : "https://api.github.com/users/junderw/events{/privacy}",
         "followers_url" : "https://api.github.com/users/junderw/followers",
         "following_url" : "https://api.github.com/users/junderw/following{/other_user}",
         "gists_url" : "https://api.github.com/users/junderw/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/junderw",
         "id" : 11246316,
         "login" : "junderw",
         "node_id" : "MDQ6VXNlcjExMjQ2MzE2",
         "organizations_url" : "https://api.github.com/users/junderw/orgs",
         "received_events_url" : "https://api.github.com/users/junderw/received_events",
         "repos_url" : "https://api.github.com/users/junderw/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/junderw/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/junderw/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/junderw"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369513725"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369513725"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`s/TESTDUMMY/TAPROOT/` here and in testnet (regtest is fine). Also think you want to set timeout to something less expired.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T11:45:32Z",
      "diff_hunk" : "@@ -83,6 +83,11 @@ class CMainParams : public CChainParams {\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999; // December 31, 2008\n \n+        // Deployment of Taproot\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].bit = 2;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369513725",
      "id" : 369513725,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTUxMzcyNQ==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 88,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "src/chainparams.cpp",
      "position" : null,
      "pull_request_review_id" : 346527063,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369513725",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369593203"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369593203"
         }
      },
      "author_association" : "NONE",
      "body" : "```suggestion\r\n    DEPLOYMENT_TAPROOT, // Deployment of BIP-340/BIP-341/BIP-342\r\n```",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T14:31:49Z",
      "diff_hunk" : "@@ -14,6 +14,7 @@ namespace Consensus {\n enum DeploymentPos\n {\n     DEPLOYMENT_TESTDUMMY,\n+    DEPLOYMENT_TAPROOT, // Deployment of bip-taproot/bip-tapscript/bip-schnorr",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369593203",
      "id" : 369593203,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU5MzIwMw==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 17,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/consensus/params.h",
      "position" : null,
      "pull_request_review_id" : 346630927,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369593203",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/30683012?v=4",
         "events_url" : "https://api.github.com/users/MaxHillebrand/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MaxHillebrand/followers",
         "following_url" : "https://api.github.com/users/MaxHillebrand/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MaxHillebrand/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MaxHillebrand",
         "id" : 30683012,
         "login" : "MaxHillebrand",
         "node_id" : "MDQ6VXNlcjMwNjgzMDEy",
         "organizations_url" : "https://api.github.com/users/MaxHillebrand/orgs",
         "received_events_url" : "https://api.github.com/users/MaxHillebrand/received_events",
         "repos_url" : "https://api.github.com/users/MaxHillebrand/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MaxHillebrand/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MaxHillebrand/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MaxHillebrand"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369593612"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369593612"
         }
      },
      "author_association" : "NONE",
      "body" : "```suggestion\r\n/** Return a CHashWriter primed for computing BIP-340 compatible tagged hashes.\r\n```",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T14:32:25Z",
      "diff_hunk" : "@@ -204,4 +218,12 @@ unsigned int MurmurHash3(unsigned int nHashSeed, const std::vector<unsigned char\n \n void BIP32Hash(const ChainCode &chainCode, unsigned int nChild, unsigned char header, const unsigned char data[32], unsigned char output[64]);\n \n+/** Return a CHashWriter primed for computing bip-schnorr compatible tagged hashes.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369593612",
      "id" : 369593612,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU5MzYxMg==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 221,
      "original_position" : 60,
      "original_start_line" : null,
      "path" : "src/hash.h",
      "position" : null,
      "pull_request_review_id" : 346630927,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369593612",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/30683012?v=4",
         "events_url" : "https://api.github.com/users/MaxHillebrand/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MaxHillebrand/followers",
         "following_url" : "https://api.github.com/users/MaxHillebrand/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MaxHillebrand/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MaxHillebrand",
         "id" : 30683012,
         "login" : "MaxHillebrand",
         "node_id" : "MDQ6VXNlcjMwNjgzMDEy",
         "organizations_url" : "https://api.github.com/users/MaxHillebrand/orgs",
         "received_events_url" : "https://api.github.com/users/MaxHillebrand/received_events",
         "repos_url" : "https://api.github.com/users/MaxHillebrand/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MaxHillebrand/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MaxHillebrand/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MaxHillebrand"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369597072"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369597072"
         }
      },
      "author_association" : "NONE",
      "body" : "```suggestion\r\n * BIP-340\r\n```",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T14:38:17Z",
      "diff_hunk" : "@@ -0,0 +1,125 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369597072",
      "id" : 369597072,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU5NzA3Mg==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 11,
      "original_position" : 11,
      "original_start_line" : null,
      "path" : "src/secp256k1/include/secp256k1_schnorrsig.h",
      "position" : null,
      "pull_request_review_id" : 346630927,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369597072",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/30683012?v=4",
         "events_url" : "https://api.github.com/users/MaxHillebrand/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MaxHillebrand/followers",
         "following_url" : "https://api.github.com/users/MaxHillebrand/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MaxHillebrand/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MaxHillebrand",
         "id" : 30683012,
         "login" : "MaxHillebrand",
         "node_id" : "MDQ6VXNlcjMwNjgzMDEy",
         "organizations_url" : "https://api.github.com/users/MaxHillebrand/orgs",
         "received_events_url" : "https://api.github.com/users/MaxHillebrand/received_events",
         "repos_url" : "https://api.github.com/users/MaxHillebrand/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MaxHillebrand/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MaxHillebrand/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MaxHillebrand"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369601055"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369601055"
         }
      },
      "author_association" : "NONE",
      "body" : "```suggestion\r\n        \"\"\"Construct a BIP-340 compatible Schnorr signature with this key.\"\"\"\r\n```",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T14:45:12Z",
      "diff_hunk" : "@@ -384,3 +453,33 @@ def sign_ecdsa(self, msg, low_s=True):\n         rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')\n         sb = s.to_bytes((s.bit_length() + 8) // 8, 'big')\n         return b'\\x30' + bytes([4 + len(rb) + len(sb), 2, len(rb)]) + rb + bytes([2, len(sb)]) + sb\n+\n+    def sign_schnorr(self, msg):\n+        \"\"\"Construct a bip-schnorr compatible signature with this key.\"\"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369601055",
      "id" : 369601055,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYwMTA1NQ==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 458,
      "original_position" : 126,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 346630927,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369601055",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/30683012?v=4",
         "events_url" : "https://api.github.com/users/MaxHillebrand/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MaxHillebrand/followers",
         "following_url" : "https://api.github.com/users/MaxHillebrand/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MaxHillebrand/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MaxHillebrand",
         "id" : 30683012,
         "login" : "MaxHillebrand",
         "node_id" : "MDQ6VXNlcjMwNjgzMDEy",
         "organizations_url" : "https://api.github.com/users/MaxHillebrand/orgs",
         "received_events_url" : "https://api.github.com/users/MaxHillebrand/received_events",
         "repos_url" : "https://api.github.com/users/MaxHillebrand/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MaxHillebrand/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MaxHillebrand/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MaxHillebrand"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369601369"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369601369"
         }
      },
      "author_association" : "NONE",
      "body" : "```suggestion\r\n        kp = int.from_bytes(TaggedHash(\"BIP340Derive\", x.to_bytes(32, 'big') + msg), 'big') % SECP256K1_ORDER\r\n```\r\n\r\nNot sure if this breaks anything... :confused: ",
      "commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "created_at" : "2020-01-22T14:45:44Z",
      "diff_hunk" : "@@ -384,3 +453,33 @@ def sign_ecdsa(self, msg, low_s=True):\n         rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')\n         sb = s.to_bytes((s.bit_length() + 8) // 8, 'big')\n         return b'\\x30' + bytes([4 + len(rb) + len(sb), 2, len(rb)]) + rb + bytes([2, len(sb)]) + sb\n+\n+    def sign_schnorr(self, msg):\n+        \"\"\"Construct a bip-schnorr compatible signature with this key.\"\"\"\n+        assert(self.valid)\n+        assert(self.compressed)\n+        assert(len(msg) == 32)\n+        x = self.secret\n+        pk = self.get_pubkey()\n+        if not pk.is_positive:\n+            x = SECP256K1_ORDER - x\n+        kp = int.from_bytes(TaggedHash(\"BIPSchnorrDerive\", x.to_bytes(32, 'big') + msg), 'big') % SECP256K1_ORDER",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369601369",
      "id" : 369601369,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYwMTM2OQ==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_position" : 134,
      "path" : "test/functional/test_framework/key.py",
      "position" : 134,
      "pull_request_review_id" : 346630927,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "updated_at" : "2020-01-22T14:48:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369601369",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/30683012?v=4",
         "events_url" : "https://api.github.com/users/MaxHillebrand/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MaxHillebrand/followers",
         "following_url" : "https://api.github.com/users/MaxHillebrand/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MaxHillebrand/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MaxHillebrand",
         "id" : 30683012,
         "login" : "MaxHillebrand",
         "node_id" : "MDQ6VXNlcjMwNjgzMDEy",
         "organizations_url" : "https://api.github.com/users/MaxHillebrand/orgs",
         "received_events_url" : "https://api.github.com/users/MaxHillebrand/received_events",
         "repos_url" : "https://api.github.com/users/MaxHillebrand/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MaxHillebrand/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MaxHillebrand/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MaxHillebrand"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369601564"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369601564"
         }
      },
      "author_association" : "NONE",
      "body" : "```suggestion\r\n        e = int.from_bytes(TaggedHash(\"BIP340\", R[0].to_bytes(32, 'big') + pk.get_xonly_bytes() + msg), 'big') % SECP256K1_ORDER\r\n```",
      "commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "created_at" : "2020-01-22T14:46:02Z",
      "diff_hunk" : "@@ -384,3 +453,33 @@ def sign_ecdsa(self, msg, low_s=True):\n         rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')\n         sb = s.to_bytes((s.bit_length() + 8) // 8, 'big')\n         return b'\\x30' + bytes([4 + len(rb) + len(sb), 2, len(rb)]) + rb + bytes([2, len(sb)]) + sb\n+\n+    def sign_schnorr(self, msg):\n+        \"\"\"Construct a bip-schnorr compatible signature with this key.\"\"\"\n+        assert(self.valid)\n+        assert(self.compressed)\n+        assert(len(msg) == 32)\n+        x = self.secret\n+        pk = self.get_pubkey()\n+        if not pk.is_positive:\n+            x = SECP256K1_ORDER - x\n+        kp = int.from_bytes(TaggedHash(\"BIPSchnorrDerive\", x.to_bytes(32, 'big') + msg), 'big') % SECP256K1_ORDER\n+        assert(kp != 0)\n+        R = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, kp)]))\n+        k = kp if jacobi_symbol(R[1], SECP256K1_FIELD_SIZE) == 1 else SECP256K1_ORDER - kp\n+        e = int.from_bytes(TaggedHash(\"BIPSchnorr\", R[0].to_bytes(32, 'big') + pk.get_xonly_bytes() + msg), 'big') % SECP256K1_ORDER",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369601564",
      "id" : 369601564,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYwMTU2NA==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_position" : 138,
      "path" : "test/functional/test_framework/key.py",
      "position" : 138,
      "pull_request_review_id" : 346630927,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "updated_at" : "2020-01-22T14:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369601564",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/30683012?v=4",
         "events_url" : "https://api.github.com/users/MaxHillebrand/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MaxHillebrand/followers",
         "following_url" : "https://api.github.com/users/MaxHillebrand/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MaxHillebrand/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MaxHillebrand",
         "id" : 30683012,
         "login" : "MaxHillebrand",
         "node_id" : "MDQ6VXNlcjMwNjgzMDEy",
         "organizations_url" : "https://api.github.com/users/MaxHillebrand/orgs",
         "received_events_url" : "https://api.github.com/users/MaxHillebrand/received_events",
         "repos_url" : "https://api.github.com/users/MaxHillebrand/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MaxHillebrand/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MaxHillebrand/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MaxHillebrand"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369609545"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369609545"
         }
      },
      "author_association" : "NONE",
      "body" : "```suggestion\r\n * (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\r\n```\r\n\r\nThis link is broken until the [BIP PR](https://github.com/bitcoin/bips/pull/876/) is merged.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T14:58:35Z",
      "diff_hunk" : "@@ -0,0 +1,125 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369609545",
      "id" : 369609545,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYwOTU0NQ==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 12,
      "original_position" : 12,
      "original_start_line" : null,
      "path" : "src/secp256k1/include/secp256k1_schnorrsig.h",
      "position" : null,
      "pull_request_review_id" : 346652110,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369609545",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/30683012?v=4",
         "events_url" : "https://api.github.com/users/MaxHillebrand/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MaxHillebrand/followers",
         "following_url" : "https://api.github.com/users/MaxHillebrand/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MaxHillebrand/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MaxHillebrand",
         "id" : 30683012,
         "login" : "MaxHillebrand",
         "node_id" : "MDQ6VXNlcjMwNjgzMDEy",
         "organizations_url" : "https://api.github.com/users/MaxHillebrand/orgs",
         "received_events_url" : "https://api.github.com/users/MaxHillebrand/received_events",
         "repos_url" : "https://api.github.com/users/MaxHillebrand/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MaxHillebrand/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MaxHillebrand/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MaxHillebrand"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369609932"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369609932"
         }
      },
      "author_association" : "NONE",
      "body" : "```suggestion\r\n *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bip340 is used\r\n```\r\n\r\nNot sure if this breaks anything? :confused: ",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T14:59:12Z",
      "diff_hunk" : "@@ -0,0 +1,125 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (X coordinate only; the Y coordinate is considered to be the unique\n+ * Y coordinate satisfying the curve equation that is square)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369609932",
      "id" : 369609932,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYwOTkzMg==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 72,
      "original_position" : 72,
      "original_start_line" : null,
      "path" : "src/secp256k1/include/secp256k1_schnorrsig.h",
      "position" : null,
      "pull_request_review_id" : 346652110,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369609932",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/30683012?v=4",
         "events_url" : "https://api.github.com/users/MaxHillebrand/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MaxHillebrand/followers",
         "following_url" : "https://api.github.com/users/MaxHillebrand/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MaxHillebrand/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MaxHillebrand",
         "id" : 30683012,
         "login" : "MaxHillebrand",
         "node_id" : "MDQ6VXNlcjMwNjgzMDEy",
         "organizations_url" : "https://api.github.com/users/MaxHillebrand/orgs",
         "received_events_url" : "https://api.github.com/users/MaxHillebrand/received_events",
         "repos_url" : "https://api.github.com/users/MaxHillebrand/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MaxHillebrand/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MaxHillebrand/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MaxHillebrand"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369610163"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369610163"
         }
      },
      "author_association" : "NONE",
      "body" : "```suggestion\r\n * SHA256 to SHA256(\"BIP-340\")||SHA256(\"BIP-340\"). */\r\n```",
      "commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "created_at" : "2020-01-22T14:59:34Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorr\")||SHA256(\"BIPSchnorr\"). */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369610163",
      "id" : 369610163,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYxMDE2Mw==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_position" : 33,
      "path" : "src/secp256k1/src/modules/schnorrsig/main_impl.h",
      "position" : 33,
      "pull_request_review_id" : 346652110,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "updated_at" : "2020-01-22T15:01:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369610163",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/30683012?v=4",
         "events_url" : "https://api.github.com/users/MaxHillebrand/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MaxHillebrand/followers",
         "following_url" : "https://api.github.com/users/MaxHillebrand/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MaxHillebrand/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MaxHillebrand",
         "id" : 30683012,
         "login" : "MaxHillebrand",
         "node_id" : "MDQ6VXNlcjMwNjgzMDEy",
         "organizations_url" : "https://api.github.com/users/MaxHillebrand/orgs",
         "received_events_url" : "https://api.github.com/users/MaxHillebrand/received_events",
         "repos_url" : "https://api.github.com/users/MaxHillebrand/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MaxHillebrand/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MaxHillebrand/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MaxHillebrand"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369610577"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369610577"
         }
      },
      "author_association" : "NONE",
      "body" : "```suggestion\r\n        noncefp = secp256k1_nonce_function_bip-340;\r\n```\r\n\r\nNot sure if this breaks anything :confused: ",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T15:00:13Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorr\")||SHA256(\"BIPSchnorr\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x048d9a59ul;\n+    sha->s[1] = 0xfe39fb05ul;\n+    sha->s[2] = 0x28479648ul;\n+    sha->s[3] = 0xe4a660f9ul;\n+    sha->s[4] = 0x814b9e66ul;\n+    sha->s[5] = 0x0469e801ul;\n+    sha->s[6] = 0x83909280ul;\n+    sha->s[7] = 0xb329e454ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[32];\n+    unsigned char seckey_tmp[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369610577",
      "id" : 369610577,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYxMDU3Nw==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 67,
      "original_position" : 67,
      "original_start_line" : null,
      "path" : "src/secp256k1/src/modules/schnorrsig/main_impl.h",
      "position" : null,
      "pull_request_review_id" : 346652110,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369610577",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/30683012?v=4",
         "events_url" : "https://api.github.com/users/MaxHillebrand/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MaxHillebrand/followers",
         "following_url" : "https://api.github.com/users/MaxHillebrand/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MaxHillebrand/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MaxHillebrand",
         "id" : 30683012,
         "login" : "MaxHillebrand",
         "node_id" : "MDQ6VXNlcjMwNjgzMDEy",
         "organizations_url" : "https://api.github.com/users/MaxHillebrand/orgs",
         "received_events_url" : "https://api.github.com/users/MaxHillebrand/received_events",
         "repos_url" : "https://api.github.com/users/MaxHillebrand/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MaxHillebrand/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MaxHillebrand/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MaxHillebrand"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369610885"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369610885"
         }
      },
      "author_association" : "NONE",
      "body" : "```suggestion\r\n    if (!noncefp(buf, msg32, seckey_tmp, (unsigned char *) \"BIP340Derive\", (void*)ndata, 0)) {\r\n```\r\nNot sure if this breaks anything :confused:",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T15:00:44Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorr\")||SHA256(\"BIPSchnorr\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x048d9a59ul;\n+    sha->s[1] = 0xfe39fb05ul;\n+    sha->s[2] = 0x28479648ul;\n+    sha->s[3] = 0xe4a660f9ul;\n+    sha->s[4] = 0x814b9e66ul;\n+    sha->s[5] = 0x0469e801ul;\n+    sha->s[6] = 0x83909280ul;\n+    sha->s[7] = 0xb329e454ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[32];\n+    unsigned char seckey_tmp[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have a square Y. */\n+    if (!secp256k1_fe_is_quad_var(&pk.y)) {\n+        secp256k1_scalar_negate(&x, &x);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey_tmp, &x);\n+    if (!noncefp(buf, msg32, seckey_tmp, (unsigned char *) \"BIPSchnorrDerive\", (void*)ndata, 0)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369610885",
      "id" : 369610885,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYxMDg4NQ==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 87,
      "original_position" : 87,
      "original_start_line" : null,
      "path" : "src/secp256k1/src/modules/schnorrsig/main_impl.h",
      "position" : null,
      "pull_request_review_id" : 346652110,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369610885",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/30683012?v=4",
         "events_url" : "https://api.github.com/users/MaxHillebrand/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MaxHillebrand/followers",
         "following_url" : "https://api.github.com/users/MaxHillebrand/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MaxHillebrand/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MaxHillebrand",
         "id" : 30683012,
         "login" : "MaxHillebrand",
         "node_id" : "MDQ6VXNlcjMwNjgzMDEy",
         "organizations_url" : "https://api.github.com/users/MaxHillebrand/orgs",
         "received_events_url" : "https://api.github.com/users/MaxHillebrand/received_events",
         "repos_url" : "https://api.github.com/users/MaxHillebrand/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MaxHillebrand/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MaxHillebrand/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MaxHillebrand"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369611161"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369611161"
         }
      },
      "author_association" : "NONE",
      "body" : "```suggestion\r\n        e = int.from_bytes(TaggedHash(\"BIP-340\", sig[0:32] + self.get_bytes()[1:33] + msg), 'big') % SECP256K1_ORDER\r\n```",
      "commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "created_at" : "2020-01-22T15:01:07Z",
      "diff_hunk" : "@@ -322,6 +353,40 @@ def verify_ecdsa(self, sig, msg, low_s=True):\n             return False\n         return True\n \n+    def verify_schnorr(self, sig, msg):\n+        assert(len(msg) == 32)\n+        assert(len(sig) == 64)\n+        assert(self.valid)\n+        assert(self.compressed)\n+        r = int.from_bytes(sig[0:32], 'big')\n+        if r >= SECP256K1_FIELD_SIZE:\n+            return False\n+        s = int.from_bytes(sig[32:64], 'big')\n+        if s >= SECP256K1_ORDER:\n+            return False\n+        e = int.from_bytes(TaggedHash(\"BIPSchnorr\", sig[0:32] + self.get_bytes()[1:33] + msg), 'big') % SECP256K1_ORDER",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369611161",
      "id" : 369611161,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYxMTE2MQ==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_position" : 83,
      "path" : "test/functional/test_framework/key.py",
      "position" : 83,
      "pull_request_review_id" : 346652110,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "updated_at" : "2020-01-22T15:02:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369611161",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/30683012?v=4",
         "events_url" : "https://api.github.com/users/MaxHillebrand/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MaxHillebrand/followers",
         "following_url" : "https://api.github.com/users/MaxHillebrand/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MaxHillebrand/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MaxHillebrand",
         "id" : 30683012,
         "login" : "MaxHillebrand",
         "node_id" : "MDQ6VXNlcjMwNjgzMDEy",
         "organizations_url" : "https://api.github.com/users/MaxHillebrand/orgs",
         "received_events_url" : "https://api.github.com/users/MaxHillebrand/received_events",
         "repos_url" : "https://api.github.com/users/MaxHillebrand/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MaxHillebrand/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MaxHillebrand/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MaxHillebrand"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369630927"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369630927"
         }
      },
      "author_association" : "NONE",
      "body" : "Is there a name for this condition that can be explained with a function name or at least a comment?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T15:32:38Z",
      "diff_hunk" : "@@ -231,6 +231,25 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check P2TR standard limits\n+        if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE && !prevScript.IsPayToScriptHash()) {\n+            // Taproot spend\n+            const auto& stack = tx.vin[i].scriptWitness.stack;\n+            size_t stack_size = stack.size();\n+            if (stack_size >= 2 && !stack[stack_size - 1].empty() && stack[stack_size - 1][0] == ANNEX_TAG) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369630927",
      "id" : 369630927,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzMDkyNw==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 240,
      "original_position" : 10,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : null,
      "pull_request_review_id" : 346679982,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369630927",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1731?v=4",
         "events_url" : "https://api.github.com/users/skwp/events{/privacy}",
         "followers_url" : "https://api.github.com/users/skwp/followers",
         "following_url" : "https://api.github.com/users/skwp/following{/other_user}",
         "gists_url" : "https://api.github.com/users/skwp/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/skwp",
         "id" : 1731,
         "login" : "skwp",
         "node_id" : "MDQ6VXNlcjE3MzE=",
         "organizations_url" : "https://api.github.com/users/skwp/orgs",
         "received_events_url" : "https://api.github.com/users/skwp/received_events",
         "repos_url" : "https://api.github.com/users/skwp/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/skwp/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/skwp/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/skwp"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369632680"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369632680"
         }
      },
      "author_association" : "NONE",
      "body" : "why nested conditional here, but not nested above (line 240)?  both branches have \"stack_size >= 2\" as well. without understanding what any of this means, would it be clearer to write like this, removing the duplication and nesting?\r\n\r\n```\r\n// precondition for taproot (?)\r\nif (stack_size < 2) { return }\r\n\r\nif (!stack[stack_size - 1].empty() && stack[stack_size - 1][0] == ANNEX_TAG) {\r\n// whatever this is\r\n\r\n} else if ((stack[stack_size - 1][0] & 0xfe) == 0xc0)) {\r\n// script path spend\r\n\r\n}\r\n```",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T15:35:39Z",
      "diff_hunk" : "@@ -231,6 +231,25 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check P2TR standard limits\n+        if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE && !prevScript.IsPayToScriptHash()) {\n+            // Taproot spend\n+            const auto& stack = tx.vin[i].scriptWitness.stack;\n+            size_t stack_size = stack.size();\n+            if (stack_size >= 2 && !stack[stack_size - 1].empty() && stack[stack_size - 1][0] == ANNEX_TAG) {\n+                stack_size--; // Ignore annex\n+            }\n+            if (stack_size >= 2) {\n+                // Script path spend\n+                if ((stack[stack_size - 1][0] & 0xfe) == 0xc0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369632680",
      "id" : 369632680,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzMjY4MA==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 245,
      "original_position" : 15,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : null,
      "pull_request_review_id" : 346682415,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369632680",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1731?v=4",
         "events_url" : "https://api.github.com/users/skwp/events{/privacy}",
         "followers_url" : "https://api.github.com/users/skwp/followers",
         "following_url" : "https://api.github.com/users/skwp/following{/other_user}",
         "gists_url" : "https://api.github.com/users/skwp/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/skwp",
         "id" : 1731,
         "login" : "skwp",
         "node_id" : "MDQ6VXNlcjE3MzE=",
         "organizations_url" : "https://api.github.com/users/skwp/orgs",
         "received_events_url" : "https://api.github.com/users/skwp/received_events",
         "repos_url" : "https://api.github.com/users/skwp/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/skwp/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/skwp/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/skwp"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369656551"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369656551"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't see the problem, personally.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T16:13:54Z",
      "diff_hunk" : "@@ -231,6 +231,25 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check P2TR standard limits\n+        if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE && !prevScript.IsPayToScriptHash()) {\n+            // Taproot spend\n+            const auto& stack = tx.vin[i].scriptWitness.stack;\n+            size_t stack_size = stack.size();\n+            if (stack_size >= 2 && !stack[stack_size - 1].empty() && stack[stack_size - 1][0] == ANNEX_TAG) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369656551",
      "id" : 369656551,
      "in_reply_to_id" : 369630927,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY1NjU1MQ==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 240,
      "original_position" : 10,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : null,
      "pull_request_review_id" : 346713685,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369656551",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@MaxHillebrand A few overall comments:\r\n* I don't think all references to (bip-)taproot/tapscript/schnorr should be changed to the BIP numbers; in some cases maybe we should just drop the \"bip-\" prefix (e.g. I think talking about a \"taproot spend\" is more clear than \"bip341 spend\").\r\n* All changes in the src/secp256k1 directory should go to https://github.com/bitcoin-core/secp256k1/pull/558 instead (the src/secp256k1 is a git subtree imported from there).\r\n* The \"BIPSchnorr\" and \"BIPSchnorrDerive\" tagged hash tags are part of the spec, which I don't think should be changed.",
      "created_at" : "2020-01-22T17:25:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-577295396",
      "id" : 577295396,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU3NzI5NTM5Ng==",
      "updated_at" : "2020-01-22T17:25:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/577295396",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369698012"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369698012"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@skwp I'll add some comments to clarify, but what you're suggesting would be incorrect.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T17:26:15Z",
      "diff_hunk" : "@@ -231,6 +231,25 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check P2TR standard limits\n+        if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE && !prevScript.IsPayToScriptHash()) {\n+            // Taproot spend\n+            const auto& stack = tx.vin[i].scriptWitness.stack;\n+            size_t stack_size = stack.size();\n+            if (stack_size >= 2 && !stack[stack_size - 1].empty() && stack[stack_size - 1][0] == ANNEX_TAG) {\n+                stack_size--; // Ignore annex\n+            }\n+            if (stack_size >= 2) {\n+                // Script path spend\n+                if ((stack[stack_size - 1][0] & 0xfe) == 0xc0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369698012",
      "id" : 369698012,
      "in_reply_to_id" : 369632680,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5ODAxMg==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 245,
      "original_position" : 15,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : null,
      "pull_request_review_id" : 346767800,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369698012",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "Thanks @sipa, I agree with your comments. \r\nI have deleted my suggestions to change the tagged hashes, the others are still open. Please ACK/NACK and commit what you think is correct.",
      "created_at" : "2020-01-22T17:34:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-577299155",
      "id" : 577299155,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU3NzI5OTE1NQ==",
      "updated_at" : "2020-01-22T17:34:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/577299155",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/30683012?v=4",
         "events_url" : "https://api.github.com/users/MaxHillebrand/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MaxHillebrand/followers",
         "following_url" : "https://api.github.com/users/MaxHillebrand/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MaxHillebrand/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MaxHillebrand",
         "id" : 30683012,
         "login" : "MaxHillebrand",
         "node_id" : "MDQ6VXNlcjMwNjgzMDEy",
         "organizations_url" : "https://api.github.com/users/MaxHillebrand/orgs",
         "received_events_url" : "https://api.github.com/users/MaxHillebrand/received_events",
         "repos_url" : "https://api.github.com/users/MaxHillebrand/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MaxHillebrand/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MaxHillebrand/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MaxHillebrand"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369704810"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369704810"
         }
      },
      "author_association" : "NONE",
      "body" : "Thanks @sipa. I'm not trying to nitpick, rather looking at ways to lower the barrier for reviewers and thus help get more eyes on things. I find that complex conditionals with lots of low level details can make bugs hard to spot and make it daunting for people new to the source to contribute. There might be good reason for the style employed throughout the code and we probably can't change everything overnight, but even things like magic numbers (0xfe?? 0xc0??) everywhere makes it really hard to reason about, imho. Seems like we can make the source easier to read as we go with named conditionals, constants, etc. ",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T17:39:38Z",
      "diff_hunk" : "@@ -231,6 +231,25 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check P2TR standard limits\n+        if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE && !prevScript.IsPayToScriptHash()) {\n+            // Taproot spend\n+            const auto& stack = tx.vin[i].scriptWitness.stack;\n+            size_t stack_size = stack.size();\n+            if (stack_size >= 2 && !stack[stack_size - 1].empty() && stack[stack_size - 1][0] == ANNEX_TAG) {\n+                stack_size--; // Ignore annex\n+            }\n+            if (stack_size >= 2) {\n+                // Script path spend\n+                if ((stack[stack_size - 1][0] & 0xfe) == 0xc0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369704810",
      "id" : 369704810,
      "in_reply_to_id" : 369632680,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTcwNDgxMA==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 245,
      "original_position" : 15,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : null,
      "pull_request_review_id" : 346776320,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369704810",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1731?v=4",
         "events_url" : "https://api.github.com/users/skwp/events{/privacy}",
         "followers_url" : "https://api.github.com/users/skwp/followers",
         "following_url" : "https://api.github.com/users/skwp/following{/other_user}",
         "gists_url" : "https://api.github.com/users/skwp/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/skwp",
         "id" : 1731,
         "login" : "skwp",
         "node_id" : "MDQ6VXNlcjE3MzE=",
         "organizations_url" : "https://api.github.com/users/skwp/orgs",
         "received_events_url" : "https://api.github.com/users/skwp/received_events",
         "repos_url" : "https://api.github.com/users/skwp/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/skwp/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/skwp/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/skwp"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369708533"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369708533"
         }
      },
      "author_association" : "NONE",
      "body" : "hey kalle, please see my comment below to pieter. I'm seeing if people are open to using a more consistent single level of abstraction to make the source easier to read.\r\n\r\ne.g. this can be evaluated by a newb (ignore if I got the concepts wrong, I'm trying to illustrate a more literate / single level of abstraction style as per http://principles-wiki.net/principles:single_level_of_abstraction)\r\n\r\n```\r\nif (payToTapRoot)\r\n  if annexOnStack\r\n    stack_size--; // ignore annex\r\n  else \r\n    if (OpWhateverOnStack)\r\n      checkWhateverConditionWithLoop\r\n    end\r\n```\r\n\r\nAgain I could have totally gotten the details wrong but if the program looked like that at a single level of abstraction, with magic numbers given names and conditionals given names, many more people could actually participate in the PR process and grok what's going on.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T17:47:18Z",
      "diff_hunk" : "@@ -231,6 +231,25 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check P2TR standard limits\n+        if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE && !prevScript.IsPayToScriptHash()) {\n+            // Taproot spend\n+            const auto& stack = tx.vin[i].scriptWitness.stack;\n+            size_t stack_size = stack.size();\n+            if (stack_size >= 2 && !stack[stack_size - 1].empty() && stack[stack_size - 1][0] == ANNEX_TAG) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369708533",
      "id" : 369708533,
      "in_reply_to_id" : 369630927,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTcwODUzMw==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 240,
      "original_position" : 10,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : null,
      "pull_request_review_id" : 346781045,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369708533",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1731?v=4",
         "events_url" : "https://api.github.com/users/skwp/events{/privacy}",
         "followers_url" : "https://api.github.com/users/skwp/followers",
         "following_url" : "https://api.github.com/users/skwp/following{/other_user}",
         "gists_url" : "https://api.github.com/users/skwp/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/skwp",
         "id" : 1731,
         "login" : "skwp",
         "node_id" : "MDQ6VXNlcjE3MzE=",
         "organizations_url" : "https://api.github.com/users/skwp/orgs",
         "received_events_url" : "https://api.github.com/users/skwp/received_events",
         "repos_url" : "https://api.github.com/users/skwp/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/skwp/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/skwp/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/skwp"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369711202"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369711202"
         }
      },
      "author_association" : "NONE",
      "body" : "\r\nIn fact I see that these magic numbers are already given names elsewhere. Can we use them here? This is way more readable and expresses intent\r\n\r\n```\r\n(stack[stack_size - 1][0] & TAPROOT_LEAF_MASK) == TAPROOT_LEAF_TAPSCRIPT\r\n```",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T17:52:38Z",
      "diff_hunk" : "@@ -231,6 +231,25 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check P2TR standard limits\n+        if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE && !prevScript.IsPayToScriptHash()) {\n+            // Taproot spend\n+            const auto& stack = tx.vin[i].scriptWitness.stack;\n+            size_t stack_size = stack.size();\n+            if (stack_size >= 2 && !stack[stack_size - 1].empty() && stack[stack_size - 1][0] == ANNEX_TAG) {\n+                stack_size--; // Ignore annex\n+            }\n+            if (stack_size >= 2) {\n+                // Script path spend\n+                if ((stack[stack_size - 1][0] & 0xfe) == 0xc0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369711202",
      "id" : 369711202,
      "in_reply_to_id" : 369632680,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTcxMTIwMg==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 245,
      "original_position" : 15,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : null,
      "pull_request_review_id" : 346784383,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369711202",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1731?v=4",
         "events_url" : "https://api.github.com/users/skwp/events{/privacy}",
         "followers_url" : "https://api.github.com/users/skwp/followers",
         "following_url" : "https://api.github.com/users/skwp/following{/other_user}",
         "gists_url" : "https://api.github.com/users/skwp/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/skwp",
         "id" : 1731,
         "login" : "skwp",
         "node_id" : "MDQ6VXNlcjE3MzE=",
         "organizations_url" : "https://api.github.com/users/skwp/orgs",
         "received_events_url" : "https://api.github.com/users/skwp/received_events",
         "repos_url" : "https://api.github.com/users/skwp/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/skwp/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/skwp/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/skwp"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369764799"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369764799"
         }
      },
      "author_association" : "NONE",
      "body" : "taghash is written twice. Is this intentional?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T19:42:07Z",
      "diff_hunk" : "@@ -77,3 +78,12 @@ void BIP32Hash(const ChainCode &chainCode, unsigned int nChild, unsigned char he\n     num[3] = (nChild >>  0) & 0xFF;\n     CHMAC_SHA512(chainCode.begin(), chainCode.size()).Write(&header, 1).Write(data, 32).Write(num, 4).Finalize(output);\n }\n+\n+CHashWriter TaggedHash(const std::string& tag)\n+{\n+    CHashWriter writer(SER_GETHASH, 0);\n+    uint256 taghash;\n+    CSHA256().Write((unsigned char*)tag.data(), tag.size()).Finalize(taghash.begin());\n+    writer << taghash << taghash;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369764799",
      "id" : 369764799,
      "line" : 94,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc2NDc5OQ==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 94,
      "original_position" : 18,
      "original_start_line" : null,
      "path" : "src/hash.cpp",
      "position" : 18,
      "pull_request_review_id" : 346852688,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369764799",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/60033096?v=4",
         "events_url" : "https://api.github.com/users/constcast-glitch/events{/privacy}",
         "followers_url" : "https://api.github.com/users/constcast-glitch/followers",
         "following_url" : "https://api.github.com/users/constcast-glitch/following{/other_user}",
         "gists_url" : "https://api.github.com/users/constcast-glitch/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/constcast-glitch",
         "id" : 60033096,
         "login" : "constcast-glitch",
         "node_id" : "MDQ6VXNlcjYwMDMzMDk2",
         "organizations_url" : "https://api.github.com/users/constcast-glitch/orgs",
         "received_events_url" : "https://api.github.com/users/constcast-glitch/received_events",
         "repos_url" : "https://api.github.com/users/constcast-glitch/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/constcast-glitch/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/constcast-glitch/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/constcast-glitch"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369766227"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369766227"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yes, please read the spec.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T19:45:02Z",
      "diff_hunk" : "@@ -77,3 +78,12 @@ void BIP32Hash(const ChainCode &chainCode, unsigned int nChild, unsigned char he\n     num[3] = (nChild >>  0) & 0xFF;\n     CHMAC_SHA512(chainCode.begin(), chainCode.size()).Write(&header, 1).Write(data, 32).Write(num, 4).Finalize(output);\n }\n+\n+CHashWriter TaggedHash(const std::string& tag)\n+{\n+    CHashWriter writer(SER_GETHASH, 0);\n+    uint256 taghash;\n+    CSHA256().Write((unsigned char*)tag.data(), tag.size()).Finalize(taghash.begin());\n+    writer << taghash << taghash;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369766227",
      "id" : 369766227,
      "in_reply_to_id" : 369764799,
      "line" : 94,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc2NjIyNw==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 94,
      "original_position" : 18,
      "original_start_line" : null,
      "path" : "src/hash.cpp",
      "position" : 18,
      "pull_request_review_id" : 346854522,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369766227",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369768378"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369768378"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: `reinterpret_cast<unsigned char*>(const_cast<char*>(`?\r\n\r\nThe `const_cast` could be removed with C++17 and a switch to rvalue references.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T19:49:33Z",
      "diff_hunk" : "@@ -77,3 +78,12 @@ void BIP32Hash(const ChainCode &chainCode, unsigned int nChild, unsigned char he\n     num[3] = (nChild >>  0) & 0xFF;\n     CHMAC_SHA512(chainCode.begin(), chainCode.size()).Write(&header, 1).Write(data, 32).Write(num, 4).Finalize(output);\n }\n+\n+CHashWriter TaggedHash(const std::string& tag)\n+{\n+    CHashWriter writer(SER_GETHASH, 0);\n+    uint256 taghash;\n+    CSHA256().Write((unsigned char*)tag.data(), tag.size()).Finalize(taghash.begin());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369768378",
      "id" : 369768378,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc2ODM3OA==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 86,
      "original_position" : 17,
      "original_start_line" : null,
      "path" : "src/hash.cpp",
      "position" : null,
      "pull_request_review_id" : 346857429,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369768378",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369778313"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369778313"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This should just be `(const char*)tag.data`. We don't usually use C++ style casts for primitive types (they're all equivalent anyway, and the C++ style ones are very verbose).",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T20:11:10Z",
      "diff_hunk" : "@@ -77,3 +78,12 @@ void BIP32Hash(const ChainCode &chainCode, unsigned int nChild, unsigned char he\n     num[3] = (nChild >>  0) & 0xFF;\n     CHMAC_SHA512(chainCode.begin(), chainCode.size()).Write(&header, 1).Write(data, 32).Write(num, 4).Finalize(output);\n }\n+\n+CHashWriter TaggedHash(const std::string& tag)\n+{\n+    CHashWriter writer(SER_GETHASH, 0);\n+    uint256 taghash;\n+    CSHA256().Write((unsigned char*)tag.data(), tag.size()).Finalize(taghash.begin());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369778313",
      "id" : 369778313,
      "in_reply_to_id" : 369768378,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc3ODMxMw==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 86,
      "original_position" : 17,
      "original_start_line" : null,
      "path" : "src/hash.cpp",
      "position" : null,
      "pull_request_review_id" : 346870366,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369778313",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369779079"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369779079"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Changed into `SHA256Uint256`, and moved to hash.{h,cpp}.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T20:12:57Z",
      "diff_hunk" : "@@ -1189,7 +1358,14 @@ uint256 GetPrevoutHash(const T& txTo)\n     for (const auto& txin : txTo.vin) {\n         ss << txin.prevout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n+}\n+\n+uint256 HashAgain(const uint256& hash)\n+{\n+    uint256 result;\n+    CSHA256().Write(hash.begin(), 32).Finalize(result.begin());\n+    return result;\n }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369779079",
      "id" : 369779079,
      "in_reply_to_id" : 369389626,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc3OTA3OQ==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 1369,
      "original_position" : 314,
      "original_start_line" : 1364,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 346871432,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369779079",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369779340"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369779340"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nice catch, fixed. I don't know what \"less expired\" means; all dates in the past are equally expired.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T20:13:32Z",
      "diff_hunk" : "@@ -83,6 +83,11 @@ class CMainParams : public CChainParams {\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999; // December 31, 2008\n \n+        // Deployment of Taproot\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].bit = 2;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369779340",
      "id" : 369779340,
      "in_reply_to_id" : 369513725,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc3OTM0MA==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 88,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "src/chainparams.cpp",
      "position" : null,
      "pull_request_review_id" : 346871779,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369779340",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369779414"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369779414"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T20:13:41Z",
      "diff_hunk" : "@@ -14,6 +14,7 @@ namespace Consensus {\n enum DeploymentPos\n {\n     DEPLOYMENT_TESTDUMMY,\n+    DEPLOYMENT_TAPROOT, // Deployment of bip-taproot/bip-tapscript/bip-schnorr",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369779414",
      "id" : 369779414,
      "in_reply_to_id" : 369593203,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc3OTQxNA==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 17,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/consensus/params.h",
      "position" : null,
      "pull_request_review_id" : 346871873,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369779414",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369779485"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369779485"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T20:13:50Z",
      "diff_hunk" : "@@ -204,4 +218,12 @@ unsigned int MurmurHash3(unsigned int nHashSeed, const std::vector<unsigned char\n \n void BIP32Hash(const ChainCode &chainCode, unsigned int nChild, unsigned char header, const unsigned char data[32], unsigned char output[64]);\n \n+/** Return a CHashWriter primed for computing bip-schnorr compatible tagged hashes.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369779485",
      "id" : 369779485,
      "in_reply_to_id" : 369593612,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc3OTQ4NQ==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 221,
      "original_position" : 60,
      "original_start_line" : null,
      "path" : "src/hash.h",
      "position" : null,
      "pull_request_review_id" : 346871950,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369779485",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369779689"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369779689"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This belongs in https://github.com/bitcoin-core/secp256k1/pull/558.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T20:14:18Z",
      "diff_hunk" : "@@ -0,0 +1,125 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369779689",
      "id" : 369779689,
      "in_reply_to_id" : 369597072,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc3OTY4OQ==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 11,
      "original_position" : 11,
      "original_start_line" : null,
      "path" : "src/secp256k1/include/secp256k1_schnorrsig.h",
      "position" : null,
      "pull_request_review_id" : 346872218,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369779689",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369779758"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369779758"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T20:14:28Z",
      "diff_hunk" : "@@ -384,3 +453,33 @@ def sign_ecdsa(self, msg, low_s=True):\n         rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')\n         sb = s.to_bytes((s.bit_length() + 8) // 8, 'big')\n         return b'\\x30' + bytes([4 + len(rb) + len(sb), 2, len(rb)]) + rb + bytes([2, len(sb)]) + sb\n+\n+    def sign_schnorr(self, msg):\n+        \"\"\"Construct a bip-schnorr compatible signature with this key.\"\"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369779758",
      "id" : 369779758,
      "in_reply_to_id" : 369601055,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc3OTc1OA==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 458,
      "original_position" : 126,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 346872310,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369779758",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369779870"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369779870"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This belongs in https://github.com/bitcoin-core/secp256k1/pull/558.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T20:14:45Z",
      "diff_hunk" : "@@ -0,0 +1,125 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369779870",
      "id" : 369779870,
      "in_reply_to_id" : 369609545,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc3OTg3MA==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 12,
      "original_position" : 12,
      "original_start_line" : null,
      "path" : "src/secp256k1/include/secp256k1_schnorrsig.h",
      "position" : null,
      "pull_request_review_id" : 346872452,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369779870",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369780016"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369780016"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This belongs in https://github.com/bitcoin-core/secp256k1/pull/558.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T20:15:08Z",
      "diff_hunk" : "@@ -0,0 +1,125 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (X coordinate only; the Y coordinate is considered to be the unique\n+ * Y coordinate satisfying the curve equation that is square)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369780016",
      "id" : 369780016,
      "in_reply_to_id" : 369609932,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc4MDAxNg==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 72,
      "original_position" : 72,
      "original_start_line" : null,
      "path" : "src/secp256k1/include/secp256k1_schnorrsig.h",
      "position" : null,
      "pull_request_review_id" : 346872658,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369780016",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369780198"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369780198"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This belongs in https://github.com/bitcoin-core/secp256k1/pull/558. Also, that would be invalid C code.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T20:15:30Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorr\")||SHA256(\"BIPSchnorr\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x048d9a59ul;\n+    sha->s[1] = 0xfe39fb05ul;\n+    sha->s[2] = 0x28479648ul;\n+    sha->s[3] = 0xe4a660f9ul;\n+    sha->s[4] = 0x814b9e66ul;\n+    sha->s[5] = 0x0469e801ul;\n+    sha->s[6] = 0x83909280ul;\n+    sha->s[7] = 0xb329e454ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[32];\n+    unsigned char seckey_tmp[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369780198",
      "id" : 369780198,
      "in_reply_to_id" : 369610577,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc4MDE5OA==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 67,
      "original_position" : 67,
      "original_start_line" : null,
      "path" : "src/secp256k1/src/modules/schnorrsig/main_impl.h",
      "position" : null,
      "pull_request_review_id" : 346872915,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369780198",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369780376"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369780376"
         }
      },
      "author_association" : "NONE",
      "body" : "Unify Taproot capitalization in comments.\r\n```suggestion\r\n    DEPLOYMENT_TAPROOT, // Deployment of Taproot (BIPs 340-342)\r\n```",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T20:15:52Z",
      "diff_hunk" : "@@ -14,6 +14,7 @@ namespace Consensus {\n enum DeploymentPos\n {\n     DEPLOYMENT_TESTDUMMY,\n+    DEPLOYMENT_TAPROOT, // Deployment of taproot (BIPs 340-342)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369780376",
      "id" : 369780376,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc4MDM3Ng==",
      "original_commit_id" : "9f578bfcc7f0b63b50371f5ae046edf2e98fda5b",
      "original_line" : 17,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/consensus/params.h",
      "position" : null,
      "pull_request_review_id" : 346873146,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369780376",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/9156103?v=4",
         "events_url" : "https://api.github.com/users/nopara73/events{/privacy}",
         "followers_url" : "https://api.github.com/users/nopara73/followers",
         "following_url" : "https://api.github.com/users/nopara73/following{/other_user}",
         "gists_url" : "https://api.github.com/users/nopara73/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/nopara73",
         "id" : 9156103,
         "login" : "nopara73",
         "node_id" : "MDQ6VXNlcjkxNTYxMDM=",
         "organizations_url" : "https://api.github.com/users/nopara73/orgs",
         "received_events_url" : "https://api.github.com/users/nopara73/received_events",
         "repos_url" : "https://api.github.com/users/nopara73/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/nopara73/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/nopara73/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/nopara73"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369780392"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369780392"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Changing that would violate the spec.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T20:15:54Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+int secp256k1_schnorrsig_serialize(const secp256k1_context* ctx, unsigned char *out64, const secp256k1_schnorrsig* sig) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(out64 != NULL);\n+    ARG_CHECK(sig != NULL);\n+    memcpy(out64, sig->data, 64);\n+    return 1;\n+}\n+\n+int secp256k1_schnorrsig_parse(const secp256k1_context* ctx, secp256k1_schnorrsig* sig, const unsigned char *in64) {\n+    (void) ctx;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(in64 != NULL);\n+    memcpy(sig->data, in64, 64);\n+    return 1;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorr\")||SHA256(\"BIPSchnorr\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x048d9a59ul;\n+    sha->s[1] = 0xfe39fb05ul;\n+    sha->s[2] = 0x28479648ul;\n+    sha->s[3] = 0xe4a660f9ul;\n+    sha->s[4] = 0x814b9e66ul;\n+    sha->s[5] = 0x0469e801ul;\n+    sha->s[6] = 0x83909280ul;\n+    sha->s[7] = 0xb329e454ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, secp256k1_schnorrsig *sig, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, void *ndata) {\n+    secp256k1_scalar x;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej pkj;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    int overflow;\n+    unsigned char buf[32];\n+    unsigned char seckey_tmp[32];\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bipschnorr;\n+    }\n+    secp256k1_scalar_set_b32(&x, seckey, &overflow);\n+    /* Fail if the secret key is invalid. */\n+    if (overflow || secp256k1_scalar_is_zero(&x)) {\n+        memset(sig, 0, sizeof(*sig));\n+        return 0;\n+    }\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pkj, &x);\n+    secp256k1_ge_set_gej(&pk, &pkj);\n+\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have a square Y. */\n+    if (!secp256k1_fe_is_quad_var(&pk.y)) {\n+        secp256k1_scalar_negate(&x, &x);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey_tmp, &x);\n+    if (!noncefp(buf, msg32, seckey_tmp, (unsigned char *) \"BIPSchnorrDerive\", (void*)ndata, 0)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369780392",
      "id" : 369780392,
      "in_reply_to_id" : 369610885,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc4MDM5Mg==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 87,
      "original_position" : 87,
      "original_start_line" : null,
      "path" : "src/secp256k1/src/modules/schnorrsig/main_impl.h",
      "position" : null,
      "pull_request_review_id" : 346873165,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369780392",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369780523"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369780523"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've added some comments. Better now?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T20:16:09Z",
      "diff_hunk" : "@@ -231,6 +231,25 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check P2TR standard limits\n+        if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE && !prevScript.IsPayToScriptHash()) {\n+            // Taproot spend\n+            const auto& stack = tx.vin[i].scriptWitness.stack;\n+            size_t stack_size = stack.size();\n+            if (stack_size >= 2 && !stack[stack_size - 1].empty() && stack[stack_size - 1][0] == ANNEX_TAG) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369780523",
      "id" : 369780523,
      "in_reply_to_id" : 369630927,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc4MDUyMw==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 240,
      "original_position" : 10,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : null,
      "pull_request_review_id" : 346873333,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369780523",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369780765"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369780765"
         }
      },
      "author_association" : "NONE",
      "body" : "Unify Taproot capitalization in comments.\r\n```suggestion\r\n    // Making unknown Taproot leaf versions non-standard\r\n```",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T20:16:37Z",
      "diff_hunk" : "@@ -114,32 +120,98 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot validation\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown taproot leaf versions non-standard",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369780765",
      "id" : 369780765,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc4MDc2NQ==",
      "original_commit_id" : "9f578bfcc7f0b63b50371f5ae046edf2e98fda5b",
      "original_line" : 128,
      "original_position" : 31,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 346873608,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369780765",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/9156103?v=4",
         "events_url" : "https://api.github.com/users/nopara73/events{/privacy}",
         "followers_url" : "https://api.github.com/users/nopara73/followers",
         "following_url" : "https://api.github.com/users/nopara73/following{/other_user}",
         "gists_url" : "https://api.github.com/users/nopara73/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/nopara73",
         "id" : 9156103,
         "login" : "nopara73",
         "node_id" : "MDQ6VXNlcjkxNTYxMDM=",
         "organizations_url" : "https://api.github.com/users/nopara73/orgs",
         "received_events_url" : "https://api.github.com/users/nopara73/received_events",
         "repos_url" : "https://api.github.com/users/nopara73/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/nopara73/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/nopara73/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/nopara73"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369781034"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369781034"
         }
      },
      "author_association" : "NONE",
      "body" : "Unify Taproot capitalization in comments.\r\n\r\n```suggestion\r\n    // Taproot\r\n```",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T20:17:15Z",
      "diff_hunk" : "@@ -138,6 +138,9 @@ const char* GetOpName(opcodetype opcode)\n     case OP_NOP9                   : return \"OP_NOP9\";\n     case OP_NOP10                  : return \"OP_NOP10\";\n \n+    // taproot",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369781034",
      "id" : 369781034,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc4MTAzNA==",
      "original_commit_id" : "9f578bfcc7f0b63b50371f5ae046edf2e98fda5b",
      "original_line" : 141,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/script/script.cpp",
      "position" : null,
      "pull_request_review_id" : 346873945,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369781034",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/9156103?v=4",
         "events_url" : "https://api.github.com/users/nopara73/events{/privacy}",
         "followers_url" : "https://api.github.com/users/nopara73/followers",
         "following_url" : "https://api.github.com/users/nopara73/following{/other_user}",
         "gists_url" : "https://api.github.com/users/nopara73/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/nopara73",
         "id" : 9156103,
         "login" : "nopara73",
         "node_id" : "MDQ6VXNlcjkxNTYxMDM=",
         "organizations_url" : "https://api.github.com/users/nopara73/orgs",
         "received_events_url" : "https://api.github.com/users/nopara73/received_events",
         "repos_url" : "https://api.github.com/users/nopara73/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/nopara73/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/nopara73/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/nopara73"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369781217"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369781217"
         }
      },
      "author_association" : "NONE",
      "body" : "Unify Taproot capitalization in comments.\r\n```suggestion\r\n    // Taproot\r\n```",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T20:17:39Z",
      "diff_hunk" : "@@ -187,6 +198,9 @@ enum opcodetype\n     OP_NOP9 = 0xb8,\n     OP_NOP10 = 0xb9,\n \n+    // taproot",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369781217",
      "id" : 369781217,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc4MTIxNw==",
      "original_commit_id" : "9f578bfcc7f0b63b50371f5ae046edf2e98fda5b",
      "original_line" : 201,
      "original_position" : 22,
      "original_start_line" : null,
      "path" : "src/script/script.h",
      "position" : null,
      "pull_request_review_id" : 346874197,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369781217",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/9156103?v=4",
         "events_url" : "https://api.github.com/users/nopara73/events{/privacy}",
         "followers_url" : "https://api.github.com/users/nopara73/followers",
         "following_url" : "https://api.github.com/users/nopara73/following{/other_user}",
         "gists_url" : "https://api.github.com/users/nopara73/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/nopara73",
         "id" : 9156103,
         "login" : "nopara73",
         "node_id" : "MDQ6VXNlcjkxNTYxMDM=",
         "organizations_url" : "https://api.github.com/users/nopara73/orgs",
         "received_events_url" : "https://api.github.com/users/nopara73/received_events",
         "repos_url" : "https://api.github.com/users/nopara73/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/nopara73/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/nopara73/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/nopara73"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369781409"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369781409"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Changed it to use the constants, that's obviously the better way.\r\n\r\nThe reason why the annex does not use a nested conditional is because it's a single `if` statement that tests the presence of the annex (as in: both conditions are needed to have an annex). The tapscript conditional is split up into the logical \"this is a script path spending\" condition and the \"this is a leaf version 0xc0 script\".",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T20:18:04Z",
      "diff_hunk" : "@@ -231,6 +231,25 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check P2TR standard limits\n+        if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE && !prevScript.IsPayToScriptHash()) {\n+            // Taproot spend\n+            const auto& stack = tx.vin[i].scriptWitness.stack;\n+            size_t stack_size = stack.size();\n+            if (stack_size >= 2 && !stack[stack_size - 1].empty() && stack[stack_size - 1][0] == ANNEX_TAG) {\n+                stack_size--; // Ignore annex\n+            }\n+            if (stack_size >= 2) {\n+                // Script path spend\n+                if ((stack[stack_size - 1][0] & 0xfe) == 0xc0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369781409",
      "id" : 369781409,
      "in_reply_to_id" : 369632680,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc4MTQwOQ==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 245,
      "original_position" : 15,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : null,
      "pull_request_review_id" : 346874459,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369781409",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369781835"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369781835"
         }
      },
      "author_association" : "NONE",
      "body" : "Unify Taproot capitalization in comments.\r\n```suggestion\r\n                # Don't use 32-byte v1 witness (used by Taproot)\r\n```",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T20:18:59Z",
      "diff_hunk" : "@@ -1364,7 +1365,11 @@ def test_segwit_versions(self):\n         assert_equal(len(self.nodes[1].getrawmempool()), 0)\n         for version in list(range(OP_1, OP_16 + 1)) + [OP_0]:\n             # First try to spend to a future version segwit script_pubkey.\n-            script_pubkey = CScript([CScriptOp(version), witness_hash])\n+            if version == OP_1:\n+                # Don't use 32-byte v1 witness (used by taproot)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369781835",
      "id" : 369781835,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc4MTgzNQ==",
      "original_commit_id" : "9f578bfcc7f0b63b50371f5ae046edf2e98fda5b",
      "original_line" : 1369,
      "original_position" : 14,
      "original_start_line" : null,
      "path" : "test/functional/p2p_segwit.py",
      "position" : null,
      "pull_request_review_id" : 346874977,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369781835",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/9156103?v=4",
         "events_url" : "https://api.github.com/users/nopara73/events{/privacy}",
         "followers_url" : "https://api.github.com/users/nopara73/followers",
         "following_url" : "https://api.github.com/users/nopara73/following{/other_user}",
         "gists_url" : "https://api.github.com/users/nopara73/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/nopara73",
         "id" : 9156103,
         "login" : "nopara73",
         "node_id" : "MDQ6VXNlcjkxNTYxMDM=",
         "organizations_url" : "https://api.github.com/users/nopara73/orgs",
         "received_events_url" : "https://api.github.com/users/nopara73/received_events",
         "repos_url" : "https://api.github.com/users/nopara73/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/nopara73/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/nopara73/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/nopara73"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369784302"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369784302"
         }
      },
      "author_association" : "NONE",
      "body" : "Unify Taproot capitalization in comments.\r\n```suggestion\r\n# Test Taproot softfork.\r\n```",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T20:24:19Z",
      "diff_hunk" : "@@ -0,0 +1,600 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test taproot softfork.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369784302",
      "id" : 369784302,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc4NDMwMg==",
      "original_commit_id" : "9f578bfcc7f0b63b50371f5ae046edf2e98fda5b",
      "original_line" : 5,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 346878131,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369784302",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/9156103?v=4",
         "events_url" : "https://api.github.com/users/nopara73/events{/privacy}",
         "followers_url" : "https://api.github.com/users/nopara73/followers",
         "following_url" : "https://api.github.com/users/nopara73/following{/other_user}",
         "gists_url" : "https://api.github.com/users/nopara73/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/nopara73",
         "id" : 9156103,
         "login" : "nopara73",
         "node_id" : "MDQ6VXNlcjkxNTYxMDM=",
         "organizations_url" : "https://api.github.com/users/nopara73/orgs",
         "received_events_url" : "https://api.github.com/users/nopara73/received_events",
         "repos_url" : "https://api.github.com/users/nopara73/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/nopara73/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/nopara73/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/nopara73"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369786605"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369786605"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: Perhaps more readable if we avoid magic numbers with something like:\r\n```c++\r\nstatic_assert(SIGHASH_TAPOUTPUTMASK < SIGHASH_TAPINPUTMASK);\r\nif ((hash_type > SIGHASH_TAPOUTPUTMASK) && (hash_type <= SIGHASH_TAPINPUTMASK || hash_type > (SIGHASH_TAPINPUTMASK | SIGHASH_TAPOUTPUTMASK))) return false;\r\n```\r\n\r\nAlternatively, a comment could be helpful.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T20:29:59Z",
      "diff_hunk" : "@@ -1209,27 +1378,137 @@ uint256 GetOutputsHash(const T& txTo)\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n+}\n+\n+uint256 GetSpentAmountsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n }\n \n } // namespace\n \n template <class T>\n-PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n+    m_spent_outputs = std::move(spent_outputs);\n+\n+    if (ready) return;\n     // Cache is calculated only for transactions with witness\n     if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+        m_prevouts_hash = GetPrevoutHash(txTo);\n+        hashPrevouts = SHA256Uint256(m_prevouts_hash);\n+        m_sequences_hash = GetSequenceHash(txTo);\n+        hashSequence = SHA256Uint256(m_sequences_hash);\n+        m_outputs_hash = GetOutputsHash(txTo);\n+        hashOutputs = SHA256Uint256(m_outputs_hash);\n         ready = true;\n+\n+        if (!m_spent_outputs.empty()) {\n+            m_amounts_spent_hash = GetSpentAmountsHash(m_spent_outputs);\n+            m_amounts_spent_ready = true;\n+        }\n     }\n }\n \n+template <class T>\n+PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+{\n+    Init(txTo, {});\n+}\n+\n // explicit instantiation\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");\n+static const CHashWriter HasherTapLeaf = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HasherTapBranch = TaggedHash(\"TapBranch\");\n+static const CHashWriter HasherTapTweak = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData& cache)\n+{\n+    assert(in_pos < tx_to.vin.size());\n+    assert(sigversion == SigVersion::TAPROOT || sigversion == SigVersion::TAPSCRIPT);\n+    assert(cache.ready && cache.m_amounts_spent_ready);\n+\n+    CHashWriter ss = HasherTapSighash;\n+\n+    // Epoch\n+    uint8_t epoch = 0;\n+    ss << epoch;\n+\n+    // Hash type\n+    if ((hash_type > 3) && (hash_type < 0x81 || hash_type > 0x83)) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369786605",
      "id" : 369786605,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc4NjYwNQ==",
      "original_commit_id" : "9f578bfcc7f0b63b50371f5ae046edf2e98fda5b",
      "original_line" : 1449,
      "original_position" : 396,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 346881218,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369786605",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369786833"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369786833"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: is it clearer to use or comment e.g. `WITNESS_V0`, and `TAPROOT` below?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T20:30:32Z",
      "diff_hunk" : "@@ -1209,27 +1378,137 @@ uint256 GetOutputsHash(const T& txTo)\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n+}\n+\n+uint256 GetSpentAmountsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n }\n \n } // namespace\n \n template <class T>\n-PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n+    m_spent_outputs = std::move(spent_outputs);\n+\n+    if (ready) return;\n     // Cache is calculated only for transactions with witness\n     if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+        m_prevouts_hash = GetPrevoutHash(txTo);\n+        hashPrevouts = SHA256Uint256(m_prevouts_hash);\n+        m_sequences_hash = GetSequenceHash(txTo);\n+        hashSequence = SHA256Uint256(m_sequences_hash);\n+        m_outputs_hash = GetOutputsHash(txTo);\n+        hashOutputs = SHA256Uint256(m_outputs_hash);\n         ready = true;\n+\n+        if (!m_spent_outputs.empty()) {\n+            m_amounts_spent_hash = GetSpentAmountsHash(m_spent_outputs);\n+            m_amounts_spent_ready = true;\n+        }\n     }\n }\n \n+template <class T>\n+PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+{\n+    Init(txTo, {});\n+}\n+\n // explicit instantiation\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");\n+static const CHashWriter HasherTapLeaf = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HasherTapBranch = TaggedHash(\"TapBranch\");\n+static const CHashWriter HasherTapTweak = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData& cache)\n+{\n+    assert(in_pos < tx_to.vin.size());\n+    assert(sigversion == SigVersion::TAPROOT || sigversion == SigVersion::TAPSCRIPT);\n+    assert(cache.ready && cache.m_amounts_spent_ready);\n+\n+    CHashWriter ss = HasherTapSighash;\n+\n+    // Epoch\n+    uint8_t epoch = 0;\n+    ss << epoch;\n+\n+    // Hash type\n+    if ((hash_type > 3) && (hash_type < 0x81 || hash_type > 0x83)) return false;\n+    ss << hash_type;\n+    const uint8_t input_type = hash_type & SIGHASH_TAPINPUTMASK;\n+    const uint8_t output_type = hash_type & SIGHASH_TAPOUTPUTMASK;\n+\n+    // Transaction level data\n+    ss << tx_to.nVersion;\n+    ss << tx_to.nLockTime;\n+\n+    if (input_type == SIGHASH_TAPDEFAULT) {\n+        ss << cache.m_prevouts_hash;\n+        ss << cache.m_amounts_spent_hash;\n+        ss << cache.m_sequences_hash;\n+    }\n+    if (output_type == SIGHASH_TAPDEFAULT || output_type == SIGHASH_ALL) {\n+        ss << cache.m_outputs_hash;\n+    }\n+\n+    // Data about the input/prevout being spent\n+    const CScript& scriptPubKey = cache.m_spent_outputs[in_pos].scriptPubKey;\n+    uint8_t spend_type = 0;\n+    assert(execdata.m_annex_init);\n+    if (execdata.m_annex_present) {\n+        spend_type |= 1;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369786833",
      "id" : 369786833,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc4NjgzMw==",
      "original_commit_id" : "9f578bfcc7f0b63b50371f5ae046edf2e98fda5b",
      "original_line" : 1472,
      "original_position" : 419,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 346881537,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369786833",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369791114"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369791114"
         }
      },
      "author_association" : "NONE",
      "body" : "I have suggested the changes [there](https://github.com/bitcoin-core/secp256k1/pull/558#pullrequestreview-346886721)",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T20:40:39Z",
      "diff_hunk" : "@@ -0,0 +1,125 @@\n+#ifndef SECP256K1_SCHNORRSIG_H\n+#define SECP256K1_SCHNORRSIG_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/** This module implements a variant of Schnorr signatures compliant with\n+ * BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki).\n+ */\n+\n+/** Opaque data structure that holds a parsed Schnorr signature.\n+ *\n+ *  The exact representation of data inside is implementation defined and not\n+ *  guaranteed to be portable between different platforms or versions. It is\n+ *  however guaranteed to be 64 bytes in size, and can be safely copied/moved.\n+ *  If you need to convert to a format suitable for storage, transmission, or\n+ *  comparison, use the `secp256k1_schnorrsig_serialize` and\n+ *  `secp256k1_schnorrsig_parse` functions.\n+ */\n+typedef struct {\n+    unsigned char data[64];\n+} secp256k1_schnorrsig;\n+\n+/** Serialize a Schnorr signature.\n+ *\n+ *  Returns: 1\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:   out64: pointer to a 64-byte array to store the serialized signature\n+ *  In:      sig: pointer to the signature\n+ *\n+ *  See secp256k1_schnorrsig_parse for details about the encoding.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_serialize(\n+    const secp256k1_context* ctx,\n+    unsigned char *out64,\n+    const secp256k1_schnorrsig* sig\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Parse a Schnorr signature.\n+ *\n+ *  Returns: 1 when the signature could be parsed, 0 otherwise.\n+ *  Args:    ctx: a secp256k1 context object\n+ *  Out:     sig: pointer to a signature object\n+ *  In:     in64: pointer to the 64-byte signature to be parsed\n+ *\n+ * The signature is serialized in the form R||s, where R is a 32-byte public\n+ * key (X coordinate only; the Y coordinate is considered to be the unique\n+ * Y coordinate satisfying the curve equation that is square)\n+ * and s is a 32-byte big-endian scalar.\n+ *\n+ * After the call, sig will always be initialized. If parsing failed or the\n+ * encoded numbers are out of range, signature validation with it is\n+ * guaranteed to fail for every message and public key.\n+ */\n+SECP256K1_API int secp256k1_schnorrsig_parse(\n+    const secp256k1_context* ctx,\n+    secp256k1_schnorrsig* sig,\n+    const unsigned char *in64\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Create a Schnorr signature.\n+ *\n+ * Returns 1 on success, 0 on failure.\n+ *  Args:    ctx: pointer to a context object, initialized for signing (cannot be NULL)\n+ *  Out:     sig: pointer to the returned signature (cannot be NULL)\n+ *  In:    msg32: the 32-byte message being signed (cannot be NULL)\n+ *        seckey: pointer to a 32-byte secret key (cannot be NULL)\n+ *       noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_bipschnorr is used",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369791114",
      "id" : 369791114,
      "in_reply_to_id" : 369609932,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc5MTExNA==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 72,
      "original_position" : 72,
      "original_start_line" : null,
      "path" : "src/secp256k1/include/secp256k1_schnorrsig.h",
      "position" : null,
      "pull_request_review_id" : 346887117,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369791114",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/30683012?v=4",
         "events_url" : "https://api.github.com/users/MaxHillebrand/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MaxHillebrand/followers",
         "following_url" : "https://api.github.com/users/MaxHillebrand/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MaxHillebrand/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MaxHillebrand",
         "id" : 30683012,
         "login" : "MaxHillebrand",
         "node_id" : "MDQ6VXNlcjMwNjgzMDEy",
         "organizations_url" : "https://api.github.com/users/MaxHillebrand/orgs",
         "received_events_url" : "https://api.github.com/users/MaxHillebrand/received_events",
         "repos_url" : "https://api.github.com/users/MaxHillebrand/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MaxHillebrand/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MaxHillebrand/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MaxHillebrand"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369791691"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369791691"
         }
      },
      "author_association" : "NONE",
      "body" : "```suggestion\r\n                    // Leaf version 0xc0 (aka Tapscript, see BIP 342)\r\n```",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T20:41:54Z",
      "diff_hunk" : "@@ -231,6 +231,31 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check P2TR standard limits\n+        if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE && !prevScript.IsPayToScriptHash()) {\n+            // Taproot spend (non-P2SH-wrapped, version 1, witness program size 32; see BIP 341)\n+            const auto& stack = tx.vin[i].scriptWitness.stack;\n+            size_t stack_size = stack.size();\n+            if (stack_size >= 2 && !stack[stack_size - 1].empty() && stack[stack_size - 1][0] == ANNEX_TAG) {\n+                stack_size--; // Ignore annex if present\n+            }\n+            if (stack_size >= 2) {\n+                // Script path spend (2 or more stack elements are removing optional annex)\n+                if ((stack[stack_size - 1][0] & TAPROOT_LEAF_MASK) == TAPROOT_LEAF_TAPSCRIPT) {\n+                    // Leaf version 0xc0 (aka tapscript, see BIP 342)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369791691",
      "id" : 369791691,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc5MTY5MQ==",
      "original_commit_id" : "9f578bfcc7f0b63b50371f5ae046edf2e98fda5b",
      "original_line" : 246,
      "original_position" : 16,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : null,
      "pull_request_review_id" : 346887828,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369791691",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/30683012?v=4",
         "events_url" : "https://api.github.com/users/MaxHillebrand/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MaxHillebrand/followers",
         "following_url" : "https://api.github.com/users/MaxHillebrand/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MaxHillebrand/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MaxHillebrand",
         "id" : 30683012,
         "login" : "MaxHillebrand",
         "node_id" : "MDQ6VXNlcjMwNjgzMDEy",
         "organizations_url" : "https://api.github.com/users/MaxHillebrand/orgs",
         "received_events_url" : "https://api.github.com/users/MaxHillebrand/received_events",
         "repos_url" : "https://api.github.com/users/MaxHillebrand/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MaxHillebrand/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MaxHillebrand/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MaxHillebrand"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369791787"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369791787"
         }
      },
      "author_association" : "NONE",
      "body" : "```suggestion\r\n/** The maximum size of each witness stack item in a standard Tapscript */\r\n```",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T20:42:10Z",
      "diff_hunk" : "@@ -40,6 +40,8 @@ static const bool DEFAULT_PERMIT_BAREMULTISIG = true;\n static const unsigned int MAX_STANDARD_P2WSH_STACK_ITEMS = 100;\n /** The maximum size of each witness stack item in a standard P2WSH script */\n static const unsigned int MAX_STANDARD_P2WSH_STACK_ITEM_SIZE = 80;\n+/** The maximum size of each witness stack item in a standard tapscript */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369791787",
      "id" : 369791787,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc5MTc4Nw==",
      "original_commit_id" : "9f578bfcc7f0b63b50371f5ae046edf2e98fda5b",
      "original_line" : 43,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/policy/policy.h",
      "position" : null,
      "pull_request_review_id" : 346887828,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369791787",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/30683012?v=4",
         "events_url" : "https://api.github.com/users/MaxHillebrand/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MaxHillebrand/followers",
         "following_url" : "https://api.github.com/users/MaxHillebrand/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MaxHillebrand/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MaxHillebrand",
         "id" : 30683012,
         "login" : "MaxHillebrand",
         "node_id" : "MDQ6VXNlcjMwNjgzMDEy",
         "organizations_url" : "https://api.github.com/users/MaxHillebrand/orgs",
         "received_events_url" : "https://api.github.com/users/MaxHillebrand/received_events",
         "repos_url" : "https://api.github.com/users/MaxHillebrand/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MaxHillebrand/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MaxHillebrand/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MaxHillebrand"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369791871"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369791871"
         }
      },
      "author_association" : "NONE",
      "body" : "```suggestion\r\n    // Making unknown public key versions in Tapscript non-standard\r\n```",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T20:42:23Z",
      "diff_hunk" : "@@ -114,32 +120,98 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot validation\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making the use of (unknown) annexes non-standard (currently no annexes are known)\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 20),\n+\n+    // Making unknown public key versions in tapscript non-standard",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369791871",
      "id" : 369791871,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc5MTg3MQ==",
      "original_commit_id" : "9f578bfcc7f0b63b50371f5ae046edf2e98fda5b",
      "original_line" : 139,
      "original_position" : 42,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 346887828,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369791871",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/30683012?v=4",
         "events_url" : "https://api.github.com/users/MaxHillebrand/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MaxHillebrand/followers",
         "following_url" : "https://api.github.com/users/MaxHillebrand/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MaxHillebrand/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MaxHillebrand",
         "id" : 30683012,
         "login" : "MaxHillebrand",
         "node_id" : "MDQ6VXNlcjMwNjgzMDEy",
         "organizations_url" : "https://api.github.com/users/MaxHillebrand/orgs",
         "received_events_url" : "https://api.github.com/users/MaxHillebrand/received_events",
         "repos_url" : "https://api.github.com/users/MaxHillebrand/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MaxHillebrand/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MaxHillebrand/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MaxHillebrand"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369792013"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369792013"
         }
      },
      "author_association" : "NONE",
      "body" : "```suggestion\r\n// Validation weight per passing signature (Tapscript only).\r\n```",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T20:42:46Z",
      "diff_hunk" : "@@ -44,6 +44,17 @@ static const unsigned int LOCKTIME_THRESHOLD = 500000000; // Tue Nov  5 00:53:20\n // SEQUENCE_FINAL).\n static const uint32_t LOCKTIME_MAX = 0xFFFFFFFFU;\n \n+// Tag for input annex. If there are at least two witness elements for a transaction input,\n+// and the first byte of the last element is 0x50, this last element is called annex, and\n+// has meanings independent of the script\n+static const unsigned int ANNEX_TAG = 0x50;\n+\n+// Validation weight per passing signature (tapscript only).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369792013",
      "id" : 369792013,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc5MjAxMw==",
      "original_commit_id" : "9f578bfcc7f0b63b50371f5ae046edf2e98fda5b",
      "original_line" : 52,
      "original_position" : 9,
      "original_start_line" : null,
      "path" : "src/script/script.h",
      "position" : null,
      "pull_request_review_id" : 346887828,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369792013",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/30683012?v=4",
         "events_url" : "https://api.github.com/users/MaxHillebrand/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MaxHillebrand/followers",
         "following_url" : "https://api.github.com/users/MaxHillebrand/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MaxHillebrand/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MaxHillebrand",
         "id" : 30683012,
         "login" : "MaxHillebrand",
         "node_id" : "MDQ6VXNlcjMwNjgzMDEy",
         "organizations_url" : "https://api.github.com/users/MaxHillebrand/orgs",
         "received_events_url" : "https://api.github.com/users/MaxHillebrand/received_events",
         "repos_url" : "https://api.github.com/users/MaxHillebrand/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MaxHillebrand/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MaxHillebrand/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MaxHillebrand"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369792104"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369792104"
         }
      },
      "author_association" : "NONE",
      "body" : "```suggestion\r\n// How much weight budget is added to the witness size (Tapscript only).\r\n```",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T20:42:58Z",
      "diff_hunk" : "@@ -44,6 +44,17 @@ static const unsigned int LOCKTIME_THRESHOLD = 500000000; // Tue Nov  5 00:53:20\n // SEQUENCE_FINAL).\n static const uint32_t LOCKTIME_MAX = 0xFFFFFFFFU;\n \n+// Tag for input annex. If there are at least two witness elements for a transaction input,\n+// and the first byte of the last element is 0x50, this last element is called annex, and\n+// has meanings independent of the script\n+static const unsigned int ANNEX_TAG = 0x50;\n+\n+// Validation weight per passing signature (tapscript only).\n+static constexpr uint64_t VALIDATION_WEIGHT_PER_SIGOP_PASSED = 50;\n+\n+// How much weight budget is added to the witness size (tapscript only).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369792104",
      "id" : 369792104,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc5MjEwNA==",
      "original_commit_id" : "9f578bfcc7f0b63b50371f5ae046edf2e98fda5b",
      "original_line" : 55,
      "original_position" : 12,
      "original_start_line" : null,
      "path" : "src/script/script.h",
      "position" : null,
      "pull_request_review_id" : 346887828,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369792104",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/30683012?v=4",
         "events_url" : "https://api.github.com/users/MaxHillebrand/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MaxHillebrand/followers",
         "following_url" : "https://api.github.com/users/MaxHillebrand/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MaxHillebrand/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MaxHillebrand",
         "id" : 30683012,
         "login" : "MaxHillebrand",
         "node_id" : "MDQ6VXNlcjMwNjgzMDEy",
         "organizations_url" : "https://api.github.com/users/MaxHillebrand/orgs",
         "received_events_url" : "https://api.github.com/users/MaxHillebrand/received_events",
         "repos_url" : "https://api.github.com/users/MaxHillebrand/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MaxHillebrand/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MaxHillebrand/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MaxHillebrand"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369792258"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369792258"
         }
      },
      "author_association" : "NONE",
      "body" : "```suggestion\r\n# Tapscript\r\n```",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T20:43:20Z",
      "diff_hunk" : "@@ -223,11 +229,8 @@ def __new__(cls, n):\n OP_NOP9 = CScriptOp(0xb8)\n OP_NOP10 = CScriptOp(0xb9)\n \n-# template matching params\n-OP_SMALLINTEGER = CScriptOp(0xfa)\n-OP_PUBKEYS = CScriptOp(0xfb)\n-OP_PUBKEYHASH = CScriptOp(0xfd)\n-OP_PUBKEY = CScriptOp(0xfe)\n+# tapscript",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369792258",
      "id" : 369792258,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc5MjI1OA==",
      "original_commit_id" : "9f578bfcc7f0b63b50371f5ae046edf2e98fda5b",
      "original_line" : 232,
      "original_position" : 32,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/script.py",
      "position" : null,
      "pull_request_review_id" : 346887828,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369792258",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/30683012?v=4",
         "events_url" : "https://api.github.com/users/MaxHillebrand/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MaxHillebrand/followers",
         "following_url" : "https://api.github.com/users/MaxHillebrand/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MaxHillebrand/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MaxHillebrand",
         "id" : 30683012,
         "login" : "MaxHillebrand",
         "node_id" : "MDQ6VXNlcjMwNjgzMDEy",
         "organizations_url" : "https://api.github.com/users/MaxHillebrand/orgs",
         "received_events_url" : "https://api.github.com/users/MaxHillebrand/received_events",
         "repos_url" : "https://api.github.com/users/MaxHillebrand/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MaxHillebrand/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MaxHillebrand/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MaxHillebrand"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369798203"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369798203"
         }
      },
      "author_association" : "MEMBER",
      "body" : "~~nit: `stack.back()`~~\r\n\r\nNeglected to examine the full context.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T20:56:18Z",
      "diff_hunk" : "@@ -231,6 +231,31 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check P2TR standard limits\n+        if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE && !prevScript.IsPayToScriptHash()) {\n+            // Taproot spend (non-P2SH-wrapped, version 1, witness program size 32; see BIP 341)\n+            const auto& stack = tx.vin[i].scriptWitness.stack;\n+            size_t stack_size = stack.size();\n+            if (stack_size >= 2 && !stack[stack_size - 1].empty() && stack[stack_size - 1][0] == ANNEX_TAG) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369798203",
      "id" : 369798203,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc5ODIwMw==",
      "original_commit_id" : "9f578bfcc7f0b63b50371f5ae046edf2e98fda5b",
      "original_line" : 240,
      "original_position" : 10,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : null,
      "pull_request_review_id" : 346896145,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369798203",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369798364"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369798364"
         }
      },
      "author_association" : "MEMBER",
      "body" : "No, that would be incorrect.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T20:56:38Z",
      "diff_hunk" : "@@ -231,6 +231,31 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check P2TR standard limits\n+        if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE && !prevScript.IsPayToScriptHash()) {\n+            // Taproot spend (non-P2SH-wrapped, version 1, witness program size 32; see BIP 341)\n+            const auto& stack = tx.vin[i].scriptWitness.stack;\n+            size_t stack_size = stack.size();\n+            if (stack_size >= 2 && !stack[stack_size - 1].empty() && stack[stack_size - 1][0] == ANNEX_TAG) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369798364",
      "id" : 369798364,
      "in_reply_to_id" : 369798203,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc5ODM2NA==",
      "original_commit_id" : "9f578bfcc7f0b63b50371f5ae046edf2e98fda5b",
      "original_line" : 240,
      "original_position" : 10,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : null,
      "pull_request_review_id" : 346896354,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369798364",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369804204"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369804204"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: how about `!= sizeof(((secp256k1_schnorrsig){0}).data)`, a `static_assert`, or similar?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T21:08:52Z",
      "diff_hunk" : "@@ -166,6 +167,23 @@ static int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1\n     return 1;\n }\n \n+bool XOnlyPubKey::VerifySchnorr(const uint256 &hash, const std::vector<unsigned char>& sigbytes) const {\n+    if (sigbytes.size() != 64) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369804204",
      "id" : 369804204,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTgwNDIwNA==",
      "original_commit_id" : "2c55acda1cba362b08e289d60fe77eb8baaeb17e",
      "original_line" : 177,
      "original_position" : 13,
      "original_start_line" : null,
      "path" : "src/pubkey.cpp",
      "position" : null,
      "pull_request_review_id" : 346903893,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369804204",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369805872"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369805872"
         }
      },
      "author_association" : "NONE",
      "body" : "Thanks definitely helps, though I would still love to see some vars extracted to named for readability and deduplication. I'm not gonna nitpick your code for style, I'm just a humble bitcoin pleb. But I do know what it's like to scale codebases to be friendly to onboarding new devs. I do think readability should be a concern if we want more devs in bitcoin. e.g. `stack[stack_size - 1]` is repeated all over the place. call it `top_of_stack` and so much more readable!   ",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T21:12:15Z",
      "diff_hunk" : "@@ -231,6 +231,25 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check P2TR standard limits\n+        if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE && !prevScript.IsPayToScriptHash()) {\n+            // Taproot spend\n+            const auto& stack = tx.vin[i].scriptWitness.stack;\n+            size_t stack_size = stack.size();\n+            if (stack_size >= 2 && !stack[stack_size - 1].empty() && stack[stack_size - 1][0] == ANNEX_TAG) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369805872",
      "id" : 369805872,
      "in_reply_to_id" : 369630927,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTgwNTg3Mg==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 240,
      "original_position" : 10,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : null,
      "pull_request_review_id" : 346905955,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369805872",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1731?v=4",
         "events_url" : "https://api.github.com/users/skwp/events{/privacy}",
         "followers_url" : "https://api.github.com/users/skwp/followers",
         "following_url" : "https://api.github.com/users/skwp/following{/other_user}",
         "gists_url" : "https://api.github.com/users/skwp/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/skwp",
         "id" : 1731,
         "login" : "skwp",
         "node_id" : "MDQ6VXNlcjE3MzE=",
         "organizations_url" : "https://api.github.com/users/skwp/orgs",
         "received_events_url" : "https://api.github.com/users/skwp/received_events",
         "repos_url" : "https://api.github.com/users/skwp/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/skwp/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/skwp/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/skwp"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369810334"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369810334"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Well the reason is that the `stack_size` variable changes, so a \"top_of_stack\" one would need to be updated, kinda defeating its meaning.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T21:22:27Z",
      "diff_hunk" : "@@ -231,6 +231,25 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check P2TR standard limits\n+        if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE && !prevScript.IsPayToScriptHash()) {\n+            // Taproot spend\n+            const auto& stack = tx.vin[i].scriptWitness.stack;\n+            size_t stack_size = stack.size();\n+            if (stack_size >= 2 && !stack[stack_size - 1].empty() && stack[stack_size - 1][0] == ANNEX_TAG) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369810334",
      "id" : 369810334,
      "in_reply_to_id" : 369630927,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTgxMDMzNA==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 240,
      "original_position" : 10,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : null,
      "pull_request_review_id" : 346911857,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369810334",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369834460"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369834460"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: a `NONE_EXECUTED` constant would be expressive",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T22:15:55Z",
      "diff_hunk" : "@@ -293,19 +444,25 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n     CScript::const_iterator pbegincodehash = script.begin();\n     opcodetype opcode;\n     valtype vchPushValue;\n-    std::vector<bool> vfExec;\n+    ConditionStack vfExec;\n     std::vector<valtype> altstack;\n     set_error(serror, SCRIPT_ERR_UNKNOWN_ERROR);\n-    if (script.size() > MAX_SCRIPT_SIZE)\n+    if ((sigversion == SigVersion::BASE || sigversion == SigVersion::WITNESS_V0) && script.size() > MAX_SCRIPT_SIZE) {\n         return set_error(serror, SCRIPT_ERR_SCRIPT_SIZE);\n+    }\n+    if (sigversion == SigVersion::TAPSCRIPT && stack.size() > MAX_STACK_SIZE) {\n+        return set_error(serror, SCRIPT_ERR_STACK_SIZE);\n+    }\n     int nOpCount = 0;\n     bool fRequireMinimal = (flags & SCRIPT_VERIFY_MINIMALDATA) != 0;\n+    uint32_t opcode_pos = 0;\n+    execdata.m_codeseparator_pos = 0xFFFFFFFFUL;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369834460",
      "id" : 369834460,
      "line" : 459,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTgzNDQ2MA==",
      "original_commit_id" : "2c55acda1cba362b08e289d60fe77eb8baaeb17e",
      "original_line" : 459,
      "original_position" : 178,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 117,
      "pull_request_review_id" : 346942138,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369834460",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369849023"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369849023"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In the end, all of this is probably personal taste but I think there is a reason why a lot of those magic numbers are just literals. This number will never need to change.\r\n `sizeof(((secp256k1_schnorrsig){0}).data)` just makes the code harder to read and review (because you need to look up the definition of `secp256k1_schnorrsig`, and it would be a little bit like having a constant `BITS_IN_UINT256 = 256`.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T22:50:55Z",
      "diff_hunk" : "@@ -166,6 +167,23 @@ static int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1\n     return 1;\n }\n \n+bool XOnlyPubKey::VerifySchnorr(const uint256 &hash, const std::vector<unsigned char>& sigbytes) const {\n+    if (sigbytes.size() != 64) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369849023",
      "id" : 369849023,
      "in_reply_to_id" : 369804204,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg0OTAyMw==",
      "original_commit_id" : "2c55acda1cba362b08e289d60fe77eb8baaeb17e",
      "original_line" : 177,
      "original_position" : 13,
      "original_start_line" : null,
      "path" : "src/pubkey.cpp",
      "position" : null,
      "pull_request_review_id" : 346959975,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369849023",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/1071625?v=4",
         "events_url" : "https://api.github.com/users/real-or-random/events{/privacy}",
         "followers_url" : "https://api.github.com/users/real-or-random/followers",
         "following_url" : "https://api.github.com/users/real-or-random/following{/other_user}",
         "gists_url" : "https://api.github.com/users/real-or-random/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/real-or-random",
         "id" : 1071625,
         "login" : "real-or-random",
         "node_id" : "MDQ6VXNlcjEwNzE2MjU=",
         "organizations_url" : "https://api.github.com/users/real-or-random/orgs",
         "received_events_url" : "https://api.github.com/users/real-or-random/received_events",
         "repos_url" : "https://api.github.com/users/real-or-random/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/real-or-random/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/real-or-random/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/real-or-random"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369852128"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369852128"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This seems weird to me. How can we verify a signature for a point which does not have a square Y? Such public keys are not defined in bip-schnorr.\r\n\r\nI think it'd be clearer to assert that the pubkey has a square Y before verifying. I'd also suggest adding a `get_xonly_pubkey()` method to `ECKey` so we can directly get the valid bip-schnorr pubkey.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T22:59:23Z",
      "diff_hunk" : "@@ -322,6 +353,40 @@ def verify_ecdsa(self, sig, msg, low_s=True):\n             return False\n         return True\n \n+    def verify_schnorr(self, sig, msg):\n+        assert(len(msg) == 32)\n+        assert(len(sig) == 64)\n+        assert(self.valid)\n+        assert(self.compressed)\n+        r = int.from_bytes(sig[0:32], 'big')\n+        if r >= SECP256K1_FIELD_SIZE:\n+            return False\n+        s = int.from_bytes(sig[32:64], 'big')\n+        if s >= SECP256K1_ORDER:\n+            return False\n+        e = int.from_bytes(TaggedHash(\"BIPSchnorr\", sig[0:32] + self.get_bytes()[1:33] + msg), 'big') % SECP256K1_ORDER\n+        if self.is_positive:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369852128",
      "id" : 369852128,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg1MjEyOA==",
      "original_commit_id" : "2c55acda1cba362b08e289d60fe77eb8baaeb17e",
      "original_line" : 368,
      "original_position" : 84,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 346963790,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369852128",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369865203"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369865203"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> This seems weird to me. How can we verify a signature for a point which does not have a square Y? Such public keys are not defined in bip-schnorr.\r\n\r\nHm in fact it's different in yet another way. \r\n - The very pedantic version: bip-schnorr defines public keys to be byte arrays of length 32. \"square y\" does not make sense for byte arrays. \r\n - The less pedantic version: Even if you interpret the byte array as an integer, it's supposed to encode an x-coordinate only. \"square y\" does not make sense for an x-coordinate.\r\n\r\nSee also https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr/reference.py#L99\r\n\r\nIf we want to be compatible with the existing code here, I'm not sure what the best approach is. Maybe it makes more sense to accept a byte string, then parse it into a point and then use the existing code?\r\nedit: Well okay, I think in the end that's already happening in the code, but I think it will still be cleaner if the `verify_schnorr` function would not take points directly.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T23:39:29Z",
      "diff_hunk" : "@@ -322,6 +353,40 @@ def verify_ecdsa(self, sig, msg, low_s=True):\n             return False\n         return True\n \n+    def verify_schnorr(self, sig, msg):\n+        assert(len(msg) == 32)\n+        assert(len(sig) == 64)\n+        assert(self.valid)\n+        assert(self.compressed)\n+        r = int.from_bytes(sig[0:32], 'big')\n+        if r >= SECP256K1_FIELD_SIZE:\n+            return False\n+        s = int.from_bytes(sig[32:64], 'big')\n+        if s >= SECP256K1_ORDER:\n+            return False\n+        e = int.from_bytes(TaggedHash(\"BIPSchnorr\", sig[0:32] + self.get_bytes()[1:33] + msg), 'big') % SECP256K1_ORDER\n+        if self.is_positive:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369865203",
      "id" : 369865203,
      "in_reply_to_id" : 369852128,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg2NTIwMw==",
      "original_commit_id" : "2c55acda1cba362b08e289d60fe77eb8baaeb17e",
      "original_line" : 368,
      "original_position" : 84,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 346979617,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369865203",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/1071625?v=4",
         "events_url" : "https://api.github.com/users/real-or-random/events{/privacy}",
         "followers_url" : "https://api.github.com/users/real-or-random/followers",
         "following_url" : "https://api.github.com/users/real-or-random/following{/other_user}",
         "gists_url" : "https://api.github.com/users/real-or-random/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/real-or-random",
         "id" : 1071625,
         "login" : "real-or-random",
         "node_id" : "MDQ6VXNlcjEwNzE2MjU=",
         "organizations_url" : "https://api.github.com/users/real-or-random/orgs",
         "received_events_url" : "https://api.github.com/users/real-or-random/received_events",
         "repos_url" : "https://api.github.com/users/real-or-random/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/real-or-random/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/real-or-random/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/real-or-random"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369866607"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369866607"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The notion is that by tying one constant to a formal description, we can make explicit and enforced a connection that would otherwise be implicit and unenforced. IMO, that such a thing can't be violated is always better than that it won't be violated.\r\n\r\nThere are ways to do that without making the code markedly more complex, such as offloading it to a constant + `static_assert`.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-22T23:44:46Z",
      "diff_hunk" : "@@ -166,6 +167,23 @@ static int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1\n     return 1;\n }\n \n+bool XOnlyPubKey::VerifySchnorr(const uint256 &hash, const std::vector<unsigned char>& sigbytes) const {\n+    if (sigbytes.size() != 64) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369866607",
      "id" : 369866607,
      "in_reply_to_id" : 369804204,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg2NjYwNw==",
      "original_commit_id" : "2c55acda1cba362b08e289d60fe77eb8baaeb17e",
      "original_line" : 177,
      "original_position" : 13,
      "original_start_line" : null,
      "path" : "src/pubkey.cpp",
      "position" : null,
      "pull_request_review_id" : 346981391,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369866607",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369896427"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369896427"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've changed this code quite a bit. What do you think?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-23T01:42:47Z",
      "diff_hunk" : "@@ -231,6 +231,25 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check P2TR standard limits\n+        if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE && !prevScript.IsPayToScriptHash()) {\n+            // Taproot spend\n+            const auto& stack = tx.vin[i].scriptWitness.stack;\n+            size_t stack_size = stack.size();\n+            if (stack_size >= 2 && !stack[stack_size - 1].empty() && stack[stack_size - 1][0] == ANNEX_TAG) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369896427",
      "id" : 369896427,
      "in_reply_to_id" : 369630927,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg5NjQyNw==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 240,
      "original_position" : 10,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : null,
      "pull_request_review_id" : 347017092,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369896427",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369896642"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369896642"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Updated.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-23T01:43:31Z",
      "diff_hunk" : "@@ -14,6 +14,7 @@ namespace Consensus {\n enum DeploymentPos\n {\n     DEPLOYMENT_TESTDUMMY,\n+    DEPLOYMENT_TAPROOT, // Deployment of taproot (BIPs 340-342)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369896642",
      "id" : 369896642,
      "in_reply_to_id" : 369780376,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg5NjY0Mg==",
      "original_commit_id" : "9f578bfcc7f0b63b50371f5ae046edf2e98fda5b",
      "original_line" : 17,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/consensus/params.h",
      "position" : null,
      "pull_request_review_id" : 347017315,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369896642",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369896679"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369896679"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Updated.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-23T01:43:39Z",
      "diff_hunk" : "@@ -114,32 +120,98 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot validation\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown taproot leaf versions non-standard",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369896679",
      "id" : 369896679,
      "in_reply_to_id" : 369780765,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg5NjY3OQ==",
      "original_commit_id" : "9f578bfcc7f0b63b50371f5ae046edf2e98fda5b",
      "original_line" : 128,
      "original_position" : 31,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 347017353,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369896679",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369896713"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369896713"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Updated.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-23T01:43:46Z",
      "diff_hunk" : "@@ -138,6 +138,9 @@ const char* GetOpName(opcodetype opcode)\n     case OP_NOP9                   : return \"OP_NOP9\";\n     case OP_NOP10                  : return \"OP_NOP10\";\n \n+    // taproot",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369896713",
      "id" : 369896713,
      "in_reply_to_id" : 369781034,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg5NjcxMw==",
      "original_commit_id" : "9f578bfcc7f0b63b50371f5ae046edf2e98fda5b",
      "original_line" : 141,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/script/script.cpp",
      "position" : null,
      "pull_request_review_id" : 347017399,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369896713",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369896841"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369896841"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Updated.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-23T01:44:15Z",
      "diff_hunk" : "@@ -187,6 +198,9 @@ enum opcodetype\n     OP_NOP9 = 0xb8,\n     OP_NOP10 = 0xb9,\n \n+    // taproot",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369896841",
      "id" : 369896841,
      "in_reply_to_id" : 369781217,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg5Njg0MQ==",
      "original_commit_id" : "9f578bfcc7f0b63b50371f5ae046edf2e98fda5b",
      "original_line" : 201,
      "original_position" : 22,
      "original_start_line" : null,
      "path" : "src/script/script.h",
      "position" : null,
      "pull_request_review_id" : 347017546,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369896841",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369896888"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369896888"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Updated.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-23T01:44:25Z",
      "diff_hunk" : "@@ -1364,7 +1365,11 @@ def test_segwit_versions(self):\n         assert_equal(len(self.nodes[1].getrawmempool()), 0)\n         for version in list(range(OP_1, OP_16 + 1)) + [OP_0]:\n             # First try to spend to a future version segwit script_pubkey.\n-            script_pubkey = CScript([CScriptOp(version), witness_hash])\n+            if version == OP_1:\n+                # Don't use 32-byte v1 witness (used by taproot)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369896888",
      "id" : 369896888,
      "in_reply_to_id" : 369781835,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg5Njg4OA==",
      "original_commit_id" : "9f578bfcc7f0b63b50371f5ae046edf2e98fda5b",
      "original_line" : 1369,
      "original_position" : 14,
      "original_start_line" : null,
      "path" : "test/functional/p2p_segwit.py",
      "position" : null,
      "pull_request_review_id" : 347017604,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369896888",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369897072"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369897072"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Updated.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-23T01:44:56Z",
      "diff_hunk" : "@@ -0,0 +1,600 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test taproot softfork.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369897072",
      "id" : 369897072,
      "in_reply_to_id" : 369784302,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg5NzA3Mg==",
      "original_commit_id" : "9f578bfcc7f0b63b50371f5ae046edf2e98fda5b",
      "original_line" : 5,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 347017814,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369897072",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369897737"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369897737"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Sorry, I meant it should expire in the future or the taproot deployment will fail to activate.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-23T01:47:16Z",
      "diff_hunk" : "@@ -83,6 +83,11 @@ class CMainParams : public CChainParams {\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999; // December 31, 2008\n \n+        // Deployment of Taproot\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].bit = 2;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369897737",
      "id" : 369897737,
      "in_reply_to_id" : 369513725,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg5NzczNw==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 88,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "src/chainparams.cpp",
      "position" : null,
      "pull_request_review_id" : 347018496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369897737",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369898283"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369898283"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This PR intentionally doesn't include mainnet activation; the values here are just a dummy. Apart from the fact that no activation time (or mechanism) has been established yet, that activation logic will likely be included in a different release than the validation logic (thus needing a separate PR anyway).",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-23T01:49:06Z",
      "diff_hunk" : "@@ -83,6 +83,11 @@ class CMainParams : public CChainParams {\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999; // December 31, 2008\n \n+        // Deployment of Taproot\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].bit = 2;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369898283",
      "id" : 369898283,
      "in_reply_to_id" : 369513725,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTg5ODI4Mw==",
      "original_commit_id" : "1f499c5b67e9f42e90ac115b43b7c7aa9b44a75c",
      "original_line" : 88,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "src/chainparams.cpp",
      "position" : null,
      "pull_request_review_id" : 347019063,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369898283",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369910526"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369910526"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Updated.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-23T02:47:47Z",
      "diff_hunk" : "@@ -114,32 +120,98 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot validation\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making the use of (unknown) annexes non-standard (currently no annexes are known)\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 20),\n+\n+    // Making unknown public key versions in tapscript non-standard",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369910526",
      "id" : 369910526,
      "in_reply_to_id" : 369791871,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkxMDUyNg==",
      "original_commit_id" : "9f578bfcc7f0b63b50371f5ae046edf2e98fda5b",
      "original_line" : 139,
      "original_position" : 42,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 347033160,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369910526",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369910547"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369910547"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Updated.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-23T02:47:57Z",
      "diff_hunk" : "@@ -40,6 +40,8 @@ static const bool DEFAULT_PERMIT_BAREMULTISIG = true;\n static const unsigned int MAX_STANDARD_P2WSH_STACK_ITEMS = 100;\n /** The maximum size of each witness stack item in a standard P2WSH script */\n static const unsigned int MAX_STANDARD_P2WSH_STACK_ITEM_SIZE = 80;\n+/** The maximum size of each witness stack item in a standard tapscript */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369910547",
      "id" : 369910547,
      "in_reply_to_id" : 369791787,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkxMDU0Nw==",
      "original_commit_id" : "9f578bfcc7f0b63b50371f5ae046edf2e98fda5b",
      "original_line" : 43,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/policy/policy.h",
      "position" : null,
      "pull_request_review_id" : 347033191,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369910547",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369910572"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369910572"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Updated.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-23T02:48:06Z",
      "diff_hunk" : "@@ -231,6 +231,31 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check P2TR standard limits\n+        if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE && !prevScript.IsPayToScriptHash()) {\n+            // Taproot spend (non-P2SH-wrapped, version 1, witness program size 32; see BIP 341)\n+            const auto& stack = tx.vin[i].scriptWitness.stack;\n+            size_t stack_size = stack.size();\n+            if (stack_size >= 2 && !stack[stack_size - 1].empty() && stack[stack_size - 1][0] == ANNEX_TAG) {\n+                stack_size--; // Ignore annex if present\n+            }\n+            if (stack_size >= 2) {\n+                // Script path spend (2 or more stack elements are removing optional annex)\n+                if ((stack[stack_size - 1][0] & TAPROOT_LEAF_MASK) == TAPROOT_LEAF_TAPSCRIPT) {\n+                    // Leaf version 0xc0 (aka tapscript, see BIP 342)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369910572",
      "id" : 369910572,
      "in_reply_to_id" : 369791691,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkxMDU3Mg==",
      "original_commit_id" : "9f578bfcc7f0b63b50371f5ae046edf2e98fda5b",
      "original_line" : 246,
      "original_position" : 16,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : null,
      "pull_request_review_id" : 347033220,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369910572",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369910604"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369910604"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Updated.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-23T02:48:15Z",
      "diff_hunk" : "@@ -44,6 +44,17 @@ static const unsigned int LOCKTIME_THRESHOLD = 500000000; // Tue Nov  5 00:53:20\n // SEQUENCE_FINAL).\n static const uint32_t LOCKTIME_MAX = 0xFFFFFFFFU;\n \n+// Tag for input annex. If there are at least two witness elements for a transaction input,\n+// and the first byte of the last element is 0x50, this last element is called annex, and\n+// has meanings independent of the script\n+static const unsigned int ANNEX_TAG = 0x50;\n+\n+// Validation weight per passing signature (tapscript only).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369910604",
      "id" : 369910604,
      "in_reply_to_id" : 369792013,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkxMDYwNA==",
      "original_commit_id" : "9f578bfcc7f0b63b50371f5ae046edf2e98fda5b",
      "original_line" : 52,
      "original_position" : 9,
      "original_start_line" : null,
      "path" : "src/script/script.h",
      "position" : null,
      "pull_request_review_id" : 347033259,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369910604",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369910632"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369910632"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Updated.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-23T02:48:23Z",
      "diff_hunk" : "@@ -44,6 +44,17 @@ static const unsigned int LOCKTIME_THRESHOLD = 500000000; // Tue Nov  5 00:53:20\n // SEQUENCE_FINAL).\n static const uint32_t LOCKTIME_MAX = 0xFFFFFFFFU;\n \n+// Tag for input annex. If there are at least two witness elements for a transaction input,\n+// and the first byte of the last element is 0x50, this last element is called annex, and\n+// has meanings independent of the script\n+static const unsigned int ANNEX_TAG = 0x50;\n+\n+// Validation weight per passing signature (tapscript only).\n+static constexpr uint64_t VALIDATION_WEIGHT_PER_SIGOP_PASSED = 50;\n+\n+// How much weight budget is added to the witness size (tapscript only).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369910632",
      "id" : 369910632,
      "in_reply_to_id" : 369792104,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkxMDYzMg==",
      "original_commit_id" : "9f578bfcc7f0b63b50371f5ae046edf2e98fda5b",
      "original_line" : 55,
      "original_position" : 12,
      "original_start_line" : null,
      "path" : "src/script/script.h",
      "position" : null,
      "pull_request_review_id" : 347033296,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369910632",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369910663"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369910663"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Updated.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-23T02:48:32Z",
      "diff_hunk" : "@@ -223,11 +229,8 @@ def __new__(cls, n):\n OP_NOP9 = CScriptOp(0xb8)\n OP_NOP10 = CScriptOp(0xb9)\n \n-# template matching params\n-OP_SMALLINTEGER = CScriptOp(0xfa)\n-OP_PUBKEYS = CScriptOp(0xfb)\n-OP_PUBKEYHASH = CScriptOp(0xfd)\n-OP_PUBKEY = CScriptOp(0xfe)\n+# tapscript",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369910663",
      "id" : 369910663,
      "in_reply_to_id" : 369792258,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkxMDY2Mw==",
      "original_commit_id" : "9f578bfcc7f0b63b50371f5ae046edf2e98fda5b",
      "original_line" : 232,
      "original_position" : 32,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/script.py",
      "position" : null,
      "pull_request_review_id" : 347033324,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369910663",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369915231"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369915231"
         }
      },
      "author_association" : "NONE",
      "body" : "Btw, I wasn't planning to waste your time on this by suggesting to manually fix it up. You can just click apply suggestion on GitHub and it'll create a shared commit.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-23T03:13:58Z",
      "diff_hunk" : "@@ -14,6 +14,7 @@ namespace Consensus {\n enum DeploymentPos\n {\n     DEPLOYMENT_TESTDUMMY,\n+    DEPLOYMENT_TAPROOT, // Deployment of taproot (BIPs 340-342)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r369915231",
      "id" : 369915231,
      "in_reply_to_id" : 369780376,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkxNTIzMQ==",
      "original_commit_id" : "9f578bfcc7f0b63b50371f5ae046edf2e98fda5b",
      "original_line" : 17,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/consensus/params.h",
      "position" : null,
      "pull_request_review_id" : 347038715,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/369915231",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/9156103?v=4",
         "events_url" : "https://api.github.com/users/nopara73/events{/privacy}",
         "followers_url" : "https://api.github.com/users/nopara73/followers",
         "following_url" : "https://api.github.com/users/nopara73/following{/other_user}",
         "gists_url" : "https://api.github.com/users/nopara73/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/nopara73",
         "id" : 9156103,
         "login" : "nopara73",
         "node_id" : "MDQ6VXNlcjkxNTYxMDM=",
         "organizations_url" : "https://api.github.com/users/nopara73/orgs",
         "received_events_url" : "https://api.github.com/users/nopara73/received_events",
         "repos_url" : "https://api.github.com/users/nopara73/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/nopara73/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/nopara73/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/nopara73"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370020828"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370020828"
         }
      },
      "author_association" : "NONE",
      "body" : "Use taproot instead of tap?\r\nSIGHASH_TAPROOT_DEFAULT\r\nTAPROOT like other instances, e.g. TAPROOT_PROGRAM_SIZE.\r\n\r\nAlso, SignatureHashTap() renamed to SignatureHashTaproot()?\r\nSimilar to VerifyTaprootCommitment.\r\n",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-23T09:51:59Z",
      "diff_hunk" : "@@ -24,6 +26,10 @@ enum\n     SIGHASH_NONE = 2,\n     SIGHASH_SINGLE = 3,\n     SIGHASH_ANYONECANPAY = 0x80,\n+\n+    SIGHASH_TAPDEFAULT = 0,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370020828",
      "id" : 370020828,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAyMDgyOA==",
      "original_commit_id" : "41acd620b5a0018b9ab5eb709ef54fafa8937324",
      "original_line" : 30,
      "original_position" : 16,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 347171002,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370020828",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/60021837?v=4",
         "events_url" : "https://api.github.com/users/v1048576/events{/privacy}",
         "followers_url" : "https://api.github.com/users/v1048576/followers",
         "following_url" : "https://api.github.com/users/v1048576/following{/other_user}",
         "gists_url" : "https://api.github.com/users/v1048576/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/v1048576",
         "id" : 60021837,
         "login" : "v1048576",
         "node_id" : "MDQ6VXNlcjYwMDIxODM3",
         "organizations_url" : "https://api.github.com/users/v1048576/orgs",
         "received_events_url" : "https://api.github.com/users/v1048576/received_events",
         "repos_url" : "https://api.github.com/users/v1048576/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/v1048576/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/v1048576/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/v1048576"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370024599"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370024599"
         }
      },
      "author_association" : "NONE",
      "body" : "Why not check against opcode defines? ",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-23T09:59:10Z",
      "diff_hunk" : "@@ -326,3 +329,11 @@ bool GetScriptOp(CScriptBase::const_iterator& pc, CScriptBase::const_iterator en\n     opcodeRet = static_cast<opcodetype>(opcode);\n     return true;\n }\n+\n+bool IsOpSuccess(const opcodetype& opcode)\n+{\n+    return (opcode == 0x50 || opcode == 0x62 || opcode == 0x89 ||",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370024599",
      "id" : 370024599,
      "line" : 337,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAyNDU5OQ==",
      "original_commit_id" : "41acd620b5a0018b9ab5eb709ef54fafa8937324",
      "original_line" : 337,
      "original_position" : 17,
      "original_start_line" : null,
      "path" : "src/script/script.cpp",
      "position" : 17,
      "pull_request_review_id" : 347175631,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370024599",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/60021837?v=4",
         "events_url" : "https://api.github.com/users/v1048576/events{/privacy}",
         "followers_url" : "https://api.github.com/users/v1048576/followers",
         "following_url" : "https://api.github.com/users/v1048576/following{/other_user}",
         "gists_url" : "https://api.github.com/users/v1048576/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/v1048576",
         "id" : 60021837,
         "login" : "v1048576",
         "node_id" : "MDQ6VXNlcjYwMDIxODM3",
         "organizations_url" : "https://api.github.com/users/v1048576/orgs",
         "received_events_url" : "https://api.github.com/users/v1048576/received_events",
         "repos_url" : "https://api.github.com/users/v1048576/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/v1048576/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/v1048576/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/v1048576"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370142806"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370142806"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`verify_schnorr` has been updated to be a function that takes a pubkey (32-byte array) instead of being a method on `ECPubKey`.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-23T14:18:32Z",
      "diff_hunk" : "@@ -322,6 +353,40 @@ def verify_ecdsa(self, sig, msg, low_s=True):\n             return False\n         return True\n \n+    def verify_schnorr(self, sig, msg):\n+        assert(len(msg) == 32)\n+        assert(len(sig) == 64)\n+        assert(self.valid)\n+        assert(self.compressed)\n+        r = int.from_bytes(sig[0:32], 'big')\n+        if r >= SECP256K1_FIELD_SIZE:\n+            return False\n+        s = int.from_bytes(sig[32:64], 'big')\n+        if s >= SECP256K1_ORDER:\n+            return False\n+        e = int.from_bytes(TaggedHash(\"BIPSchnorr\", sig[0:32] + self.get_bytes()[1:33] + msg), 'big') % SECP256K1_ORDER\n+        if self.is_positive:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370142806",
      "id" : 370142806,
      "in_reply_to_id" : 369852128,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDE0MjgwNg==",
      "original_commit_id" : "2c55acda1cba362b08e289d60fe77eb8baaeb17e",
      "original_line" : 368,
      "original_position" : 84,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 347329335,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370142806",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370147930"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370147930"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should these be updated to be BIP schnorr pubkeys (32-byte arrays)?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-23T14:27:05Z",
      "diff_hunk" : "@@ -0,0 +1,600 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import create_coinbase, create_block, add_witness_commitment\n+from test_framework.messages import CTransaction, CTxIn, CTxOut, COutPoint, CTxInWitness\n+from test_framework.script import CScript, TaprootSignatureHash, taproot_construct, OP_0, OP_1, OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD, OP_IF, OP_CODESEPARATOR, OP_ELSE, OP_ENDIF, OP_DROP, LEAF_VERSION_TAPSCRIPT, SIGHASH_SINGLE, is_op_success, CScriptOp, OP_RETURN, OP_VERIF, OP_1NEGATE, OP_EQUAL, OP_SWAP, OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY, OP_NOTIF, OP_2DROP, OP_NOT, OP_2DUP, OP_1SUB, OP_DUP, MAX_SCRIPT_ELEMENT_SIZE, LOCKTIME_THRESHOLD, ANNEX_TAG\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, hex_str_to_bytes\n+from test_framework.key import ECKey, SECP256K1_ORDER, verify_schnorr\n+from test_framework.address import program_to_witness\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+import struct\n+\n+EMPTYWITNESS_ERROR = \"non-mandatory-script-verify-flag (Witness program was passed an empty witness) (code 64)\"\n+INVALIDKEYPATHSIG_ERROR = \"non-mandatory-script-verify-flag (Invalid signature for Taproot key path spending) (code 64)\"\n+UNKNOWNWITNESS_ERROR = \"non-mandatory-script-verify-flag (Witness version reserved for soft-fork upgrades) (code 64)\"\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+def tx_from_hex(hexstring):\n+    tx = CTransaction()\n+    f = BytesIO(hex_str_to_bytes(hexstring))\n+    tx.deserialize(f)\n+    return tx\n+\n+def get_taproot_bech32(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return program_to_witness(1, info[2:])\n+\n+def random_op_success():\n+    ret = 0\n+    while (not is_op_success(ret)):\n+        ret = random.randint(0x50, 0xfe)\n+    return CScriptOp(ret)\n+\n+def random_unknown_leaf_ver(no_annex_tag=True):\n+    ret = LEAF_VERSION_TAPSCRIPT\n+    while (ret == LEAF_VERSION_TAPSCRIPT or (no_annex_tag and ret == (ANNEX_TAG & 0xfe))):\n+        ret = random.randrange(128) * 2\n+    return ret\n+\n+def random_bytes(n):\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def random_script(size, no_success = True):\n+    ret = bytes()\n+    while (len(ret) < size):\n+        remain = size - len(ret)\n+        opcode = random.randrange(256)\n+        while (no_success and is_op_success(opcode)):\n+            opcode = random.randrange(256)\n+        if opcode == 0 or opcode >= OP_1NEGATE:\n+            ret += bytes([opcode])\n+        elif opcode <= 75 and opcode <= remain - 1:\n+            ret += bytes([opcode]) + random_bytes(opcode)\n+        elif opcode == 76 and remain >= 2:\n+            pushsize = random.randint(0, min(0xff, remain - 2))\n+            ret += bytes([opcode]) + bytes([pushsize]) + random_bytes(pushsize)\n+        elif opcode == 77 and remain >= 3:\n+            pushsize = random.randint(0, min(0xffff, remain - 3))\n+            ret += bytes([opcode]) + struct.pack(b'<H', pushsize) + random_bytes(pushsize)\n+        elif opcode == 78 and remain >= 5:\n+            pushsize = random.randint(0, min(0xffffffff, remain - 5))\n+            ret += bytes([opcode]) + struct.pack(b'<I', pushsize) + random_bytes(pushsize)\n+    assert len(ret) == size\n+    return ret\n+\n+def random_invalid_push(size):\n+    assert size > 0\n+    ret = bytes()\n+    opcode = 78\n+    if size <= 75:\n+        opcode = random.randint(75, 78)\n+    elif size <= 255:\n+        opcode = random.randint(76, 78)\n+    elif size <= 0xffff:\n+        opcode = random.randint(77, 78)\n+    if opcode == 75:\n+        ret = bytes([size]) + random_bytes(size - 1)\n+    elif opcode == 76:\n+        ret = bytes([opcode]) + bytes([size]) + random_bytes(size - 2)\n+    elif opcode == 77:\n+        ret = bytes([opcode]) + struct.pack(b'<H', size) + random_bytes(max(0, size - 3))\n+    else:\n+        ret = bytes([opcode]) + struct.pack(b'<I', size) + random_bytes(max(0, size - 5))\n+    assert len(ret) >= size\n+    return ret[:size]\n+\n+def random_checksig_style(pubkey):\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num+1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def damage_bytes(b):\n+    return (int.from_bytes(b, 'big') ^ (1 << random.randrange(len(b)*8))).to_bytes(len(b), 'big')\n+\n+# Each spender is a tuple of:\n+# - A scriptPubKey (CScript)\n+# - An address for that scriptPubKey (string)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A witness stack-producing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+\n+Spender = namedtuple(\"Spender\", \"script,address,comment,is_standard,sat_function\")\n+\n+def spend_single_sig(tx, input_index, spent_utxos, info, key, annex=None, hashtype=0, prefix=None, suffix=None, script=None, pos=-1, damage=False):\n+    if prefix is None:\n+        prefix = []\n+    if suffix is None:\n+        suffix = []\n+\n+    ht = hashtype\n+\n+    damage_type = random.randrange(5) if damage else -1\n+    '''\n+    * 0. bit flip the sighash\n+    * 1. bit flip the signature\n+    * If the expected hashtype is 0:\n+    -- 2. append a 0 to the signature\n+    -- 3. append a random value of 1-255 to the signature\n+    * If the expected hashtype is not 0:\n+    -- 2. do not append hashtype to the signature\n+    -- 3. append a random incorrect value of 0-255 to the signature\n+    * 4. extra witness element\n+    '''\n+\n+    # Taproot key path spend: tweak key\n+    if script is None:\n+        pubkey = key.get_pubkey()\n+        if not pubkey.is_positive:\n+            key.negate()\n+        key = key.tweak_add(info[1])\n+        assert(key is not None)\n+    # Change SIGHASH_SINGLE into SIGHASH_ALL if no corresponding output\n+    if (ht & 3 == SIGHASH_SINGLE and input_index >= len(tx.vout)):\n+        ht ^= 2\n+    # Compute sighash\n+    if script:\n+        sighash = TaprootSignatureHash(tx, spent_utxos, ht, input_index, scriptpath = True, script = script, codeseparator_pos = pos, annex = annex)\n+    else:\n+        sighash = TaprootSignatureHash(tx, spent_utxos, ht, input_index, scriptpath = False, annex = annex)\n+    if damage_type == 0:\n+        sighash = damage_bytes(sighash)\n+    # Compute signature\n+    sig = key.sign_schnorr(sighash)\n+    if damage_type == 1:\n+        sig = damage_bytes(sig)\n+    if damage_type == 2:\n+        if ht == 0:\n+            sig += bytes([0])\n+    elif damage_type == 3:\n+        random_ht = ht\n+        while random_ht == ht:\n+            random_ht = random.randrange(256)\n+        sig += bytes([random_ht])\n+    elif ht > 0:\n+        sig += bytes([ht])\n+    # Construct witness\n+    ret = prefix + [sig] + suffix\n+    if script is not None:\n+        ret += [script, info[2][script]]\n+    if annex is not None:\n+        ret += [annex]\n+    if damage_type == 4:\n+        ret = [random_bytes(random.randrange(5))] + ret\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = ret\n+\n+def spend_alwaysvalid(tx, input_index, info, script, annex=None, damage=False):\n+    if isinstance(script, tuple):\n+        version, script = script\n+    ret = [script, info[2][script]]\n+    if damage:\n+        # With 50% chance, we bit flip the script (unless the script is an empty vector)\n+        # With 50% chance, we bit flip the control block\n+        if random.choice([True, False]) or len(ret[0]) == 0:\n+            # Annex is always required for leaf version 0x50\n+            # Unless the original version is 0x50, we couldn't convert it to 0x50 without using annex\n+            tmp = damage_bytes(ret[1])\n+            while annex is None and tmp[0] == ANNEX_TAG and ret[1][0] != ANNEX_TAG:\n+                tmp = damage_bytes(ret[1])\n+            ret[1] = tmp\n+        else:\n+            ret[0] = damage_bytes(ret[0])\n+    if annex is not None:\n+        ret += [annex]\n+    # Randomly add input witness\n+    if random.choice([True, False]):\n+        for i in range(random.randint(1, 10)):\n+            ret = [random_bytes(random.randint(0, MAX_SCRIPT_ELEMENT_SIZE*2))] + ret\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = ret\n+\n+def spender_sighash_mutation(spenders, info, comment, standard=True, **kwargs):\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_single_sig(t, i, u, damage=not v, info=info, **kwargs)\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn))\n+\n+def spender_two_paths(spenders, info, comment, standard, success, failure):\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_single_sig(t, i, u, damage=False, info=info, **(success if v else failure))\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn))\n+\n+def spender_alwaysvalid(spenders, info, comment, **kwargs):\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_alwaysvalid(t, i, damage=not v, info=info, **kwargs)\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=False, sat_function=fn))\n+\n+def nested_script(script, depth):\n+    if depth == 0:\n+        return script\n+    return [nested_script(script, depth - 1), CScript([OP_RETURN])]\n+\n+UTXOData = namedtuple('UTXOData', 'input,output,spender')\n+\n+class TAPROOTTest(BitcoinTestFramework):\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.extra_args = [[\"-whitelist=127.0.0.1\", \"-acceptnonstdtxn=0\", \"-par=1\"]]\n+\n+    def block_submit(self, node, txs, msg, cb_pubkey=None, fees=0, witness=False, accept=False):\n+        block = create_block(self.tip, create_coinbase(self.lastblockheight + 1, pubkey=cb_pubkey, fees=fees), self.lastblocktime + 1)\n+        block.nVersion = 4\n+        for tx in txs:\n+            tx.rehash()\n+            block.vtx.append(tx)\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        witness and add_witness_commitment(block)\n+        block.rehash()\n+        block.solve()\n+        node.submitblock(block.serialize(True).hex())\n+        if (accept):\n+            assert node.getbestblockhash() == block.hash, \"Failed to accept: \" + msg\n+            self.tip = block.sha256\n+            self.lastblockhash = block.hash\n+            self.lastblocktime += 1\n+            self.lastblockheight += 1\n+        else:\n+            assert node.getbestblockhash() == self.lastblockhash, \"Failed to reject: \" + msg\n+\n+    def test_spenders(self, spenders, input_counts):\n+        \"\"\"Run randomized tests with a number of \"spenders\".\n+\n+\n+        Each spender embodies a test; in a large randomized test, it is verified\n+        that toggling the valid argument to each lambda toggles the validity of\n+        the transaction. This is accomplished by constructing transactions consisting\n+        of all valid inputs, except one invalid one.\n+        \"\"\"\n+\n+        # Construct a UTXO to spend for each of the spenders\n+        self.nodes[0].generate(110)\n+        bal = self.nodes[0].getbalance() * 3 / (4*len(spenders))\n+        random.shuffle(spenders)\n+        num_spenders = len(spenders)\n+        utxos = []\n+        while len(spenders):\n+            # Create the necessary outputs in multiple transactions, as sPKs may be repeated (which sendmany does not support)\n+            outputs = {}\n+            new_spenders = []\n+            batch = []\n+            for spender in spenders:\n+                addr = spender.address\n+                if len(batch) == 100 or addr in outputs:\n+                    new_spenders.append(spender)\n+                else:\n+                    amount = random.randrange(int(bal * 95000000), int(bal * 105000000))\n+                    outputs[addr] = amount / 100000000\n+                    batch.append(spender)\n+            self.log.info(\"Constructing %i UTXOs for spending tests\" % len(batch))\n+            tx = tx_from_hex(self.nodes[0].getrawtransaction(self.nodes[0].sendmany(\"\", outputs)))\n+            tx.rehash()\n+            spenders = new_spenders\n+            random.shuffle(spenders)\n+\n+            # Map created UTXOs back to the spenders they were created for\n+            for n, out in enumerate(tx.vout):\n+                for spender in batch:\n+                    if out.scriptPubKey == spender.script:\n+                        utxos.append(UTXOData(input=COutPoint(tx.sha256, n), output=out, spender=spender))\n+                        break\n+        assert(len(utxos) == num_spenders)\n+        random.shuffle(utxos)\n+        self.nodes[0].generate(1)\n+\n+        # Construct a bunch of sPKs that send coins back to the host wallet\n+        self.log.info(\"Constructing 100 addresses for returning coins\")\n+        host_spks = []\n+        host_pubkeys = []\n+        for i in range(100):\n+            addr = self.nodes[0].getnewaddress(address_type=random.choice([\"legacy\", \"p2sh-segwit\", \"bech32\"]))\n+            info = self.nodes[0].getaddressinfo(addr)\n+            spk = hex_str_to_bytes(info['scriptPubKey'])\n+            host_spks.append(spk)\n+            host_pubkeys.append(hex_str_to_bytes(info['pubkey']))\n+\n+        # Pick random subsets of UTXOs to construct transactions with\n+        self.lastblockhash = self.nodes[0].getbestblockhash()\n+        self.tip = int(\"0x\" + self.lastblockhash, 0)\n+        block = self.nodes[0].getblock(self.lastblockhash)\n+        self.lastblockheight = block['height']\n+        self.lastblocktime = block['time']\n+        while len(utxos):\n+            tx = CTransaction()\n+            tx.nVersion = random.choice([1, 2, random.randint(-0x80000000,0x7fffffff)])\n+            min_sequence = (tx.nVersion != 1 and tx.nVersion != 0) * 0x80000000 # The minimum sequence number to disable relative locktime\n+            if random.choice([True, False]):\n+                tx.nLockTime = random.randrange(LOCKTIME_THRESHOLD, self.lastblocktime - 7200) # all absolute locktimes in the past\n+            else:\n+                tx.nLockTime = random.randrange(self.lastblockheight+1) # all block heights in the past\n+\n+            # Pick 1 to 4 UTXOs to construct transaction inputs\n+            acceptable_input_counts = [cnt for cnt in input_counts if cnt <= len(utxos)]\n+            while True:\n+                inputs = random.choice(acceptable_input_counts)\n+                remaining = len(utxos) - inputs\n+                if remaining == 0 or remaining >= max(input_counts) or remaining in input_counts:\n+                    break\n+            input_utxos = utxos[-inputs:]\n+            utxos = utxos[:-inputs]\n+            fee = random.randrange(MIN_FEE * 2, MIN_FEE * 4) # 10000-20000 sat fee\n+            in_value = sum(utxo.output.nValue for utxo in input_utxos) - fee\n+            tx.vin = [CTxIn(outpoint = input_utxos[i].input, nSequence = random.randint(min_sequence, 0xffffffff)) for i in range(inputs)]\n+            tx.wit.vtxinwit = [CTxInWitness() for i in range(inputs)]\n+            self.log.info(\"Test: %s\" % (\", \".join(utxo.spender.comment for utxo in input_utxos)))\n+\n+            # Add 1 to 4 outputs\n+            outputs = random.choice([1,2,3,4])\n+            assert in_value >= 0 and fee - outputs * DUST_LIMIT >= MIN_FEE\n+            for i in range(outputs):\n+                tx.vout.append(CTxOut())\n+                if in_value <= DUST_LIMIT:\n+                    tx.vout[-1].nValue = DUST_LIMIT\n+                elif i < outputs - 1:\n+                    tx.vout[-1].nValue = in_value\n+                else:\n+                    tx.vout[-1].nValue = random.randint(DUST_LIMIT, in_value)\n+                in_value -= tx.vout[-1].nValue\n+                tx.vout[-1].scriptPubKey = random.choice(host_spks)\n+            fee += in_value\n+            assert(fee >= 0)\n+\n+            # For each inputs, make it fail once; then succeed once\n+            for fail_input in range(inputs + 1):\n+                # Wipe scriptSig/witness\n+                for i in range(inputs):\n+                    tx.vin[i].scriptSig = CScript()\n+                    tx.wit.vtxinwit[i] = CTxInWitness()\n+                # Fill inputs/witnesses\n+                for i in range(inputs):\n+                    fn = input_utxos[i].spender.sat_function\n+                    fn(tx, i, [utxo.output for utxo in input_utxos], i != fail_input)\n+                # Submit to mempool to check standardness\n+                standard = fail_input == inputs and all(utxo.spender.is_standard for utxo in input_utxos) and tx.nVersion >= 1 and tx.nVersion <= 2\n+                if standard:\n+                    self.nodes[0].sendrawtransaction(tx.serialize().hex(), 0)\n+                    assert(self.nodes[0].getmempoolentry(tx.hash) is not None)\n+                else:\n+                    assert_raises_rpc_error(-26, None, self.nodes[0].sendrawtransaction, tx.serialize().hex(), 0)\n+                # Submit in a block\n+                tx.rehash()\n+                msg = ','.join(utxo.spender.comment + (\"*\" if n == fail_input else \"\") for n, utxo in enumerate(input_utxos))\n+                self.block_submit(self.nodes[0], [tx], msg, witness=True, accept=fail_input == inputs, cb_pubkey=random.choice(host_pubkeys), fees=fee)\n+\n+    def build_spenders(self):\n+        VALID_SIGHASHES = [0,1,2,3,0x81,0x82,0x83]\n+        spenders = []\n+\n+        for annex in [None, bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+            standard = annex is None\n+            sec1, sec2 = ECKey(), ECKey()\n+            sec1.generate()\n+            sec2.generate()\n+            pub1, pub2 = sec1.get_pubkey(), sec2.get_pubkey()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370147930",
      "id" : 370147930,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDE0NzkzMA==",
      "original_commit_id" : "41acd620b5a0018b9ab5eb709ef54fafa8937324",
      "original_line" : 403,
      "original_position" : 403,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 347336167,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370147930",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370215597"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370215597"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "It's never reused. Renaming it just makes you look up a definition.   Adding a comment like \"// Fall-through value if none are executed.\" would be both more informative and not create a reason to bounce around the code.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-23T16:16:34Z",
      "diff_hunk" : "@@ -293,19 +444,25 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n     CScript::const_iterator pbegincodehash = script.begin();\n     opcodetype opcode;\n     valtype vchPushValue;\n-    std::vector<bool> vfExec;\n+    ConditionStack vfExec;\n     std::vector<valtype> altstack;\n     set_error(serror, SCRIPT_ERR_UNKNOWN_ERROR);\n-    if (script.size() > MAX_SCRIPT_SIZE)\n+    if ((sigversion == SigVersion::BASE || sigversion == SigVersion::WITNESS_V0) && script.size() > MAX_SCRIPT_SIZE) {\n         return set_error(serror, SCRIPT_ERR_SCRIPT_SIZE);\n+    }\n+    if (sigversion == SigVersion::TAPSCRIPT && stack.size() > MAX_STACK_SIZE) {\n+        return set_error(serror, SCRIPT_ERR_STACK_SIZE);\n+    }\n     int nOpCount = 0;\n     bool fRequireMinimal = (flags & SCRIPT_VERIFY_MINIMALDATA) != 0;\n+    uint32_t opcode_pos = 0;\n+    execdata.m_codeseparator_pos = 0xFFFFFFFFUL;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370215597",
      "id" : 370215597,
      "in_reply_to_id" : 369834460,
      "line" : 459,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIxNTU5Nw==",
      "original_commit_id" : "2c55acda1cba362b08e289d60fe77eb8baaeb17e",
      "original_line" : 459,
      "original_position" : 178,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 117,
      "pull_request_review_id" : 347426231,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370215597",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "node_id" : "MDQ6VXNlcjg1ODQ1NA==",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370223920"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370223920"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I agree with real-or-random.\r\n\r\nsecp256k1_schnorrsig should be \"functionally opaque\"-- like the other secp256k1_ types it isn't actually an opaque struct *only* so it can be allocated on the stack. Library users should not be messing around with the internals of these types, and the library API makes *no* promise that the internal representation won't change (and for some of them it's even currently different on different platforms-- although not this one).\r\n\r\nIf the representation of  secp256k1_schnorrsig were to change, signatures with sizes other than 64 bytes wouldn't suddenly become valid in Bitcoin.\r\n\r\nIf you were talking about a '64' who's purposes was to allocate memory to store a secp256k1_schnorrsig then your reflex to interrogate it with sizeof would be well placed-- but that isn't the case here.  The data field in a secp256k1_schnorrsig could change length pretty arbitrarily (for example, storing R decompressed) and this line wouldn't change). \r\n",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-23T16:30:33Z",
      "diff_hunk" : "@@ -166,6 +167,23 @@ static int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1\n     return 1;\n }\n \n+bool XOnlyPubKey::VerifySchnorr(const uint256 &hash, const std::vector<unsigned char>& sigbytes) const {\n+    if (sigbytes.size() != 64) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370223920",
      "id" : 370223920,
      "in_reply_to_id" : 369804204,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIyMzkyMA==",
      "original_commit_id" : "2c55acda1cba362b08e289d60fe77eb8baaeb17e",
      "original_line" : 177,
      "original_position" : 13,
      "original_start_line" : null,
      "path" : "src/pubkey.cpp",
      "position" : null,
      "pull_request_review_id" : 347437420,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370223920",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "node_id" : "MDQ6VXNlcjg1ODQ1NA==",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370225174"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370225174"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Because they're all \"OP_SUCCESS\"?  They aren't other opcodes right now. Some of them share values with non-tapscript opcodes, but the usage is different.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-23T16:32:37Z",
      "diff_hunk" : "@@ -326,3 +329,11 @@ bool GetScriptOp(CScriptBase::const_iterator& pc, CScriptBase::const_iterator en\n     opcodeRet = static_cast<opcodetype>(opcode);\n     return true;\n }\n+\n+bool IsOpSuccess(const opcodetype& opcode)\n+{\n+    return (opcode == 0x50 || opcode == 0x62 || opcode == 0x89 ||",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370225174",
      "id" : 370225174,
      "in_reply_to_id" : 370024599,
      "line" : 337,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIyNTE3NA==",
      "original_commit_id" : "41acd620b5a0018b9ab5eb709ef54fafa8937324",
      "original_line" : 337,
      "original_position" : 17,
      "original_start_line" : null,
      "path" : "src/script/script.cpp",
      "position" : 17,
      "pull_request_review_id" : 347439038,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370225174",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "node_id" : "MDQ6VXNlcjg1ODQ1NA==",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370227533"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370227533"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I find that much less readable, particularly since the symbolic values you define wouldn't be used anywhere else. More comments, however, would be fine.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-23T16:36:30Z",
      "diff_hunk" : "@@ -1209,27 +1378,137 @@ uint256 GetOutputsHash(const T& txTo)\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n+}\n+\n+uint256 GetSpentAmountsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n }\n \n } // namespace\n \n template <class T>\n-PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n+    m_spent_outputs = std::move(spent_outputs);\n+\n+    if (ready) return;\n     // Cache is calculated only for transactions with witness\n     if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+        m_prevouts_hash = GetPrevoutHash(txTo);\n+        hashPrevouts = SHA256Uint256(m_prevouts_hash);\n+        m_sequences_hash = GetSequenceHash(txTo);\n+        hashSequence = SHA256Uint256(m_sequences_hash);\n+        m_outputs_hash = GetOutputsHash(txTo);\n+        hashOutputs = SHA256Uint256(m_outputs_hash);\n         ready = true;\n+\n+        if (!m_spent_outputs.empty()) {\n+            m_amounts_spent_hash = GetSpentAmountsHash(m_spent_outputs);\n+            m_amounts_spent_ready = true;\n+        }\n     }\n }\n \n+template <class T>\n+PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+{\n+    Init(txTo, {});\n+}\n+\n // explicit instantiation\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");\n+static const CHashWriter HasherTapLeaf = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HasherTapBranch = TaggedHash(\"TapBranch\");\n+static const CHashWriter HasherTapTweak = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData& cache)\n+{\n+    assert(in_pos < tx_to.vin.size());\n+    assert(sigversion == SigVersion::TAPROOT || sigversion == SigVersion::TAPSCRIPT);\n+    assert(cache.ready && cache.m_amounts_spent_ready);\n+\n+    CHashWriter ss = HasherTapSighash;\n+\n+    // Epoch\n+    uint8_t epoch = 0;\n+    ss << epoch;\n+\n+    // Hash type\n+    if ((hash_type > 3) && (hash_type < 0x81 || hash_type > 0x83)) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370227533",
      "id" : 370227533,
      "in_reply_to_id" : 369786605,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIyNzUzMw==",
      "original_commit_id" : "9f578bfcc7f0b63b50371f5ae046edf2e98fda5b",
      "original_line" : 1449,
      "original_position" : 396,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 347442068,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370227533",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "node_id" : "MDQ6VXNlcjg1ODQ1NA==",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370234826"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370234826"
         }
      },
      "author_association" : "NONE",
      "body" : "nit: This function (VerifyECDSASignature) is formatted different than VerifySchnorrSignature which have the single line if-statements on one line. Maybe use same formatting for consistency since the functions are very similar in layout. I guess it's because this function already existed and don't want to make unrelated formatting changes. New here so not sure if this is a valid remark. Please excuse me if so.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-23T16:49:25Z",
      "diff_hunk" : "@@ -79,15 +87,25 @@ void InitSignatureCache()\n             (nElems*sizeof(uint256)) >>20, (nMaxCacheSize*2)>>20, nElems);\n }\n \n-bool CachingTransactionSignatureChecker::VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& pubkey, const uint256& sighash) const\n+bool CachingTransactionSignatureChecker::VerifyECDSASignature(const std::vector<unsigned char>& vchSig, const CPubKey& pubkey, const uint256& sighash) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370234826",
      "id" : 370234826,
      "line" : 101,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIzNDgyNg==",
      "original_commit_id" : "41acd620b5a0018b9ab5eb709ef54fafa8937324",
      "original_line" : 101,
      "original_position" : 25,
      "original_start_line" : null,
      "path" : "src/script/sigcache.cpp",
      "position" : 53,
      "pull_request_review_id" : 347451586,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370234826",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/60033096?v=4",
         "events_url" : "https://api.github.com/users/constcast-glitch/events{/privacy}",
         "followers_url" : "https://api.github.com/users/constcast-glitch/followers",
         "following_url" : "https://api.github.com/users/constcast-glitch/following{/other_user}",
         "gists_url" : "https://api.github.com/users/constcast-glitch/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/constcast-glitch",
         "id" : 60033096,
         "login" : "constcast-glitch",
         "node_id" : "MDQ6VXNlcjYwMDMzMDk2",
         "organizations_url" : "https://api.github.com/users/constcast-glitch/orgs",
         "received_events_url" : "https://api.github.com/users/constcast-glitch/received_events",
         "repos_url" : "https://api.github.com/users/constcast-glitch/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/constcast-glitch/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/constcast-glitch/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/constcast-glitch"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370236330"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370236330"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fair enough, it's a matter of opinion as to which is more legible - though I see a few uses, e.g.:\r\nhttps://github.com/bitcoin/bitcoin/pull/17977/files#diff-b81dfdd8a5bd80fe9f82b5a40c4c991eR180\r\n",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-23T16:52:07Z",
      "diff_hunk" : "@@ -293,19 +444,25 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n     CScript::const_iterator pbegincodehash = script.begin();\n     opcodetype opcode;\n     valtype vchPushValue;\n-    std::vector<bool> vfExec;\n+    ConditionStack vfExec;\n     std::vector<valtype> altstack;\n     set_error(serror, SCRIPT_ERR_UNKNOWN_ERROR);\n-    if (script.size() > MAX_SCRIPT_SIZE)\n+    if ((sigversion == SigVersion::BASE || sigversion == SigVersion::WITNESS_V0) && script.size() > MAX_SCRIPT_SIZE) {\n         return set_error(serror, SCRIPT_ERR_SCRIPT_SIZE);\n+    }\n+    if (sigversion == SigVersion::TAPSCRIPT && stack.size() > MAX_STACK_SIZE) {\n+        return set_error(serror, SCRIPT_ERR_STACK_SIZE);\n+    }\n     int nOpCount = 0;\n     bool fRequireMinimal = (flags & SCRIPT_VERIFY_MINIMALDATA) != 0;\n+    uint32_t opcode_pos = 0;\n+    execdata.m_codeseparator_pos = 0xFFFFFFFFUL;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370236330",
      "id" : 370236330,
      "in_reply_to_id" : 369834460,
      "line" : 459,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIzNjMzMA==",
      "original_commit_id" : "2c55acda1cba362b08e289d60fe77eb8baaeb17e",
      "original_line" : 459,
      "original_position" : 178,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 117,
      "pull_request_review_id" : 347453549,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370236330",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370255036"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370255036"
         }
      },
      "author_association" : "NONE",
      "body" : "I was expecting something along the lines of OP_SUCCESS80, ..., OP_SUCCESS254.\r\nOP_SUCCESSx mapping explicitly shows the shared opcodes?\r\n\r\n",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-23T17:28:35Z",
      "diff_hunk" : "@@ -326,3 +329,11 @@ bool GetScriptOp(CScriptBase::const_iterator& pc, CScriptBase::const_iterator en\n     opcodeRet = static_cast<opcodetype>(opcode);\n     return true;\n }\n+\n+bool IsOpSuccess(const opcodetype& opcode)\n+{\n+    return (opcode == 0x50 || opcode == 0x62 || opcode == 0x89 ||",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370255036",
      "id" : 370255036,
      "in_reply_to_id" : 370024599,
      "line" : 337,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI1NTAzNg==",
      "original_commit_id" : "41acd620b5a0018b9ab5eb709ef54fafa8937324",
      "original_line" : 337,
      "original_position" : 17,
      "original_start_line" : null,
      "path" : "src/script/script.cpp",
      "position" : 17,
      "pull_request_review_id" : 347478221,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370255036",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/60021837?v=4",
         "events_url" : "https://api.github.com/users/v1048576/events{/privacy}",
         "followers_url" : "https://api.github.com/users/v1048576/followers",
         "following_url" : "https://api.github.com/users/v1048576/following{/other_user}",
         "gists_url" : "https://api.github.com/users/v1048576/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/v1048576",
         "id" : 60021837,
         "login" : "v1048576",
         "node_id" : "MDQ6VXNlcjYwMDIxODM3",
         "organizations_url" : "https://api.github.com/users/v1048576/orgs",
         "received_events_url" : "https://api.github.com/users/v1048576/received_events",
         "repos_url" : "https://api.github.com/users/v1048576/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/v1048576/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/v1048576/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/v1048576"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370905531"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370905531"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I agree as well. The size of serialized signatures is not inherently related to the in-memory representation of secp256k1_schnorrsig.\r\n\r\nThe BIP says something about sizes 64 and 65. The code does the exact same thing. You could introduce a constant, but I think that's just distracting. You'd need to go look up the constant to verify the code is correct, while now you can just directly compare it with the BIP.\r\n\r\n",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-25T01:48:33Z",
      "diff_hunk" : "@@ -166,6 +167,23 @@ static int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1\n     return 1;\n }\n \n+bool XOnlyPubKey::VerifySchnorr(const uint256 &hash, const std::vector<unsigned char>& sigbytes) const {\n+    if (sigbytes.size() != 64) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370905531",
      "id" : 370905531,
      "in_reply_to_id" : 369804204,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkwNTUzMQ==",
      "original_commit_id" : "2c55acda1cba362b08e289d60fe77eb8baaeb17e",
      "original_line" : 177,
      "original_position" : 13,
      "original_start_line" : null,
      "path" : "src/pubkey.cpp",
      "position" : null,
      "pull_request_review_id" : 348302303,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370905531",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370906951"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370906951"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I considered that, but I don't think the amount of code needed is worth it, or would be more readable (if there isn't a normative IsOpSuccess function, you'd be adding 87 constants to the enum, and instead writing \"opcode == OP_SUCCESS80 || opcode == OP_SUCCESS98 || opcode == OP_SUCCESS126 || ...\" in `ExecuteWitnessProgram` directly).",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-25T02:08:38Z",
      "diff_hunk" : "@@ -326,3 +329,11 @@ bool GetScriptOp(CScriptBase::const_iterator& pc, CScriptBase::const_iterator en\n     opcodeRet = static_cast<opcodetype>(opcode);\n     return true;\n }\n+\n+bool IsOpSuccess(const opcodetype& opcode)\n+{\n+    return (opcode == 0x50 || opcode == 0x62 || opcode == 0x89 ||",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370906951",
      "id" : 370906951,
      "in_reply_to_id" : 370024599,
      "line" : 337,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkwNjk1MQ==",
      "original_commit_id" : "41acd620b5a0018b9ab5eb709ef54fafa8937324",
      "original_line" : 337,
      "original_position" : 17,
      "original_start_line" : null,
      "path" : "src/script/script.cpp",
      "position" : 17,
      "pull_request_review_id" : 348303775,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370906951",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370907161"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370907161"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This is intentional, see https://github.com/bitcoin/bitcoin/blob/master/doc/developer-notes.md#coding-style-general:\r\n\r\n> When writing patches, favor the new style over attempting to mimic the surrounding style, except for move-only commits.\r\n>\r\n> Do not submit patches solely to modify the style of existing code.\r\n\r\nSo the new Schnorr code follows the preferred style, even though the ECDSA one retains the style it had before.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-25T02:11:37Z",
      "diff_hunk" : "@@ -79,15 +87,25 @@ void InitSignatureCache()\n             (nElems*sizeof(uint256)) >>20, (nMaxCacheSize*2)>>20, nElems);\n }\n \n-bool CachingTransactionSignatureChecker::VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& pubkey, const uint256& sighash) const\n+bool CachingTransactionSignatureChecker::VerifyECDSASignature(const std::vector<unsigned char>& vchSig, const CPubKey& pubkey, const uint256& sighash) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370907161",
      "id" : 370907161,
      "in_reply_to_id" : 370234826,
      "line" : 101,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkwNzE2MQ==",
      "original_commit_id" : "41acd620b5a0018b9ab5eb709ef54fafa8937324",
      "original_line" : 101,
      "original_position" : 25,
      "original_start_line" : null,
      "path" : "src/script/sigcache.cpp",
      "position" : 53,
      "pull_request_review_id" : 348303986,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370907161",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370908359"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370908359"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've rewritten this code in an overall more readable way, I think.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-25T02:32:35Z",
      "diff_hunk" : "@@ -1209,27 +1378,137 @@ uint256 GetOutputsHash(const T& txTo)\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n+}\n+\n+uint256 GetSpentAmountsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n }\n \n } // namespace\n \n template <class T>\n-PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n+    m_spent_outputs = std::move(spent_outputs);\n+\n+    if (ready) return;\n     // Cache is calculated only for transactions with witness\n     if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+        m_prevouts_hash = GetPrevoutHash(txTo);\n+        hashPrevouts = SHA256Uint256(m_prevouts_hash);\n+        m_sequences_hash = GetSequenceHash(txTo);\n+        hashSequence = SHA256Uint256(m_sequences_hash);\n+        m_outputs_hash = GetOutputsHash(txTo);\n+        hashOutputs = SHA256Uint256(m_outputs_hash);\n         ready = true;\n+\n+        if (!m_spent_outputs.empty()) {\n+            m_amounts_spent_hash = GetSpentAmountsHash(m_spent_outputs);\n+            m_amounts_spent_ready = true;\n+        }\n     }\n }\n \n+template <class T>\n+PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+{\n+    Init(txTo, {});\n+}\n+\n // explicit instantiation\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");\n+static const CHashWriter HasherTapLeaf = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HasherTapBranch = TaggedHash(\"TapBranch\");\n+static const CHashWriter HasherTapTweak = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData& cache)\n+{\n+    assert(in_pos < tx_to.vin.size());\n+    assert(sigversion == SigVersion::TAPROOT || sigversion == SigVersion::TAPSCRIPT);\n+    assert(cache.ready && cache.m_amounts_spent_ready);\n+\n+    CHashWriter ss = HasherTapSighash;\n+\n+    // Epoch\n+    uint8_t epoch = 0;\n+    ss << epoch;\n+\n+    // Hash type\n+    if ((hash_type > 3) && (hash_type < 0x81 || hash_type > 0x83)) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370908359",
      "id" : 370908359,
      "in_reply_to_id" : 369786605,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkwODM1OQ==",
      "original_commit_id" : "9f578bfcc7f0b63b50371f5ae046edf2e98fda5b",
      "original_line" : 1449,
      "original_position" : 396,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 348305242,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370908359",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370908392"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370908392"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've rewritten this code to match the BIP specification more closely.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-25T02:33:03Z",
      "diff_hunk" : "@@ -1209,27 +1378,137 @@ uint256 GetOutputsHash(const T& txTo)\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n+}\n+\n+uint256 GetSpentAmountsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n }\n \n } // namespace\n \n template <class T>\n-PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n+    m_spent_outputs = std::move(spent_outputs);\n+\n+    if (ready) return;\n     // Cache is calculated only for transactions with witness\n     if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+        m_prevouts_hash = GetPrevoutHash(txTo);\n+        hashPrevouts = SHA256Uint256(m_prevouts_hash);\n+        m_sequences_hash = GetSequenceHash(txTo);\n+        hashSequence = SHA256Uint256(m_sequences_hash);\n+        m_outputs_hash = GetOutputsHash(txTo);\n+        hashOutputs = SHA256Uint256(m_outputs_hash);\n         ready = true;\n+\n+        if (!m_spent_outputs.empty()) {\n+            m_amounts_spent_hash = GetSpentAmountsHash(m_spent_outputs);\n+            m_amounts_spent_ready = true;\n+        }\n     }\n }\n \n+template <class T>\n+PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+{\n+    Init(txTo, {});\n+}\n+\n // explicit instantiation\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");\n+static const CHashWriter HasherTapLeaf = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HasherTapBranch = TaggedHash(\"TapBranch\");\n+static const CHashWriter HasherTapTweak = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData& cache)\n+{\n+    assert(in_pos < tx_to.vin.size());\n+    assert(sigversion == SigVersion::TAPROOT || sigversion == SigVersion::TAPSCRIPT);\n+    assert(cache.ready && cache.m_amounts_spent_ready);\n+\n+    CHashWriter ss = HasherTapSighash;\n+\n+    // Epoch\n+    uint8_t epoch = 0;\n+    ss << epoch;\n+\n+    // Hash type\n+    if ((hash_type > 3) && (hash_type < 0x81 || hash_type > 0x83)) return false;\n+    ss << hash_type;\n+    const uint8_t input_type = hash_type & SIGHASH_TAPINPUTMASK;\n+    const uint8_t output_type = hash_type & SIGHASH_TAPOUTPUTMASK;\n+\n+    // Transaction level data\n+    ss << tx_to.nVersion;\n+    ss << tx_to.nLockTime;\n+\n+    if (input_type == SIGHASH_TAPDEFAULT) {\n+        ss << cache.m_prevouts_hash;\n+        ss << cache.m_amounts_spent_hash;\n+        ss << cache.m_sequences_hash;\n+    }\n+    if (output_type == SIGHASH_TAPDEFAULT || output_type == SIGHASH_ALL) {\n+        ss << cache.m_outputs_hash;\n+    }\n+\n+    // Data about the input/prevout being spent\n+    const CScript& scriptPubKey = cache.m_spent_outputs[in_pos].scriptPubKey;\n+    uint8_t spend_type = 0;\n+    assert(execdata.m_annex_init);\n+    if (execdata.m_annex_present) {\n+        spend_type |= 1;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370908392",
      "id" : 370908392,
      "in_reply_to_id" : 369786833,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkwODM5Mg==",
      "original_commit_id" : "9f578bfcc7f0b63b50371f5ae046edf2e98fda5b",
      "original_line" : 1472,
      "original_position" : 419,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 348305271,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370908392",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370908425"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370908425"
         }
      },
      "author_association" : "MEMBER",
      "body" : "That initialization wasn't needed actually, I've removed it. The constant in just in one place now.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-25T02:33:38Z",
      "diff_hunk" : "@@ -293,19 +444,25 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n     CScript::const_iterator pbegincodehash = script.begin();\n     opcodetype opcode;\n     valtype vchPushValue;\n-    std::vector<bool> vfExec;\n+    ConditionStack vfExec;\n     std::vector<valtype> altstack;\n     set_error(serror, SCRIPT_ERR_UNKNOWN_ERROR);\n-    if (script.size() > MAX_SCRIPT_SIZE)\n+    if ((sigversion == SigVersion::BASE || sigversion == SigVersion::WITNESS_V0) && script.size() > MAX_SCRIPT_SIZE) {\n         return set_error(serror, SCRIPT_ERR_SCRIPT_SIZE);\n+    }\n+    if (sigversion == SigVersion::TAPSCRIPT && stack.size() > MAX_STACK_SIZE) {\n+        return set_error(serror, SCRIPT_ERR_STACK_SIZE);\n+    }\n     int nOpCount = 0;\n     bool fRequireMinimal = (flags & SCRIPT_VERIFY_MINIMALDATA) != 0;\n+    uint32_t opcode_pos = 0;\n+    execdata.m_codeseparator_pos = 0xFFFFFFFFUL;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370908425",
      "id" : 370908425,
      "in_reply_to_id" : 369834460,
      "line" : 459,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkwODQyNQ==",
      "original_commit_id" : "2c55acda1cba362b08e289d60fe77eb8baaeb17e",
      "original_line" : 459,
      "original_position" : 178,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 117,
      "pull_request_review_id" : 348305306,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370908425",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370908463"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370908463"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've completely rewritten the Python Schnorr code now, not using ECKey/ECPubKey at all.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-25T02:34:12Z",
      "diff_hunk" : "@@ -322,6 +353,40 @@ def verify_ecdsa(self, sig, msg, low_s=True):\n             return False\n         return True\n \n+    def verify_schnorr(self, sig, msg):\n+        assert(len(msg) == 32)\n+        assert(len(sig) == 64)\n+        assert(self.valid)\n+        assert(self.compressed)\n+        r = int.from_bytes(sig[0:32], 'big')\n+        if r >= SECP256K1_FIELD_SIZE:\n+            return False\n+        s = int.from_bytes(sig[32:64], 'big')\n+        if s >= SECP256K1_ORDER:\n+            return False\n+        e = int.from_bytes(TaggedHash(\"BIPSchnorr\", sig[0:32] + self.get_bytes()[1:33] + msg), 'big') % SECP256K1_ORDER\n+        if self.is_positive:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370908463",
      "id" : 370908463,
      "in_reply_to_id" : 369852128,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkwODQ2Mw==",
      "original_commit_id" : "2c55acda1cba362b08e289d60fe77eb8baaeb17e",
      "original_line" : 368,
      "original_position" : 84,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 348305346,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370908463",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370908509"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370908509"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\nfrom test_framework.script import (\r\n    ANNEX_TAG,\r\n    CScript,\r\n    CScriptOp,\r\n    LEAF_VERSION_TAPSCRIPT,\r\n    LOCKTIME_THRESHOLD,\r\n    MAX_SCRIPT_ELEMENT_SIZE,\r\n    OP_0,\r\n    OP_1,\r\n    OP_1SUB,\r\n    OP_1NEGATE,\r\n    OP_2DROP,\r\n    OP_2DUP,\r\n    OP_CHECKMULTISIG,\r\n    OP_CHECKMULTISIGVERIFY,\r\n    OP_CHECKSIG,\r\n    OP_CHECKSIGADD,\r\n    OP_CHECKSIGVERIFY,\r\n    OP_CODESEPARATOR,\r\n    OP_DROP,\r\n    OP_DUP,\r\n    OP_ELSE,\r\n    OP_ENDIF,\r\n    OP_EQUAL,\r\n    OP_IF,\r\n    OP_NOT,\r\n    OP_NOTIF,\r\n    OP_RETURN,\r\n    OP_SWAP,\r\n    OP_VERIF,\r\n    SIGHASH_SINGLE,\r\n    TaprootSignatureHash,\r\n    is_op_success,\r\n    taproot_construct,\r\n)\r\n```",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-25T02:35:04Z",
      "diff_hunk" : "@@ -0,0 +1,594 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import create_coinbase, create_block, add_witness_commitment\n+from test_framework.messages import CTransaction, CTxIn, CTxOut, COutPoint, CTxInWitness\n+from test_framework.script import CScript, TaprootSignatureHash, taproot_construct, OP_0, OP_1, OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD, OP_IF, OP_CODESEPARATOR, OP_ELSE, OP_ENDIF, OP_DROP, LEAF_VERSION_TAPSCRIPT, SIGHASH_SINGLE, is_op_success, CScriptOp, OP_RETURN, OP_VERIF, OP_1NEGATE, OP_EQUAL, OP_SWAP, OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY, OP_NOTIF, OP_2DROP, OP_NOT, OP_2DUP, OP_1SUB, OP_DUP, MAX_SCRIPT_ELEMENT_SIZE, LOCKTIME_THRESHOLD, ANNEX_TAG",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370908509",
      "id" : 370908509,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkwODUwOQ==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 9,
      "original_position" : 9,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 348305311,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370908509",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370908697"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370908697"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Agree, those enum values were weird. Changed to SIGHASH_INPUT_MASK, SIGHASH_OUTPUT_MASK, and SIGHASH_DEFAULT; even though they're Taproot specific for now, that's not inherently the case.\r\n\r\n`SignatureHashTap` wasn't actually necessary, it was a leftover from older code. I've removed it.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-25T02:37:57Z",
      "diff_hunk" : "@@ -24,6 +26,10 @@ enum\n     SIGHASH_NONE = 2,\n     SIGHASH_SINGLE = 3,\n     SIGHASH_ANYONECANPAY = 0x80,\n+\n+    SIGHASH_TAPDEFAULT = 0,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370908697",
      "id" : 370908697,
      "in_reply_to_id" : 370020828,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkwODY5Nw==",
      "original_commit_id" : "41acd620b5a0018b9ab5eb709ef54fafa8937324",
      "original_line" : 30,
      "original_position" : 16,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 348305557,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370908697",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370908724"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370908724"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done by completely rewriting the Schnorr Python code.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-25T02:38:26Z",
      "diff_hunk" : "@@ -0,0 +1,600 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import create_coinbase, create_block, add_witness_commitment\n+from test_framework.messages import CTransaction, CTxIn, CTxOut, COutPoint, CTxInWitness\n+from test_framework.script import CScript, TaprootSignatureHash, taproot_construct, OP_0, OP_1, OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD, OP_IF, OP_CODESEPARATOR, OP_ELSE, OP_ENDIF, OP_DROP, LEAF_VERSION_TAPSCRIPT, SIGHASH_SINGLE, is_op_success, CScriptOp, OP_RETURN, OP_VERIF, OP_1NEGATE, OP_EQUAL, OP_SWAP, OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY, OP_NOTIF, OP_2DROP, OP_NOT, OP_2DUP, OP_1SUB, OP_DUP, MAX_SCRIPT_ELEMENT_SIZE, LOCKTIME_THRESHOLD, ANNEX_TAG\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, hex_str_to_bytes\n+from test_framework.key import ECKey, SECP256K1_ORDER, verify_schnorr\n+from test_framework.address import program_to_witness\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+import struct\n+\n+EMPTYWITNESS_ERROR = \"non-mandatory-script-verify-flag (Witness program was passed an empty witness) (code 64)\"\n+INVALIDKEYPATHSIG_ERROR = \"non-mandatory-script-verify-flag (Invalid signature for Taproot key path spending) (code 64)\"\n+UNKNOWNWITNESS_ERROR = \"non-mandatory-script-verify-flag (Witness version reserved for soft-fork upgrades) (code 64)\"\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+def tx_from_hex(hexstring):\n+    tx = CTransaction()\n+    f = BytesIO(hex_str_to_bytes(hexstring))\n+    tx.deserialize(f)\n+    return tx\n+\n+def get_taproot_bech32(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return program_to_witness(1, info[2:])\n+\n+def random_op_success():\n+    ret = 0\n+    while (not is_op_success(ret)):\n+        ret = random.randint(0x50, 0xfe)\n+    return CScriptOp(ret)\n+\n+def random_unknown_leaf_ver(no_annex_tag=True):\n+    ret = LEAF_VERSION_TAPSCRIPT\n+    while (ret == LEAF_VERSION_TAPSCRIPT or (no_annex_tag and ret == (ANNEX_TAG & 0xfe))):\n+        ret = random.randrange(128) * 2\n+    return ret\n+\n+def random_bytes(n):\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def random_script(size, no_success = True):\n+    ret = bytes()\n+    while (len(ret) < size):\n+        remain = size - len(ret)\n+        opcode = random.randrange(256)\n+        while (no_success and is_op_success(opcode)):\n+            opcode = random.randrange(256)\n+        if opcode == 0 or opcode >= OP_1NEGATE:\n+            ret += bytes([opcode])\n+        elif opcode <= 75 and opcode <= remain - 1:\n+            ret += bytes([opcode]) + random_bytes(opcode)\n+        elif opcode == 76 and remain >= 2:\n+            pushsize = random.randint(0, min(0xff, remain - 2))\n+            ret += bytes([opcode]) + bytes([pushsize]) + random_bytes(pushsize)\n+        elif opcode == 77 and remain >= 3:\n+            pushsize = random.randint(0, min(0xffff, remain - 3))\n+            ret += bytes([opcode]) + struct.pack(b'<H', pushsize) + random_bytes(pushsize)\n+        elif opcode == 78 and remain >= 5:\n+            pushsize = random.randint(0, min(0xffffffff, remain - 5))\n+            ret += bytes([opcode]) + struct.pack(b'<I', pushsize) + random_bytes(pushsize)\n+    assert len(ret) == size\n+    return ret\n+\n+def random_invalid_push(size):\n+    assert size > 0\n+    ret = bytes()\n+    opcode = 78\n+    if size <= 75:\n+        opcode = random.randint(75, 78)\n+    elif size <= 255:\n+        opcode = random.randint(76, 78)\n+    elif size <= 0xffff:\n+        opcode = random.randint(77, 78)\n+    if opcode == 75:\n+        ret = bytes([size]) + random_bytes(size - 1)\n+    elif opcode == 76:\n+        ret = bytes([opcode]) + bytes([size]) + random_bytes(size - 2)\n+    elif opcode == 77:\n+        ret = bytes([opcode]) + struct.pack(b'<H', size) + random_bytes(max(0, size - 3))\n+    else:\n+        ret = bytes([opcode]) + struct.pack(b'<I', size) + random_bytes(max(0, size - 5))\n+    assert len(ret) >= size\n+    return ret[:size]\n+\n+def random_checksig_style(pubkey):\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num+1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def damage_bytes(b):\n+    return (int.from_bytes(b, 'big') ^ (1 << random.randrange(len(b)*8))).to_bytes(len(b), 'big')\n+\n+# Each spender is a tuple of:\n+# - A scriptPubKey (CScript)\n+# - An address for that scriptPubKey (string)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A witness stack-producing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+\n+Spender = namedtuple(\"Spender\", \"script,address,comment,is_standard,sat_function\")\n+\n+def spend_single_sig(tx, input_index, spent_utxos, info, key, annex=None, hashtype=0, prefix=None, suffix=None, script=None, pos=-1, damage=False):\n+    if prefix is None:\n+        prefix = []\n+    if suffix is None:\n+        suffix = []\n+\n+    ht = hashtype\n+\n+    damage_type = random.randrange(5) if damage else -1\n+    '''\n+    * 0. bit flip the sighash\n+    * 1. bit flip the signature\n+    * If the expected hashtype is 0:\n+    -- 2. append a 0 to the signature\n+    -- 3. append a random value of 1-255 to the signature\n+    * If the expected hashtype is not 0:\n+    -- 2. do not append hashtype to the signature\n+    -- 3. append a random incorrect value of 0-255 to the signature\n+    * 4. extra witness element\n+    '''\n+\n+    # Taproot key path spend: tweak key\n+    if script is None:\n+        pubkey = key.get_pubkey()\n+        if not pubkey.is_positive:\n+            key.negate()\n+        key = key.tweak_add(info[1])\n+        assert(key is not None)\n+    # Change SIGHASH_SINGLE into SIGHASH_ALL if no corresponding output\n+    if (ht & 3 == SIGHASH_SINGLE and input_index >= len(tx.vout)):\n+        ht ^= 2\n+    # Compute sighash\n+    if script:\n+        sighash = TaprootSignatureHash(tx, spent_utxos, ht, input_index, scriptpath = True, script = script, codeseparator_pos = pos, annex = annex)\n+    else:\n+        sighash = TaprootSignatureHash(tx, spent_utxos, ht, input_index, scriptpath = False, annex = annex)\n+    if damage_type == 0:\n+        sighash = damage_bytes(sighash)\n+    # Compute signature\n+    sig = key.sign_schnorr(sighash)\n+    if damage_type == 1:\n+        sig = damage_bytes(sig)\n+    if damage_type == 2:\n+        if ht == 0:\n+            sig += bytes([0])\n+    elif damage_type == 3:\n+        random_ht = ht\n+        while random_ht == ht:\n+            random_ht = random.randrange(256)\n+        sig += bytes([random_ht])\n+    elif ht > 0:\n+        sig += bytes([ht])\n+    # Construct witness\n+    ret = prefix + [sig] + suffix\n+    if script is not None:\n+        ret += [script, info[2][script]]\n+    if annex is not None:\n+        ret += [annex]\n+    if damage_type == 4:\n+        ret = [random_bytes(random.randrange(5))] + ret\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = ret\n+\n+def spend_alwaysvalid(tx, input_index, info, script, annex=None, damage=False):\n+    if isinstance(script, tuple):\n+        version, script = script\n+    ret = [script, info[2][script]]\n+    if damage:\n+        # With 50% chance, we bit flip the script (unless the script is an empty vector)\n+        # With 50% chance, we bit flip the control block\n+        if random.choice([True, False]) or len(ret[0]) == 0:\n+            # Annex is always required for leaf version 0x50\n+            # Unless the original version is 0x50, we couldn't convert it to 0x50 without using annex\n+            tmp = damage_bytes(ret[1])\n+            while annex is None and tmp[0] == ANNEX_TAG and ret[1][0] != ANNEX_TAG:\n+                tmp = damage_bytes(ret[1])\n+            ret[1] = tmp\n+        else:\n+            ret[0] = damage_bytes(ret[0])\n+    if annex is not None:\n+        ret += [annex]\n+    # Randomly add input witness\n+    if random.choice([True, False]):\n+        for i in range(random.randint(1, 10)):\n+            ret = [random_bytes(random.randint(0, MAX_SCRIPT_ELEMENT_SIZE*2))] + ret\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = ret\n+\n+def spender_sighash_mutation(spenders, info, comment, standard=True, **kwargs):\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_single_sig(t, i, u, damage=not v, info=info, **kwargs)\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn))\n+\n+def spender_two_paths(spenders, info, comment, standard, success, failure):\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_single_sig(t, i, u, damage=False, info=info, **(success if v else failure))\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn))\n+\n+def spender_alwaysvalid(spenders, info, comment, **kwargs):\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_alwaysvalid(t, i, damage=not v, info=info, **kwargs)\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=False, sat_function=fn))\n+\n+def nested_script(script, depth):\n+    if depth == 0:\n+        return script\n+    return [nested_script(script, depth - 1), CScript([OP_RETURN])]\n+\n+UTXOData = namedtuple('UTXOData', 'input,output,spender')\n+\n+class TAPROOTTest(BitcoinTestFramework):\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.extra_args = [[\"-whitelist=127.0.0.1\", \"-acceptnonstdtxn=0\", \"-par=1\"]]\n+\n+    def block_submit(self, node, txs, msg, cb_pubkey=None, fees=0, witness=False, accept=False):\n+        block = create_block(self.tip, create_coinbase(self.lastblockheight + 1, pubkey=cb_pubkey, fees=fees), self.lastblocktime + 1)\n+        block.nVersion = 4\n+        for tx in txs:\n+            tx.rehash()\n+            block.vtx.append(tx)\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        witness and add_witness_commitment(block)\n+        block.rehash()\n+        block.solve()\n+        node.submitblock(block.serialize(True).hex())\n+        if (accept):\n+            assert node.getbestblockhash() == block.hash, \"Failed to accept: \" + msg\n+            self.tip = block.sha256\n+            self.lastblockhash = block.hash\n+            self.lastblocktime += 1\n+            self.lastblockheight += 1\n+        else:\n+            assert node.getbestblockhash() == self.lastblockhash, \"Failed to reject: \" + msg\n+\n+    def test_spenders(self, spenders, input_counts):\n+        \"\"\"Run randomized tests with a number of \"spenders\".\n+\n+\n+        Each spender embodies a test; in a large randomized test, it is verified\n+        that toggling the valid argument to each lambda toggles the validity of\n+        the transaction. This is accomplished by constructing transactions consisting\n+        of all valid inputs, except one invalid one.\n+        \"\"\"\n+\n+        # Construct a UTXO to spend for each of the spenders\n+        self.nodes[0].generate(110)\n+        bal = self.nodes[0].getbalance() * 3 / (4*len(spenders))\n+        random.shuffle(spenders)\n+        num_spenders = len(spenders)\n+        utxos = []\n+        while len(spenders):\n+            # Create the necessary outputs in multiple transactions, as sPKs may be repeated (which sendmany does not support)\n+            outputs = {}\n+            new_spenders = []\n+            batch = []\n+            for spender in spenders:\n+                addr = spender.address\n+                if len(batch) == 100 or addr in outputs:\n+                    new_spenders.append(spender)\n+                else:\n+                    amount = random.randrange(int(bal * 95000000), int(bal * 105000000))\n+                    outputs[addr] = amount / 100000000\n+                    batch.append(spender)\n+            self.log.info(\"Constructing %i UTXOs for spending tests\" % len(batch))\n+            tx = tx_from_hex(self.nodes[0].getrawtransaction(self.nodes[0].sendmany(\"\", outputs)))\n+            tx.rehash()\n+            spenders = new_spenders\n+            random.shuffle(spenders)\n+\n+            # Map created UTXOs back to the spenders they were created for\n+            for n, out in enumerate(tx.vout):\n+                for spender in batch:\n+                    if out.scriptPubKey == spender.script:\n+                        utxos.append(UTXOData(input=COutPoint(tx.sha256, n), output=out, spender=spender))\n+                        break\n+        assert(len(utxos) == num_spenders)\n+        random.shuffle(utxos)\n+        self.nodes[0].generate(1)\n+\n+        # Construct a bunch of sPKs that send coins back to the host wallet\n+        self.log.info(\"Constructing 100 addresses for returning coins\")\n+        host_spks = []\n+        host_pubkeys = []\n+        for i in range(100):\n+            addr = self.nodes[0].getnewaddress(address_type=random.choice([\"legacy\", \"p2sh-segwit\", \"bech32\"]))\n+            info = self.nodes[0].getaddressinfo(addr)\n+            spk = hex_str_to_bytes(info['scriptPubKey'])\n+            host_spks.append(spk)\n+            host_pubkeys.append(hex_str_to_bytes(info['pubkey']))\n+\n+        # Pick random subsets of UTXOs to construct transactions with\n+        self.lastblockhash = self.nodes[0].getbestblockhash()\n+        self.tip = int(\"0x\" + self.lastblockhash, 0)\n+        block = self.nodes[0].getblock(self.lastblockhash)\n+        self.lastblockheight = block['height']\n+        self.lastblocktime = block['time']\n+        while len(utxos):\n+            tx = CTransaction()\n+            tx.nVersion = random.choice([1, 2, random.randint(-0x80000000,0x7fffffff)])\n+            min_sequence = (tx.nVersion != 1 and tx.nVersion != 0) * 0x80000000 # The minimum sequence number to disable relative locktime\n+            if random.choice([True, False]):\n+                tx.nLockTime = random.randrange(LOCKTIME_THRESHOLD, self.lastblocktime - 7200) # all absolute locktimes in the past\n+            else:\n+                tx.nLockTime = random.randrange(self.lastblockheight+1) # all block heights in the past\n+\n+            # Pick 1 to 4 UTXOs to construct transaction inputs\n+            acceptable_input_counts = [cnt for cnt in input_counts if cnt <= len(utxos)]\n+            while True:\n+                inputs = random.choice(acceptable_input_counts)\n+                remaining = len(utxos) - inputs\n+                if remaining == 0 or remaining >= max(input_counts) or remaining in input_counts:\n+                    break\n+            input_utxos = utxos[-inputs:]\n+            utxos = utxos[:-inputs]\n+            fee = random.randrange(MIN_FEE * 2, MIN_FEE * 4) # 10000-20000 sat fee\n+            in_value = sum(utxo.output.nValue for utxo in input_utxos) - fee\n+            tx.vin = [CTxIn(outpoint = input_utxos[i].input, nSequence = random.randint(min_sequence, 0xffffffff)) for i in range(inputs)]\n+            tx.wit.vtxinwit = [CTxInWitness() for i in range(inputs)]\n+            self.log.info(\"Test: %s\" % (\", \".join(utxo.spender.comment for utxo in input_utxos)))\n+\n+            # Add 1 to 4 outputs\n+            outputs = random.choice([1,2,3,4])\n+            assert in_value >= 0 and fee - outputs * DUST_LIMIT >= MIN_FEE\n+            for i in range(outputs):\n+                tx.vout.append(CTxOut())\n+                if in_value <= DUST_LIMIT:\n+                    tx.vout[-1].nValue = DUST_LIMIT\n+                elif i < outputs - 1:\n+                    tx.vout[-1].nValue = in_value\n+                else:\n+                    tx.vout[-1].nValue = random.randint(DUST_LIMIT, in_value)\n+                in_value -= tx.vout[-1].nValue\n+                tx.vout[-1].scriptPubKey = random.choice(host_spks)\n+            fee += in_value\n+            assert(fee >= 0)\n+\n+            # For each inputs, make it fail once; then succeed once\n+            for fail_input in range(inputs + 1):\n+                # Wipe scriptSig/witness\n+                for i in range(inputs):\n+                    tx.vin[i].scriptSig = CScript()\n+                    tx.wit.vtxinwit[i] = CTxInWitness()\n+                # Fill inputs/witnesses\n+                for i in range(inputs):\n+                    fn = input_utxos[i].spender.sat_function\n+                    fn(tx, i, [utxo.output for utxo in input_utxos], i != fail_input)\n+                # Submit to mempool to check standardness\n+                standard = fail_input == inputs and all(utxo.spender.is_standard for utxo in input_utxos) and tx.nVersion >= 1 and tx.nVersion <= 2\n+                if standard:\n+                    self.nodes[0].sendrawtransaction(tx.serialize().hex(), 0)\n+                    assert(self.nodes[0].getmempoolentry(tx.hash) is not None)\n+                else:\n+                    assert_raises_rpc_error(-26, None, self.nodes[0].sendrawtransaction, tx.serialize().hex(), 0)\n+                # Submit in a block\n+                tx.rehash()\n+                msg = ','.join(utxo.spender.comment + (\"*\" if n == fail_input else \"\") for n, utxo in enumerate(input_utxos))\n+                self.block_submit(self.nodes[0], [tx], msg, witness=True, accept=fail_input == inputs, cb_pubkey=random.choice(host_pubkeys), fees=fee)\n+\n+    def build_spenders(self):\n+        VALID_SIGHASHES = [0,1,2,3,0x81,0x82,0x83]\n+        spenders = []\n+\n+        for annex in [None, bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+            standard = annex is None\n+            sec1, sec2 = ECKey(), ECKey()\n+            sec1.generate()\n+            sec2.generate()\n+            pub1, pub2 = sec1.get_pubkey(), sec2.get_pubkey()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370908724",
      "id" : 370908724,
      "in_reply_to_id" : 370147930,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkwODcyNA==",
      "original_commit_id" : "41acd620b5a0018b9ab5eb709ef54fafa8937324",
      "original_line" : 403,
      "original_position" : 403,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 348305579,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370908724",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370908763"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370908763"
         }
      },
      "author_association" : "MEMBER",
      "body" : "What a waste of lines. Is this more readable?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-25T02:39:14Z",
      "diff_hunk" : "@@ -0,0 +1,594 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import create_coinbase, create_block, add_witness_commitment\n+from test_framework.messages import CTransaction, CTxIn, CTxOut, COutPoint, CTxInWitness\n+from test_framework.script import CScript, TaprootSignatureHash, taproot_construct, OP_0, OP_1, OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD, OP_IF, OP_CODESEPARATOR, OP_ELSE, OP_ENDIF, OP_DROP, LEAF_VERSION_TAPSCRIPT, SIGHASH_SINGLE, is_op_success, CScriptOp, OP_RETURN, OP_VERIF, OP_1NEGATE, OP_EQUAL, OP_SWAP, OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY, OP_NOTIF, OP_2DROP, OP_NOT, OP_2DUP, OP_1SUB, OP_DUP, MAX_SCRIPT_ELEMENT_SIZE, LOCKTIME_THRESHOLD, ANNEX_TAG",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370908763",
      "id" : 370908763,
      "in_reply_to_id" : 370908509,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkwODc2Mw==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 9,
      "original_position" : 9,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 348305617,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370908763",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370909411"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370909411"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Lines don't really cost anything. This is definitely *readable*, compared to the big blob it replaces.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-25T02:52:25Z",
      "diff_hunk" : "@@ -0,0 +1,594 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import create_coinbase, create_block, add_witness_commitment\n+from test_framework.messages import CTransaction, CTxIn, CTxOut, COutPoint, CTxInWitness\n+from test_framework.script import CScript, TaprootSignatureHash, taproot_construct, OP_0, OP_1, OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD, OP_IF, OP_CODESEPARATOR, OP_ELSE, OP_ENDIF, OP_DROP, LEAF_VERSION_TAPSCRIPT, SIGHASH_SINGLE, is_op_success, CScriptOp, OP_RETURN, OP_VERIF, OP_1NEGATE, OP_EQUAL, OP_SWAP, OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY, OP_NOTIF, OP_2DROP, OP_NOT, OP_2DUP, OP_1SUB, OP_DUP, MAX_SCRIPT_ELEMENT_SIZE, LOCKTIME_THRESHOLD, ANNEX_TAG",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370909411",
      "id" : 370909411,
      "in_reply_to_id" : 370908509,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkwOTQxMQ==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 9,
      "original_position" : 9,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 348306215,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370909411",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370909591"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370909591"
         }
      },
      "author_association" : "MEMBER",
      "body" : "They cost screen space, and this isn't something that really requires reading.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-25T02:55:52Z",
      "diff_hunk" : "@@ -0,0 +1,594 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import create_coinbase, create_block, add_witness_commitment\n+from test_framework.messages import CTransaction, CTxIn, CTxOut, COutPoint, CTxInWitness\n+from test_framework.script import CScript, TaprootSignatureHash, taproot_construct, OP_0, OP_1, OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD, OP_IF, OP_CODESEPARATOR, OP_ELSE, OP_ENDIF, OP_DROP, LEAF_VERSION_TAPSCRIPT, SIGHASH_SINGLE, is_op_success, CScriptOp, OP_RETURN, OP_VERIF, OP_1NEGATE, OP_EQUAL, OP_SWAP, OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY, OP_NOTIF, OP_2DROP, OP_NOT, OP_2DUP, OP_1SUB, OP_DUP, MAX_SCRIPT_ELEMENT_SIZE, LOCKTIME_THRESHOLD, ANNEX_TAG",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370909591",
      "id" : 370909591,
      "in_reply_to_id" : 370908509,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkwOTU5MQ==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 9,
      "original_position" : 9,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 348306374,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370909591",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370909779"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370909779"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It feels like people can just scroll down if they aren't interested, or not if they are. I prefer to let the reader decide whether they desire to read or not. Anyway, it's not big enough to waste time over. Do ignore.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-25T03:00:08Z",
      "diff_hunk" : "@@ -0,0 +1,594 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import create_coinbase, create_block, add_witness_commitment\n+from test_framework.messages import CTransaction, CTxIn, CTxOut, COutPoint, CTxInWitness\n+from test_framework.script import CScript, TaprootSignatureHash, taproot_construct, OP_0, OP_1, OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD, OP_IF, OP_CODESEPARATOR, OP_ELSE, OP_ENDIF, OP_DROP, LEAF_VERSION_TAPSCRIPT, SIGHASH_SINGLE, is_op_success, CScriptOp, OP_RETURN, OP_VERIF, OP_1NEGATE, OP_EQUAL, OP_SWAP, OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY, OP_NOTIF, OP_2DROP, OP_NOT, OP_2DUP, OP_1SUB, OP_DUP, MAX_SCRIPT_ELEMENT_SIZE, LOCKTIME_THRESHOLD, ANNEX_TAG",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370909779",
      "id" : 370909779,
      "in_reply_to_id" : 370908509,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkwOTc3OQ==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 9,
      "original_position" : 9,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 348306555,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370909779",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370916701"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370916701"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: indentation (here and L1781).",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-25T06:10:32Z",
      "diff_hunk" : "@@ -1416,10 +1728,68 @@ bool GenericTransactionSignatureChecker<T>::CheckSequence(const CScriptNum& nSeq\n template class GenericTransactionSignatureChecker<CTransaction>;\n template class GenericTransactionSignatureChecker<CMutableTransaction>;\n \n-static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool ExecuteWitnessProgram(std::vector<std::vector<unsigned char>> stack, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, const ScriptExecutionData& execdata, ScriptError* serror)\n+{\n+    // OP_SUCCESSx processing overrides everything, including stack element size limits\n+    if (sigversion == SigVersion::TAPSCRIPT) {\n+        CScript::const_iterator pc = scriptPubKey.begin();\n+        while (pc < scriptPubKey.end()) {\n+            opcodetype opcode;\n+            if (!scriptPubKey.GetOp(pc, opcode)) {\n+                // Note how this condition would not be reached if an unknown OP_SUCCESSx was found\n+                return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n+            }\n+            // New opcodes will be listed here. May use a different sigversion to modify existing opcodes.\n+            if (IsOpSuccess(opcode)) {\n+                if (flags & SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS) {\n+                    return set_error(serror, SCRIPT_ERR_DISCOURAGE_OP_SUCCESS);\n+                }\n+                return set_success(serror);\n+            }\n+        }\n+    }\n+\n+    // Disallow stack item size > MAX_SCRIPT_ELEMENT_SIZE in witness stack\n+    for (unsigned int i = 0; i < stack.size(); i++) {\n+        if (stack.at(i).size() > MAX_SCRIPT_ELEMENT_SIZE) {\n+            return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n+        }\n+    }\n+\n+    // Run the script interpreter.\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, serror, execdata)) return false;\n+\n+    // Scripts inside witness implicitly require cleanstack behaviour\n+    if (stack.size() != 1) return set_error(serror, SCRIPT_ERR_CLEANSTACK);\n+    if (!CastToBool(stack.back())) return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n+    return true;\n+}\n+\n+static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, const std::vector<unsigned char>& program, const CScript& script, uint256* tapleaf_hash)\n+{\n+    int path_len = (control.size() - TAPROOT_CONTROL_BASE_SIZE) / TAPROOT_CONTROL_NODE_SIZE;\n+    XOnlyPubKey p{uint256(std::vector<unsigned char>(control.begin() + 1, control.begin() + TAPROOT_CONTROL_BASE_SIZE))};\n+    XOnlyPubKey q{uint256(program)};\n+    uint256 k = (CHashWriter(HasherTapLeaf) << uint8_t(control[0] & TAPROOT_LEAF_MASK) << script).GetSHA256();\n+    if (tapleaf_hash) *tapleaf_hash = k;\n+    for (int i = 0; i < path_len; ++i) {\n+        CHashWriter ss_branch = HasherTapBranch;\n+        auto node_begin = control.data() + TAPROOT_CONTROL_BASE_SIZE + TAPROOT_CONTROL_NODE_SIZE * i;\n+        if (std::lexicographical_compare(k.begin(), k.end(), node_begin, node_begin + TAPROOT_CONTROL_NODE_SIZE)) {\n+           ss_branch << k << Span<const unsigned char>(node_begin, TAPROOT_CONTROL_NODE_SIZE);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370916701",
      "id" : 370916701,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNjcwMQ==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 1777,
      "original_position" : 595,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 348312432,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370916701",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370939945"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370939945"
         }
      },
      "author_association" : "NONE",
      "body" : "Ah yes, good point about 87 constants, thanks for the clarification.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-25T15:42:05Z",
      "diff_hunk" : "@@ -326,3 +329,11 @@ bool GetScriptOp(CScriptBase::const_iterator& pc, CScriptBase::const_iterator en\n     opcodeRet = static_cast<opcodetype>(opcode);\n     return true;\n }\n+\n+bool IsOpSuccess(const opcodetype& opcode)\n+{\n+    return (opcode == 0x50 || opcode == 0x62 || opcode == 0x89 ||",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370939945",
      "id" : 370939945,
      "in_reply_to_id" : 370024599,
      "line" : 337,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkzOTk0NQ==",
      "original_commit_id" : "41acd620b5a0018b9ab5eb709ef54fafa8937324",
      "original_line" : 337,
      "original_position" : 17,
      "original_start_line" : null,
      "path" : "src/script/script.cpp",
      "position" : 17,
      "pull_request_review_id" : 348331546,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370939945",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/60021837?v=4",
         "events_url" : "https://api.github.com/users/v1048576/events{/privacy}",
         "followers_url" : "https://api.github.com/users/v1048576/followers",
         "following_url" : "https://api.github.com/users/v1048576/following{/other_user}",
         "gists_url" : "https://api.github.com/users/v1048576/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/v1048576",
         "id" : 60021837,
         "login" : "v1048576",
         "node_id" : "MDQ6VXNlcjYwMDIxODM3",
         "organizations_url" : "https://api.github.com/users/v1048576/orgs",
         "received_events_url" : "https://api.github.com/users/v1048576/received_events",
         "repos_url" : "https://api.github.com/users/v1048576/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/v1048576/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/v1048576/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/v1048576"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370948291"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370948291"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "documentation nit: preference to not use -1 to indicate a sentinel for a unsigned type.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-25T18:30:36Z",
      "diff_hunk" : "@@ -114,32 +120,101 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making the use of (unknown) annexes non-standard (currently no annexes are known)\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 20),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 21),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    //! Single-SHA256 versions\n+    uint256 m_prevouts_hash, m_sequences_hash, m_outputs_hash, m_amounts_spent_hash;\n+    bool m_amounts_spent_ready = false;\n+\n+    //! Double-SHA256 versions\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n     bool ready = false;\n+    std::vector<CTxOut> m_spent_outputs;\n+\n+    PrecomputedTransactionData() = default;\n+\n+    template <class T>\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and P2SH redeemscripts; see BIP 16\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with non-P2SH 32 byte program (Taproot), key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with non-P2SH 32 byte program (Taproot), script path spending, leaf version 0xc0 (Tapscript); see BIP 342\n+};\n+\n+struct ScriptExecutionData\n+{\n+    //! Whether m_tapleaf_hash is initialized.\n+    bool m_tapleaf_hash_init = false;\n+    //! The tapleaf hash.\n+    uint256 m_tapleaf_hash;\n+\n+    //! Whether m_codeseparator_pos is initialized.\n+    bool m_codeseparator_pos_init = false;\n+    //! Opcode position of the last executed OP_CODESEPARATOR (or -1 if none executed).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370948291",
      "id" : 370948291,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0ODI5MQ==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 182,
      "original_position" : 87,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 348338700,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370948291",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370948398"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370948398"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "UB nit: while this is safe, I believe, as it is used, it would be better to initialize this to either true or false should there be a bug, it would at least not invoke UB.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-25T18:32:40Z",
      "diff_hunk" : "@@ -114,32 +120,101 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making the use of (unknown) annexes non-standard (currently no annexes are known)\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 20),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 21),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    //! Single-SHA256 versions\n+    uint256 m_prevouts_hash, m_sequences_hash, m_outputs_hash, m_amounts_spent_hash;\n+    bool m_amounts_spent_ready = false;\n+\n+    //! Double-SHA256 versions\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n     bool ready = false;\n+    std::vector<CTxOut> m_spent_outputs;\n+\n+    PrecomputedTransactionData() = default;\n+\n+    template <class T>\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and P2SH redeemscripts; see BIP 16\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with non-P2SH 32 byte program (Taproot), key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with non-P2SH 32 byte program (Taproot), script path spending, leaf version 0xc0 (Tapscript); see BIP 342\n+};\n+\n+struct ScriptExecutionData\n+{\n+    //! Whether m_tapleaf_hash is initialized.\n+    bool m_tapleaf_hash_init = false;\n+    //! The tapleaf hash.\n+    uint256 m_tapleaf_hash;\n+\n+    //! Whether m_codeseparator_pos is initialized.\n+    bool m_codeseparator_pos_init = false;\n+    //! Opcode position of the last executed OP_CODESEPARATOR (or -1 if none executed).\n+    uint32_t m_codeseparator_pos;\n+\n+    //! Whether m_annex_present and m_annex_hash are initialized.\n+    bool m_annex_init = false;\n+    //! Whether an annex is present.\n+    bool m_annex_present;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370948398",
      "id" : 370948398,
      "line" : 195,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0ODM5OA==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 195,
      "original_position" : 93,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : 108,
      "pull_request_review_id" : 348338789,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370948398",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370948552"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370948552"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Not initializing it means giving valgrind a chance to detect incorrect use. I prefer to keep values uninitialized if they're actually intended to not be used.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-25T18:35:52Z",
      "diff_hunk" : "@@ -114,32 +120,101 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making the use of (unknown) annexes non-standard (currently no annexes are known)\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 20),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 21),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    //! Single-SHA256 versions\n+    uint256 m_prevouts_hash, m_sequences_hash, m_outputs_hash, m_amounts_spent_hash;\n+    bool m_amounts_spent_ready = false;\n+\n+    //! Double-SHA256 versions\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n     bool ready = false;\n+    std::vector<CTxOut> m_spent_outputs;\n+\n+    PrecomputedTransactionData() = default;\n+\n+    template <class T>\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and P2SH redeemscripts; see BIP 16\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with non-P2SH 32 byte program (Taproot), key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with non-P2SH 32 byte program (Taproot), script path spending, leaf version 0xc0 (Tapscript); see BIP 342\n+};\n+\n+struct ScriptExecutionData\n+{\n+    //! Whether m_tapleaf_hash is initialized.\n+    bool m_tapleaf_hash_init = false;\n+    //! The tapleaf hash.\n+    uint256 m_tapleaf_hash;\n+\n+    //! Whether m_codeseparator_pos is initialized.\n+    bool m_codeseparator_pos_init = false;\n+    //! Opcode position of the last executed OP_CODESEPARATOR (or -1 if none executed).\n+    uint32_t m_codeseparator_pos;\n+\n+    //! Whether m_annex_present and m_annex_hash are initialized.\n+    bool m_annex_init = false;\n+    //! Whether an annex is present.\n+    bool m_annex_present;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370948552",
      "id" : 370948552,
      "in_reply_to_id" : 370948398,
      "line" : 195,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0ODU1Mg==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 195,
      "original_position" : 93,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : 108,
      "pull_request_review_id" : 348338928,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370948552",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370948973"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370948973"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I'm generally not a fan of these Data interfaces which have all the bool x_init fields.\r\n\r\nAs an alternative, we could use an optional type wrapper.\r\n\r\nHowever, optional types depend on boost until c++17, which we shouldn't introduce consensus dependencies on.\r\n\r\nMy proposal would be to copy the definition of c++17 optional into https://github.com/bitcoin/bitcoin/blob/99813a9745fe10a58bedd7a4cb721faf14f907a4/src/optional.h and drop the boost dependency, and then use this here. This can be done as a PR separate from Taproot so as not to further burden this PR.\r\n\r\n\r\nHere, optionals express both the nothing set and not initialized state (hence dual-wrapped options) but perhaps we'd be OK in collapsing the wrapped ones to represent (not initialized or not set) OR value.\r\n\r\n```c++\r\n struct ScriptExecutionData\r\n {\r\n     //! The tapleaf hash.\r\n     Option<uint256> m_tapleaf_hash;\r\n     Option<Option<uint32_t>> m_codeseparator_pos;\r\n     //! Hash of the annex data, if any\r\n     Option<Option<uint256>> m_annex_hash;\r\n     /** How much validation weight is left (decremented for every successful signature check). */\r\n     Option<int64_t> m_validation_weight_left;\r\n };\r\n```\r\n\r\nThis would seem, to me, to make the interface quite a bit safer and eliminates a bunch of initialization logic & prevents UB from cropping up.\r\n\r\nIt would also be, in my opinion, a larger project (perhaps worthwhile) to generally rethink this state object to be accessed through an interface that guarantees the fields are accessed correctly -- e.g., once a m_validation_weight_left is set it can only be read or decreased, and the function to decrease can set error if the condition isn't met on underflow. Maybe not worth that large of a refactor though, I think optionals would already be an improvement.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-25T18:43:18Z",
      "diff_hunk" : "@@ -114,32 +120,101 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making the use of (unknown) annexes non-standard (currently no annexes are known)\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 20),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 21),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    //! Single-SHA256 versions\n+    uint256 m_prevouts_hash, m_sequences_hash, m_outputs_hash, m_amounts_spent_hash;\n+    bool m_amounts_spent_ready = false;\n+\n+    //! Double-SHA256 versions\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n     bool ready = false;\n+    std::vector<CTxOut> m_spent_outputs;\n+\n+    PrecomputedTransactionData() = default;\n+\n+    template <class T>\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and P2SH redeemscripts; see BIP 16\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with non-P2SH 32 byte program (Taproot), key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with non-P2SH 32 byte program (Taproot), script path spending, leaf version 0xc0 (Tapscript); see BIP 342\n+};\n+\n+struct ScriptExecutionData",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370948973",
      "id" : 370948973,
      "line" : 180,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0ODk3Mw==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 180,
      "original_position" : 78,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : 93,
      "pull_request_review_id" : 348339318,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370948973",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370949281"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370949281"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "That's an interesting point I hadn't considered! Could be an interesting separate project idea to have a macro of something like\r\n\r\n`DEFINED_CONSENSUS(param) ---> if not VALGRIND_BUILD param endig`\r\n\r\nto make sure that we define these things when we build for consensus, but to leave them undefined for valigrind.\r\n\r\nThis could be expanded to, for class members which you want to have this check, to union/wrap and define an accessor function via macro to avoid class initialization and be able to check initialization for arbitrary things not just primitives.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-25T18:49:10Z",
      "diff_hunk" : "@@ -114,32 +120,101 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making the use of (unknown) annexes non-standard (currently no annexes are known)\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 20),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 21),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    //! Single-SHA256 versions\n+    uint256 m_prevouts_hash, m_sequences_hash, m_outputs_hash, m_amounts_spent_hash;\n+    bool m_amounts_spent_ready = false;\n+\n+    //! Double-SHA256 versions\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n     bool ready = false;\n+    std::vector<CTxOut> m_spent_outputs;\n+\n+    PrecomputedTransactionData() = default;\n+\n+    template <class T>\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and P2SH redeemscripts; see BIP 16\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with non-P2SH 32 byte program (Taproot), key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with non-P2SH 32 byte program (Taproot), script path spending, leaf version 0xc0 (Tapscript); see BIP 342\n+};\n+\n+struct ScriptExecutionData\n+{\n+    //! Whether m_tapleaf_hash is initialized.\n+    bool m_tapleaf_hash_init = false;\n+    //! The tapleaf hash.\n+    uint256 m_tapleaf_hash;\n+\n+    //! Whether m_codeseparator_pos is initialized.\n+    bool m_codeseparator_pos_init = false;\n+    //! Opcode position of the last executed OP_CODESEPARATOR (or -1 if none executed).\n+    uint32_t m_codeseparator_pos;\n+\n+    //! Whether m_annex_present and m_annex_hash are initialized.\n+    bool m_annex_init = false;\n+    //! Whether an annex is present.\n+    bool m_annex_present;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370949281",
      "id" : 370949281,
      "in_reply_to_id" : 370948398,
      "line" : 195,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0OTI4MQ==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 195,
      "original_position" : 93,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : 108,
      "pull_request_review_id" : 348339581,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370949281",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370949751"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370949751"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Does that really add anything? Yes, it technically removes UB in this case, but replaces it with incorrect consensus code. Furthermore, there already is a runtime check to avoid it (the _init) flag, and the ability to detect it during tests through Valgrind/ubsan/... (in the even less likely case the _init flag is set incorrectly).\r\n\r\nI feel this is all overkill, and we should just stick to the common practice of not initializing variables that deliberately hold no value.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-25T18:59:08Z",
      "diff_hunk" : "@@ -114,32 +120,101 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making the use of (unknown) annexes non-standard (currently no annexes are known)\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 20),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 21),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    //! Single-SHA256 versions\n+    uint256 m_prevouts_hash, m_sequences_hash, m_outputs_hash, m_amounts_spent_hash;\n+    bool m_amounts_spent_ready = false;\n+\n+    //! Double-SHA256 versions\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n     bool ready = false;\n+    std::vector<CTxOut> m_spent_outputs;\n+\n+    PrecomputedTransactionData() = default;\n+\n+    template <class T>\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and P2SH redeemscripts; see BIP 16\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with non-P2SH 32 byte program (Taproot), key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with non-P2SH 32 byte program (Taproot), script path spending, leaf version 0xc0 (Tapscript); see BIP 342\n+};\n+\n+struct ScriptExecutionData\n+{\n+    //! Whether m_tapleaf_hash is initialized.\n+    bool m_tapleaf_hash_init = false;\n+    //! The tapleaf hash.\n+    uint256 m_tapleaf_hash;\n+\n+    //! Whether m_codeseparator_pos is initialized.\n+    bool m_codeseparator_pos_init = false;\n+    //! Opcode position of the last executed OP_CODESEPARATOR (or -1 if none executed).\n+    uint32_t m_codeseparator_pos;\n+\n+    //! Whether m_annex_present and m_annex_hash are initialized.\n+    bool m_annex_init = false;\n+    //! Whether an annex is present.\n+    bool m_annex_present;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370949751",
      "id" : 370949751,
      "in_reply_to_id" : 370948398,
      "line" : 195,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0OTc1MQ==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 195,
      "original_position" : 93,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : 108,
      "pull_request_review_id" : 348340028,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370949751",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370950458"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370950458"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "My point was more that we don't get the valgrind checkability for non primitive types, which seems like a good property if we want it for primitive types. A 0'd hash should be treated as undefined so that valgrind could pick it up.\r\n\r\nBut I'm resolving this convo here as it's a sidetrack, as noted above, \"Could be an interesting separate project idea\".",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-25T19:12:51Z",
      "diff_hunk" : "@@ -114,32 +120,101 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making the use of (unknown) annexes non-standard (currently no annexes are known)\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 20),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 21),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    //! Single-SHA256 versions\n+    uint256 m_prevouts_hash, m_sequences_hash, m_outputs_hash, m_amounts_spent_hash;\n+    bool m_amounts_spent_ready = false;\n+\n+    //! Double-SHA256 versions\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n     bool ready = false;\n+    std::vector<CTxOut> m_spent_outputs;\n+\n+    PrecomputedTransactionData() = default;\n+\n+    template <class T>\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and P2SH redeemscripts; see BIP 16\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with non-P2SH 32 byte program (Taproot), key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with non-P2SH 32 byte program (Taproot), script path spending, leaf version 0xc0 (Tapscript); see BIP 342\n+};\n+\n+struct ScriptExecutionData\n+{\n+    //! Whether m_tapleaf_hash is initialized.\n+    bool m_tapleaf_hash_init = false;\n+    //! The tapleaf hash.\n+    uint256 m_tapleaf_hash;\n+\n+    //! Whether m_codeseparator_pos is initialized.\n+    bool m_codeseparator_pos_init = false;\n+    //! Opcode position of the last executed OP_CODESEPARATOR (or -1 if none executed).\n+    uint32_t m_codeseparator_pos;\n+\n+    //! Whether m_annex_present and m_annex_hash are initialized.\n+    bool m_annex_init = false;\n+    //! Whether an annex is present.\n+    bool m_annex_present;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370950458",
      "id" : 370950458,
      "in_reply_to_id" : 370948398,
      "line" : 195,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MDQ1OA==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 195,
      "original_position" : 93,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : 108,
      "pull_request_review_id" : 348340726,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370950458",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370950492"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370950492"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I agree to an extent that all the _init variables are ugly, but I don't think that they're that bad if you see them as just runtime checks for invalid code. The same can be accomplished without them using ubsan/valgrind, in many cases.\r\n\r\nAbout using Option... It's arguably the right tool for the job, but there is no singular \"definition of c++17 optional\"; there is the libstdc++ implementation, and the libc++ one, both of which may be relying on platform specific extensions (I haven't checked). Even ignoring that, the libstdc++ one is 1500 lines of code, which I think is really overkill for what we'd get. Since the Boost one can't be used in libconsensus, I think the current code is not too bad.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-25T19:13:13Z",
      "diff_hunk" : "@@ -114,32 +120,101 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making the use of (unknown) annexes non-standard (currently no annexes are known)\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 20),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 21),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    //! Single-SHA256 versions\n+    uint256 m_prevouts_hash, m_sequences_hash, m_outputs_hash, m_amounts_spent_hash;\n+    bool m_amounts_spent_ready = false;\n+\n+    //! Double-SHA256 versions\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n     bool ready = false;\n+    std::vector<CTxOut> m_spent_outputs;\n+\n+    PrecomputedTransactionData() = default;\n+\n+    template <class T>\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and P2SH redeemscripts; see BIP 16\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with non-P2SH 32 byte program (Taproot), key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with non-P2SH 32 byte program (Taproot), script path spending, leaf version 0xc0 (Tapscript); see BIP 342\n+};\n+\n+struct ScriptExecutionData",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r370950492",
      "id" : 370950492,
      "in_reply_to_id" : 370948973,
      "line" : 180,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MDQ5Mg==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 180,
      "original_position" : 78,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : 93,
      "pull_request_review_id" : 348340742,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/370950492",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371029813"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371029813"
         }
      },
      "author_association" : "NONE",
      "body" : "I believe \"If the this nonce function ...\" should be \"If this nonce function ...\".",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-26T21:14:54Z",
      "diff_hunk" : "@@ -333,6 +413,54 @@ static SECP256K1_INLINE void buffer_append(unsigned char *buf, unsigned int *off\n     *offset += len;\n }\n \n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorrDerive\")||SHA256(\"BIPSchnorrDerive\"). */\n+static void secp256k1_nonce_function_bipschnorr_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x1cd78ec3ul;\n+    sha->s[1] = 0xc4425f87ul;\n+    sha->s[2] = 0xb4f1a9f1ul;\n+    sha->s[3] = 0xa16abd8dul;\n+    sha->s[4] = 0x5a6dea72ul;\n+    sha->s[5] = 0xd28469e3ul;\n+    sha->s[6] = 0x17119b2eul;\n+    sha->s[7] = 0x7bd19a16ul;\n+    sha->bytes = 64;\n+}\n+\n+/* This nonce function is described in BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki) */\n+static int nonce_function_bipschnorr(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If the this nonce function is used in BIP-schnorr signing as",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371029813",
      "id" : 371029813,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTAyOTgxMw==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 440,
      "original_position" : 252,
      "original_start_line" : null,
      "path" : "src/secp256k1/src/secp256k1.c",
      "position" : null,
      "pull_request_review_id" : 348405313,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371029813",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/60033096?v=4",
         "events_url" : "https://api.github.com/users/constcast-glitch/events{/privacy}",
         "followers_url" : "https://api.github.com/users/constcast-glitch/followers",
         "following_url" : "https://api.github.com/users/constcast-glitch/following{/other_user}",
         "gists_url" : "https://api.github.com/users/constcast-glitch/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/constcast-glitch",
         "id" : 60033096,
         "login" : "constcast-glitch",
         "node_id" : "MDQ6VXNlcjYwMDMzMDk2",
         "organizations_url" : "https://api.github.com/users/constcast-glitch/orgs",
         "received_events_url" : "https://api.github.com/users/constcast-glitch/received_events",
         "repos_url" : "https://api.github.com/users/constcast-glitch/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/constcast-glitch/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/constcast-glitch/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/constcast-glitch"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371030754"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371030754"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Can you repeat this comment here: https://github.com/bitcoin-core/secp256k1/pull/558  ?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-26T21:30:38Z",
      "diff_hunk" : "@@ -333,6 +413,54 @@ static SECP256K1_INLINE void buffer_append(unsigned char *buf, unsigned int *off\n     *offset += len;\n }\n \n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorrDerive\")||SHA256(\"BIPSchnorrDerive\"). */\n+static void secp256k1_nonce_function_bipschnorr_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x1cd78ec3ul;\n+    sha->s[1] = 0xc4425f87ul;\n+    sha->s[2] = 0xb4f1a9f1ul;\n+    sha->s[3] = 0xa16abd8dul;\n+    sha->s[4] = 0x5a6dea72ul;\n+    sha->s[5] = 0xd28469e3ul;\n+    sha->s[6] = 0x17119b2eul;\n+    sha->s[7] = 0x7bd19a16ul;\n+    sha->bytes = 64;\n+}\n+\n+/* This nonce function is described in BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki) */\n+static int nonce_function_bipschnorr(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If the this nonce function is used in BIP-schnorr signing as",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371030754",
      "id" : 371030754,
      "in_reply_to_id" : 371029813,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTAzMDc1NA==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 440,
      "original_position" : 252,
      "original_start_line" : null,
      "path" : "src/secp256k1/src/secp256k1.c",
      "position" : null,
      "pull_request_review_id" : 348406096,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371030754",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "node_id" : "MDQ6VXNlcjg1ODQ1NA==",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371031177"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371031177"
         }
      },
      "author_association" : "NONE",
      "body" : "Done",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-26T21:37:06Z",
      "diff_hunk" : "@@ -333,6 +413,54 @@ static SECP256K1_INLINE void buffer_append(unsigned char *buf, unsigned int *off\n     *offset += len;\n }\n \n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIPSchnorrDerive\")||SHA256(\"BIPSchnorrDerive\"). */\n+static void secp256k1_nonce_function_bipschnorr_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x1cd78ec3ul;\n+    sha->s[1] = 0xc4425f87ul;\n+    sha->s[2] = 0xb4f1a9f1ul;\n+    sha->s[3] = 0xa16abd8dul;\n+    sha->s[4] = 0x5a6dea72ul;\n+    sha->s[5] = 0xd28469e3ul;\n+    sha->s[6] = 0x17119b2eul;\n+    sha->s[7] = 0x7bd19a16ul;\n+    sha->bytes = 64;\n+}\n+\n+/* This nonce function is described in BIP-schnorr\n+ * (https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki) */\n+static int nonce_function_bipschnorr(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    secp256k1_sha256 sha;\n+\n+    if (counter != 0) {\n+        return 0;\n+    }\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If the this nonce function is used in BIP-schnorr signing as",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371031177",
      "id" : 371031177,
      "in_reply_to_id" : 371029813,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTAzMTE3Nw==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 440,
      "original_position" : 252,
      "original_start_line" : null,
      "path" : "src/secp256k1/src/secp256k1.c",
      "position" : null,
      "pull_request_review_id" : 348406393,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371031177",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/60033096?v=4",
         "events_url" : "https://api.github.com/users/constcast-glitch/events{/privacy}",
         "followers_url" : "https://api.github.com/users/constcast-glitch/followers",
         "following_url" : "https://api.github.com/users/constcast-glitch/following{/other_user}",
         "gists_url" : "https://api.github.com/users/constcast-glitch/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/constcast-glitch",
         "id" : 60033096,
         "login" : "constcast-glitch",
         "node_id" : "MDQ6VXNlcjYwMDMzMDk2",
         "organizations_url" : "https://api.github.com/users/constcast-glitch/orgs",
         "received_events_url" : "https://api.github.com/users/constcast-glitch/received_events",
         "repos_url" : "https://api.github.com/users/constcast-glitch/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/constcast-glitch/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/constcast-glitch/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/constcast-glitch"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371073789"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371073789"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It would be nice if there was an `IsValid()` function to check if the pubkey is actually valid, as opposed to the signature being invalid.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-27T06:07:23Z",
      "diff_hunk" : "@@ -203,6 +203,25 @@ class CPubKey\n     bool Derive(CPubKey& pubkeyChild, ChainCode &ccChild, unsigned int nChild, const ChainCode& cc) const;\n };\n \n+class XOnlyPubKey {\n+private:\n+    uint256 m_keydata;\n+\n+public:\n+    XOnlyPubKey(const uint256& in) : m_keydata(in) {}\n+\n+    /** Verify a 64-byte Schnorr signature.\n+     *\n+     * If the signature is not 64 bytes, or the public key is not fully valid, false is returned.\n+     */\n+    bool VerifySchnorr(const uint256& hash, const std::vector<unsigned char>& vchSig) const;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371073789",
      "id" : 371073789,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTA3Mzc4OQ==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 220,
      "original_position" : 15,
      "original_start_line" : null,
      "path" : "src/pubkey.h",
      "position" : null,
      "pull_request_review_id" : 348451722,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371073789",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371077447"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371077447"
         }
      },
      "author_association" : "MEMBER",
      "body" : "There should be no need.\n\nPublic keys as specified by BIP340 are 32-byte arrays, not points or X coordinates or whatever. The signature validation algorithm takes as input a 32-byte public key, and 64-byte signature, and a 32-byte message.\n\nThis is intentionally different from how ECDSA works, where differences between encoding errors and invalid signatures are significant, and arguably the cause of all the trouble we went through with ECDSA encodings, and BIP66...\n\nSo, to be clear: there should never be a behavior difference between an invalid signature and invalidity due to invalid public keys. Both are just inputs for which the verification returns false. Having a way to distinguish the two would be a risk.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-27T06:27:03Z",
      "diff_hunk" : "@@ -203,6 +203,25 @@ class CPubKey\n     bool Derive(CPubKey& pubkeyChild, ChainCode &ccChild, unsigned int nChild, const ChainCode& cc) const;\n };\n \n+class XOnlyPubKey {\n+private:\n+    uint256 m_keydata;\n+\n+public:\n+    XOnlyPubKey(const uint256& in) : m_keydata(in) {}\n+\n+    /** Verify a 64-byte Schnorr signature.\n+     *\n+     * If the signature is not 64 bytes, or the public key is not fully valid, false is returned.\n+     */\n+    bool VerifySchnorr(const uint256& hash, const std::vector<unsigned char>& vchSig) const;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371077447",
      "id" : 371077447,
      "in_reply_to_id" : 371073789,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTA3NzQ0Nw==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 220,
      "original_position" : 15,
      "original_start_line" : null,
      "path" : "src/pubkey.h",
      "position" : null,
      "pull_request_review_id" : 348457942,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371077447",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371081681"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371081681"
         }
      },
      "author_association" : "NONE",
      "body" : "> It would be nice if there was an `IsValid()` function to check if the pubkey is actually valid, as opposed to the signature being invalid.\r\n\r\n```\r\nclass XOnlyPubKey {\r\nprivate:\r\n    uint256 m_keydata;\r\n\r\npublic:\r\n    XOnlyPubKey(const uint256& in) : m_keydata(in) {}\r\n\r\n    /** Verify a 64-byte Schnorr signature.\r\n     *\r\n     * If the signature is not 64 bytes, or the public key is not fully valid, false is returned.\r\n     */\r\n    bool VerifySchnorr(const uint256& hash, const std::vector<unsigned char>& vchSig) const;\r\n    bool CheckPayToContract(const XOnlyPubKey& base, const uint256& hash, bool sign) const;\r\n\r\n    const unsigned char& operator[](int pos) const { return *(m_keydata.begin() + pos); }\r\n    const unsigned char* data() const { return m_keydata.begin(); }\r\n    size_t size() const { return 32; }\r\n};\r\n```\r\n\r\nThis on-line instruction is already doing the job \r\n``XOnlyPubKey(const uint256& in) : m_keydata(in) {}``",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-27T06:44:51Z",
      "diff_hunk" : "@@ -203,6 +203,25 @@ class CPubKey\n     bool Derive(CPubKey& pubkeyChild, ChainCode &ccChild, unsigned int nChild, const ChainCode& cc) const;\n };\n \n+class XOnlyPubKey {\n+private:\n+    uint256 m_keydata;\n+\n+public:\n+    XOnlyPubKey(const uint256& in) : m_keydata(in) {}\n+\n+    /** Verify a 64-byte Schnorr signature.\n+     *\n+     * If the signature is not 64 bytes, or the public key is not fully valid, false is returned.\n+     */\n+    bool VerifySchnorr(const uint256& hash, const std::vector<unsigned char>& vchSig) const;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371081681",
      "id" : 371081681,
      "in_reply_to_id" : 371073789,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTA4MTY4MQ==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 220,
      "original_position" : 15,
      "original_start_line" : null,
      "path" : "src/pubkey.h",
      "position" : null,
      "pull_request_review_id" : 348461813,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371081681",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7686916?v=4",
         "events_url" : "https://api.github.com/users/StEvUgnIn/events{/privacy}",
         "followers_url" : "https://api.github.com/users/StEvUgnIn/followers",
         "following_url" : "https://api.github.com/users/StEvUgnIn/following{/other_user}",
         "gists_url" : "https://api.github.com/users/StEvUgnIn/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/StEvUgnIn",
         "id" : 7686916,
         "login" : "StEvUgnIn",
         "node_id" : "MDQ6VXNlcjc2ODY5MTY=",
         "organizations_url" : "https://api.github.com/users/StEvUgnIn/orgs",
         "received_events_url" : "https://api.github.com/users/StEvUgnIn/received_events",
         "repos_url" : "https://api.github.com/users/StEvUgnIn/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/StEvUgnIn/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/StEvUgnIn/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/StEvUgnIn"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371085911"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371085911"
         }
      },
      "author_association" : "NONE",
      "body" : "I examined libstdc++ implementation for RISC-V architechture and it seems portable and independent from any physical architecture\r\nhttps://github.com/riscv/riscv-gcc/commits/riscv-gcc-8.3.0/libstdc%2B%2B-v3",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-27T07:07:29Z",
      "diff_hunk" : "@@ -114,32 +120,101 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making the use of (unknown) annexes non-standard (currently no annexes are known)\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 20),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 21),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    //! Single-SHA256 versions\n+    uint256 m_prevouts_hash, m_sequences_hash, m_outputs_hash, m_amounts_spent_hash;\n+    bool m_amounts_spent_ready = false;\n+\n+    //! Double-SHA256 versions\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n     bool ready = false;\n+    std::vector<CTxOut> m_spent_outputs;\n+\n+    PrecomputedTransactionData() = default;\n+\n+    template <class T>\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and P2SH redeemscripts; see BIP 16\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with non-P2SH 32 byte program (Taproot), key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with non-P2SH 32 byte program (Taproot), script path spending, leaf version 0xc0 (Tapscript); see BIP 342\n+};\n+\n+struct ScriptExecutionData",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371085911",
      "id" : 371085911,
      "in_reply_to_id" : 370948973,
      "line" : 180,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTA4NTkxMQ==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 180,
      "original_position" : 78,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : 93,
      "pull_request_review_id" : 348466970,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371085911",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7686916?v=4",
         "events_url" : "https://api.github.com/users/StEvUgnIn/events{/privacy}",
         "followers_url" : "https://api.github.com/users/StEvUgnIn/followers",
         "following_url" : "https://api.github.com/users/StEvUgnIn/following{/other_user}",
         "gists_url" : "https://api.github.com/users/StEvUgnIn/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/StEvUgnIn",
         "id" : 7686916,
         "login" : "StEvUgnIn",
         "node_id" : "MDQ6VXNlcjc2ODY5MTY=",
         "organizations_url" : "https://api.github.com/users/StEvUgnIn/orgs",
         "received_events_url" : "https://api.github.com/users/StEvUgnIn/received_events",
         "repos_url" : "https://api.github.com/users/StEvUgnIn/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/StEvUgnIn/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/StEvUgnIn/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/StEvUgnIn"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371090589"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371090589"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@sipa It is not useful to be able to distinguish between an invalid pubkey and an invalid signature? I don't understand the reasoning there. Indeed it should be helpful to be able to tell a user which part they fat fingered, if any.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-27T07:25:50Z",
      "diff_hunk" : "@@ -203,6 +203,25 @@ class CPubKey\n     bool Derive(CPubKey& pubkeyChild, ChainCode &ccChild, unsigned int nChild, const ChainCode& cc) const;\n };\n \n+class XOnlyPubKey {\n+private:\n+    uint256 m_keydata;\n+\n+public:\n+    XOnlyPubKey(const uint256& in) : m_keydata(in) {}\n+\n+    /** Verify a 64-byte Schnorr signature.\n+     *\n+     * If the signature is not 64 bytes, or the public key is not fully valid, false is returned.\n+     */\n+    bool VerifySchnorr(const uint256& hash, const std::vector<unsigned char>& vchSig) const;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371090589",
      "id" : 371090589,
      "in_reply_to_id" : 371073789,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTA5MDU4OQ==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 220,
      "original_position" : 15,
      "original_start_line" : null,
      "path" : "src/pubkey.h",
      "position" : null,
      "pull_request_review_id" : 348472760,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371090589",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371090902"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371090902"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@StEvUgnIn No, I am talking about the call to secp256k1_xonly_pubkey_parse failing.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-27T07:27:13Z",
      "diff_hunk" : "@@ -203,6 +203,25 @@ class CPubKey\n     bool Derive(CPubKey& pubkeyChild, ChainCode &ccChild, unsigned int nChild, const ChainCode& cc) const;\n };\n \n+class XOnlyPubKey {\n+private:\n+    uint256 m_keydata;\n+\n+public:\n+    XOnlyPubKey(const uint256& in) : m_keydata(in) {}\n+\n+    /** Verify a 64-byte Schnorr signature.\n+     *\n+     * If the signature is not 64 bytes, or the public key is not fully valid, false is returned.\n+     */\n+    bool VerifySchnorr(const uint256& hash, const std::vector<unsigned char>& vchSig) const;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371090902",
      "id" : 371090902,
      "in_reply_to_id" : 371073789,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTA5MDkwMg==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 220,
      "original_position" : 15,
      "original_start_line" : null,
      "path" : "src/pubkey.h",
      "position" : null,
      "pull_request_review_id" : 348473180,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371090902",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371091495"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371091495"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Sure, for users it may be useful to have a sanity check. But consensus code should never distinguish between invalid public key and invalid signature.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-27T07:29:40Z",
      "diff_hunk" : "@@ -203,6 +203,25 @@ class CPubKey\n     bool Derive(CPubKey& pubkeyChild, ChainCode &ccChild, unsigned int nChild, const ChainCode& cc) const;\n };\n \n+class XOnlyPubKey {\n+private:\n+    uint256 m_keydata;\n+\n+public:\n+    XOnlyPubKey(const uint256& in) : m_keydata(in) {}\n+\n+    /** Verify a 64-byte Schnorr signature.\n+     *\n+     * If the signature is not 64 bytes, or the public key is not fully valid, false is returned.\n+     */\n+    bool VerifySchnorr(const uint256& hash, const std::vector<unsigned char>& vchSig) const;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371091495",
      "id" : 371091495,
      "in_reply_to_id" : 371073789,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTA5MTQ5NQ==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 220,
      "original_position" : 15,
      "original_start_line" : null,
      "path" : "src/pubkey.h",
      "position" : null,
      "pull_request_review_id" : 348473938,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371091495",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371095590"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371095590"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I agree. That said, having `IsValid()` would be helpful for non-consensus use.. I guess that would be tempting to use in consensus code, so a warning comment might be needed.",
      "commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "created_at" : "2020-01-27T07:45:22Z",
      "diff_hunk" : "@@ -203,6 +203,25 @@ class CPubKey\n     bool Derive(CPubKey& pubkeyChild, ChainCode &ccChild, unsigned int nChild, const ChainCode& cc) const;\n };\n \n+class XOnlyPubKey {\n+private:\n+    uint256 m_keydata;\n+\n+public:\n+    XOnlyPubKey(const uint256& in) : m_keydata(in) {}\n+\n+    /** Verify a 64-byte Schnorr signature.\n+     *\n+     * If the signature is not 64 bytes, or the public key is not fully valid, false is returned.\n+     */\n+    bool VerifySchnorr(const uint256& hash, const std::vector<unsigned char>& vchSig) const;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371095590",
      "id" : 371095590,
      "in_reply_to_id" : 371073789,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTA5NTU5MA==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_position" : 15,
      "path" : "src/pubkey.h",
      "position" : 15,
      "pull_request_review_id" : 348478776,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "updated_at" : "2020-01-27T07:45:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371095590",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371411509"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371411509"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@StEvUgnIn We can't just copy GPL code, unfortunately. Using libc++'s version may be an option, but it still seems overkill to me (it also contains lots of libc++ specific macros, that may require additional files to be included).",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-27T18:37:19Z",
      "diff_hunk" : "@@ -114,32 +120,101 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making the use of (unknown) annexes non-standard (currently no annexes are known)\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 20),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 21),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    //! Single-SHA256 versions\n+    uint256 m_prevouts_hash, m_sequences_hash, m_outputs_hash, m_amounts_spent_hash;\n+    bool m_amounts_spent_ready = false;\n+\n+    //! Double-SHA256 versions\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n     bool ready = false;\n+    std::vector<CTxOut> m_spent_outputs;\n+\n+    PrecomputedTransactionData() = default;\n+\n+    template <class T>\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and P2SH redeemscripts; see BIP 16\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with non-P2SH 32 byte program (Taproot), key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with non-P2SH 32 byte program (Taproot), script path spending, leaf version 0xc0 (Tapscript); see BIP 342\n+};\n+\n+struct ScriptExecutionData",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371411509",
      "id" : 371411509,
      "in_reply_to_id" : 370948973,
      "line" : 180,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQxMTUwOQ==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 180,
      "original_position" : 78,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : 93,
      "pull_request_review_id" : 348885402,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371411509",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371645313"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371645313"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This assertion will be hit, because `cache` is null when using the below constructor:\r\n\r\nhttps://github.com/bitcoin/bitcoin/blob/b8048b814821913b1f4c1c2070ec68b0c9001ec8/src/script/interpreter.h#L258\r\n\r\nMaybe checking if txdata is non-null and complain if it isn't, at\r\n\r\nhttps://github.com/bitcoin/bitcoin/blob/b8048b814821913b1f4c1c2070ec68b0c9001ec8/src/script/interpreter.cpp#L1638\r\n",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-28T07:40:38Z",
      "diff_hunk" : "@@ -1209,27 +1379,141 @@ uint256 GetOutputsHash(const T& txTo)\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n+}\n+\n+uint256 GetSpentAmountsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n }\n \n } // namespace\n \n template <class T>\n-PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n+    m_spent_outputs = std::move(spent_outputs);\n+\n+    if (ready) return;\n     // Cache is calculated only for transactions with witness\n     if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+        m_prevouts_hash = GetPrevoutHash(txTo);\n+        hashPrevouts = SHA256Uint256(m_prevouts_hash);\n+        m_sequences_hash = GetSequenceHash(txTo);\n+        hashSequence = SHA256Uint256(m_sequences_hash);\n+        m_outputs_hash = GetOutputsHash(txTo);\n+        hashOutputs = SHA256Uint256(m_outputs_hash);\n         ready = true;\n+\n+        if (!m_spent_outputs.empty()) {\n+            m_amounts_spent_hash = GetSpentAmountsHash(m_spent_outputs);\n+            m_amounts_spent_ready = true;\n+        }\n     }\n }\n \n+template <class T>\n+PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+{\n+    Init(txTo, {});\n+}\n+\n // explicit instantiation\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");\n+static const CHashWriter HasherTapLeaf = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HasherTapBranch = TaggedHash(\"TapBranch\");\n+static const CHashWriter HasherTapTweak = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData& cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    case SigVersion::TAPSCRIPT:\n+        ext_flag = 1;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache.ready && cache.m_amounts_spent_ready);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371645313",
      "id" : 371645313,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY0NTMxMw==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 1451,
      "original_position" : 398,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 349174435,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371645313",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371653934"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371653934"
         }
      },
      "author_association" : "MEMBER",
      "body" : "If someone does `txdata = PrecomputedTransactionData(tx);` and then later tries to do `txdata.Init(tx, spent_outputs);` this line will terminate, despite `m_amounts_spent_ready` not being updated based on the new spent_outputs. Perhaps\r\n\r\n```C++\r\nif (ready && spent_outputs.empty()) return;\r\n```\r\n\r\nEdit: maybe even split into `if !ready, make hashes` and `if !m_amounts_spend_ready`, do spent stuff. (also fixed description; m_spent_outputs is updated, but the bool is not)",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-28T08:07:12Z",
      "diff_hunk" : "@@ -1209,27 +1379,141 @@ uint256 GetOutputsHash(const T& txTo)\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n+}\n+\n+uint256 GetSpentAmountsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n }\n \n } // namespace\n \n template <class T>\n-PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n+    m_spent_outputs = std::move(spent_outputs);\n+\n+    if (ready) return;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371653934",
      "id" : 371653934,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY1MzkzNA==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 1401,
      "original_position" : 345,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 349185038,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371653934",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371655553"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371655553"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Well yes it would assert because that would be invalid. It seems it's just doing its job?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-28T08:12:15Z",
      "diff_hunk" : "@@ -1209,27 +1379,141 @@ uint256 GetOutputsHash(const T& txTo)\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n+}\n+\n+uint256 GetSpentAmountsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n }\n \n } // namespace\n \n template <class T>\n-PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n+    m_spent_outputs = std::move(spent_outputs);\n+\n+    if (ready) return;\n     // Cache is calculated only for transactions with witness\n     if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+        m_prevouts_hash = GetPrevoutHash(txTo);\n+        hashPrevouts = SHA256Uint256(m_prevouts_hash);\n+        m_sequences_hash = GetSequenceHash(txTo);\n+        hashSequence = SHA256Uint256(m_sequences_hash);\n+        m_outputs_hash = GetOutputsHash(txTo);\n+        hashOutputs = SHA256Uint256(m_outputs_hash);\n         ready = true;\n+\n+        if (!m_spent_outputs.empty()) {\n+            m_amounts_spent_hash = GetSpentAmountsHash(m_spent_outputs);\n+            m_amounts_spent_ready = true;\n+        }\n     }\n }\n \n+template <class T>\n+PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+{\n+    Init(txTo, {});\n+}\n+\n // explicit instantiation\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");\n+static const CHashWriter HasherTapLeaf = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HasherTapBranch = TaggedHash(\"TapBranch\");\n+static const CHashWriter HasherTapTweak = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData& cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    case SigVersion::TAPSCRIPT:\n+        ext_flag = 1;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache.ready && cache.m_amounts_spent_ready);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371655553",
      "id" : 371655553,
      "in_reply_to_id" : 371645313,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY1NTU1Mw==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 1451,
      "original_position" : 398,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 349187181,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371655553",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371658686"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371658686"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm not arguing against the assert, I'm saying that we should catch 'cache is null' before this point.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-28T08:21:08Z",
      "diff_hunk" : "@@ -1209,27 +1379,141 @@ uint256 GetOutputsHash(const T& txTo)\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n+}\n+\n+uint256 GetSpentAmountsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n }\n \n } // namespace\n \n template <class T>\n-PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n+    m_spent_outputs = std::move(spent_outputs);\n+\n+    if (ready) return;\n     // Cache is calculated only for transactions with witness\n     if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+        m_prevouts_hash = GetPrevoutHash(txTo);\n+        hashPrevouts = SHA256Uint256(m_prevouts_hash);\n+        m_sequences_hash = GetSequenceHash(txTo);\n+        hashSequence = SHA256Uint256(m_sequences_hash);\n+        m_outputs_hash = GetOutputsHash(txTo);\n+        hashOutputs = SHA256Uint256(m_outputs_hash);\n         ready = true;\n+\n+        if (!m_spent_outputs.empty()) {\n+            m_amounts_spent_hash = GetSpentAmountsHash(m_spent_outputs);\n+            m_amounts_spent_ready = true;\n+        }\n     }\n }\n \n+template <class T>\n+PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+{\n+    Init(txTo, {});\n+}\n+\n // explicit instantiation\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");\n+static const CHashWriter HasherTapLeaf = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HasherTapBranch = TaggedHash(\"TapBranch\");\n+static const CHashWriter HasherTapTweak = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData& cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    case SigVersion::TAPSCRIPT:\n+        ext_flag = 1;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache.ready && cache.m_amounts_spent_ready);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371658686",
      "id" : 371658686,
      "in_reply_to_id" : 371645313,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY1ODY4Ng==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 1451,
      "original_position" : 398,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 349191089,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371658686",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371663250"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371663250"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Because it's misleading and confusing. The assert is not triggering for the right reasons (I don't even think it's triggering at all, though tbh I'm not sure how C++ deals with being passed a null value for a referenced non-reference like this).\r\n\r\nIt's checking whether the cache is ready, but in reality the cache is null. This method does not even take a ref to begin with. The one place it's called is L1638, which could just do an `assert(txdata)` before calling `SignatureHashSchnorr`.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-28T08:33:20Z",
      "diff_hunk" : "@@ -1209,27 +1379,141 @@ uint256 GetOutputsHash(const T& txTo)\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n+}\n+\n+uint256 GetSpentAmountsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n }\n \n } // namespace\n \n template <class T>\n-PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n+    m_spent_outputs = std::move(spent_outputs);\n+\n+    if (ready) return;\n     // Cache is calculated only for transactions with witness\n     if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+        m_prevouts_hash = GetPrevoutHash(txTo);\n+        hashPrevouts = SHA256Uint256(m_prevouts_hash);\n+        m_sequences_hash = GetSequenceHash(txTo);\n+        hashSequence = SHA256Uint256(m_sequences_hash);\n+        m_outputs_hash = GetOutputsHash(txTo);\n+        hashOutputs = SHA256Uint256(m_outputs_hash);\n         ready = true;\n+\n+        if (!m_spent_outputs.empty()) {\n+            m_amounts_spent_hash = GetSpentAmountsHash(m_spent_outputs);\n+            m_amounts_spent_ready = true;\n+        }\n     }\n }\n \n+template <class T>\n+PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+{\n+    Init(txTo, {});\n+}\n+\n // explicit instantiation\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");\n+static const CHashWriter HasherTapLeaf = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HasherTapBranch = TaggedHash(\"TapBranch\");\n+static const CHashWriter HasherTapTweak = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData& cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    case SigVersion::TAPSCRIPT:\n+        ext_flag = 1;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache.ready && cache.m_amounts_spent_ready);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371663250",
      "id" : 371663250,
      "in_reply_to_id" : 371645313,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY2MzI1MA==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 1451,
      "original_position" : 398,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 349196821,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371663250",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371663431"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371663431"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't think that helps. If you reach this point without the cache initialized, you're using the code incorrectly.\n\nWhat is perhaps not clear is that this is not just a cache - we can't recompute data in it if it missing based on other sources. We rely on it to pass in essential information about the spending that cannot be retrieved otherwise.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-28T08:33:48Z",
      "diff_hunk" : "@@ -1209,27 +1379,141 @@ uint256 GetOutputsHash(const T& txTo)\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n+}\n+\n+uint256 GetSpentAmountsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n }\n \n } // namespace\n \n template <class T>\n-PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n+    m_spent_outputs = std::move(spent_outputs);\n+\n+    if (ready) return;\n     // Cache is calculated only for transactions with witness\n     if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+        m_prevouts_hash = GetPrevoutHash(txTo);\n+        hashPrevouts = SHA256Uint256(m_prevouts_hash);\n+        m_sequences_hash = GetSequenceHash(txTo);\n+        hashSequence = SHA256Uint256(m_sequences_hash);\n+        m_outputs_hash = GetOutputsHash(txTo);\n+        hashOutputs = SHA256Uint256(m_outputs_hash);\n         ready = true;\n+\n+        if (!m_spent_outputs.empty()) {\n+            m_amounts_spent_hash = GetSpentAmountsHash(m_spent_outputs);\n+            m_amounts_spent_ready = true;\n+        }\n     }\n }\n \n+template <class T>\n+PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+{\n+    Init(txTo, {});\n+}\n+\n // explicit instantiation\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");\n+static const CHashWriter HasherTapLeaf = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HasherTapBranch = TaggedHash(\"TapBranch\");\n+static const CHashWriter HasherTapTweak = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData& cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    case SigVersion::TAPSCRIPT:\n+        ext_flag = 1;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache.ready && cache.m_amounts_spent_ready);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371663431",
      "id" : 371663431,
      "in_reply_to_id" : 371645313,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY2MzQzMQ==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 1451,
      "original_position" : 398,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 349197043,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371663431",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371664502"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371664502"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Oh, you're talking about null vs uninitialized. I'll investigate tomorrow. Dereferencing or invoking a member function of a null pointer is UB; if that can happen we should indeed catch it earlier. I can't check the code right now.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-28T08:36:41Z",
      "diff_hunk" : "@@ -1209,27 +1379,141 @@ uint256 GetOutputsHash(const T& txTo)\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n+}\n+\n+uint256 GetSpentAmountsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n }\n \n } // namespace\n \n template <class T>\n-PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n+    m_spent_outputs = std::move(spent_outputs);\n+\n+    if (ready) return;\n     // Cache is calculated only for transactions with witness\n     if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+        m_prevouts_hash = GetPrevoutHash(txTo);\n+        hashPrevouts = SHA256Uint256(m_prevouts_hash);\n+        m_sequences_hash = GetSequenceHash(txTo);\n+        hashSequence = SHA256Uint256(m_sequences_hash);\n+        m_outputs_hash = GetOutputsHash(txTo);\n+        hashOutputs = SHA256Uint256(m_outputs_hash);\n         ready = true;\n+\n+        if (!m_spent_outputs.empty()) {\n+            m_amounts_spent_hash = GetSpentAmountsHash(m_spent_outputs);\n+            m_amounts_spent_ready = true;\n+        }\n     }\n }\n \n+template <class T>\n+PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+{\n+    Init(txTo, {});\n+}\n+\n // explicit instantiation\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");\n+static const CHashWriter HasherTapLeaf = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HasherTapBranch = TaggedHash(\"TapBranch\");\n+static const CHashWriter HasherTapTweak = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData& cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    case SigVersion::TAPSCRIPT:\n+        ext_flag = 1;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache.ready && cache.m_amounts_spent_ready);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371664502",
      "id" : 371664502,
      "in_reply_to_id" : 371645313,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY2NDUwMg==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 1451,
      "original_position" : 398,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 349198500,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371664502",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371667917"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371667917"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Hm.. for v0 this is actually accomodated for\r\n```C++\r\n        const bool cacheready = cache && cache->ready;\r\n```\r\nwhereas for v1 this is mandatory. I still think it's unnecessarily unhelpful, and a bit scary to have non-ref null values in code paths (even if as you say this is a hint of a bigger problem).",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-28T08:44:49Z",
      "diff_hunk" : "@@ -1209,27 +1379,141 @@ uint256 GetOutputsHash(const T& txTo)\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n+}\n+\n+uint256 GetSpentAmountsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n }\n \n } // namespace\n \n template <class T>\n-PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n+    m_spent_outputs = std::move(spent_outputs);\n+\n+    if (ready) return;\n     // Cache is calculated only for transactions with witness\n     if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+        m_prevouts_hash = GetPrevoutHash(txTo);\n+        hashPrevouts = SHA256Uint256(m_prevouts_hash);\n+        m_sequences_hash = GetSequenceHash(txTo);\n+        hashSequence = SHA256Uint256(m_sequences_hash);\n+        m_outputs_hash = GetOutputsHash(txTo);\n+        hashOutputs = SHA256Uint256(m_outputs_hash);\n         ready = true;\n+\n+        if (!m_spent_outputs.empty()) {\n+            m_amounts_spent_hash = GetSpentAmountsHash(m_spent_outputs);\n+            m_amounts_spent_ready = true;\n+        }\n     }\n }\n \n+template <class T>\n+PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+{\n+    Init(txTo, {});\n+}\n+\n // explicit instantiation\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");\n+static const CHashWriter HasherTapLeaf = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HasherTapBranch = TaggedHash(\"TapBranch\");\n+static const CHashWriter HasherTapTweak = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData& cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    case SigVersion::TAPSCRIPT:\n+        ext_flag = 1;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache.ready && cache.m_amounts_spent_ready);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371667917",
      "id" : 371667917,
      "in_reply_to_id" : 371645313,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY2NzkxNw==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 1451,
      "original_position" : 398,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 349202739,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371667917",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371669023"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371669023"
         }
      },
      "author_association" : "MEMBER",
      "body" : "What do \"non-ref null values\" mean?\n\nA reference to nullptr is illegal, always. Only pointers can be nullptr.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-28T08:47:20Z",
      "diff_hunk" : "@@ -1209,27 +1379,141 @@ uint256 GetOutputsHash(const T& txTo)\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n+}\n+\n+uint256 GetSpentAmountsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n }\n \n } // namespace\n \n template <class T>\n-PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n+    m_spent_outputs = std::move(spent_outputs);\n+\n+    if (ready) return;\n     // Cache is calculated only for transactions with witness\n     if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+        m_prevouts_hash = GetPrevoutHash(txTo);\n+        hashPrevouts = SHA256Uint256(m_prevouts_hash);\n+        m_sequences_hash = GetSequenceHash(txTo);\n+        hashSequence = SHA256Uint256(m_sequences_hash);\n+        m_outputs_hash = GetOutputsHash(txTo);\n+        hashOutputs = SHA256Uint256(m_outputs_hash);\n         ready = true;\n+\n+        if (!m_spent_outputs.empty()) {\n+            m_amounts_spent_hash = GetSpentAmountsHash(m_spent_outputs);\n+            m_amounts_spent_ready = true;\n+        }\n     }\n }\n \n+template <class T>\n+PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+{\n+    Init(txTo, {});\n+}\n+\n // explicit instantiation\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");\n+static const CHashWriter HasherTapLeaf = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HasherTapBranch = TaggedHash(\"TapBranch\");\n+static const CHashWriter HasherTapTweak = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData& cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    case SigVersion::TAPSCRIPT:\n+        ext_flag = 1;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache.ready && cache.m_amounts_spent_ready);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371669023",
      "id" : 371669023,
      "in_reply_to_id" : 371645313,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY2OTAyMw==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 1451,
      "original_position" : 398,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 349204074,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371669023",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371674659"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371674659"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In `SignatureHashSchnorr`, the last parameter, defined as `const PrecomputedTransactionData& cache`, is `0x0000000000000000` for the case where `*this->txdata == nullptr` above. This may be using the code incorrectly, but it seems worth catching before that call above.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-28T08:58:59Z",
      "diff_hunk" : "@@ -1209,27 +1379,141 @@ uint256 GetOutputsHash(const T& txTo)\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n+}\n+\n+uint256 GetSpentAmountsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n }\n \n } // namespace\n \n template <class T>\n-PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n+    m_spent_outputs = std::move(spent_outputs);\n+\n+    if (ready) return;\n     // Cache is calculated only for transactions with witness\n     if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+        m_prevouts_hash = GetPrevoutHash(txTo);\n+        hashPrevouts = SHA256Uint256(m_prevouts_hash);\n+        m_sequences_hash = GetSequenceHash(txTo);\n+        hashSequence = SHA256Uint256(m_sequences_hash);\n+        m_outputs_hash = GetOutputsHash(txTo);\n+        hashOutputs = SHA256Uint256(m_outputs_hash);\n         ready = true;\n+\n+        if (!m_spent_outputs.empty()) {\n+            m_amounts_spent_hash = GetSpentAmountsHash(m_spent_outputs);\n+            m_amounts_spent_ready = true;\n+        }\n     }\n }\n \n+template <class T>\n+PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+{\n+    Init(txTo, {});\n+}\n+\n // explicit instantiation\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");\n+static const CHashWriter HasherTapLeaf = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HasherTapBranch = TaggedHash(\"TapBranch\");\n+static const CHashWriter HasherTapTweak = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData& cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    case SigVersion::TAPSCRIPT:\n+        ext_flag = 1;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache.ready && cache.m_amounts_spent_ready);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r371674659",
      "id" : 371674659,
      "in_reply_to_id" : 371645313,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY3NDY1OQ==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 1451,
      "original_position" : 398,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 349210969,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/371674659",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r372771079"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/372771079"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I believe this should be called `SignatureHashSchnorr` and be `<typename T>` to match `interpreter.cpp` v.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-30T05:57:55Z",
      "diff_hunk" : "@@ -114,32 +120,101 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making the use of (unknown) annexes non-standard (currently no annexes are known)\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 20),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 21),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    //! Single-SHA256 versions\n+    uint256 m_prevouts_hash, m_sequences_hash, m_outputs_hash, m_amounts_spent_hash;\n+    bool m_amounts_spent_ready = false;\n+\n+    //! Double-SHA256 versions\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n     bool ready = false;\n+    std::vector<CTxOut> m_spent_outputs;\n+\n+    PrecomputedTransactionData() = default;\n+\n+    template <class T>\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and P2SH redeemscripts; see BIP 16\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with non-P2SH 32 byte program (Taproot), key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with non-P2SH 32 byte program (Taproot), script path spending, leaf version 0xc0 (Tapscript); see BIP 342\n+};\n+\n+struct ScriptExecutionData\n+{\n+    //! Whether m_tapleaf_hash is initialized.\n+    bool m_tapleaf_hash_init = false;\n+    //! The tapleaf hash.\n+    uint256 m_tapleaf_hash;\n+\n+    //! Whether m_codeseparator_pos is initialized.\n+    bool m_codeseparator_pos_init = false;\n+    //! Opcode position of the last executed OP_CODESEPARATOR (or -1 if none executed).\n+    uint32_t m_codeseparator_pos;\n+\n+    //! Whether m_annex_present and m_annex_hash are initialized.\n+    bool m_annex_init = false;\n+    //! Whether an annex is present.\n+    bool m_annex_present;\n+    //! Hash of the annex data.\n+    uint256 m_annex_hash;\n+\n+    /** Whether m_validation_weight_left is initialized. */\n+    bool m_validation_weight_left_init = false;\n+    /** How much validation weight is left (decremented for every successful signature check). */\n+    int64_t m_validation_weight_left;\n };\n \n /** Signature hash sizes */\n static constexpr size_t WITNESS_V0_SCRIPTHASH_SIZE = 32;\n static constexpr size_t WITNESS_V0_KEYHASH_SIZE = 20;\n+static constexpr size_t WITNESS_V1_TAPROOT_SIZE = 32;\n+\n+\n+static constexpr uint8_t TAPROOT_LEAF_MASK = 0xfe;\n+static constexpr uint8_t TAPROOT_LEAF_TAPSCRIPT = 0xc0;\n+static constexpr size_t TAPROOT_PROGRAM_SIZE = 32;\n+static constexpr size_t TAPROOT_CONTROL_BASE_SIZE = 33;\n+static constexpr size_t TAPROOT_CONTROL_NODE_SIZE = 32;\n+static constexpr size_t TAPROOT_CONTROL_MAX_NODE_COUNT = 128;\n+static constexpr size_t TAPROOT_CONTROL_MAX_SIZE = TAPROOT_CONTROL_BASE_SIZE + TAPROOT_CONTROL_NODE_SIZE * TAPROOT_CONTROL_MAX_NODE_COUNT;\n \n template <class T>\n uint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn, int nHashType, const CAmount& amount, SigVersion sigversion, const PrecomputedTransactionData* cache = nullptr);\n \n+template <class T>\n+bool SignatureHashTap(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, unsigned int in_pos, uint8_t hash_type, SigVersion sigversion, const PrecomputedTransactionData& cache);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r372771079",
      "id" : 372771079,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc3MTA3OQ==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 216,
      "original_position" : 121,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 350595516,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/372771079",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r373074045"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/373074045"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "@JeremyRubin Don't forget that the `std` namespace get special treatment from the compiler.\r\nso copying code from `libstd` without checking it might actually contain implementation defined behavior that won't necessarily work correctly with a different compiler(or even just by being outside of the std namespace).",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-30T17:01:35Z",
      "diff_hunk" : "@@ -114,32 +120,101 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making the use of (unknown) annexes non-standard (currently no annexes are known)\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 20),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 21),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    //! Single-SHA256 versions\n+    uint256 m_prevouts_hash, m_sequences_hash, m_outputs_hash, m_amounts_spent_hash;\n+    bool m_amounts_spent_ready = false;\n+\n+    //! Double-SHA256 versions\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n     bool ready = false;\n+    std::vector<CTxOut> m_spent_outputs;\n+\n+    PrecomputedTransactionData() = default;\n+\n+    template <class T>\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and P2SH redeemscripts; see BIP 16\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with non-P2SH 32 byte program (Taproot), key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with non-P2SH 32 byte program (Taproot), script path spending, leaf version 0xc0 (Tapscript); see BIP 342\n+};\n+\n+struct ScriptExecutionData",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r373074045",
      "id" : 373074045,
      "in_reply_to_id" : 370948973,
      "line" : 180,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzA3NDA0NQ==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 180,
      "original_position" : 78,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : 93,
      "pull_request_review_id" : 350987923,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/373074045",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2167860?v=4",
         "events_url" : "https://api.github.com/users/elichai/events{/privacy}",
         "followers_url" : "https://api.github.com/users/elichai/followers",
         "following_url" : "https://api.github.com/users/elichai/following{/other_user}",
         "gists_url" : "https://api.github.com/users/elichai/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/elichai",
         "id" : 2167860,
         "login" : "elichai",
         "node_id" : "MDQ6VXNlcjIxNjc4NjA=",
         "organizations_url" : "https://api.github.com/users/elichai/orgs",
         "received_events_url" : "https://api.github.com/users/elichai/received_events",
         "repos_url" : "https://api.github.com/users/elichai/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/elichai/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/elichai/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/elichai"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r373351801"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/373351801"
         }
      },
      "author_association" : "NONE",
      "body" : "@kallewoof OK",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-01-31T07:51:32Z",
      "diff_hunk" : "@@ -203,6 +203,25 @@ class CPubKey\n     bool Derive(CPubKey& pubkeyChild, ChainCode &ccChild, unsigned int nChild, const ChainCode& cc) const;\n };\n \n+class XOnlyPubKey {\n+private:\n+    uint256 m_keydata;\n+\n+public:\n+    XOnlyPubKey(const uint256& in) : m_keydata(in) {}\n+\n+    /** Verify a 64-byte Schnorr signature.\n+     *\n+     * If the signature is not 64 bytes, or the public key is not fully valid, false is returned.\n+     */\n+    bool VerifySchnorr(const uint256& hash, const std::vector<unsigned char>& vchSig) const;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r373351801",
      "id" : 373351801,
      "in_reply_to_id" : 371073789,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzM1MTgwMQ==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 220,
      "original_position" : 15,
      "original_start_line" : null,
      "path" : "src/pubkey.h",
      "position" : null,
      "pull_request_review_id" : 351337332,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/373351801",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7686916?v=4",
         "events_url" : "https://api.github.com/users/StEvUgnIn/events{/privacy}",
         "followers_url" : "https://api.github.com/users/StEvUgnIn/followers",
         "following_url" : "https://api.github.com/users/StEvUgnIn/following{/other_user}",
         "gists_url" : "https://api.github.com/users/StEvUgnIn/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/StEvUgnIn",
         "id" : 7686916,
         "login" : "StEvUgnIn",
         "node_id" : "MDQ6VXNlcjc2ODY5MTY=",
         "organizations_url" : "https://api.github.com/users/StEvUgnIn/orgs",
         "received_events_url" : "https://api.github.com/users/StEvUgnIn/received_events",
         "repos_url" : "https://api.github.com/users/StEvUgnIn/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/StEvUgnIn/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/StEvUgnIn/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/StEvUgnIn"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r384485907"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/384485907"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Is the P2SH check necessary here? There is a test for `prevScript.IsWitnessProgram()` a few lines up, is there anyway the script could still be P2SH at this point?\r\nOr should this actually test `prev.scriptPubKey.IsPayToScriptHash()` which is the actual previous TX output script, defined before `prevScript` is updated to the redeem script.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-02-26T13:19:30Z",
      "diff_hunk" : "@@ -231,6 +231,30 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check P2TR standard limits\n+        if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE && !prevScript.IsPayToScriptHash()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r384485907",
      "id" : 384485907,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ4NTkwNw==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 236,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : null,
      "pull_request_review_id" : 364889274,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/384485907",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2084648?v=4",
         "events_url" : "https://api.github.com/users/pinheadmz/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pinheadmz/followers",
         "following_url" : "https://api.github.com/users/pinheadmz/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pinheadmz/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pinheadmz",
         "id" : 2084648,
         "login" : "pinheadmz",
         "node_id" : "MDQ6VXNlcjIwODQ2NDg=",
         "organizations_url" : "https://api.github.com/users/pinheadmz/orgs",
         "received_events_url" : "https://api.github.com/users/pinheadmz/received_events",
         "repos_url" : "https://api.github.com/users/pinheadmz/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pinheadmz/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pinheadmz/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pinheadmz"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r389978895"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/389978895"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Adding the `!is_p2sh` here means that any transaction input spending a P2SH-wrapped segwit v1 output will be valid, but will fail standardness with`SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM` (\"Witness version reserved for soft-fork upgrades\") which seems like the wrong error message. We're not expecting P2SH-wrapped segwit v1 outputs to reinterpreted by a future soft-fork, we're simply leaving them unencumbered for safety reasons. I think for correctness we should return a new error type in that case.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-03-09T21:44:03Z",
      "diff_hunk" : "@@ -1428,45 +1798,78 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);\n             }\n             scriptPubKey = CScript(witness.stack.back().begin(), witness.stack.back().end());\n-            stack = std::vector<std::vector<unsigned char> >(witness.stack.begin(), witness.stack.end() - 1);\n             uint256 hashScriptPubKey;\n             CSHA256().Write(&scriptPubKey[0], scriptPubKey.size()).Finalize(hashScriptPubKey.begin());\n             if (memcmp(hashScriptPubKey.begin(), program.data(), 32)) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);\n             }\n+            return ExecuteWitnessProgram({witness.stack.begin(), witness.stack.end() - 1}, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, execdata, serror);\n         } else if (program.size() == WITNESS_V0_KEYHASH_SIZE) {\n             // Special case for pay-to-pubkeyhash; signature + pubkey in witness\n             if (witness.stack.size() != 2) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH); // 2 items in witness\n             }\n             scriptPubKey << OP_DUP << OP_HASH160 << program << OP_EQUALVERIFY << OP_CHECKSIG;\n-            stack = witness.stack;\n+            return ExecuteWitnessProgram(witness.stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, execdata, serror);\n         } else {\n             return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH);\n         }\n-    } else if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM) {\n-        return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM);\n-    } else {\n-        // Higher version witness scripts return true for future softfork compatibility\n-        return set_success(serror);\n+        assert(false); // Unreachable code\n     }\n \n-    // Disallow stack item size > MAX_SCRIPT_ELEMENT_SIZE in witness stack\n-    for (unsigned int i = 0; i < stack.size(); i++) {\n-        if (stack.at(i).size() > MAX_SCRIPT_ELEMENT_SIZE)\n-            return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n+    if (witversion == 1 && program.size() == TAPROOT_PROGRAM_SIZE && !is_p2sh) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r389978895",
      "id" : 389978895,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk3ODg5NQ==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 1820,
      "original_position" : 647,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 371550181,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/389978895",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\n This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/fa733bbd78add587e19f0175ab9c127a8c27e024/CONTRIBUTING.md#rebasing-changes).",
      "created_at" : "2020-03-13T22:58:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-598964995",
      "id" : 598964995,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU5ODk2NDk5NQ==",
      "updated_at" : "2020-03-13T22:58:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/598964995",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I've rebased this on master, and taken the most recent version of https://github.com/bitcoin-core/secp256k1/pull/558 (which I've saved at https://github.com/jnewbery/secp256k1/tree/819c3a6c1 since the PR will have commits squashed and further small changes made). The rebased branch is at https://github.com/jnewbery/bitcoin/tree/pr17977.1. Changes:\r\n\r\n- _O(1) OP_IF/NOTIF/ELSE/ENDIF script implementation_ and _Abstract out script execution out of VerifyWitnessProgram()_ have both been merged into master (#16902 and #18002) so are no longer part of this PR.\r\n- The interface to `secp256k1_xonly_pubkey_tweak_test` has been changed to take the 32 bytes serialized output pubkey.\r\n- 32 bytes pubkeys are now implicit even y, not implicit square y\r\n- tagged hashes have changed\r\n\r\nI haven't implemented the synthetic nonce/auxiliary randomness from https://github.com/bitcoin/bips/pull/893 in the test code. That could be done separately (but there's nothing to be done in bitcoind for this - it'd be more as demonstration code in the test framework).\r\n\r\nThe _[MOVEONLY] Move single-sig checking EvalScript code to EvalChecksig_ and _[REFACTOR] Initialize PrecomputedTransactionData in CheckInputs_ commits could be sliced off into their own PRs. There's not any benefit from those changes outside Taproot, but if people think it'd be useful to reduce the size of this PR, I'm happy to open and maintain those PRs.",
      "created_at" : "2020-03-17T21:18:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-600306118",
      "id" : 600306118,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYwMDMwNjExOA==",
      "updated_at" : "2020-03-17T21:18:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/600306118",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased, and included @jnewbery's changes from above.\r\n\r\nHere is what I did:\r\n* I created a rebase myself (with the old libsecp256k1, and old square pubkey rule).\r\n* Compared the final tree with John's version, allowing me to review the even-pubkey changes; everything looked correct, but I saw a few minor improvements.\r\n* I switched to John's version, apart from this patch:\r\n```diff\r\ndiff --git a/src/pubkey.cpp b/src/pubkey.cpp\r\nindex 246c19a8f8..2231a4ee71 100644\r\n--- a/src/pubkey.cpp\r\n+++ b/src/pubkey.cpp\r\n@@ -178,9 +178,8 @@ bool XOnlyPubKey::VerifySchnorr(const uint256 &hash, const std::vector<unsigned\r\n \r\n bool XOnlyPubKey::CheckPayToContract(const XOnlyPubKey& base, const uint256& hash, bool negated) const\r\n {\r\n-    secp256k1_xonly_pubkey base_point, output_point;\r\n+    secp256k1_xonly_pubkey base_point;\r\n     if (!secp256k1_xonly_pubkey_parse(secp256k1_context_verify, &base_point, base.data())) return false;\r\n-    if (!secp256k1_xonly_pubkey_parse(secp256k1_context_verify, &output_point, m_keydata.begin())) return false;\r\n     return secp256k1_xonly_pubkey_tweak_test(secp256k1_context_verify, m_keydata.begin(), negated, &base_point, hash.begin());\r\n }\r\n \r\ndiff --git a/src/script/interpreter.cpp b/src/script/interpreter.cpp\r\nindex 12ad6e7236..c3dd00de43 100644\r\n--- a/src/script/interpreter.cpp\r\n+++ b/src/script/interpreter.cpp\r\n@@ -1812,7 +1812,6 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\r\n         } else {\r\n             return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH);\r\n         }\r\n-        assert(false); // Unreachable code\r\n     } else if (witversion == 1 && program.size() == TAPROOT_PROGRAM_SIZE && !is_p2sh) {\r\n         if (!(flags & SCRIPT_VERIFY_TAPROOT)) return set_success(serror);\r\n         auto stack = witness.stack;\r\n@@ -1857,7 +1856,6 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\r\n             }\r\n             return set_success(serror);\r\n         }\r\n-        assert(false); // Unreachable code\r\n     } else {\r\n         if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM) {\r\n             return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM);\r\n```\r\n* Also added a commit 61bdc448dffdc41ef03cb775bfb67e0dac1dca09, after noticing that an unnecessary stack copy was being made in `VerifyWitnessProgram`.\r\n* Pushed to the PR branch, and noticed that a new rebase was necessary.\r\n* Did another rebase.\r\n* Noticed the tests were failing, due to a bug introduced in #17319; fixed in 1d293165551dbc6403dba59c2e5a896c5ae5366e (submitted separately as #18374).",
      "created_at" : "2020-03-18T05:43:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-600435965",
      "id" : 600435965,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYwMDQzNTk2NQ==",
      "updated_at" : "2020-03-18T05:47:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/600435965",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r396012415"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/396012415"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This seems to be more of a potential improvement for later.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-03-21T17:39:59Z",
      "diff_hunk" : "@@ -114,32 +120,101 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making the use of (unknown) annexes non-standard (currently no annexes are known)\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 20),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 21),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    //! Single-SHA256 versions\n+    uint256 m_prevouts_hash, m_sequences_hash, m_outputs_hash, m_amounts_spent_hash;\n+    bool m_amounts_spent_ready = false;\n+\n+    //! Double-SHA256 versions\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n     bool ready = false;\n+    std::vector<CTxOut> m_spent_outputs;\n+\n+    PrecomputedTransactionData() = default;\n+\n+    template <class T>\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and P2SH redeemscripts; see BIP 16\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with non-P2SH 32 byte program (Taproot), key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with non-P2SH 32 byte program (Taproot), script path spending, leaf version 0xc0 (Tapscript); see BIP 342\n+};\n+\n+struct ScriptExecutionData",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r396012415",
      "id" : 396012415,
      "in_reply_to_id" : 370948973,
      "line" : 180,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMjQxNQ==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 180,
      "original_position" : 78,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : 93,
      "pull_request_review_id" : 378936564,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/396012415",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r396012754"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/396012754"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@kallewoof So, I suggest that maybe we add a way to test if a pubkey is valid later when wallet support is added. But as the current PR is solely consensus/validation code, I think it's simpler and safer to not expose that distinction for now.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-03-21T17:43:44Z",
      "diff_hunk" : "@@ -203,6 +203,25 @@ class CPubKey\n     bool Derive(CPubKey& pubkeyChild, ChainCode &ccChild, unsigned int nChild, const ChainCode& cc) const;\n };\n \n+class XOnlyPubKey {\n+private:\n+    uint256 m_keydata;\n+\n+public:\n+    XOnlyPubKey(const uint256& in) : m_keydata(in) {}\n+\n+    /** Verify a 64-byte Schnorr signature.\n+     *\n+     * If the signature is not 64 bytes, or the public key is not fully valid, false is returned.\n+     */\n+    bool VerifySchnorr(const uint256& hash, const std::vector<unsigned char>& vchSig) const;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r396012754",
      "id" : 396012754,
      "in_reply_to_id" : 371073789,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxMjc1NA==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 220,
      "original_position" : 15,
      "original_start_line" : null,
      "path" : "src/pubkey.h",
      "position" : null,
      "pull_request_review_id" : 378936837,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/396012754",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r396018821"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/396018821"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-03-21T18:56:16Z",
      "diff_hunk" : "@@ -0,0 +1,594 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import create_coinbase, create_block, add_witness_commitment\n+from test_framework.messages import CTransaction, CTxIn, CTxOut, COutPoint, CTxInWitness\n+from test_framework.script import CScript, TaprootSignatureHash, taproot_construct, OP_0, OP_1, OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD, OP_IF, OP_CODESEPARATOR, OP_ELSE, OP_ENDIF, OP_DROP, LEAF_VERSION_TAPSCRIPT, SIGHASH_SINGLE, is_op_success, CScriptOp, OP_RETURN, OP_VERIF, OP_1NEGATE, OP_EQUAL, OP_SWAP, OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY, OP_NOTIF, OP_2DROP, OP_NOT, OP_2DUP, OP_1SUB, OP_DUP, MAX_SCRIPT_ELEMENT_SIZE, LOCKTIME_THRESHOLD, ANNEX_TAG",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r396018821",
      "id" : 396018821,
      "in_reply_to_id" : 370908509,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxODgyMQ==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 9,
      "original_position" : 9,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 378942331,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/396018821",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r396018978"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/396018978"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nice catch, I finally looked into this, and I agree this is too fragile. I've changed `SignatureHashSchnorr` to take a pointer to a `PrecomputedTramsactionData` instead, and assert fail when it's null.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-03-21T18:57:26Z",
      "diff_hunk" : "@@ -1209,27 +1379,141 @@ uint256 GetOutputsHash(const T& txTo)\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n+}\n+\n+uint256 GetSpentAmountsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n }\n \n } // namespace\n \n template <class T>\n-PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n+    m_spent_outputs = std::move(spent_outputs);\n+\n+    if (ready) return;\n     // Cache is calculated only for transactions with witness\n     if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+        m_prevouts_hash = GetPrevoutHash(txTo);\n+        hashPrevouts = SHA256Uint256(m_prevouts_hash);\n+        m_sequences_hash = GetSequenceHash(txTo);\n+        hashSequence = SHA256Uint256(m_sequences_hash);\n+        m_outputs_hash = GetOutputsHash(txTo);\n+        hashOutputs = SHA256Uint256(m_outputs_hash);\n         ready = true;\n+\n+        if (!m_spent_outputs.empty()) {\n+            m_amounts_spent_hash = GetSpentAmountsHash(m_spent_outputs);\n+            m_amounts_spent_ready = true;\n+        }\n     }\n }\n \n+template <class T>\n+PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+{\n+    Init(txTo, {});\n+}\n+\n // explicit instantiation\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");\n+static const CHashWriter HasherTapLeaf = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HasherTapBranch = TaggedHash(\"TapBranch\");\n+static const CHashWriter HasherTapTweak = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData& cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    case SigVersion::TAPSCRIPT:\n+        ext_flag = 1;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache.ready && cache.m_amounts_spent_ready);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r396018978",
      "id" : 396018978,
      "in_reply_to_id" : 371645313,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxODk3OA==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 1451,
      "original_position" : 398,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 378942489,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/396018978",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r396019071"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/396019071"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It's not called anywhere externally, so I've just dropped it from the header file.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-03-21T18:57:56Z",
      "diff_hunk" : "@@ -114,32 +120,101 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making the use of (unknown) annexes non-standard (currently no annexes are known)\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 20),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 21),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    //! Single-SHA256 versions\n+    uint256 m_prevouts_hash, m_sequences_hash, m_outputs_hash, m_amounts_spent_hash;\n+    bool m_amounts_spent_ready = false;\n+\n+    //! Double-SHA256 versions\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n     bool ready = false;\n+    std::vector<CTxOut> m_spent_outputs;\n+\n+    PrecomputedTransactionData() = default;\n+\n+    template <class T>\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and P2SH redeemscripts; see BIP 16\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with non-P2SH 32 byte program (Taproot), key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with non-P2SH 32 byte program (Taproot), script path spending, leaf version 0xc0 (Tapscript); see BIP 342\n+};\n+\n+struct ScriptExecutionData\n+{\n+    //! Whether m_tapleaf_hash is initialized.\n+    bool m_tapleaf_hash_init = false;\n+    //! The tapleaf hash.\n+    uint256 m_tapleaf_hash;\n+\n+    //! Whether m_codeseparator_pos is initialized.\n+    bool m_codeseparator_pos_init = false;\n+    //! Opcode position of the last executed OP_CODESEPARATOR (or -1 if none executed).\n+    uint32_t m_codeseparator_pos;\n+\n+    //! Whether m_annex_present and m_annex_hash are initialized.\n+    bool m_annex_init = false;\n+    //! Whether an annex is present.\n+    bool m_annex_present;\n+    //! Hash of the annex data.\n+    uint256 m_annex_hash;\n+\n+    /** Whether m_validation_weight_left is initialized. */\n+    bool m_validation_weight_left_init = false;\n+    /** How much validation weight is left (decremented for every successful signature check). */\n+    int64_t m_validation_weight_left;\n };\n \n /** Signature hash sizes */\n static constexpr size_t WITNESS_V0_SCRIPTHASH_SIZE = 32;\n static constexpr size_t WITNESS_V0_KEYHASH_SIZE = 20;\n+static constexpr size_t WITNESS_V1_TAPROOT_SIZE = 32;\n+\n+\n+static constexpr uint8_t TAPROOT_LEAF_MASK = 0xfe;\n+static constexpr uint8_t TAPROOT_LEAF_TAPSCRIPT = 0xc0;\n+static constexpr size_t TAPROOT_PROGRAM_SIZE = 32;\n+static constexpr size_t TAPROOT_CONTROL_BASE_SIZE = 33;\n+static constexpr size_t TAPROOT_CONTROL_NODE_SIZE = 32;\n+static constexpr size_t TAPROOT_CONTROL_MAX_NODE_COUNT = 128;\n+static constexpr size_t TAPROOT_CONTROL_MAX_SIZE = TAPROOT_CONTROL_BASE_SIZE + TAPROOT_CONTROL_NODE_SIZE * TAPROOT_CONTROL_MAX_NODE_COUNT;\n \n template <class T>\n uint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn, int nHashType, const CAmount& amount, SigVersion sigversion, const PrecomputedTransactionData* cache = nullptr);\n \n+template <class T>\n+bool SignatureHashTap(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, unsigned int in_pos, uint8_t hash_type, SigVersion sigversion, const PrecomputedTransactionData& cache);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r396019071",
      "id" : 396019071,
      "in_reply_to_id" : 372771079,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxOTA3MQ==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 216,
      "original_position" : 121,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 378942552,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/396019071",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r396019184"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/396019184"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done. I've rewritten this to effectively treat `ready` as referring to the pre-taproot stuff and `m_amounts_spend_ready` for the rest.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-03-21T18:58:34Z",
      "diff_hunk" : "@@ -1209,27 +1379,141 @@ uint256 GetOutputsHash(const T& txTo)\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n+}\n+\n+uint256 GetSpentAmountsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n }\n \n } // namespace\n \n template <class T>\n-PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n+    m_spent_outputs = std::move(spent_outputs);\n+\n+    if (ready) return;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r396019184",
      "id" : 396019184,
      "in_reply_to_id" : 371653934,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxOTE4NA==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 1401,
      "original_position" : 345,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 378942640,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/396019184",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r396019212"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/396019212"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-03-21T18:58:46Z",
      "diff_hunk" : "@@ -114,32 +120,101 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making the use of (unknown) annexes non-standard (currently no annexes are known)\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 20),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 21),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    //! Single-SHA256 versions\n+    uint256 m_prevouts_hash, m_sequences_hash, m_outputs_hash, m_amounts_spent_hash;\n+    bool m_amounts_spent_ready = false;\n+\n+    //! Double-SHA256 versions\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n     bool ready = false;\n+    std::vector<CTxOut> m_spent_outputs;\n+\n+    PrecomputedTransactionData() = default;\n+\n+    template <class T>\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and P2SH redeemscripts; see BIP 16\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with non-P2SH 32 byte program (Taproot), key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with non-P2SH 32 byte program (Taproot), script path spending, leaf version 0xc0 (Tapscript); see BIP 342\n+};\n+\n+struct ScriptExecutionData\n+{\n+    //! Whether m_tapleaf_hash is initialized.\n+    bool m_tapleaf_hash_init = false;\n+    //! The tapleaf hash.\n+    uint256 m_tapleaf_hash;\n+\n+    //! Whether m_codeseparator_pos is initialized.\n+    bool m_codeseparator_pos_init = false;\n+    //! Opcode position of the last executed OP_CODESEPARATOR (or -1 if none executed).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r396019212",
      "id" : 396019212,
      "in_reply_to_id" : 370948291,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxOTIxMg==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 182,
      "original_position" : 87,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 378942672,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/396019212",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r396019225"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/396019225"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-03-21T18:58:54Z",
      "diff_hunk" : "@@ -1416,10 +1728,68 @@ bool GenericTransactionSignatureChecker<T>::CheckSequence(const CScriptNum& nSeq\n template class GenericTransactionSignatureChecker<CTransaction>;\n template class GenericTransactionSignatureChecker<CMutableTransaction>;\n \n-static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool ExecuteWitnessProgram(std::vector<std::vector<unsigned char>> stack, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, const ScriptExecutionData& execdata, ScriptError* serror)\n+{\n+    // OP_SUCCESSx processing overrides everything, including stack element size limits\n+    if (sigversion == SigVersion::TAPSCRIPT) {\n+        CScript::const_iterator pc = scriptPubKey.begin();\n+        while (pc < scriptPubKey.end()) {\n+            opcodetype opcode;\n+            if (!scriptPubKey.GetOp(pc, opcode)) {\n+                // Note how this condition would not be reached if an unknown OP_SUCCESSx was found\n+                return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n+            }\n+            // New opcodes will be listed here. May use a different sigversion to modify existing opcodes.\n+            if (IsOpSuccess(opcode)) {\n+                if (flags & SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS) {\n+                    return set_error(serror, SCRIPT_ERR_DISCOURAGE_OP_SUCCESS);\n+                }\n+                return set_success(serror);\n+            }\n+        }\n+    }\n+\n+    // Disallow stack item size > MAX_SCRIPT_ELEMENT_SIZE in witness stack\n+    for (unsigned int i = 0; i < stack.size(); i++) {\n+        if (stack.at(i).size() > MAX_SCRIPT_ELEMENT_SIZE) {\n+            return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n+        }\n+    }\n+\n+    // Run the script interpreter.\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, serror, execdata)) return false;\n+\n+    // Scripts inside witness implicitly require cleanstack behaviour\n+    if (stack.size() != 1) return set_error(serror, SCRIPT_ERR_CLEANSTACK);\n+    if (!CastToBool(stack.back())) return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n+    return true;\n+}\n+\n+static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, const std::vector<unsigned char>& program, const CScript& script, uint256* tapleaf_hash)\n+{\n+    int path_len = (control.size() - TAPROOT_CONTROL_BASE_SIZE) / TAPROOT_CONTROL_NODE_SIZE;\n+    XOnlyPubKey p{uint256(std::vector<unsigned char>(control.begin() + 1, control.begin() + TAPROOT_CONTROL_BASE_SIZE))};\n+    XOnlyPubKey q{uint256(program)};\n+    uint256 k = (CHashWriter(HasherTapLeaf) << uint8_t(control[0] & TAPROOT_LEAF_MASK) << script).GetSHA256();\n+    if (tapleaf_hash) *tapleaf_hash = k;\n+    for (int i = 0; i < path_len; ++i) {\n+        CHashWriter ss_branch = HasherTapBranch;\n+        auto node_begin = control.data() + TAPROOT_CONTROL_BASE_SIZE + TAPROOT_CONTROL_NODE_SIZE * i;\n+        if (std::lexicographical_compare(k.begin(), k.end(), node_begin, node_begin + TAPROOT_CONTROL_NODE_SIZE)) {\n+           ss_branch << k << Span<const unsigned char>(node_begin, TAPROOT_CONTROL_NODE_SIZE);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r396019225",
      "id" : 396019225,
      "in_reply_to_id" : 370916701,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxOTIyNQ==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 1777,
      "original_position" : 595,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 378942691,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/396019225",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r396019344"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/396019344"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@pinheadmz Good point, this is wrong; it's supposed to test `prev.scriptPubKey` instead of `prevScript`. I've changed it to keep track of `p2sh`-ness above, and then test that instead.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-03-21T19:00:11Z",
      "diff_hunk" : "@@ -231,6 +231,30 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check P2TR standard limits\n+        if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE && !prevScript.IsPayToScriptHash()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r396019344",
      "id" : 396019344,
      "in_reply_to_id" : 384485907,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxOTM0NA==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 236,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : null,
      "pull_request_review_id" : 378942795,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/396019344",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r396019473"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/396019473"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Maybe we can just change the error message to also encompass things that we don't expect will ever be used? (for example, we don't expect witness programs with size below 32 - and certainly not ones with size below 20 - to be used, but they're still available for future extensions)",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-03-21T19:01:26Z",
      "diff_hunk" : "@@ -1428,45 +1798,78 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);\n             }\n             scriptPubKey = CScript(witness.stack.back().begin(), witness.stack.back().end());\n-            stack = std::vector<std::vector<unsigned char> >(witness.stack.begin(), witness.stack.end() - 1);\n             uint256 hashScriptPubKey;\n             CSHA256().Write(&scriptPubKey[0], scriptPubKey.size()).Finalize(hashScriptPubKey.begin());\n             if (memcmp(hashScriptPubKey.begin(), program.data(), 32)) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);\n             }\n+            return ExecuteWitnessProgram({witness.stack.begin(), witness.stack.end() - 1}, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, execdata, serror);\n         } else if (program.size() == WITNESS_V0_KEYHASH_SIZE) {\n             // Special case for pay-to-pubkeyhash; signature + pubkey in witness\n             if (witness.stack.size() != 2) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH); // 2 items in witness\n             }\n             scriptPubKey << OP_DUP << OP_HASH160 << program << OP_EQUALVERIFY << OP_CHECKSIG;\n-            stack = witness.stack;\n+            return ExecuteWitnessProgram(witness.stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, execdata, serror);\n         } else {\n             return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH);\n         }\n-    } else if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM) {\n-        return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM);\n-    } else {\n-        // Higher version witness scripts return true for future softfork compatibility\n-        return set_success(serror);\n+        assert(false); // Unreachable code\n     }\n \n-    // Disallow stack item size > MAX_SCRIPT_ELEMENT_SIZE in witness stack\n-    for (unsigned int i = 0; i < stack.size(); i++) {\n-        if (stack.at(i).size() > MAX_SCRIPT_ELEMENT_SIZE)\n-            return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n+    if (witversion == 1 && program.size() == TAPROOT_PROGRAM_SIZE && !is_p2sh) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r396019473",
      "id" : 396019473,
      "in_reply_to_id" : 389978895,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxOTQ3Mw==",
      "original_commit_id" : "b8048b814821913b1f4c1c2070ec68b0c9001ec8",
      "original_line" : 1820,
      "original_position" : 647,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 378942885,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/396019473",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r396032513"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/396032513"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: I'm not 100% clear on our`include` guidelines - `string` is included via `hash.h`, so if that's sufficient this line is unnecessary, if that's not sufficient, then we should also include `uint256.h`, etc here.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-03-21T21:55:09Z",
      "diff_hunk" : "@@ -6,6 +6,7 @@\n #include <crypto/common.h>\n #include <crypto/hmac_sha512.h>\n \n+#include <string>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r396032513",
      "id" : 396032513,
      "line" : 9,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAzMjUxMw==",
      "original_commit_id" : "7641c52162d383619ceb4dbf430c02e26864eff6",
      "original_line" : 9,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/hash.cpp",
      "position" : 4,
      "pull_request_review_id" : 378954769,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/396032513",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r396039037"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/396039037"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Guidelines say to include what you use, so including seems correct to me.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-03-21T23:36:00Z",
      "diff_hunk" : "@@ -6,6 +6,7 @@\n #include <crypto/common.h>\n #include <crypto/hmac_sha512.h>\n \n+#include <string>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r396039037",
      "id" : 396039037,
      "in_reply_to_id" : 396032513,
      "line" : 9,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAzOTAzNw==",
      "original_commit_id" : "7641c52162d383619ceb4dbf430c02e26864eff6",
      "original_line" : 9,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/hash.cpp",
      "position" : 4,
      "pull_request_review_id" : 378960074,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/396039037",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r397398915"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/397398915"
         }
      },
      "author_association" : "MEMBER",
      "body" : "should `stack.front()` be preferred over `stack[0]`?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-03-24T19:12:53Z",
      "diff_hunk" : "@@ -1478,51 +1727,136 @@ bool GenericTransactionSignatureChecker<T>::CheckSequence(const CScriptNum& nSeq\n template class GenericTransactionSignatureChecker<CTransaction>;\n template class GenericTransactionSignatureChecker<CMutableTransaction>;\n \n-static bool ExecuteWitnessScript(std::vector<valtype>::const_iterator begin, std::vector<valtype>::const_iterator end, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, const ScriptExecutionData& execdata, ScriptError* serror)\n {\n-    std::vector<valtype> stack{begin, end};\n+    std::vector<valtype> stack{stack_span.begin(), stack_span.end()};\n+\n+    // OP_SUCCESSx processing overrides everything, including stack element size limits\n+    if (sigversion == SigVersion::TAPSCRIPT) {\n+        CScript::const_iterator pc = scriptPubKey.begin();\n+        while (pc < scriptPubKey.end()) {\n+            opcodetype opcode;\n+            if (!scriptPubKey.GetOp(pc, opcode)) {\n+                // Note how this condition would not be reached if an unknown OP_SUCCESSx was found\n+                return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n+            }\n+            // New opcodes will be listed here. May use a different sigversion to modify existing opcodes.\n+            if (IsOpSuccess(opcode)) {\n+                if (flags & SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS) {\n+                    return set_error(serror, SCRIPT_ERR_DISCOURAGE_OP_SUCCESS);\n+                }\n+                return set_success(serror);\n+            }\n+        }\n+    }\n \n     // Disallow stack item size > MAX_SCRIPT_ELEMENT_SIZE in witness stack\n     for (const valtype& elem : stack) {\n         if (elem.size() > MAX_SCRIPT_ELEMENT_SIZE) return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n     }\n \n     // Run the script interpreter.\n-    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, serror)) return false;\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, serror, execdata)) return false;\n \n     // Scripts inside witness implicitly require cleanstack behaviour\n     if (stack.size() != 1) return set_error(serror, SCRIPT_ERR_CLEANSTACK);\n     if (!CastToBool(stack.back())) return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n     return true;\n }\n \n-static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, const std::vector<unsigned char>& program, const CScript& script, uint256* tapleaf_hash)\n+{\n+    int path_len = (control.size() - TAPROOT_CONTROL_BASE_SIZE) / TAPROOT_CONTROL_NODE_SIZE;\n+    XOnlyPubKey p{uint256(std::vector<unsigned char>(control.begin() + 1, control.begin() + TAPROOT_CONTROL_BASE_SIZE))};\n+    XOnlyPubKey q{uint256(program)};\n+    uint256 k = (CHashWriter(HasherTapLeaf) << uint8_t(control[0] & TAPROOT_LEAF_MASK) << script).GetSHA256();\n+    if (tapleaf_hash) *tapleaf_hash = k;\n+    for (int i = 0; i < path_len; ++i) {\n+        CHashWriter ss_branch = HasherTapBranch;\n+        auto node_begin = control.data() + TAPROOT_CONTROL_BASE_SIZE + TAPROOT_CONTROL_NODE_SIZE * i;\n+        if (std::lexicographical_compare(k.begin(), k.end(), node_begin, node_begin + TAPROOT_CONTROL_NODE_SIZE)) {\n+            ss_branch << k << Span<const unsigned char>(node_begin, TAPROOT_CONTROL_NODE_SIZE);\n+        } else {\n+            ss_branch << Span<const unsigned char>(node_begin, TAPROOT_CONTROL_NODE_SIZE) << k;\n+        }\n+        k = ss_branch.GetSHA256();\n+    }\n+    k = (CHashWriter(HasherTapTweak) << MakeSpan(p) << k).GetSHA256();\n+    return q.CheckPayToContract(p, k, control[0] & 1);\n+}\n+\n+static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror, bool is_p2sh)\n {\n     CScript scriptPubKey;\n+    Span<const valtype> stack = MakeSpan(witness.stack);\n+    ScriptExecutionData execdata;\n \n     if (witversion == 0) {\n         if (program.size() == WITNESS_V0_SCRIPTHASH_SIZE) {\n             // Version 0 segregated witness program: SHA256(CScript) inside the program, CScript + inputs in witness\n-            if (witness.stack.size() == 0) {\n+            if (stack.size() == 0) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);\n             }\n-            scriptPubKey = CScript(witness.stack.back().begin(), witness.stack.back().end());\n+            const valtype& script_bytes = SpanPopBack(stack);\n+            scriptPubKey = CScript(script_bytes.begin(), script_bytes.end());\n             uint256 hashScriptPubKey;\n             CSHA256().Write(&scriptPubKey[0], scriptPubKey.size()).Finalize(hashScriptPubKey.begin());\n             if (memcmp(hashScriptPubKey.begin(), program.data(), 32)) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);\n             }\n-            return ExecuteWitnessScript(witness.stack.begin(), witness.stack.end() - 1, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, serror);\n+            return ExecuteWitnessScript(stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, execdata, serror);\n         } else if (program.size() == WITNESS_V0_KEYHASH_SIZE) {\n             // Special case for pay-to-pubkeyhash; signature + pubkey in witness\n-            if (witness.stack.size() != 2) {\n+            if (stack.size() != 2) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH); // 2 items in witness\n             }\n             scriptPubKey << OP_DUP << OP_HASH160 << program << OP_EQUALVERIFY << OP_CHECKSIG;\n-            return ExecuteWitnessScript(witness.stack.begin(), witness.stack.end(), scriptPubKey, flags, SigVersion::WITNESS_V0, checker, serror);\n+            return ExecuteWitnessScript(stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, execdata, serror);\n         } else {\n             return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH);\n         }\n+    } else if (witversion == 1 && program.size() == TAPROOT_PROGRAM_SIZE && !is_p2sh) {\n+        if (!(flags & SCRIPT_VERIFY_TAPROOT)) return set_success(serror);\n+        if (stack.size() == 0) return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);\n+        if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {\n+            // Drop annex\n+            if (flags & SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX) return set_error(serror, SCRIPT_ERR_DISCOURAGE_UNKNOWN_ANNEX);\n+            const valtype& annex = SpanPopBack(stack);\n+            execdata.m_annex_hash = (CHashWriter(SER_GETHASH, 0) << annex).GetSHA256();\n+            execdata.m_annex_present = true;\n+        } else {\n+            execdata.m_annex_present = false;\n+        }\n+        execdata.m_annex_init = true;\n+        if (stack.size() == 1) {\n+            // Key path spending (stack size is 1 after removing optional annex)\n+            if (!checker.CheckSigSchnorr(stack[0], program, SigVersion::TAPROOT, execdata)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r397398915",
      "id" : 397398915,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM5ODkxNQ==",
      "original_commit_id" : "98ad33ac24ab6c64e1ff7087f02b66f763678720",
      "original_line" : 1833,
      "original_position" : 576,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 380620536,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/397398915",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r398871493"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/398871493"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-03-26T20:30:30Z",
      "diff_hunk" : "@@ -1478,51 +1727,136 @@ bool GenericTransactionSignatureChecker<T>::CheckSequence(const CScriptNum& nSeq\n template class GenericTransactionSignatureChecker<CTransaction>;\n template class GenericTransactionSignatureChecker<CMutableTransaction>;\n \n-static bool ExecuteWitnessScript(std::vector<valtype>::const_iterator begin, std::vector<valtype>::const_iterator end, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, const ScriptExecutionData& execdata, ScriptError* serror)\n {\n-    std::vector<valtype> stack{begin, end};\n+    std::vector<valtype> stack{stack_span.begin(), stack_span.end()};\n+\n+    // OP_SUCCESSx processing overrides everything, including stack element size limits\n+    if (sigversion == SigVersion::TAPSCRIPT) {\n+        CScript::const_iterator pc = scriptPubKey.begin();\n+        while (pc < scriptPubKey.end()) {\n+            opcodetype opcode;\n+            if (!scriptPubKey.GetOp(pc, opcode)) {\n+                // Note how this condition would not be reached if an unknown OP_SUCCESSx was found\n+                return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n+            }\n+            // New opcodes will be listed here. May use a different sigversion to modify existing opcodes.\n+            if (IsOpSuccess(opcode)) {\n+                if (flags & SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS) {\n+                    return set_error(serror, SCRIPT_ERR_DISCOURAGE_OP_SUCCESS);\n+                }\n+                return set_success(serror);\n+            }\n+        }\n+    }\n \n     // Disallow stack item size > MAX_SCRIPT_ELEMENT_SIZE in witness stack\n     for (const valtype& elem : stack) {\n         if (elem.size() > MAX_SCRIPT_ELEMENT_SIZE) return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n     }\n \n     // Run the script interpreter.\n-    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, serror)) return false;\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, serror, execdata)) return false;\n \n     // Scripts inside witness implicitly require cleanstack behaviour\n     if (stack.size() != 1) return set_error(serror, SCRIPT_ERR_CLEANSTACK);\n     if (!CastToBool(stack.back())) return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n     return true;\n }\n \n-static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, const std::vector<unsigned char>& program, const CScript& script, uint256* tapleaf_hash)\n+{\n+    int path_len = (control.size() - TAPROOT_CONTROL_BASE_SIZE) / TAPROOT_CONTROL_NODE_SIZE;\n+    XOnlyPubKey p{uint256(std::vector<unsigned char>(control.begin() + 1, control.begin() + TAPROOT_CONTROL_BASE_SIZE))};\n+    XOnlyPubKey q{uint256(program)};\n+    uint256 k = (CHashWriter(HasherTapLeaf) << uint8_t(control[0] & TAPROOT_LEAF_MASK) << script).GetSHA256();\n+    if (tapleaf_hash) *tapleaf_hash = k;\n+    for (int i = 0; i < path_len; ++i) {\n+        CHashWriter ss_branch = HasherTapBranch;\n+        auto node_begin = control.data() + TAPROOT_CONTROL_BASE_SIZE + TAPROOT_CONTROL_NODE_SIZE * i;\n+        if (std::lexicographical_compare(k.begin(), k.end(), node_begin, node_begin + TAPROOT_CONTROL_NODE_SIZE)) {\n+            ss_branch << k << Span<const unsigned char>(node_begin, TAPROOT_CONTROL_NODE_SIZE);\n+        } else {\n+            ss_branch << Span<const unsigned char>(node_begin, TAPROOT_CONTROL_NODE_SIZE) << k;\n+        }\n+        k = ss_branch.GetSHA256();\n+    }\n+    k = (CHashWriter(HasherTapTweak) << MakeSpan(p) << k).GetSHA256();\n+    return q.CheckPayToContract(p, k, control[0] & 1);\n+}\n+\n+static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror, bool is_p2sh)\n {\n     CScript scriptPubKey;\n+    Span<const valtype> stack = MakeSpan(witness.stack);\n+    ScriptExecutionData execdata;\n \n     if (witversion == 0) {\n         if (program.size() == WITNESS_V0_SCRIPTHASH_SIZE) {\n             // Version 0 segregated witness program: SHA256(CScript) inside the program, CScript + inputs in witness\n-            if (witness.stack.size() == 0) {\n+            if (stack.size() == 0) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);\n             }\n-            scriptPubKey = CScript(witness.stack.back().begin(), witness.stack.back().end());\n+            const valtype& script_bytes = SpanPopBack(stack);\n+            scriptPubKey = CScript(script_bytes.begin(), script_bytes.end());\n             uint256 hashScriptPubKey;\n             CSHA256().Write(&scriptPubKey[0], scriptPubKey.size()).Finalize(hashScriptPubKey.begin());\n             if (memcmp(hashScriptPubKey.begin(), program.data(), 32)) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);\n             }\n-            return ExecuteWitnessScript(witness.stack.begin(), witness.stack.end() - 1, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, serror);\n+            return ExecuteWitnessScript(stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, execdata, serror);\n         } else if (program.size() == WITNESS_V0_KEYHASH_SIZE) {\n             // Special case for pay-to-pubkeyhash; signature + pubkey in witness\n-            if (witness.stack.size() != 2) {\n+            if (stack.size() != 2) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH); // 2 items in witness\n             }\n             scriptPubKey << OP_DUP << OP_HASH160 << program << OP_EQUALVERIFY << OP_CHECKSIG;\n-            return ExecuteWitnessScript(witness.stack.begin(), witness.stack.end(), scriptPubKey, flags, SigVersion::WITNESS_V0, checker, serror);\n+            return ExecuteWitnessScript(stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, execdata, serror);\n         } else {\n             return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH);\n         }\n+    } else if (witversion == 1 && program.size() == TAPROOT_PROGRAM_SIZE && !is_p2sh) {\n+        if (!(flags & SCRIPT_VERIFY_TAPROOT)) return set_success(serror);\n+        if (stack.size() == 0) return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);\n+        if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {\n+            // Drop annex\n+            if (flags & SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX) return set_error(serror, SCRIPT_ERR_DISCOURAGE_UNKNOWN_ANNEX);\n+            const valtype& annex = SpanPopBack(stack);\n+            execdata.m_annex_hash = (CHashWriter(SER_GETHASH, 0) << annex).GetSHA256();\n+            execdata.m_annex_present = true;\n+        } else {\n+            execdata.m_annex_present = false;\n+        }\n+        execdata.m_annex_init = true;\n+        if (stack.size() == 1) {\n+            // Key path spending (stack size is 1 after removing optional annex)\n+            if (!checker.CheckSigSchnorr(stack[0], program, SigVersion::TAPROOT, execdata)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r398871493",
      "id" : 398871493,
      "in_reply_to_id" : 397398915,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg3MTQ5Mw==",
      "original_commit_id" : "98ad33ac24ab6c64e1ff7087f02b66f763678720",
      "original_line" : 1833,
      "original_position" : 576,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 382392978,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/398871493",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased on top of #18388, #18422, and #18401, and addressed a number of comments.",
      "created_at" : "2020-03-26T20:31:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-604669232",
      "id" : 604669232,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYwNDY2OTIzMg==",
      "updated_at" : "2020-03-26T20:31:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/604669232",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\n This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).",
      "created_at" : "2020-03-27T07:17:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-604851395",
      "id" : 604851395,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYwNDg1MTM5NQ==",
      "updated_at" : "2020-03-27T07:17:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/604851395",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased now that #18388 (Span stack) is merged.",
      "created_at" : "2020-03-27T20:48:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-605308348",
      "id" : 605308348,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYwNTMwODM0OA==",
      "updated_at" : "2020-03-27T20:48:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/605308348",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r399680669"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/399680669"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: could these two bools be replaced with an `Optional<bool>`? Optional is std from c++17 but currently implemented using boost::optional. Do we prefer to keep that out of consensus code?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-03-28T16:24:13Z",
      "diff_hunk" : "@@ -114,28 +120,94 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making the use of (unknown) annexes non-standard (currently no annexes are known)\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 20),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 21),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    //! Single-SHA256 versions\n+    uint256 m_prevouts_hash, m_sequences_hash, m_outputs_hash, m_amounts_spent_hash;\n+    bool m_amounts_spent_ready = false;\n+\n+    //! Double-SHA256 versions\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n     bool ready = false;\n+    std::vector<CTxOut> m_spent_outputs;\n+\n+    PrecomputedTransactionData() = default;\n+\n+    template <class T>\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and P2SH redeemscripts; see BIP 16\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with non-P2SH 32 byte program (Taproot), key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with non-P2SH 32 byte program (Taproot), script path spending, leaf version 0xc0 (Tapscript); see BIP 342\n+};\n+\n+struct ScriptExecutionData\n+{\n+    //! Whether m_tapleaf_hash is initialized.\n+    bool m_tapleaf_hash_init = false;\n+    //! The tapleaf hash.\n+    uint256 m_tapleaf_hash;\n+\n+    //! Whether m_codeseparator_pos is initialized.\n+    bool m_codeseparator_pos_init = false;\n+    //! Opcode position of the last executed OP_CODESEPARATOR (or 0xFFFFFFFF if none executed).\n+    uint32_t m_codeseparator_pos;\n+\n+    //! Whether m_annex_present and m_annex_hash are initialized.\n+    bool m_annex_init = false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r399680669",
      "id" : 399680669,
      "line" : 193,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTY4MDY2OQ==",
      "original_commit_id" : "b1e76bda23e80a4b9e510d7ea1e065f819694a93",
      "original_line" : 193,
      "original_position" : 91,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : 106,
      "pull_request_review_id" : 383327014,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/399680669",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r399683139"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/399683139"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Is this just a duplicate of `WITNESS_V1_TAPROOT_SIZE`? It's only used once in `VerifyWitnessProgram()`. Can we replace that usage with `WITNESS_V1_TAPROOT_SIZE`?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-03-28T16:46:23Z",
      "diff_hunk" : "@@ -114,28 +120,94 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making the use of (unknown) annexes non-standard (currently no annexes are known)\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 20),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 21),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    //! Single-SHA256 versions\n+    uint256 m_prevouts_hash, m_sequences_hash, m_outputs_hash, m_amounts_spent_hash;\n+    bool m_amounts_spent_ready = false;\n+\n+    //! Double-SHA256 versions\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n     bool ready = false;\n+    std::vector<CTxOut> m_spent_outputs;\n+\n+    PrecomputedTransactionData() = default;\n+\n+    template <class T>\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and P2SH redeemscripts; see BIP 16\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with non-P2SH 32 byte program (Taproot), key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with non-P2SH 32 byte program (Taproot), script path spending, leaf version 0xc0 (Tapscript); see BIP 342\n+};\n+\n+struct ScriptExecutionData\n+{\n+    //! Whether m_tapleaf_hash is initialized.\n+    bool m_tapleaf_hash_init = false;\n+    //! The tapleaf hash.\n+    uint256 m_tapleaf_hash;\n+\n+    //! Whether m_codeseparator_pos is initialized.\n+    bool m_codeseparator_pos_init = false;\n+    //! Opcode position of the last executed OP_CODESEPARATOR (or 0xFFFFFFFF if none executed).\n+    uint32_t m_codeseparator_pos;\n+\n+    //! Whether m_annex_present and m_annex_hash are initialized.\n+    bool m_annex_init = false;\n+    //! Whether an annex is present.\n+    bool m_annex_present;\n+    //! Hash of the annex data.\n+    uint256 m_annex_hash;\n+\n+    /** Whether m_validation_weight_left is initialized. */\n+    bool m_validation_weight_left_init = false;\n+    /** How much validation weight is left (decremented for every successful signature check). */\n+    int64_t m_validation_weight_left;\n };\n \n /** Signature hash sizes */\n static constexpr size_t WITNESS_V0_SCRIPTHASH_SIZE = 32;\n static constexpr size_t WITNESS_V0_KEYHASH_SIZE = 20;\n+static constexpr size_t WITNESS_V1_TAPROOT_SIZE = 32;\n+\n+\n+static constexpr uint8_t TAPROOT_LEAF_MASK = 0xfe;\n+static constexpr uint8_t TAPROOT_LEAF_TAPSCRIPT = 0xc0;\n+static constexpr size_t TAPROOT_PROGRAM_SIZE = 32;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r399683139",
      "id" : 399683139,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTY4MzEzOQ==",
      "original_commit_id" : "b1e76bda23e80a4b9e510d7ea1e065f819694a93",
      "original_line" : 206,
      "original_position" : 111,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 383328887,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/399683139",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r399694732"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/399694732"
         }
      },
      "author_association" : "MEMBER",
      "body" : "We can't use boost in libconsensus (well we could if we add a dependency mess to it, but I suspect we rather not). There was an earlier discussion in this PR about this, including the option of including a simple native Optional type definition. I think this is overkill, and this approach is fine for now - we can switch to std::optional once it's available.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-03-28T18:37:35Z",
      "diff_hunk" : "@@ -114,28 +120,94 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making the use of (unknown) annexes non-standard (currently no annexes are known)\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 20),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 21),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    //! Single-SHA256 versions\n+    uint256 m_prevouts_hash, m_sequences_hash, m_outputs_hash, m_amounts_spent_hash;\n+    bool m_amounts_spent_ready = false;\n+\n+    //! Double-SHA256 versions\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n     bool ready = false;\n+    std::vector<CTxOut> m_spent_outputs;\n+\n+    PrecomputedTransactionData() = default;\n+\n+    template <class T>\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and P2SH redeemscripts; see BIP 16\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with non-P2SH 32 byte program (Taproot), key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with non-P2SH 32 byte program (Taproot), script path spending, leaf version 0xc0 (Tapscript); see BIP 342\n+};\n+\n+struct ScriptExecutionData\n+{\n+    //! Whether m_tapleaf_hash is initialized.\n+    bool m_tapleaf_hash_init = false;\n+    //! The tapleaf hash.\n+    uint256 m_tapleaf_hash;\n+\n+    //! Whether m_codeseparator_pos is initialized.\n+    bool m_codeseparator_pos_init = false;\n+    //! Opcode position of the last executed OP_CODESEPARATOR (or 0xFFFFFFFF if none executed).\n+    uint32_t m_codeseparator_pos;\n+\n+    //! Whether m_annex_present and m_annex_hash are initialized.\n+    bool m_annex_init = false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r399694732",
      "id" : 399694732,
      "in_reply_to_id" : 399680669,
      "line" : 193,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTY5NDczMg==",
      "original_commit_id" : "b1e76bda23e80a4b9e510d7ea1e065f819694a93",
      "original_line" : 193,
      "original_position" : 91,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : 106,
      "pull_request_review_id" : 383338094,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/399694732",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r399694847"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/399694847"
         }
      },
      "author_association" : "MEMBER",
      "body" : "~~The constants happen to be identical, but there is no a-priori reason why they would be (if you wouldn't know the BIP, say). They're separate concepts, so merging the constants would IMO defeat the purpose of having a named constant in the first place.~~",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-03-28T18:38:36Z",
      "diff_hunk" : "@@ -114,28 +120,94 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making the use of (unknown) annexes non-standard (currently no annexes are known)\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 20),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 21),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    //! Single-SHA256 versions\n+    uint256 m_prevouts_hash, m_sequences_hash, m_outputs_hash, m_amounts_spent_hash;\n+    bool m_amounts_spent_ready = false;\n+\n+    //! Double-SHA256 versions\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n     bool ready = false;\n+    std::vector<CTxOut> m_spent_outputs;\n+\n+    PrecomputedTransactionData() = default;\n+\n+    template <class T>\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and P2SH redeemscripts; see BIP 16\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with non-P2SH 32 byte program (Taproot), key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with non-P2SH 32 byte program (Taproot), script path spending, leaf version 0xc0 (Tapscript); see BIP 342\n+};\n+\n+struct ScriptExecutionData\n+{\n+    //! Whether m_tapleaf_hash is initialized.\n+    bool m_tapleaf_hash_init = false;\n+    //! The tapleaf hash.\n+    uint256 m_tapleaf_hash;\n+\n+    //! Whether m_codeseparator_pos is initialized.\n+    bool m_codeseparator_pos_init = false;\n+    //! Opcode position of the last executed OP_CODESEPARATOR (or 0xFFFFFFFF if none executed).\n+    uint32_t m_codeseparator_pos;\n+\n+    //! Whether m_annex_present and m_annex_hash are initialized.\n+    bool m_annex_init = false;\n+    //! Whether an annex is present.\n+    bool m_annex_present;\n+    //! Hash of the annex data.\n+    uint256 m_annex_hash;\n+\n+    /** Whether m_validation_weight_left is initialized. */\n+    bool m_validation_weight_left_init = false;\n+    /** How much validation weight is left (decremented for every successful signature check). */\n+    int64_t m_validation_weight_left;\n };\n \n /** Signature hash sizes */\n static constexpr size_t WITNESS_V0_SCRIPTHASH_SIZE = 32;\n static constexpr size_t WITNESS_V0_KEYHASH_SIZE = 20;\n+static constexpr size_t WITNESS_V1_TAPROOT_SIZE = 32;\n+\n+\n+static constexpr uint8_t TAPROOT_LEAF_MASK = 0xfe;\n+static constexpr uint8_t TAPROOT_LEAF_TAPSCRIPT = 0xc0;\n+static constexpr size_t TAPROOT_PROGRAM_SIZE = 32;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r399694847",
      "id" : 399694847,
      "in_reply_to_id" : 399683139,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTY5NDg0Nw==",
      "original_commit_id" : "b1e76bda23e80a4b9e510d7ea1e065f819694a93",
      "original_line" : 206,
      "original_position" : 111,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 383338186,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/399694847",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r399708460"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/399708460"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm confused by what the difference is.\r\n\r\nIn policy.cpp:\r\n\r\n```\r\n        if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE && !p2sh) {\r\n```\r\n\r\nIn interpreter.cpp:\r\n\r\n```\r\n    } else if (witversion == 1 && program.size() == TAPROOT_PROGRAM_SIZE && !is_p2sh) {\r\n```\r\n\r\nAre those not comparing the same data to the same constant, just with different constant names?\r\n\r\n(those functions use the same constant names for segwit V0 scripthash program sizes:\r\n\r\n```\r\n        if (program.size() == WITNESS_V0_SCRIPTHASH_SIZE) {\r\n```\r\n\r\nand\r\n\r\n```\r\n        if (witnessversion == 0 && witnessprogram.size() == WITNESS_V0_SCRIPTHASH_SIZE) {\r\n```\r\n)",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-03-28T20:54:51Z",
      "diff_hunk" : "@@ -114,28 +120,94 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making the use of (unknown) annexes non-standard (currently no annexes are known)\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 20),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 21),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    //! Single-SHA256 versions\n+    uint256 m_prevouts_hash, m_sequences_hash, m_outputs_hash, m_amounts_spent_hash;\n+    bool m_amounts_spent_ready = false;\n+\n+    //! Double-SHA256 versions\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n     bool ready = false;\n+    std::vector<CTxOut> m_spent_outputs;\n+\n+    PrecomputedTransactionData() = default;\n+\n+    template <class T>\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and P2SH redeemscripts; see BIP 16\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with non-P2SH 32 byte program (Taproot), key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with non-P2SH 32 byte program (Taproot), script path spending, leaf version 0xc0 (Tapscript); see BIP 342\n+};\n+\n+struct ScriptExecutionData\n+{\n+    //! Whether m_tapleaf_hash is initialized.\n+    bool m_tapleaf_hash_init = false;\n+    //! The tapleaf hash.\n+    uint256 m_tapleaf_hash;\n+\n+    //! Whether m_codeseparator_pos is initialized.\n+    bool m_codeseparator_pos_init = false;\n+    //! Opcode position of the last executed OP_CODESEPARATOR (or 0xFFFFFFFF if none executed).\n+    uint32_t m_codeseparator_pos;\n+\n+    //! Whether m_annex_present and m_annex_hash are initialized.\n+    bool m_annex_init = false;\n+    //! Whether an annex is present.\n+    bool m_annex_present;\n+    //! Hash of the annex data.\n+    uint256 m_annex_hash;\n+\n+    /** Whether m_validation_weight_left is initialized. */\n+    bool m_validation_weight_left_init = false;\n+    /** How much validation weight is left (decremented for every successful signature check). */\n+    int64_t m_validation_weight_left;\n };\n \n /** Signature hash sizes */\n static constexpr size_t WITNESS_V0_SCRIPTHASH_SIZE = 32;\n static constexpr size_t WITNESS_V0_KEYHASH_SIZE = 20;\n+static constexpr size_t WITNESS_V1_TAPROOT_SIZE = 32;\n+\n+\n+static constexpr uint8_t TAPROOT_LEAF_MASK = 0xfe;\n+static constexpr uint8_t TAPROOT_LEAF_TAPSCRIPT = 0xc0;\n+static constexpr size_t TAPROOT_PROGRAM_SIZE = 32;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r399708460",
      "id" : 399708460,
      "in_reply_to_id" : 399683139,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTcwODQ2MA==",
      "original_commit_id" : "b1e76bda23e80a4b9e510d7ea1e065f819694a93",
      "original_line" : 206,
      "original_position" : 111,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 383348789,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/399708460",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r399710184"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/399710184"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Oh, of course! Sorry, I misread; thinking that one was the constant for (v0) P2WSH. Will merge them into one.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-03-28T21:12:57Z",
      "diff_hunk" : "@@ -114,28 +120,94 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making the use of (unknown) annexes non-standard (currently no annexes are known)\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 20),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 21),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    //! Single-SHA256 versions\n+    uint256 m_prevouts_hash, m_sequences_hash, m_outputs_hash, m_amounts_spent_hash;\n+    bool m_amounts_spent_ready = false;\n+\n+    //! Double-SHA256 versions\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n     bool ready = false;\n+    std::vector<CTxOut> m_spent_outputs;\n+\n+    PrecomputedTransactionData() = default;\n+\n+    template <class T>\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and P2SH redeemscripts; see BIP 16\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with non-P2SH 32 byte program (Taproot), key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with non-P2SH 32 byte program (Taproot), script path spending, leaf version 0xc0 (Tapscript); see BIP 342\n+};\n+\n+struct ScriptExecutionData\n+{\n+    //! Whether m_tapleaf_hash is initialized.\n+    bool m_tapleaf_hash_init = false;\n+    //! The tapleaf hash.\n+    uint256 m_tapleaf_hash;\n+\n+    //! Whether m_codeseparator_pos is initialized.\n+    bool m_codeseparator_pos_init = false;\n+    //! Opcode position of the last executed OP_CODESEPARATOR (or 0xFFFFFFFF if none executed).\n+    uint32_t m_codeseparator_pos;\n+\n+    //! Whether m_annex_present and m_annex_hash are initialized.\n+    bool m_annex_init = false;\n+    //! Whether an annex is present.\n+    bool m_annex_present;\n+    //! Hash of the annex data.\n+    uint256 m_annex_hash;\n+\n+    /** Whether m_validation_weight_left is initialized. */\n+    bool m_validation_weight_left_init = false;\n+    /** How much validation weight is left (decremented for every successful signature check). */\n+    int64_t m_validation_weight_left;\n };\n \n /** Signature hash sizes */\n static constexpr size_t WITNESS_V0_SCRIPTHASH_SIZE = 32;\n static constexpr size_t WITNESS_V0_KEYHASH_SIZE = 20;\n+static constexpr size_t WITNESS_V1_TAPROOT_SIZE = 32;\n+\n+\n+static constexpr uint8_t TAPROOT_LEAF_MASK = 0xfe;\n+static constexpr uint8_t TAPROOT_LEAF_TAPSCRIPT = 0xc0;\n+static constexpr size_t TAPROOT_PROGRAM_SIZE = 32;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r399710184",
      "id" : 399710184,
      "in_reply_to_id" : 399683139,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTcxMDE4NA==",
      "original_commit_id" : "b1e76bda23e80a4b9e510d7ea1e065f819694a93",
      "original_line" : 206,
      "original_position" : 111,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 383350124,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/399710184",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r399716976"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/399716976"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-03-28T22:26:34Z",
      "diff_hunk" : "@@ -114,28 +120,94 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making the use of (unknown) annexes non-standard (currently no annexes are known)\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 20),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 21),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    //! Single-SHA256 versions\n+    uint256 m_prevouts_hash, m_sequences_hash, m_outputs_hash, m_amounts_spent_hash;\n+    bool m_amounts_spent_ready = false;\n+\n+    //! Double-SHA256 versions\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n     bool ready = false;\n+    std::vector<CTxOut> m_spent_outputs;\n+\n+    PrecomputedTransactionData() = default;\n+\n+    template <class T>\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and P2SH redeemscripts; see BIP 16\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with non-P2SH 32 byte program (Taproot), key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with non-P2SH 32 byte program (Taproot), script path spending, leaf version 0xc0 (Tapscript); see BIP 342\n+};\n+\n+struct ScriptExecutionData\n+{\n+    //! Whether m_tapleaf_hash is initialized.\n+    bool m_tapleaf_hash_init = false;\n+    //! The tapleaf hash.\n+    uint256 m_tapleaf_hash;\n+\n+    //! Whether m_codeseparator_pos is initialized.\n+    bool m_codeseparator_pos_init = false;\n+    //! Opcode position of the last executed OP_CODESEPARATOR (or 0xFFFFFFFF if none executed).\n+    uint32_t m_codeseparator_pos;\n+\n+    //! Whether m_annex_present and m_annex_hash are initialized.\n+    bool m_annex_init = false;\n+    //! Whether an annex is present.\n+    bool m_annex_present;\n+    //! Hash of the annex data.\n+    uint256 m_annex_hash;\n+\n+    /** Whether m_validation_weight_left is initialized. */\n+    bool m_validation_weight_left_init = false;\n+    /** How much validation weight is left (decremented for every successful signature check). */\n+    int64_t m_validation_weight_left;\n };\n \n /** Signature hash sizes */\n static constexpr size_t WITNESS_V0_SCRIPTHASH_SIZE = 32;\n static constexpr size_t WITNESS_V0_KEYHASH_SIZE = 20;\n+static constexpr size_t WITNESS_V1_TAPROOT_SIZE = 32;\n+\n+\n+static constexpr uint8_t TAPROOT_LEAF_MASK = 0xfe;\n+static constexpr uint8_t TAPROOT_LEAF_TAPSCRIPT = 0xc0;\n+static constexpr size_t TAPROOT_PROGRAM_SIZE = 32;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r399716976",
      "id" : 399716976,
      "in_reply_to_id" : 399683139,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTcxNjk3Ng==",
      "original_commit_id" : "b1e76bda23e80a4b9e510d7ea1e065f819694a93",
      "original_line" : 206,
      "original_position" : 111,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 383354971,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/399716976",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Made another change: the policy-checking code now also uses Span stacks.",
      "created_at" : "2020-03-28T22:27:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-605527885",
      "id" : 605527885,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYwNTUyNzg4NQ==",
      "updated_at" : "2020-03-28T22:27:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/605527885",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\n This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).",
      "created_at" : "2020-04-10T18:44:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-612164511",
      "id" : 612164511,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYxMjE2NDUxMQ==",
      "updated_at" : "2020-04-10T18:44:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/612164511",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Don't rebase yet. I hope to get #18401 merged soon.",
      "created_at" : "2020-04-10T20:30:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-612203848",
      "id" : 612203848,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYxMjIwMzg0OA==",
      "updated_at" : "2020-04-10T20:30:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/612203848",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r407052056"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/407052056"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Optional nit (feel free to ignore): Refer to the BIP (341) explaining why single hashes are added. https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-15",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-04-11T11:23:46Z",
      "diff_hunk" : "@@ -114,28 +120,92 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making the use of (unknown) annexes non-standard (currently no annexes are known)\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 20),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 21),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    //! Single-SHA256 versions",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r407052056",
      "id" : 407052056,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA1MjA1Ng==",
      "original_commit_id" : "e83b1772d00c5e8538675735ce3df83c8fa4efdb",
      "original_line" : 147,
      "original_position" : 50,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 391758259,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/407052056",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/16323900?v=4",
         "events_url" : "https://api.github.com/users/michaelfolkson/events{/privacy}",
         "followers_url" : "https://api.github.com/users/michaelfolkson/followers",
         "following_url" : "https://api.github.com/users/michaelfolkson/following{/other_user}",
         "gists_url" : "https://api.github.com/users/michaelfolkson/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/michaelfolkson",
         "id" : 16323900,
         "login" : "michaelfolkson",
         "node_id" : "MDQ6VXNlcjE2MzIzOTAw",
         "organizations_url" : "https://api.github.com/users/michaelfolkson/orgs",
         "received_events_url" : "https://api.github.com/users/michaelfolkson/received_events",
         "repos_url" : "https://api.github.com/users/michaelfolkson/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/michaelfolkson/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/michaelfolkson/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/michaelfolkson"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I've rebased this branch on master here: https://github.com/jnewbery/bitcoin/tree/pr17977.2 (using the same libsecp commit).\r\n\r\nThis did require one additional commit https://github.com/jnewbery/bitcoin/commit/df38ebef99229a29c16cda571ded4a3613ead743 due to the new assert added in `PrecomputedTransactionData::Init()`. I'll PR that separately.",
      "created_at" : "2020-04-16T19:19:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-614846939",
      "id" : 614846939,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYxNDg0NjkzOQ==",
      "updated_at" : "2020-04-16T19:19:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/614846939",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I've rebased on master again now that https://github.com/jnewbery/bitcoin/commit/df38ebef99229a29c16cda571ded4a3613ead743 is merged. Here: https://github.com/jnewbery/bitcoin/tree/pr17977.3",
      "created_at" : "2020-04-19T15:21:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-616160883",
      "id" : 616160883,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYxNjE2MDg4Mw==",
      "updated_at" : "2020-04-19T15:21:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/616160883",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@jnewbery Did the rebase myself, and ended up with an almost identical tree as yours. Yours was slightly cleaner, so I used that one, rebased it on a new secp256k1 subtree merge, and pushed it.",
      "created_at" : "2020-04-19T21:34:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-616228768",
      "id" : 616228768,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYxNjIyODc2OA==",
      "updated_at" : "2020-04-19T21:34:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/616228768",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "BTW if willing https://github.com/bitcoin/bitcoin/pull/18071 plucks out some of the changes from taproot & should be a relatively easy rebase. A couple symbol names are changed for clarity as the crypto return value has changed from the double hash to the single. ",
      "created_at" : "2020-04-21T19:14:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-617359858",
      "id" : 617359858,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYxNzM1OTg1OA==",
      "updated_at" : "2020-04-21T19:14:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/617359858",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\n This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).",
      "created_at" : "2020-04-27T00:35:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-619650782",
      "id" : 619650782,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYxOTY1MDc4Mg==",
      "updated_at" : "2020-04-27T00:35:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/619650782",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased, updated libsecp256k1 branch, and converted the Schnorr framework test to a Python unittest (see #18576).",
      "created_at" : "2020-05-02T21:19:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-623014565",
      "id" : 623014565,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYyMzAxNDU2NQ==",
      "updated_at" : "2020-05-02T21:19:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/623014565",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r419018428"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/419018428"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\ntest/functional/test_framework/address.py:10:1: F401 '.script.hash256' imported but unused",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-05-02T22:58:24Z",
      "diff_hunk" : "@@ -6,6 +6,7 @@\n \n import enum\n \n+from .base58 import byte_to_base58\n from .script import hash256, hash160, sha256, CScript, OP_0",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r419018428",
      "id" : 419018428,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTAxODQyOA==",
      "original_commit_id" : "c547a9683bd42e23242cc073fcef9bf4bfe91653",
      "original_line" : 10,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/address.py",
      "position" : null,
      "pull_request_review_id" : 404566752,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/419018428",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r420596666"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/420596666"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-05-06T07:34:10Z",
      "diff_hunk" : "@@ -6,6 +6,7 @@\n \n import enum\n \n+from .base58 import byte_to_base58\n from .script import hash256, hash160, sha256, CScript, OP_0",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r420596666",
      "id" : 420596666,
      "in_reply_to_id" : 419018428,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU5NjY2Ng==",
      "original_commit_id" : "c547a9683bd42e23242cc073fcef9bf4bfe91653",
      "original_line" : 10,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/address.py",
      "position" : null,
      "pull_request_review_id" : 406365052,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/420596666",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@sipa IIUC, the secp256k1 changes here are currently updating our subtree to upstream @ https://github.com/bitcoin-core/secp256k1/commit/e9fccd4de1f2b382545dfbadeae54868447e2cdf; with https://github.com/bitcoin-core/secp256k1/pull/558 on top. \r\n\r\nGiven there's been another push to https://github.com/bitcoin-core/secp256k1/pull/558, as well as additional merges to secp256k1 master, and, it's now been more than a year since we [last updated our subtree](https://github.com/bitcoin/bitcoin/pull/15703), could you pull the secp256k1 subtree update out of here, and PR it separately? Then we'd have less change here, and what's left would just be Schnorr related (#558). It's also a good time as we are early in the 0.21 cycle.",
      "created_at" : "2020-05-22T08:40:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-632574049",
      "id" : 632574049,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYzMjU3NDA0OQ==",
      "updated_at" : "2020-05-22T08:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/632574049",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased to include the new bitcoin-core/secp256k1#558.\r\n\r\n@fanquake Will do, as soon as a few recent improvements are merged in the secp256k1 repository.",
      "created_at" : "2020-05-22T20:17:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-632894808",
      "id" : 632894808,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYzMjg5NDgwOA==",
      "updated_at" : "2020-05-23T00:15:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/632894808",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Updated now to include the changes in https://github.com/bitcoin/bips/pull/920.",
      "created_at" : "2020-05-23T00:14:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-632952016",
      "id" : 632952016,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYzMjk1MjAxNg==",
      "updated_at" : "2020-05-23T00:14:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/632952016",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\n This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).",
      "created_at" : "2020-05-30T17:17:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-636359543",
      "id" : 636359543,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYzNjM1OTU0Mw==",
      "updated_at" : "2020-05-30T17:17:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/636359543",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased on top of #19228 ",
      "created_at" : "2020-06-10T00:49:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-641655191",
      "id" : 641655191,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY0MTY1NTE5MQ==",
      "updated_at" : "2020-06-10T00:49:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/641655191",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\n This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).",
      "created_at" : "2020-06-10T14:38:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-642053046",
      "id" : 642053046,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY0MjA1MzA0Ng==",
      "updated_at" : "2020-06-10T14:38:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/642053046",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased after merge of #19228 and #18468.",
      "created_at" : "2020-06-18T16:27:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-646144752",
      "id" : 646144752,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY0NjE0NDc1Mg==",
      "updated_at" : "2020-06-18T16:27:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/646144752",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r448490009"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/448490009"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Any reason not to put the cheap policy check before VerifyTaprootCommitment() ? ",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-01T16:45:21Z",
      "diff_hunk" : "@@ -1674,11 +1697,42 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n         } else {\n             return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH);\n         }\n+    } else if (witversion == 1 && program.size() == WITNESS_V1_TAPROOT_SIZE && !is_p2sh) {\n+        // BIP341 Taproot: 32-byte non-P2SH witness v1 program (which encodes a P2C-tweaked pubkey)\n+        if (!(flags & SCRIPT_VERIFY_TAPROOT)) return set_success(serror);\n+        if (stack.size() == 0) return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);\n+        if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {\n+            // Drop annex\n+            if (flags & SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX) return set_error(serror, SCRIPT_ERR_DISCOURAGE_UNKNOWN_ANNEX);\n+            SpanPopBack(stack);\n+        }\n+        if (stack.size() == 1) {\n+            // Key path spending (stack size is 1 after removing optional annex)\n+            if (!checker.CheckSigSchnorr(stack.front(), program, SigVersion::TAPROOT)) {\n+                return set_error(serror, SCRIPT_ERR_TAPROOT_INVALID_SIG);\n+            }\n+            return set_success(serror);\n+        } else {\n+            // Script path spending (stack size is >1 after removing optional annex)\n+            const valtype& control = SpanPopBack(stack);\n+            const valtype& script_bytes = SpanPopBack(stack);\n+            scriptPubKey = CScript(script_bytes.begin(), script_bytes.end());\n+            if (control.size() < TAPROOT_CONTROL_BASE_SIZE || control.size() > TAPROOT_CONTROL_MAX_SIZE || ((control.size() - TAPROOT_CONTROL_BASE_SIZE) % TAPROOT_CONTROL_NODE_SIZE) != 0) {\n+                return set_error(serror, SCRIPT_ERR_TAPROOT_WRONG_CONTROL_SIZE);\n+            }\n+            if (!VerifyTaprootCommitment(control, program, scriptPubKey)) {\n+                return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);\n+            }\n+            if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r448490009",
      "id" : 448490009,
      "line" : 1900,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ5MDAwOQ==",
      "original_commit_id" : "a9f418aeb0d31acadd0d5114158fb1fcb9094f40",
      "original_line" : 1900,
      "original_position" : 86,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 617,
      "pull_request_review_id" : 441036603,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/448490009",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r454607993"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/454607993"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`s/32/hash.size()/` if you don't mind",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-14T19:57:40Z",
      "diff_hunk" : "@@ -87,3 +87,10 @@ CHashWriter TaggedHash(const std::string& tag)\n     writer << taghash << taghash;\n     return writer;\n }\n+\n+uint256 SHA256Uint256(const uint256& hash)\n+{\n+    uint256 result;\n+    CSHA256().Write(hash.begin(), 32).Finalize(result.begin());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r454607993",
      "id" : 454607993,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYwNzk5Mw==",
      "original_commit_id" : "146952354b534b4684c9b94fd9bfe5817b063eb3",
      "original_line" : 94,
      "original_position" : 8,
      "original_start_line" : null,
      "path" : "src/hash.cpp",
      "position" : null,
      "pull_request_review_id" : 448420413,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/454607993",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r454610820"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/454610820"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Is this ever expected to not hit?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-14T20:02:59Z",
      "diff_hunk" : "@@ -1299,9 +1317,17 @@ void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_o\n \n     // Cache is calculated only for transactions with witness\n     if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+        m_prevouts_hash = GetPrevoutHash(txTo);\n+        hashPrevouts = SHA256Uint256(m_prevouts_hash);\n+        m_sequences_hash = GetSequenceHash(txTo);\n+        hashSequence = SHA256Uint256(m_sequences_hash);\n+        m_outputs_hash = GetOutputsHash(txTo);\n+        hashOutputs = SHA256Uint256(m_outputs_hash);\n+        if (!m_spent_outputs.empty()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r454610820",
      "id" : 454610820,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYxMDgyMA==",
      "original_commit_id" : "146952354b534b4684c9b94fd9bfe5817b063eb3",
      "original_line" : 1417,
      "original_position" : 58,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 448420413,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/454610820",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r454610931"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/454610931"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Is this for simply catching assertion condition?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-14T20:03:16Z",
      "diff_hunk" : "@@ -1299,9 +1317,17 @@ void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_o\n \n     // Cache is calculated only for transactions with witness\n     if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+        m_prevouts_hash = GetPrevoutHash(txTo);\n+        hashPrevouts = SHA256Uint256(m_prevouts_hash);\n+        m_sequences_hash = GetSequenceHash(txTo);\n+        hashSequence = SHA256Uint256(m_sequences_hash);\n+        m_outputs_hash = GetOutputsHash(txTo);\n+        hashOutputs = SHA256Uint256(m_outputs_hash);\n+        if (!m_spent_outputs.empty()) {\n+            m_spent_amounts_hash = GetSpentAmountsHash(m_spent_outputs);\n+            m_spent_scripts_hash = GetSpentScriptsHash(m_spent_outputs);\n+            m_spent_outputs_ready = true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r454610931",
      "id" : 454610931,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYxMDkzMQ==",
      "original_commit_id" : "146952354b534b4684c9b94fd9bfe5817b063eb3",
      "original_line" : 1420,
      "original_position" : 61,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 448420413,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/454610931",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r454613765"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/454613765"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`s/32/m_keydata.size()/`",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-14T20:08:37Z",
      "diff_hunk" : "@@ -203,6 +203,23 @@ class CPubKey\n     bool Derive(CPubKey& pubkeyChild, ChainCode &ccChild, unsigned int nChild, const ChainCode& cc) const;\n };\n \n+class XOnlyPubKey {\n+private:\n+    uint256 m_keydata;\n+\n+public:\n+    XOnlyPubKey(const uint256& in) : m_keydata(in) {}\n+\n+    /** Verify a 64-byte Schnorr signature.\n+     *\n+     * If the signature is not 64 bytes, or the public key is not fully valid, false is returned.\n+     */\n+    bool VerifySchnorr(const uint256& hash, const std::vector<unsigned char>& vchSig) const;\n+\n+    const unsigned char& operator[](int pos) const { return *(m_keydata.begin() + pos); }\n+    size_t size() const { return 32; }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r454613765",
      "id" : 454613765,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYxMzc2NQ==",
      "original_commit_id" : "05b00d5eabea621d2cab55362f6c5a21f74311df",
      "original_line" : 220,
      "original_position" : 18,
      "original_start_line" : null,
      "path" : "src/pubkey.h",
      "position" : null,
      "pull_request_review_id" : 448420413,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/454613765",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r454624482"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/454624482"
         }
      },
      "author_association" : "MEMBER",
      "body" : "please annotate `/* is_p2sh */`",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-14T20:28:26Z",
      "diff_hunk" : "@@ -1724,7 +1778,7 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n                 // The scriptSig must be _exactly_ CScript(), otherwise we reintroduce malleability.\n                 return set_error(serror, SCRIPT_ERR_WITNESS_MALLEATED);\n             }\n-            if (!VerifyWitnessProgram(*witness, witnessversion, witnessprogram, flags, checker, serror)) {\n+            if (!VerifyWitnessProgram(*witness, witnessversion, witnessprogram, flags, checker, serror, false)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r454624482",
      "id" : 454624482,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYyNDQ4Mg==",
      "original_commit_id" : "a9f418aeb0d31acadd0d5114158fb1fcb9094f40",
      "original_line" : 1781,
      "original_position" : 105,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 448420413,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/454624482",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r454624548"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/454624548"
         }
      },
      "author_association" : "MEMBER",
      "body" : "please annotate `/* is_p2sh */`",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-14T20:28:32Z",
      "diff_hunk" : "@@ -1769,7 +1823,7 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n                     // reintroduce malleability.\n                     return set_error(serror, SCRIPT_ERR_WITNESS_MALLEATED_P2SH);\n                 }\n-                if (!VerifyWitnessProgram(*witness, witnessversion, witnessprogram, flags, checker, serror)) {\n+                if (!VerifyWitnessProgram(*witness, witnessversion, witnessprogram, flags, checker, serror, true)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r454624548",
      "id" : 454624548,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYyNDU0OA==",
      "original_commit_id" : "a9f418aeb0d31acadd0d5114158fb1fcb9094f40",
      "original_line" : 1826,
      "original_position" : 114,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 448420413,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/454624548",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r454627469"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/454627469"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could mention the key could be busted too.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-14T20:33:49Z",
      "diff_hunk" : "@@ -91,6 +95,10 @@ std::string ScriptErrorString(const ScriptError serror)\n             return \"Witness provided for non-witness script\";\n         case SCRIPT_ERR_WITNESS_PUBKEYTYPE:\n             return \"Using non-compressed keys in segwit\";\n+        case SCRIPT_ERR_TAPROOT_INVALID_SIG:\n+            return \"Invalid signature for Taproot key path spending\";",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r454627469",
      "id" : 454627469,
      "line" : 101,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYyNzQ2OQ==",
      "original_commit_id" : "a9f418aeb0d31acadd0d5114158fb1fcb9094f40",
      "original_line" : 101,
      "original_position" : 16,
      "original_start_line" : null,
      "path" : "src/script/script_error.cpp",
      "position" : 18,
      "pull_request_review_id" : 448420413,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/454627469",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r454634063"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/454634063"
         }
      },
      "author_association" : "MEMBER",
      "body" : "did I miss why the const is dropped here?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-14T20:45:46Z",
      "diff_hunk" : "@@ -1391,9 +1391,9 @@ bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, const uint32_t in_p\n     }\n \n     // Data about the input/prevout being spent\n-    const auto* witstack = &tx_to.vin[in_pos].scriptWitness.stack;\n-    bool have_annex = witstack->size() > 1 && witstack->back().size() > 0 && witstack->back()[0] == 0xff;\n-    const uint8_t spend_type = (ext_flag << 1) + (have_annex ? 1 : 0); // The low bit indicates whether an annex is present.\n+    assert(execdata.m_annex_init);\n+    bool have_annex = execdata.m_annex_present;\n+    uint8_t spend_type = (ext_flag << 1) + (have_annex ? 1 : 0); // The low bit indicates whether an annex is present.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r454634063",
      "id" : 454634063,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYzNDA2Mw==",
      "original_commit_id" : "da73c5e3eb01bb362f6427fa7302079f3d981ac5",
      "original_line" : 1396,
      "original_position" : 27,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 448420413,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/454634063",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r454635726"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/454635726"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Would be nice when time comes.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-14T20:48:52Z",
      "diff_hunk" : "@@ -114,28 +120,94 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making the use of (unknown) annexes non-standard (currently no annexes are known)\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 20),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 21),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    //! Single-SHA256 versions\n+    uint256 m_prevouts_hash, m_sequences_hash, m_outputs_hash, m_amounts_spent_hash;\n+    bool m_amounts_spent_ready = false;\n+\n+    //! Double-SHA256 versions\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n     bool ready = false;\n+    std::vector<CTxOut> m_spent_outputs;\n+\n+    PrecomputedTransactionData() = default;\n+\n+    template <class T>\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and P2SH redeemscripts; see BIP 16\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with non-P2SH 32 byte program (Taproot), key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with non-P2SH 32 byte program (Taproot), script path spending, leaf version 0xc0 (Tapscript); see BIP 342\n+};\n+\n+struct ScriptExecutionData\n+{\n+    //! Whether m_tapleaf_hash is initialized.\n+    bool m_tapleaf_hash_init = false;\n+    //! The tapleaf hash.\n+    uint256 m_tapleaf_hash;\n+\n+    //! Whether m_codeseparator_pos is initialized.\n+    bool m_codeseparator_pos_init = false;\n+    //! Opcode position of the last executed OP_CODESEPARATOR (or 0xFFFFFFFF if none executed).\n+    uint32_t m_codeseparator_pos;\n+\n+    //! Whether m_annex_present and m_annex_hash are initialized.\n+    bool m_annex_init = false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r454635726",
      "id" : 454635726,
      "in_reply_to_id" : 399680669,
      "line" : 193,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYzNTcyNg==",
      "original_commit_id" : "b1e76bda23e80a4b9e510d7ea1e065f819694a93",
      "original_line" : 193,
      "original_position" : 91,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : 106,
      "pull_request_review_id" : 448420413,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/454635726",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r454637523"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/454637523"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> The following validation sequence is consensus critical.\r\n\r\nYou don't say",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-14T20:52:05Z",
      "diff_hunk" : "@@ -371,6 +368,67 @@ static bool EvalChecksig(const valtype& vchSig, const valtype& vchPubKey, CScrip\n     return true;\n }\n \n+static bool EvalChecksigTapscript(const valtype& sig, const valtype& pubkey, ScriptExecutionData& execdata, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& success)\n+{\n+    assert(sigversion == SigVersion::TAPSCRIPT);\n+\n+    /*\n+     *  The following validation sequence is consensus critical. Please note how --",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r454637523",
      "id" : 454637523,
      "line" : 376,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYzNzUyMw==",
      "original_commit_id" : "7cdc010c70aa5e65e6b8e149b7f22e2fc93697fc",
      "original_line" : 376,
      "original_position" : 26,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 36,
      "pull_request_review_id" : 448420413,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/454637523",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r454650575"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/454650575"
         }
      },
      "author_association" : "MEMBER",
      "body" : "N.B.: Let's make sure there's a test that catches the >4 bytes rule for addition",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-14T21:16:49Z",
      "diff_hunk" : "@@ -1029,9 +1098,32 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                 }\n                 break;\n \n+                case OP_CHECKSIGADD:\n+                {\n+                    // OP_CHECKSIGADD is only available in Tapscript\n+                    if (sigversion != SigVersion::TAPSCRIPT) return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n+\n+                    // (sig num pubkey -- num)\n+                    if (stack.size() < 3) return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n+\n+                    const valtype& sig = stacktop(-3);\n+                    const CScriptNum num(stacktop(-2), fRequireMinimal);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r454650575",
      "id" : 454650575,
      "line" : 1111,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1MDU3NQ==",
      "original_commit_id" : "7cdc010c70aa5e65e6b8e149b7f22e2fc93697fc",
      "original_line" : 1111,
      "original_position" : 159,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 185,
      "pull_request_review_id" : 448420413,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/454650575",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r454656075"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/454656075"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The various peppering of `sigversion == SigVersion::BASE || sigversion == SigVersion::WITNESS_V0` and `sigversion != SigVersion::TAPSCRIPT` makes me a little uneasy. Synchronize these checks?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-14T21:28:11Z",
      "diff_hunk" : "@@ -408,9 +473,12 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n             if (vchPushValue.size() > MAX_SCRIPT_ELEMENT_SIZE)\n                 return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n \n-            // Note how OP_RESERVED does not count towards the opcode limit.\n-            if (opcode > OP_16 && ++nOpCount > MAX_OPS_PER_SCRIPT)\n-                return set_error(serror, SCRIPT_ERR_OP_COUNT);\n+            if (sigversion == SigVersion::BASE || sigversion == SigVersion::WITNESS_V0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r454656075",
      "id" : 454656075,
      "line" : 475,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1NjA3NQ==",
      "original_commit_id" : "7cdc010c70aa5e65e6b8e149b7f22e2fc93697fc",
      "original_line" : 475,
      "original_position" : 111,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 135,
      "pull_request_review_id" : 448420413,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/454656075",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r455042663"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/455042663"
         }
      },
      "author_association" : "MEMBER",
      "body" : "this would be easy/nice to split out for unit tests",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-15T13:16:56Z",
      "diff_hunk" : "@@ -1634,6 +1740,25 @@ static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CS\n {\n     std::vector<valtype> stack{stack_span.begin(), stack_span.end()};\n \n+    // OP_SUCCESSx processing overrides everything, including stack element size limits",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r455042663",
      "id" : 455042663,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTA0MjY2Mw==",
      "original_commit_id" : "7cdc010c70aa5e65e6b8e149b7f22e2fc93697fc",
      "original_line" : 1743,
      "original_position" : 218,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 448420413,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/455042663",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r455048734"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/455048734"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think it'd be cleaner to just make the `Span` here, then use it for next 4 lines?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-15T13:25:16Z",
      "diff_hunk" : "@@ -1645,14 +1648,34 @@ static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CS\n     return true;\n }\n \n-static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, const std::vector<unsigned char>& program, const CScript& script)\n+{\n+    int path_len = (control.size() - TAPROOT_CONTROL_BASE_SIZE) / TAPROOT_CONTROL_NODE_SIZE;\n+    XOnlyPubKey p{uint256(std::vector<unsigned char>(control.begin() + 1, control.begin() + TAPROOT_CONTROL_BASE_SIZE))};\n+    XOnlyPubKey q{uint256(program)};\n+    uint256 k = (CHashWriter(HasherTapLeaf) << uint8_t(control[0] & TAPROOT_LEAF_MASK) << script).GetSHA256();\n+    for (int i = 0; i < path_len; ++i) {\n+        CHashWriter ss_branch = HasherTapBranch;\n+        auto node_begin = control.data() + TAPROOT_CONTROL_BASE_SIZE + TAPROOT_CONTROL_NODE_SIZE * i;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r455048734",
      "id" : 455048734,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTA0ODczNA==",
      "original_commit_id" : "a9f418aeb0d31acadd0d5114158fb1fcb9094f40",
      "original_line" : 1659,
      "original_position" : 23,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 448420413,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/455048734",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r455057389"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/455057389"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Currently this only enforces `MAX_STANDARD_TAPSCRIPT_STACK_ITEM_SIZE` on top of consensus checks, yes?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-15T13:37:34Z",
      "diff_hunk" : "@@ -231,6 +233,34 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check Taproot standardness limits",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r455057389",
      "id" : 455057389,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTA1NzM4OQ==",
      "original_commit_id" : "43cbfab02a4349e6510068bbee39d836de954d68",
      "original_line" : 237,
      "original_position" : 30,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : null,
      "pull_request_review_id" : 448420413,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/455057389",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r455059396"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/455059396"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should mention/rename it to show it's \"add\" not \"mult\"",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-15T13:40:22Z",
      "diff_hunk" : "@@ -384,3 +420,125 @@ def sign_ecdsa(self, msg, low_s=True):\n         rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')\n         sb = s.to_bytes((s.bit_length() + 8) // 8, 'big')\n         return b'\\x30' + bytes([4 + len(rb) + len(sb), 2, len(rb)]) + rb + bytes([2, len(sb)]) + sb\n+\n+def compute_xonly_pubkey(key):\n+    \"\"\"Compute an x-only (32 byte) public key from a (32 byte) private key.\n+\n+    This also returns whether the resulting public key was negated.\n+    \"\"\"\n+\n+    assert(len(key) == 32)\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return (None, None)\n+    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, x)]))\n+    return (P[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(P))\n+\n+def tweak_privkey(key, tweak, negated=False):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r455059396",
      "id" : 455059396,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTA1OTM5Ng==",
      "original_commit_id" : "98ea8e9b9ba27e0b2725f02c92c2e3a64e4fdeab",
      "original_line" : 437,
      "original_position" : 201,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 448420413,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/455059396",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r455059451"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/455059451"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should mention/rename it to show it's \"add\" not \"mult\"",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-15T13:40:26Z",
      "diff_hunk" : "@@ -384,3 +420,125 @@ def sign_ecdsa(self, msg, low_s=True):\n         rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')\n         sb = s.to_bytes((s.bit_length() + 8) // 8, 'big')\n         return b'\\x30' + bytes([4 + len(rb) + len(sb), 2, len(rb)]) + rb + bytes([2, len(sb)]) + sb\n+\n+def compute_xonly_pubkey(key):\n+    \"\"\"Compute an x-only (32 byte) public key from a (32 byte) private key.\n+\n+    This also returns whether the resulting public key was negated.\n+    \"\"\"\n+\n+    assert(len(key) == 32)\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return (None, None)\n+    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, x)]))\n+    return (P[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(P))\n+\n+def tweak_privkey(key, tweak, negated=False):\n+    \"\"\"Tweak a private key (after optionally negating it).\"\"\"\n+\n+    assert(len(key) == 32)\n+    assert(len(tweak) == 32)\n+\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return None\n+    if negated:\n+       x = SECP256K1_ORDER - x\n+    t = int.from_bytes(tweak, 'big')\n+    if t >= SECP256K1_ORDER:\n+        return None\n+    x = (x + t) % SECP256K1_ORDER\n+    if x == 0:\n+        return None\n+    return x.to_bytes(32, 'big')\n+\n+def tweak_pubkey(key, tweak):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r455059451",
      "id" : 455059451,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTA1OTQ1MQ==",
      "original_commit_id" : "98ea8e9b9ba27e0b2725f02c92c2e3a64e4fdeab",
      "original_line" : 459,
      "original_position" : 220,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 448420413,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/455059451",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r455901409"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/455901409"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Afaik no, because `CheckInputScripts` returns early for coinbase transactions. An assert here would make more sense",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-16T16:06:56Z",
      "diff_hunk" : "@@ -1299,9 +1317,17 @@ void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_o\n \n     // Cache is calculated only for transactions with witness\n     if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+        m_prevouts_hash = GetPrevoutHash(txTo);\n+        hashPrevouts = SHA256Uint256(m_prevouts_hash);\n+        m_sequences_hash = GetSequenceHash(txTo);\n+        hashSequence = SHA256Uint256(m_sequences_hash);\n+        m_outputs_hash = GetOutputsHash(txTo);\n+        hashOutputs = SHA256Uint256(m_outputs_hash);\n+        if (!m_spent_outputs.empty()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r455901409",
      "id" : 455901409,
      "in_reply_to_id" : 454610820,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwMTQwOQ==",
      "original_commit_id" : "146952354b534b4684c9b94fd9bfe5817b063eb3",
      "original_line" : 1417,
      "original_position" : 58,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 449998173,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/455901409",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456016445"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456016445"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Also perhaps this is checked elsewhere by the logic that sets this SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION flag, but don't we need to check the flag version is not currently defined here?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-16T19:19:31Z",
      "diff_hunk" : "@@ -1674,11 +1697,42 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n         } else {\n             return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH);\n         }\n+    } else if (witversion == 1 && program.size() == WITNESS_V1_TAPROOT_SIZE && !is_p2sh) {\n+        // BIP341 Taproot: 32-byte non-P2SH witness v1 program (which encodes a P2C-tweaked pubkey)\n+        if (!(flags & SCRIPT_VERIFY_TAPROOT)) return set_success(serror);\n+        if (stack.size() == 0) return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);\n+        if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {\n+            // Drop annex\n+            if (flags & SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX) return set_error(serror, SCRIPT_ERR_DISCOURAGE_UNKNOWN_ANNEX);\n+            SpanPopBack(stack);\n+        }\n+        if (stack.size() == 1) {\n+            // Key path spending (stack size is 1 after removing optional annex)\n+            if (!checker.CheckSigSchnorr(stack.front(), program, SigVersion::TAPROOT)) {\n+                return set_error(serror, SCRIPT_ERR_TAPROOT_INVALID_SIG);\n+            }\n+            return set_success(serror);\n+        } else {\n+            // Script path spending (stack size is >1 after removing optional annex)\n+            const valtype& control = SpanPopBack(stack);\n+            const valtype& script_bytes = SpanPopBack(stack);\n+            scriptPubKey = CScript(script_bytes.begin(), script_bytes.end());\n+            if (control.size() < TAPROOT_CONTROL_BASE_SIZE || control.size() > TAPROOT_CONTROL_MAX_SIZE || ((control.size() - TAPROOT_CONTROL_BASE_SIZE) % TAPROOT_CONTROL_NODE_SIZE) != 0) {\n+                return set_error(serror, SCRIPT_ERR_TAPROOT_WRONG_CONTROL_SIZE);\n+            }\n+            if (!VerifyTaprootCommitment(control, program, scriptPubKey)) {\n+                return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);\n+            }\n+            if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456016445",
      "id" : 456016445,
      "in_reply_to_id" : 448490009,
      "line" : 1900,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAxNjQ0NQ==",
      "original_commit_id" : "a9f418aeb0d31acadd0d5114158fb1fcb9094f40",
      "original_line" : 1900,
      "original_position" : 86,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 617,
      "pull_request_review_id" : 450145538,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456016445",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456018116"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456018116"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Ah I think @theuni commented from an earlier commit, so it wasn't showing that a version is defined.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-16T19:22:05Z",
      "diff_hunk" : "@@ -1674,11 +1697,42 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n         } else {\n             return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH);\n         }\n+    } else if (witversion == 1 && program.size() == WITNESS_V1_TAPROOT_SIZE && !is_p2sh) {\n+        // BIP341 Taproot: 32-byte non-P2SH witness v1 program (which encodes a P2C-tweaked pubkey)\n+        if (!(flags & SCRIPT_VERIFY_TAPROOT)) return set_success(serror);\n+        if (stack.size() == 0) return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);\n+        if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {\n+            // Drop annex\n+            if (flags & SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX) return set_error(serror, SCRIPT_ERR_DISCOURAGE_UNKNOWN_ANNEX);\n+            SpanPopBack(stack);\n+        }\n+        if (stack.size() == 1) {\n+            // Key path spending (stack size is 1 after removing optional annex)\n+            if (!checker.CheckSigSchnorr(stack.front(), program, SigVersion::TAPROOT)) {\n+                return set_error(serror, SCRIPT_ERR_TAPROOT_INVALID_SIG);\n+            }\n+            return set_success(serror);\n+        } else {\n+            // Script path spending (stack size is >1 after removing optional annex)\n+            const valtype& control = SpanPopBack(stack);\n+            const valtype& script_bytes = SpanPopBack(stack);\n+            scriptPubKey = CScript(script_bytes.begin(), script_bytes.end());\n+            if (control.size() < TAPROOT_CONTROL_BASE_SIZE || control.size() > TAPROOT_CONTROL_MAX_SIZE || ((control.size() - TAPROOT_CONTROL_BASE_SIZE) % TAPROOT_CONTROL_NODE_SIZE) != 0) {\n+                return set_error(serror, SCRIPT_ERR_TAPROOT_WRONG_CONTROL_SIZE);\n+            }\n+            if (!VerifyTaprootCommitment(control, program, scriptPubKey)) {\n+                return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);\n+            }\n+            if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456018116",
      "id" : 456018116,
      "in_reply_to_id" : 448490009,
      "line" : 1900,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAxODExNg==",
      "original_commit_id" : "a9f418aeb0d31acadd0d5114158fb1fcb9094f40",
      "original_line" : 1900,
      "original_position" : 86,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 617,
      "pull_request_review_id" : 450148286,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456018116",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I reviewed the tests(way more comprehensive than I thought), and made some commits which I believe increase readability quite a bit and test case(s): https://github.com/instagibbs/bitcoin/commits/taproot_tests\r\n\r\nTests cases I'd like covered:\r\n- [x] Invalid CScriptNum( too large) as input to `CHECKSIGADD`\r\n- [ ] Tests prior to activation of taproot (ideally you could run all the tests again, make sure they always pass block validity, even \"damaged\" cases? Future Work since no activation method is specified anyways yet.)\r\n- [x] Too large for script push prior to OP_SUCCESSX causes failure(but not after)\r\n- [x] If OP_SUCCESSX is hit, stack element sizes don't exist\r\n- [x] OP_CHECKSIGADD does the correct thing with valid inputs\r\n- [x] Test that taproot/tapscript sigs don't count towards legacy/segwitv0 block sig limits.\r\n- [x] Adapt tests to explicitly check for reject message reasons for txns/blocks where possible\r\n- [ ]  \"Signature opcodes with unknown public key type and non-empty signature are also counted.\"\r\n- [ ] Test empty signatures executed don't count towards txin sigop limit\r\n... will update list as I go",
      "created_at" : "2020-07-17T14:13:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-660129903",
      "id" : 660129903,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2MDEyOTkwMw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-21T20:17:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/660129903",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456607326"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456607326"
         }
      },
      "author_association" : "MEMBER",
      "body" : "FYI nonstandard txns are rejected by default in regtest now ( I don't mind explicit args in tests so meh)",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-17T18:29:35Z",
      "diff_hunk" : "@@ -0,0 +1,638 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import create_coinbase, create_block, add_witness_commitment\n+from test_framework.messages import CTransaction, CTxIn, CTxOut, COutPoint, CTxInWitness\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_1SUB,\n+    OP_1NEGATE,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIF,\n+    SIGHASH_SINGLE,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, hex_str_to_bytes\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_privkey\n+from test_framework.address import program_to_witness, script_to_p2sh, hash160\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+import struct\n+\n+EMPTYWITNESS_ERROR = \"non-mandatory-script-verify-flag (Witness program was passed an empty witness) (code 64)\"\n+INVALIDKEYPATHSIG_ERROR = \"non-mandatory-script-verify-flag (Invalid signature for Taproot key path spending) (code 64)\"\n+UNKNOWNWITNESS_ERROR = \"non-mandatory-script-verify-flag (Witness version reserved for soft-fork upgrades) (code 64)\"\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+def tx_from_hex(hexstring):\n+    tx = CTransaction()\n+    f = BytesIO(hex_str_to_bytes(hexstring))\n+    tx.deserialize(f)\n+    return tx\n+\n+def get_taproot_bech32(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return program_to_witness(1, info[2:])\n+\n+def get_version1_p2sh(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return script_to_p2sh(info)\n+\n+def get_p2sh_spk(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return CScript([OP_HASH160, hash160(info), OP_EQUAL])\n+\n+def random_op_success():\n+    ret = 0\n+    while (not is_op_success(ret)):\n+        ret = random.randint(0x50, 0xfe)\n+    return CScriptOp(ret)\n+\n+def random_unknown_leaf_ver(no_annex_tag=True):\n+    ret = LEAF_VERSION_TAPSCRIPT\n+    while (ret == LEAF_VERSION_TAPSCRIPT or (no_annex_tag and ret == (ANNEX_TAG & 0xfe))):\n+        ret = random.randrange(128) * 2\n+    return ret\n+\n+def random_bytes(n):\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def random_script(size, no_success=True):\n+    ret = bytes()\n+    while (len(ret) < size):\n+        remain = size - len(ret)\n+        opcode = random.randrange(256)\n+        while (no_success and is_op_success(opcode)):\n+            opcode = random.randrange(256)\n+        if opcode == 0 or opcode >= OP_1NEGATE:\n+            ret += bytes([opcode])\n+        elif opcode <= 75 and opcode <= remain - 1:\n+            ret += bytes([opcode]) + random_bytes(opcode)\n+        elif opcode == 76 and remain >= 2:\n+            pushsize = random.randint(0, min(0xff, remain - 2))\n+            ret += bytes([opcode]) + bytes([pushsize]) + random_bytes(pushsize)\n+        elif opcode == 77 and remain >= 3:\n+            pushsize = random.randint(0, min(0xffff, remain - 3))\n+            ret += bytes([opcode]) + struct.pack(b'<H', pushsize) + random_bytes(pushsize)\n+        elif opcode == 78 and remain >= 5:\n+            pushsize = random.randint(0, min(0xffffffff, remain - 5))\n+            ret += bytes([opcode]) + struct.pack(b'<I', pushsize) + random_bytes(pushsize)\n+    assert len(ret) == size\n+    return ret\n+\n+def random_invalid_push(size):\n+    assert size > 0\n+    ret = bytes()\n+    opcode = 78\n+    if size <= 75:\n+        opcode = random.randint(75, 78)\n+    elif size <= 255:\n+        opcode = random.randint(76, 78)\n+    elif size <= 0xffff:\n+        opcode = random.randint(77, 78)\n+    if opcode == 75:\n+        ret = bytes([size]) + random_bytes(size - 1)\n+    elif opcode == 76:\n+        ret = bytes([opcode]) + bytes([size]) + random_bytes(size - 2)\n+    elif opcode == 77:\n+        ret = bytes([opcode]) + struct.pack(b'<H', size) + random_bytes(max(0, size - 3))\n+    else:\n+        ret = bytes([opcode]) + struct.pack(b'<I', size) + random_bytes(max(0, size - 5))\n+    assert len(ret) >= size\n+    return ret[:size]\n+\n+def random_checksig_style(pubkey):\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def damage_bytes(b):\n+    return (int.from_bytes(b, 'big') ^ (1 << random.randrange(len(b) * 8))).to_bytes(len(b), 'big')\n+\n+# Each spender is a tuple of:\n+# - A scriptPubKey (CScript)\n+# - An address for that scriptPubKey (string)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A witness stack-producing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+\n+Spender = namedtuple(\"Spender\", \"script,address,comment,is_standard,sat_function\")\n+\n+def spend_single_sig(tx, input_index, spent_utxos, info, key, annex=None, hashtype=0, prefix=None, suffix=None, script=None, pos=-1, damage=False):\n+    if prefix is None:\n+        prefix = []\n+    if suffix is None:\n+        suffix = []\n+\n+    ht = hashtype\n+\n+    damage_type = random.randrange(5) if damage else -1\n+    '''\n+    * 0. bit flip the sighash\n+    * 1. bit flip the signature\n+    * If the expected hashtype is 0:\n+    -- 2. append a 0 to the signature\n+    -- 3. append a random value of 1-255 to the signature\n+    * If the expected hashtype is not 0:\n+    -- 2. do not append hashtype to the signature\n+    -- 3. append a random incorrect value of 0-255 to the signature\n+    * 4. extra witness element\n+    '''\n+\n+    # Taproot key path spend: tweak key\n+    if script is None:\n+        _, negated = compute_xonly_pubkey(key)\n+        key = tweak_privkey(key, info[1], negated)\n+        assert(key is not None)\n+\n+    # Change SIGHASH_SINGLE into SIGHASH_ALL if no corresponding output\n+    if (ht & 3 == SIGHASH_SINGLE and input_index >= len(tx.vout)):\n+        ht ^= 2\n+    # Compute sighash\n+    if script:\n+        sighash = TaprootSignatureHash(tx, spent_utxos, ht, input_index, scriptpath=True, script=script, codeseparator_pos=pos, annex=annex)\n+    else:\n+        sighash = TaprootSignatureHash(tx, spent_utxos, ht, input_index, scriptpath=False, annex=annex)\n+    if damage_type == 0:\n+        sighash = damage_bytes(sighash)\n+    # Compute signature\n+    sig = sign_schnorr(key, sighash)\n+    if damage_type == 1:\n+        sig = damage_bytes(sig)\n+    if damage_type == 2:\n+        if ht == 0:\n+            sig += bytes([0])\n+    elif damage_type == 3:\n+        random_ht = ht\n+        while random_ht == ht:\n+            random_ht = random.randrange(256)\n+        sig += bytes([random_ht])\n+    elif ht > 0:\n+        sig += bytes([ht])\n+    # Construct witness\n+    ret = prefix + [sig] + suffix\n+    if script is not None:\n+        ret += [script, info[2][script]]\n+    if annex is not None:\n+        ret += [annex]\n+    if damage_type == 4:\n+        ret = [random_bytes(random.randrange(5))] + ret\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = ret\n+\n+def spend_alwaysvalid(tx, input_index, info, script, annex=None, damage=False):\n+    if isinstance(script, tuple):\n+        version, script = script\n+    ret = [script, info[2][script]]\n+    if damage:\n+        # With 50% chance, we bit flip the script (unless the script is an empty vector)\n+        # With 50% chance, we bit flip the control block\n+        if random.choice([True, False]) or len(ret[0]) == 0:\n+            # Annex is always required for leaf version 0x50\n+            # Unless the original version is 0x50, we couldn't convert it to 0x50 without using annex\n+            tmp = damage_bytes(ret[1])\n+            while annex is None and tmp[0] == ANNEX_TAG and ret[1][0] != ANNEX_TAG:\n+                tmp = damage_bytes(ret[1])\n+            ret[1] = tmp\n+        else:\n+            ret[0] = damage_bytes(ret[0])\n+    if annex is not None:\n+        ret += [annex]\n+    # Randomly add input witness\n+    if random.choice([True, False]):\n+        for i in range(random.randint(1, 10)):\n+            ret = [random_bytes(random.randint(0, MAX_SCRIPT_ELEMENT_SIZE * 2))] + ret\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = ret\n+\n+def spender_sighash_mutation(spenders, info, comment, standard=True, **kwargs):\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_single_sig(t, i, u, damage=not v, info=info, **kwargs)\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn))\n+\n+def spender_two_paths(spenders, info, comment, standard, success, failure):\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_single_sig(t, i, u, damage=False, info=info, **(success if v else failure))\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn))\n+\n+def spender_alwaysvalid(spenders, info, comment, **kwargs):\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_alwaysvalid(t, i, damage=not v, info=info, **kwargs)\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=False, sat_function=fn))\n+\n+def spender_alwaysvalid_p2sh(spenders, info, comment, standard, script):\n+    spk = get_p2sh_spk(info)\n+    addr = get_version1_p2sh(info)\n+\n+    def fn(t, i, u, v):\n+        if v:\n+            t.vin[i].scriptSig = CScript([info[0]])\n+            # Empty control block is only invalid if we apply taproot rules,\n+            # which we shouldn't if the spend is wrapped in P2SH\n+            t.wit.vtxinwit[i].scriptWitness.stack = [script, bytes()]\n+        else:\n+            t.vin[i].scriptSig = CScript()\n+        return\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn))\n+\n+def nested_script(script, depth):\n+    if depth == 0:\n+        return script\n+    return [nested_script(script, depth - 1), CScript([OP_RETURN])]\n+\n+UTXOData = namedtuple('UTXOData', 'input,output,spender')\n+\n+class TaprootTest(BitcoinTestFramework):\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.extra_args = [[\"-whitelist=127.0.0.1\", \"-acceptnonstdtxn=0\", \"-par=1\"]]",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456607326",
      "id" : 456607326,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYwNzMyNg==",
      "original_commit_id" : "23985b72beb1bc3bfc68086ad874ebe3e53b9364",
      "original_line" : 311,
      "original_position" : 311,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 450872865,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456607326",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456950774"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456950774"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@theuni I think it's preferable to do checks for consensus-invalidity first, so that the error code you get is more consistent. As it isn't inherently more expensive for an attacker to create a policy-invalid spend instead of one that just has an invalid signature say, I don't think it matters for DoS resistance either.\r\n\r\n@JeremyRubin I have no idea what you're trying to say.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-19T20:16:44Z",
      "diff_hunk" : "@@ -1674,11 +1697,42 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n         } else {\n             return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH);\n         }\n+    } else if (witversion == 1 && program.size() == WITNESS_V1_TAPROOT_SIZE && !is_p2sh) {\n+        // BIP341 Taproot: 32-byte non-P2SH witness v1 program (which encodes a P2C-tweaked pubkey)\n+        if (!(flags & SCRIPT_VERIFY_TAPROOT)) return set_success(serror);\n+        if (stack.size() == 0) return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);\n+        if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {\n+            // Drop annex\n+            if (flags & SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX) return set_error(serror, SCRIPT_ERR_DISCOURAGE_UNKNOWN_ANNEX);\n+            SpanPopBack(stack);\n+        }\n+        if (stack.size() == 1) {\n+            // Key path spending (stack size is 1 after removing optional annex)\n+            if (!checker.CheckSigSchnorr(stack.front(), program, SigVersion::TAPROOT)) {\n+                return set_error(serror, SCRIPT_ERR_TAPROOT_INVALID_SIG);\n+            }\n+            return set_success(serror);\n+        } else {\n+            // Script path spending (stack size is >1 after removing optional annex)\n+            const valtype& control = SpanPopBack(stack);\n+            const valtype& script_bytes = SpanPopBack(stack);\n+            scriptPubKey = CScript(script_bytes.begin(), script_bytes.end());\n+            if (control.size() < TAPROOT_CONTROL_BASE_SIZE || control.size() > TAPROOT_CONTROL_MAX_SIZE || ((control.size() - TAPROOT_CONTROL_BASE_SIZE) % TAPROOT_CONTROL_NODE_SIZE) != 0) {\n+                return set_error(serror, SCRIPT_ERR_TAPROOT_WRONG_CONTROL_SIZE);\n+            }\n+            if (!VerifyTaprootCommitment(control, program, scriptPubKey)) {\n+                return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);\n+            }\n+            if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456950774",
      "id" : 456950774,
      "in_reply_to_id" : 448490009,
      "line" : 1900,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1MDc3NA==",
      "original_commit_id" : "a9f418aeb0d31acadd0d5114158fb1fcb9094f40",
      "original_line" : 1900,
      "original_position" : 86,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 617,
      "pull_request_review_id" : 451160054,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456950774",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456951409"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456951409"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I believe this is fine right now, but if this code ends up being reused in signing logic, it will actually be empty in cases where not all spent outputs are known (e.g. legacy signing through some RPCs).",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-19T20:23:13Z",
      "diff_hunk" : "@@ -1299,9 +1317,17 @@ void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_o\n \n     // Cache is calculated only for transactions with witness\n     if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+        m_prevouts_hash = GetPrevoutHash(txTo);\n+        hashPrevouts = SHA256Uint256(m_prevouts_hash);\n+        m_sequences_hash = GetSequenceHash(txTo);\n+        hashSequence = SHA256Uint256(m_sequences_hash);\n+        m_outputs_hash = GetOutputsHash(txTo);\n+        hashOutputs = SHA256Uint256(m_outputs_hash);\n+        if (!m_spent_outputs.empty()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456951409",
      "id" : 456951409,
      "in_reply_to_id" : 454610820,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1MTQwOQ==",
      "original_commit_id" : "146952354b534b4684c9b94fd9bfe5817b063eb3",
      "original_line" : 1417,
      "original_position" : 58,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 451160435,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456951409",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456951479"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456951479"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yes. It's an alternative to using optional here (which would otherwise pull in boost stuff into libconsensus, unless we wait for c++17).",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-19T20:24:01Z",
      "diff_hunk" : "@@ -1299,9 +1317,17 @@ void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_o\n \n     // Cache is calculated only for transactions with witness\n     if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+        m_prevouts_hash = GetPrevoutHash(txTo);\n+        hashPrevouts = SHA256Uint256(m_prevouts_hash);\n+        m_sequences_hash = GetSequenceHash(txTo);\n+        hashSequence = SHA256Uint256(m_sequences_hash);\n+        m_outputs_hash = GetOutputsHash(txTo);\n+        hashOutputs = SHA256Uint256(m_outputs_hash);\n+        if (!m_spent_outputs.empty()) {\n+            m_spent_amounts_hash = GetSpentAmountsHash(m_spent_outputs);\n+            m_spent_scripts_hash = GetSpentScriptsHash(m_spent_outputs);\n+            m_spent_outputs_ready = true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456951479",
      "id" : 456951479,
      "in_reply_to_id" : 454610931,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1MTQ3OQ==",
      "original_commit_id" : "146952354b534b4684c9b94fd9bfe5817b063eb3",
      "original_line" : 1420,
      "original_position" : 61,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 451160479,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456951479",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456952147"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456952147"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Do you have a suggested string?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-19T20:30:34Z",
      "diff_hunk" : "@@ -91,6 +95,10 @@ std::string ScriptErrorString(const ScriptError serror)\n             return \"Witness provided for non-witness script\";\n         case SCRIPT_ERR_WITNESS_PUBKEYTYPE:\n             return \"Using non-compressed keys in segwit\";\n+        case SCRIPT_ERR_TAPROOT_INVALID_SIG:\n+            return \"Invalid signature for Taproot key path spending\";",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456952147",
      "id" : 456952147,
      "in_reply_to_id" : 454627469,
      "line" : 101,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1MjE0Nw==",
      "original_commit_id" : "a9f418aeb0d31acadd0d5114158fb1fcb9094f40",
      "original_line" : 101,
      "original_position" : 16,
      "original_start_line" : null,
      "path" : "src/script/script_error.cpp",
      "position" : 18,
      "pull_request_review_id" : 451160906,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456952147",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456953262"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456953262"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "![image](https://user-images.githubusercontent.com/886523/87884608-482e7a80-c9c4-11ea-9e15-4fc36b01c974.png)\r\n@theuni comment shows up on this line, which is later amended to \r\n\r\n![image](https://user-images.githubusercontent.com/886523/87884712-2d103a80-c9c5-11ea-9da4-0fdc12fdd3cb.png)\r\n\r\n\r\nSo I was simply confused from the tagged snippet as to why it did not check the taproot leaf version.\r\n\r\nBut the reason is because @theuni dropped his comment on an earlier commit, and github didn't tag it as outdated.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-19T20:41:54Z",
      "diff_hunk" : "@@ -1674,11 +1697,42 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n         } else {\n             return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH);\n         }\n+    } else if (witversion == 1 && program.size() == WITNESS_V1_TAPROOT_SIZE && !is_p2sh) {\n+        // BIP341 Taproot: 32-byte non-P2SH witness v1 program (which encodes a P2C-tweaked pubkey)\n+        if (!(flags & SCRIPT_VERIFY_TAPROOT)) return set_success(serror);\n+        if (stack.size() == 0) return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);\n+        if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {\n+            // Drop annex\n+            if (flags & SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX) return set_error(serror, SCRIPT_ERR_DISCOURAGE_UNKNOWN_ANNEX);\n+            SpanPopBack(stack);\n+        }\n+        if (stack.size() == 1) {\n+            // Key path spending (stack size is 1 after removing optional annex)\n+            if (!checker.CheckSigSchnorr(stack.front(), program, SigVersion::TAPROOT)) {\n+                return set_error(serror, SCRIPT_ERR_TAPROOT_INVALID_SIG);\n+            }\n+            return set_success(serror);\n+        } else {\n+            // Script path spending (stack size is >1 after removing optional annex)\n+            const valtype& control = SpanPopBack(stack);\n+            const valtype& script_bytes = SpanPopBack(stack);\n+            scriptPubKey = CScript(script_bytes.begin(), script_bytes.end());\n+            if (control.size() < TAPROOT_CONTROL_BASE_SIZE || control.size() > TAPROOT_CONTROL_MAX_SIZE || ((control.size() - TAPROOT_CONTROL_BASE_SIZE) % TAPROOT_CONTROL_NODE_SIZE) != 0) {\n+                return set_error(serror, SCRIPT_ERR_TAPROOT_WRONG_CONTROL_SIZE);\n+            }\n+            if (!VerifyTaprootCommitment(control, program, scriptPubKey)) {\n+                return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);\n+            }\n+            if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456953262",
      "id" : 456953262,
      "in_reply_to_id" : 448490009,
      "line" : 1900,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1MzI2Mg==",
      "original_commit_id" : "a9f418aeb0d31acadd0d5114158fb1fcb9094f40",
      "original_line" : 1900,
      "original_position" : 86,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 617,
      "pull_request_review_id" : 451161622,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456953262",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456953921"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456953921"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This is a bit annoying, as this loop has multiple distinct return branches, and it returning success can mean either continue execution or not.\r\n\r\nHappy to take some code if you have a suggestion, though.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-19T20:48:51Z",
      "diff_hunk" : "@@ -1634,6 +1740,25 @@ static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CS\n {\n     std::vector<valtype> stack{stack_span.begin(), stack_span.end()};\n \n+    // OP_SUCCESSx processing overrides everything, including stack element size limits",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456953921",
      "id" : 456953921,
      "in_reply_to_id" : 455042663,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1MzkyMQ==",
      "original_commit_id" : "7cdc010c70aa5e65e6b8e149b7f22e2fc93697fc",
      "original_line" : 1743,
      "original_position" : 218,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 451162059,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456953921",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456954404"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456954404"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ah, I see. That also explains why it may look like these two could easily be swapped @theuni - it's only in a later commit that something is added in between them (and the order matters).",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-19T20:53:34Z",
      "diff_hunk" : "@@ -1674,11 +1697,42 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n         } else {\n             return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH);\n         }\n+    } else if (witversion == 1 && program.size() == WITNESS_V1_TAPROOT_SIZE && !is_p2sh) {\n+        // BIP341 Taproot: 32-byte non-P2SH witness v1 program (which encodes a P2C-tweaked pubkey)\n+        if (!(flags & SCRIPT_VERIFY_TAPROOT)) return set_success(serror);\n+        if (stack.size() == 0) return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);\n+        if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {\n+            // Drop annex\n+            if (flags & SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX) return set_error(serror, SCRIPT_ERR_DISCOURAGE_UNKNOWN_ANNEX);\n+            SpanPopBack(stack);\n+        }\n+        if (stack.size() == 1) {\n+            // Key path spending (stack size is 1 after removing optional annex)\n+            if (!checker.CheckSigSchnorr(stack.front(), program, SigVersion::TAPROOT)) {\n+                return set_error(serror, SCRIPT_ERR_TAPROOT_INVALID_SIG);\n+            }\n+            return set_success(serror);\n+        } else {\n+            // Script path spending (stack size is >1 after removing optional annex)\n+            const valtype& control = SpanPopBack(stack);\n+            const valtype& script_bytes = SpanPopBack(stack);\n+            scriptPubKey = CScript(script_bytes.begin(), script_bytes.end());\n+            if (control.size() < TAPROOT_CONTROL_BASE_SIZE || control.size() > TAPROOT_CONTROL_MAX_SIZE || ((control.size() - TAPROOT_CONTROL_BASE_SIZE) % TAPROOT_CONTROL_NODE_SIZE) != 0) {\n+                return set_error(serror, SCRIPT_ERR_TAPROOT_WRONG_CONTROL_SIZE);\n+            }\n+            if (!VerifyTaprootCommitment(control, program, scriptPubKey)) {\n+                return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);\n+            }\n+            if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456954404",
      "id" : 456954404,
      "in_reply_to_id" : 448490009,
      "line" : 1900,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1NDQwNA==",
      "original_commit_id" : "a9f418aeb0d31acadd0d5114158fb1fcb9094f40",
      "original_line" : 1900,
      "original_position" : 86,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 617,
      "pull_request_review_id" : 451162409,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456954404",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456955941"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456955941"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think in theory @theuni's point stands, we could add a cheap check ahead of verifytaprootcommitment that checks and aborts if it's an unknown leaf version, but yes the final state makes more sense as is.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-19T21:09:35Z",
      "diff_hunk" : "@@ -1674,11 +1697,42 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n         } else {\n             return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH);\n         }\n+    } else if (witversion == 1 && program.size() == WITNESS_V1_TAPROOT_SIZE && !is_p2sh) {\n+        // BIP341 Taproot: 32-byte non-P2SH witness v1 program (which encodes a P2C-tweaked pubkey)\n+        if (!(flags & SCRIPT_VERIFY_TAPROOT)) return set_success(serror);\n+        if (stack.size() == 0) return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);\n+        if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {\n+            // Drop annex\n+            if (flags & SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX) return set_error(serror, SCRIPT_ERR_DISCOURAGE_UNKNOWN_ANNEX);\n+            SpanPopBack(stack);\n+        }\n+        if (stack.size() == 1) {\n+            // Key path spending (stack size is 1 after removing optional annex)\n+            if (!checker.CheckSigSchnorr(stack.front(), program, SigVersion::TAPROOT)) {\n+                return set_error(serror, SCRIPT_ERR_TAPROOT_INVALID_SIG);\n+            }\n+            return set_success(serror);\n+        } else {\n+            // Script path spending (stack size is >1 after removing optional annex)\n+            const valtype& control = SpanPopBack(stack);\n+            const valtype& script_bytes = SpanPopBack(stack);\n+            scriptPubKey = CScript(script_bytes.begin(), script_bytes.end());\n+            if (control.size() < TAPROOT_CONTROL_BASE_SIZE || control.size() > TAPROOT_CONTROL_MAX_SIZE || ((control.size() - TAPROOT_CONTROL_BASE_SIZE) % TAPROOT_CONTROL_NODE_SIZE) != 0) {\n+                return set_error(serror, SCRIPT_ERR_TAPROOT_WRONG_CONTROL_SIZE);\n+            }\n+            if (!VerifyTaprootCommitment(control, program, scriptPubKey)) {\n+                return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);\n+            }\n+            if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456955941",
      "id" : 456955941,
      "in_reply_to_id" : 448490009,
      "line" : 1900,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1NTk0MQ==",
      "original_commit_id" : "a9f418aeb0d31acadd0d5114158fb1fcb9094f40",
      "original_line" : 1900,
      "original_position" : 86,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 617,
      "pull_request_review_id" : 451163518,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456955941",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456956498"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456956498"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-19T21:15:12Z",
      "diff_hunk" : "@@ -87,3 +87,10 @@ CHashWriter TaggedHash(const std::string& tag)\n     writer << taghash << taghash;\n     return writer;\n }\n+\n+uint256 SHA256Uint256(const uint256& hash)\n+{\n+    uint256 result;\n+    CSHA256().Write(hash.begin(), 32).Finalize(result.begin());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456956498",
      "id" : 456956498,
      "in_reply_to_id" : 454607993,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1NjQ5OA==",
      "original_commit_id" : "146952354b534b4684c9b94fd9bfe5817b063eb3",
      "original_line" : 94,
      "original_position" : 8,
      "original_start_line" : null,
      "path" : "src/hash.cpp",
      "position" : null,
      "pull_request_review_id" : 451163861,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456956498",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456956510"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456956510"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-19T21:15:23Z",
      "diff_hunk" : "@@ -203,6 +203,23 @@ class CPubKey\n     bool Derive(CPubKey& pubkeyChild, ChainCode &ccChild, unsigned int nChild, const ChainCode& cc) const;\n };\n \n+class XOnlyPubKey {\n+private:\n+    uint256 m_keydata;\n+\n+public:\n+    XOnlyPubKey(const uint256& in) : m_keydata(in) {}\n+\n+    /** Verify a 64-byte Schnorr signature.\n+     *\n+     * If the signature is not 64 bytes, or the public key is not fully valid, false is returned.\n+     */\n+    bool VerifySchnorr(const uint256& hash, const std::vector<unsigned char>& vchSig) const;\n+\n+    const unsigned char& operator[](int pos) const { return *(m_keydata.begin() + pos); }\n+    size_t size() const { return 32; }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456956510",
      "id" : 456956510,
      "in_reply_to_id" : 454613765,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1NjUxMA==",
      "original_commit_id" : "05b00d5eabea621d2cab55362f6c5a21f74311df",
      "original_line" : 220,
      "original_position" : 18,
      "original_start_line" : null,
      "path" : "src/pubkey.h",
      "position" : null,
      "pull_request_review_id" : 451163870,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456956510",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456956524"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456956524"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-19T21:15:30Z",
      "diff_hunk" : "@@ -1724,7 +1778,7 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n                 // The scriptSig must be _exactly_ CScript(), otherwise we reintroduce malleability.\n                 return set_error(serror, SCRIPT_ERR_WITNESS_MALLEATED);\n             }\n-            if (!VerifyWitnessProgram(*witness, witnessversion, witnessprogram, flags, checker, serror)) {\n+            if (!VerifyWitnessProgram(*witness, witnessversion, witnessprogram, flags, checker, serror, false)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456956524",
      "id" : 456956524,
      "in_reply_to_id" : 454624482,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1NjUyNA==",
      "original_commit_id" : "a9f418aeb0d31acadd0d5114158fb1fcb9094f40",
      "original_line" : 1781,
      "original_position" : 105,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 451163878,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456956524",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456956547"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456956547"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-19T21:15:43Z",
      "diff_hunk" : "@@ -1769,7 +1823,7 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n                     // reintroduce malleability.\n                     return set_error(serror, SCRIPT_ERR_WITNESS_MALLEATED_P2SH);\n                 }\n-                if (!VerifyWitnessProgram(*witness, witnessversion, witnessprogram, flags, checker, serror)) {\n+                if (!VerifyWitnessProgram(*witness, witnessversion, witnessprogram, flags, checker, serror, true)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456956547",
      "id" : 456956547,
      "in_reply_to_id" : 454624548,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1NjU0Nw==",
      "original_commit_id" : "a9f418aeb0d31acadd0d5114158fb1fcb9094f40",
      "original_line" : 1826,
      "original_position" : 114,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 451163894,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456956547",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456956571"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456956571"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nope, fixed.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-19T21:15:53Z",
      "diff_hunk" : "@@ -1391,9 +1391,9 @@ bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, const uint32_t in_p\n     }\n \n     // Data about the input/prevout being spent\n-    const auto* witstack = &tx_to.vin[in_pos].scriptWitness.stack;\n-    bool have_annex = witstack->size() > 1 && witstack->back().size() > 0 && witstack->back()[0] == 0xff;\n-    const uint8_t spend_type = (ext_flag << 1) + (have_annex ? 1 : 0); // The low bit indicates whether an annex is present.\n+    assert(execdata.m_annex_init);\n+    bool have_annex = execdata.m_annex_present;\n+    uint8_t spend_type = (ext_flag << 1) + (have_annex ? 1 : 0); // The low bit indicates whether an annex is present.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456956571",
      "id" : 456956571,
      "in_reply_to_id" : 454634063,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1NjU3MQ==",
      "original_commit_id" : "da73c5e3eb01bb362f6427fa7302079f3d981ac5",
      "original_line" : 1396,
      "original_position" : 27,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 451163909,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456956571",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456956599"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456956599"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I know, right?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-19T21:16:04Z",
      "diff_hunk" : "@@ -371,6 +368,67 @@ static bool EvalChecksig(const valtype& vchSig, const valtype& vchPubKey, CScrip\n     return true;\n }\n \n+static bool EvalChecksigTapscript(const valtype& sig, const valtype& pubkey, ScriptExecutionData& execdata, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& success)\n+{\n+    assert(sigversion == SigVersion::TAPSCRIPT);\n+\n+    /*\n+     *  The following validation sequence is consensus critical. Please note how --",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456956599",
      "id" : 456956599,
      "in_reply_to_id" : 454637523,
      "line" : 376,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1NjU5OQ==",
      "original_commit_id" : "7cdc010c70aa5e65e6b8e149b7f22e2fc93697fc",
      "original_line" : 376,
      "original_position" : 26,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 36,
      "pull_request_review_id" : 451163924,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456956599",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456956607"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456956607"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Good idea.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-19T21:16:11Z",
      "diff_hunk" : "@@ -1029,9 +1098,32 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                 }\n                 break;\n \n+                case OP_CHECKSIGADD:\n+                {\n+                    // OP_CHECKSIGADD is only available in Tapscript\n+                    if (sigversion != SigVersion::TAPSCRIPT) return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n+\n+                    // (sig num pubkey -- num)\n+                    if (stack.size() < 3) return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n+\n+                    const valtype& sig = stacktop(-3);\n+                    const CScriptNum num(stacktop(-2), fRequireMinimal);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456956607",
      "id" : 456956607,
      "in_reply_to_id" : 454650575,
      "line" : 1111,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1NjYwNw==",
      "original_commit_id" : "7cdc010c70aa5e65e6b8e149b7f22e2fc93697fc",
      "original_line" : 1111,
      "original_position" : 159,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 185,
      "pull_request_review_id" : 451163931,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456956607",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456956634"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456956634"
         }
      },
      "author_association" : "MEMBER",
      "body" : "There was only one `sigversion != SigVersion::TAPSCRIPT` so I've changed that to the other one.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-19T21:16:35Z",
      "diff_hunk" : "@@ -408,9 +473,12 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n             if (vchPushValue.size() > MAX_SCRIPT_ELEMENT_SIZE)\n                 return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n \n-            // Note how OP_RESERVED does not count towards the opcode limit.\n-            if (opcode > OP_16 && ++nOpCount > MAX_OPS_PER_SCRIPT)\n-                return set_error(serror, SCRIPT_ERR_OP_COUNT);\n+            if (sigversion == SigVersion::BASE || sigversion == SigVersion::WITNESS_V0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456956634",
      "id" : 456956634,
      "in_reply_to_id" : 454656075,
      "line" : 475,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1NjYzNA==",
      "original_commit_id" : "7cdc010c70aa5e65e6b8e149b7f22e2fc93697fc",
      "original_line" : 475,
      "original_position" : 111,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 135,
      "pull_request_review_id" : 451163960,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456956634",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456956659"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456956659"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Indeed, updated comment.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-19T21:16:58Z",
      "diff_hunk" : "@@ -231,6 +233,34 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check Taproot standardness limits",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456956659",
      "id" : 456956659,
      "in_reply_to_id" : 455057389,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1NjY1OQ==",
      "original_commit_id" : "43cbfab02a4349e6510068bbee39d836de954d68",
      "original_line" : 237,
      "original_position" : 30,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : null,
      "pull_request_review_id" : 451163986,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456956659",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456956678"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456956678"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Good idea, done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-19T21:17:07Z",
      "diff_hunk" : "@@ -1645,14 +1648,34 @@ static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CS\n     return true;\n }\n \n-static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, const std::vector<unsigned char>& program, const CScript& script)\n+{\n+    int path_len = (control.size() - TAPROOT_CONTROL_BASE_SIZE) / TAPROOT_CONTROL_NODE_SIZE;\n+    XOnlyPubKey p{uint256(std::vector<unsigned char>(control.begin() + 1, control.begin() + TAPROOT_CONTROL_BASE_SIZE))};\n+    XOnlyPubKey q{uint256(program)};\n+    uint256 k = (CHashWriter(HasherTapLeaf) << uint8_t(control[0] & TAPROOT_LEAF_MASK) << script).GetSHA256();\n+    for (int i = 0; i < path_len; ++i) {\n+        CHashWriter ss_branch = HasherTapBranch;\n+        auto node_begin = control.data() + TAPROOT_CONTROL_BASE_SIZE + TAPROOT_CONTROL_NODE_SIZE * i;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456956678",
      "id" : 456956678,
      "in_reply_to_id" : 455048734,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1NjY3OA==",
      "original_commit_id" : "a9f418aeb0d31acadd0d5114158fb1fcb9094f40",
      "original_line" : 1659,
      "original_position" : 23,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 451163995,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456956678",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456956697"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456956697"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-19T21:17:17Z",
      "diff_hunk" : "@@ -384,3 +420,125 @@ def sign_ecdsa(self, msg, low_s=True):\n         rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')\n         sb = s.to_bytes((s.bit_length() + 8) // 8, 'big')\n         return b'\\x30' + bytes([4 + len(rb) + len(sb), 2, len(rb)]) + rb + bytes([2, len(sb)]) + sb\n+\n+def compute_xonly_pubkey(key):\n+    \"\"\"Compute an x-only (32 byte) public key from a (32 byte) private key.\n+\n+    This also returns whether the resulting public key was negated.\n+    \"\"\"\n+\n+    assert(len(key) == 32)\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return (None, None)\n+    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, x)]))\n+    return (P[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(P))\n+\n+def tweak_privkey(key, tweak, negated=False):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456956697",
      "id" : 456956697,
      "in_reply_to_id" : 455059396,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1NjY5Nw==",
      "original_commit_id" : "98ea8e9b9ba27e0b2725f02c92c2e3a64e4fdeab",
      "original_line" : 437,
      "original_position" : 201,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 451164006,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456956697",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456956705"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456956705"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-19T21:17:23Z",
      "diff_hunk" : "@@ -384,3 +420,125 @@ def sign_ecdsa(self, msg, low_s=True):\n         rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')\n         sb = s.to_bytes((s.bit_length() + 8) // 8, 'big')\n         return b'\\x30' + bytes([4 + len(rb) + len(sb), 2, len(rb)]) + rb + bytes([2, len(sb)]) + sb\n+\n+def compute_xonly_pubkey(key):\n+    \"\"\"Compute an x-only (32 byte) public key from a (32 byte) private key.\n+\n+    This also returns whether the resulting public key was negated.\n+    \"\"\"\n+\n+    assert(len(key) == 32)\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return (None, None)\n+    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, x)]))\n+    return (P[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(P))\n+\n+def tweak_privkey(key, tweak, negated=False):\n+    \"\"\"Tweak a private key (after optionally negating it).\"\"\"\n+\n+    assert(len(key) == 32)\n+    assert(len(tweak) == 32)\n+\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return None\n+    if negated:\n+       x = SECP256K1_ORDER - x\n+    t = int.from_bytes(tweak, 'big')\n+    if t >= SECP256K1_ORDER:\n+        return None\n+    x = (x + t) % SECP256K1_ORDER\n+    if x == 0:\n+        return None\n+    return x.to_bytes(32, 'big')\n+\n+def tweak_pubkey(key, tweak):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456956705",
      "id" : 456956705,
      "in_reply_to_id" : 455059451,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1NjcwNQ==",
      "original_commit_id" : "98ea8e9b9ba27e0b2725f02c92c2e3a64e4fdeab",
      "original_line" : 459,
      "original_position" : 220,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 451164014,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456956705",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456956776"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456956776"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-19T21:17:44Z",
      "diff_hunk" : "@@ -0,0 +1,638 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import create_coinbase, create_block, add_witness_commitment\n+from test_framework.messages import CTransaction, CTxIn, CTxOut, COutPoint, CTxInWitness\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_1SUB,\n+    OP_1NEGATE,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIF,\n+    SIGHASH_SINGLE,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, hex_str_to_bytes\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_privkey\n+from test_framework.address import program_to_witness, script_to_p2sh, hash160\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+import struct\n+\n+EMPTYWITNESS_ERROR = \"non-mandatory-script-verify-flag (Witness program was passed an empty witness) (code 64)\"\n+INVALIDKEYPATHSIG_ERROR = \"non-mandatory-script-verify-flag (Invalid signature for Taproot key path spending) (code 64)\"\n+UNKNOWNWITNESS_ERROR = \"non-mandatory-script-verify-flag (Witness version reserved for soft-fork upgrades) (code 64)\"\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+def tx_from_hex(hexstring):\n+    tx = CTransaction()\n+    f = BytesIO(hex_str_to_bytes(hexstring))\n+    tx.deserialize(f)\n+    return tx\n+\n+def get_taproot_bech32(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return program_to_witness(1, info[2:])\n+\n+def get_version1_p2sh(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return script_to_p2sh(info)\n+\n+def get_p2sh_spk(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return CScript([OP_HASH160, hash160(info), OP_EQUAL])\n+\n+def random_op_success():\n+    ret = 0\n+    while (not is_op_success(ret)):\n+        ret = random.randint(0x50, 0xfe)\n+    return CScriptOp(ret)\n+\n+def random_unknown_leaf_ver(no_annex_tag=True):\n+    ret = LEAF_VERSION_TAPSCRIPT\n+    while (ret == LEAF_VERSION_TAPSCRIPT or (no_annex_tag and ret == (ANNEX_TAG & 0xfe))):\n+        ret = random.randrange(128) * 2\n+    return ret\n+\n+def random_bytes(n):\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def random_script(size, no_success=True):\n+    ret = bytes()\n+    while (len(ret) < size):\n+        remain = size - len(ret)\n+        opcode = random.randrange(256)\n+        while (no_success and is_op_success(opcode)):\n+            opcode = random.randrange(256)\n+        if opcode == 0 or opcode >= OP_1NEGATE:\n+            ret += bytes([opcode])\n+        elif opcode <= 75 and opcode <= remain - 1:\n+            ret += bytes([opcode]) + random_bytes(opcode)\n+        elif opcode == 76 and remain >= 2:\n+            pushsize = random.randint(0, min(0xff, remain - 2))\n+            ret += bytes([opcode]) + bytes([pushsize]) + random_bytes(pushsize)\n+        elif opcode == 77 and remain >= 3:\n+            pushsize = random.randint(0, min(0xffff, remain - 3))\n+            ret += bytes([opcode]) + struct.pack(b'<H', pushsize) + random_bytes(pushsize)\n+        elif opcode == 78 and remain >= 5:\n+            pushsize = random.randint(0, min(0xffffffff, remain - 5))\n+            ret += bytes([opcode]) + struct.pack(b'<I', pushsize) + random_bytes(pushsize)\n+    assert len(ret) == size\n+    return ret\n+\n+def random_invalid_push(size):\n+    assert size > 0\n+    ret = bytes()\n+    opcode = 78\n+    if size <= 75:\n+        opcode = random.randint(75, 78)\n+    elif size <= 255:\n+        opcode = random.randint(76, 78)\n+    elif size <= 0xffff:\n+        opcode = random.randint(77, 78)\n+    if opcode == 75:\n+        ret = bytes([size]) + random_bytes(size - 1)\n+    elif opcode == 76:\n+        ret = bytes([opcode]) + bytes([size]) + random_bytes(size - 2)\n+    elif opcode == 77:\n+        ret = bytes([opcode]) + struct.pack(b'<H', size) + random_bytes(max(0, size - 3))\n+    else:\n+        ret = bytes([opcode]) + struct.pack(b'<I', size) + random_bytes(max(0, size - 5))\n+    assert len(ret) >= size\n+    return ret[:size]\n+\n+def random_checksig_style(pubkey):\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def damage_bytes(b):\n+    return (int.from_bytes(b, 'big') ^ (1 << random.randrange(len(b) * 8))).to_bytes(len(b), 'big')\n+\n+# Each spender is a tuple of:\n+# - A scriptPubKey (CScript)\n+# - An address for that scriptPubKey (string)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A witness stack-producing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+\n+Spender = namedtuple(\"Spender\", \"script,address,comment,is_standard,sat_function\")\n+\n+def spend_single_sig(tx, input_index, spent_utxos, info, key, annex=None, hashtype=0, prefix=None, suffix=None, script=None, pos=-1, damage=False):\n+    if prefix is None:\n+        prefix = []\n+    if suffix is None:\n+        suffix = []\n+\n+    ht = hashtype\n+\n+    damage_type = random.randrange(5) if damage else -1\n+    '''\n+    * 0. bit flip the sighash\n+    * 1. bit flip the signature\n+    * If the expected hashtype is 0:\n+    -- 2. append a 0 to the signature\n+    -- 3. append a random value of 1-255 to the signature\n+    * If the expected hashtype is not 0:\n+    -- 2. do not append hashtype to the signature\n+    -- 3. append a random incorrect value of 0-255 to the signature\n+    * 4. extra witness element\n+    '''\n+\n+    # Taproot key path spend: tweak key\n+    if script is None:\n+        _, negated = compute_xonly_pubkey(key)\n+        key = tweak_privkey(key, info[1], negated)\n+        assert(key is not None)\n+\n+    # Change SIGHASH_SINGLE into SIGHASH_ALL if no corresponding output\n+    if (ht & 3 == SIGHASH_SINGLE and input_index >= len(tx.vout)):\n+        ht ^= 2\n+    # Compute sighash\n+    if script:\n+        sighash = TaprootSignatureHash(tx, spent_utxos, ht, input_index, scriptpath=True, script=script, codeseparator_pos=pos, annex=annex)\n+    else:\n+        sighash = TaprootSignatureHash(tx, spent_utxos, ht, input_index, scriptpath=False, annex=annex)\n+    if damage_type == 0:\n+        sighash = damage_bytes(sighash)\n+    # Compute signature\n+    sig = sign_schnorr(key, sighash)\n+    if damage_type == 1:\n+        sig = damage_bytes(sig)\n+    if damage_type == 2:\n+        if ht == 0:\n+            sig += bytes([0])\n+    elif damage_type == 3:\n+        random_ht = ht\n+        while random_ht == ht:\n+            random_ht = random.randrange(256)\n+        sig += bytes([random_ht])\n+    elif ht > 0:\n+        sig += bytes([ht])\n+    # Construct witness\n+    ret = prefix + [sig] + suffix\n+    if script is not None:\n+        ret += [script, info[2][script]]\n+    if annex is not None:\n+        ret += [annex]\n+    if damage_type == 4:\n+        ret = [random_bytes(random.randrange(5))] + ret\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = ret\n+\n+def spend_alwaysvalid(tx, input_index, info, script, annex=None, damage=False):\n+    if isinstance(script, tuple):\n+        version, script = script\n+    ret = [script, info[2][script]]\n+    if damage:\n+        # With 50% chance, we bit flip the script (unless the script is an empty vector)\n+        # With 50% chance, we bit flip the control block\n+        if random.choice([True, False]) or len(ret[0]) == 0:\n+            # Annex is always required for leaf version 0x50\n+            # Unless the original version is 0x50, we couldn't convert it to 0x50 without using annex\n+            tmp = damage_bytes(ret[1])\n+            while annex is None and tmp[0] == ANNEX_TAG and ret[1][0] != ANNEX_TAG:\n+                tmp = damage_bytes(ret[1])\n+            ret[1] = tmp\n+        else:\n+            ret[0] = damage_bytes(ret[0])\n+    if annex is not None:\n+        ret += [annex]\n+    # Randomly add input witness\n+    if random.choice([True, False]):\n+        for i in range(random.randint(1, 10)):\n+            ret = [random_bytes(random.randint(0, MAX_SCRIPT_ELEMENT_SIZE * 2))] + ret\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = ret\n+\n+def spender_sighash_mutation(spenders, info, comment, standard=True, **kwargs):\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_single_sig(t, i, u, damage=not v, info=info, **kwargs)\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn))\n+\n+def spender_two_paths(spenders, info, comment, standard, success, failure):\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_single_sig(t, i, u, damage=False, info=info, **(success if v else failure))\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn))\n+\n+def spender_alwaysvalid(spenders, info, comment, **kwargs):\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_alwaysvalid(t, i, damage=not v, info=info, **kwargs)\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=False, sat_function=fn))\n+\n+def spender_alwaysvalid_p2sh(spenders, info, comment, standard, script):\n+    spk = get_p2sh_spk(info)\n+    addr = get_version1_p2sh(info)\n+\n+    def fn(t, i, u, v):\n+        if v:\n+            t.vin[i].scriptSig = CScript([info[0]])\n+            # Empty control block is only invalid if we apply taproot rules,\n+            # which we shouldn't if the spend is wrapped in P2SH\n+            t.wit.vtxinwit[i].scriptWitness.stack = [script, bytes()]\n+        else:\n+            t.vin[i].scriptSig = CScript()\n+        return\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn))\n+\n+def nested_script(script, depth):\n+    if depth == 0:\n+        return script\n+    return [nested_script(script, depth - 1), CScript([OP_RETURN])]\n+\n+UTXOData = namedtuple('UTXOData', 'input,output,spender')\n+\n+class TaprootTest(BitcoinTestFramework):\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.extra_args = [[\"-whitelist=127.0.0.1\", \"-acceptnonstdtxn=0\", \"-par=1\"]]",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456956776",
      "id" : 456956776,
      "in_reply_to_id" : 456607326,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1Njc3Ng==",
      "original_commit_id" : "23985b72beb1bc3bfc68086ad874ebe3e53b9364",
      "original_line" : 311,
      "original_position" : 311,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 451164036,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456956776",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased, updated to latest version of https://github.com/bitcoin-core/secp256k1/pull/558, and addressed a number of comments above.\r\n\r\n@Sjors The revert commits are a side-effect of using `git subtree` to switch to https://github.com/bitcoin-core/secp256k1/pull/558 (which itself is not based on secp256k1 master, so things in master but not there get reverted). Yes, the plan is to merge the Schnorr code in libsecp256k1, and then update subtree in this repo, before actually merging this PR.\r\n\r\n@instagibbs All of those test improvements look great! I'd prefer not picking up dozens of tiny commits for them though; do you want me to just squash them into the relevant commit here, or do you want to wait until you've done more? One nit: when adding overall comments about what a Python function does, use `\"\"\"bla\"\"\"` docstrings instead of `# comments`.",
      "created_at" : "2020-07-19T21:22:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-660711810",
      "id" : 660711810,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2MDcxMTgxMA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-19T21:28:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/660711810",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456981308"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456981308"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yeah found out the hard way after trying a few times.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-20T01:08:34Z",
      "diff_hunk" : "@@ -1634,6 +1740,25 @@ static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CS\n {\n     std::vector<valtype> stack{stack_span.begin(), stack_span.end()};\n \n+    // OP_SUCCESSx processing overrides everything, including stack element size limits",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456981308",
      "id" : 456981308,
      "in_reply_to_id" : 455042663,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MTMwOA==",
      "original_commit_id" : "7cdc010c70aa5e65e6b8e149b7f22e2fc93697fc",
      "original_line" : 1743,
      "original_position" : 218,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 451199595,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456981308",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@sipa take the tests in any form you'd like, I just thought it would be easier for you to review the changes. \r\n\r\nI'm done for now, so feel free to check off any un-ticked boxes yourself.",
      "created_at" : "2020-07-20T01:09:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-660744498",
      "id" : 660744498,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2MDc0NDQ5OA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-20T01:10:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/660744498",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456983701"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456983701"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I ended up writing that test, in the branch I posted.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-20T01:24:24Z",
      "diff_hunk" : "@@ -1029,9 +1098,32 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                 }\n                 break;\n \n+                case OP_CHECKSIGADD:\n+                {\n+                    // OP_CHECKSIGADD is only available in Tapscript\n+                    if (sigversion != SigVersion::TAPSCRIPT) return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n+\n+                    // (sig num pubkey -- num)\n+                    if (stack.size() < 3) return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n+\n+                    const valtype& sig = stacktop(-3);\n+                    const CScriptNum num(stacktop(-2), fRequireMinimal);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456983701",
      "id" : 456983701,
      "in_reply_to_id" : 454650575,
      "line" : 1111,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MzcwMQ==",
      "original_commit_id" : "7cdc010c70aa5e65e6b8e149b7f22e2fc93697fc",
      "original_line" : 1111,
      "original_position" : 159,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 185,
      "pull_request_review_id" : 451209024,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456983701",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@instagibbs All your test improvements squashed into the relevant commits here.",
      "created_at" : "2020-07-20T01:57:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-660756608",
      "id" : 660756608,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2MDc1NjYwOA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-20T01:57:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/660756608",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456992780"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456992780"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Wondering if you could un-magic this constant a bit. I was going to attempt to write another case for unknown pubkey using this template, but ran out of motivation to reverse engineer it.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-20T02:11:05Z",
      "diff_hunk" : "@@ -0,0 +1,745 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS,\n+)\n+from test_framework.messages import CTransaction, CTxIn, CTxOut, COutPoint, CTxInWitness\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_1SUB,\n+    OP_1NEGATE,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIF,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, hex_str_to_bytes, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey\n+from test_framework.address import program_to_witness, script_to_p2sh, hash160\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+import struct\n+\n+EMPTYWITNESS_ERROR = \"non-mandatory-script-verify-flag (Witness program was passed an empty witness) (code 64)\"\n+INVALIDKEYPATHSIG_ERROR = \"non-mandatory-script-verify-flag (Invalid signature for Taproot key path spending) (code 64)\"\n+UNKNOWNWITNESS_ERROR = \"non-mandatory-script-verify-flag (Witness version reserved for soft-fork upgrades) (code 64)\"\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+def tx_from_hex(hexstring):\n+    tx = CTransaction()\n+    f = BytesIO(hex_str_to_bytes(hexstring))\n+    tx.deserialize(f)\n+    return tx\n+\n+def get_taproot_bech32(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return program_to_witness(1, info[2:])\n+\n+def get_version1_p2sh(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return script_to_p2sh(info)\n+\n+def get_p2sh_spk(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return CScript([OP_HASH160, hash160(info), OP_EQUAL])\n+\n+def random_op_success():\n+    ret = 0\n+    while (not is_op_success(ret)):\n+        ret = random.randint(0x50, 0xfe)\n+    return CScriptOp(ret)\n+\n+def random_unknown_leaf_ver(no_annex_tag=True):\n+    ret = LEAF_VERSION_TAPSCRIPT\n+    while (ret == LEAF_VERSION_TAPSCRIPT or (no_annex_tag and ret == (ANNEX_TAG & 0xfe))):\n+        ret = random.randrange(128) * 2\n+    return ret\n+\n+def random_bytes(n):\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+# TODO-TAPROOT Use this in a test\n+def random_script(size, no_success=True):\n+    ret = bytes()\n+    while (len(ret) < size):\n+        remain = size - len(ret)\n+        opcode = random.randrange(256)\n+        while (no_success and is_op_success(opcode)):\n+            opcode = random.randrange(256)\n+        if opcode == 0 or opcode >= OP_1NEGATE:\n+            ret += bytes([opcode])\n+        elif opcode <= 75 and opcode <= remain - 1:\n+            ret += bytes([opcode]) + random_bytes(opcode)\n+        elif opcode == 76 and remain >= 2:\n+            pushsize = random.randint(0, min(0xff, remain - 2))\n+            ret += bytes([opcode]) + bytes([pushsize]) + random_bytes(pushsize)\n+        elif opcode == 77 and remain >= 3:\n+            pushsize = random.randint(0, min(0xffff, remain - 3))\n+            ret += bytes([opcode]) + struct.pack(b'<H', pushsize) + random_bytes(pushsize)\n+        elif opcode == 78 and remain >= 5:\n+            pushsize = random.randint(0, min(0xffffffff, remain - 5))\n+            ret += bytes([opcode]) + struct.pack(b'<I', pushsize) + random_bytes(pushsize)\n+    assert len(ret) == size\n+    return ret\n+\n+# TODO-TAPROOT Use this in a test\n+def random_invalid_push(size):\n+    assert size > 0\n+    ret = bytes()\n+    opcode = 78\n+    if size <= 75:\n+        opcode = random.randint(75, 78)\n+    elif size <= 255:\n+        opcode = random.randint(76, 78)\n+    elif size <= 0xffff:\n+        opcode = random.randint(77, 78)\n+    if opcode == 75:\n+        ret = bytes([size]) + random_bytes(size - 1)\n+    elif opcode == 76:\n+        ret = bytes([opcode]) + bytes([size]) + random_bytes(size - 2)\n+    elif opcode == 77:\n+        ret = bytes([opcode]) + struct.pack(b'<H', size) + random_bytes(max(0, size - 3))\n+    else:\n+        ret = bytes([opcode]) + struct.pack(b'<I', size) + random_bytes(max(0, size - 5))\n+    assert len(ret) >= size\n+    return ret[:size]\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def damage_bytes(b):\n+    \"\"\"Flips one bit at random in a byte string.\"\"\"\n+    return (int.from_bytes(b, 'big') ^ (1 << random.randrange(len(b) * 8))).to_bytes(len(b), 'big')\n+\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - An address for that scriptPubKey (string)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A witness stack-producing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+\n+Spender = namedtuple(\"Spender\", \"script,address,comment,is_standard,sat_function\")\n+\n+def spend_no_sig(tx, input_index, spent_utxos, info, script):\n+    \"\"\"Construct witness.\"\"\"\n+    script = script[\"script\"]\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = [script, info[2][script]]\n+\n+def spend_single_sig(tx, input_index, spent_utxos, info, key, annex=None, hashtype=0, prefix=None, suffix=None, script=None, pos=-1, damage=False):\n+    if prefix is None:\n+        prefix = []\n+    if suffix is None:\n+        suffix = []\n+\n+    ht = hashtype\n+\n+    damage_type = random.randrange(5) if damage else -1\n+    '''\n+    * 0. bit flip the sighash\n+    * 1. bit flip the signature\n+    * If the expected hashtype is 0:\n+    -- 2. append a 0 to the signature\n+    -- 3. append a random value of 1-255 to the signature\n+    * If the expected hashtype is not 0:\n+    -- 2. do not append hashtype to the signature\n+    -- 3. append a random incorrect value of 0-255 to the signature\n+    * 4. extra witness element\n+    '''\n+\n+    # Taproot key path spend: tweak key\n+    if script is None:\n+        _, negated = compute_xonly_pubkey(key)\n+        key = tweak_add_privkey(key, info[1], negated)\n+        assert(key is not None)\n+\n+    # Change SIGHASH_SINGLE into SIGHASH_ALL if no corresponding output\n+    if (ht & 3 == SIGHASH_SINGLE and input_index >= len(tx.vout)):\n+        ht ^= 2\n+    # Compute sighash\n+    if script:\n+        sighash = TaprootSignatureHash(tx, spent_utxos, ht, input_index, scriptpath=True, script=script, codeseparator_pos=pos, annex=annex)\n+    else:\n+        sighash = TaprootSignatureHash(tx, spent_utxos, ht, input_index, scriptpath=False, annex=annex)\n+    if damage_type == 0:\n+        sighash = damage_bytes(sighash)\n+    # Compute signature\n+    sig = sign_schnorr(key, sighash)\n+    if damage_type == 1:\n+        sig = damage_bytes(sig)\n+    if damage_type == 2:\n+        if ht == 0:\n+            sig += bytes([0])\n+    elif damage_type == 3:\n+        random_ht = ht\n+        while random_ht == ht:\n+            random_ht = random.randrange(256)\n+        sig += bytes([random_ht])\n+    elif ht > 0:\n+        sig += bytes([ht])\n+    # Construct witness\n+    ret = prefix + [sig] + suffix\n+    if script is not None:\n+        ret += [script, info[2][script]]\n+    if annex is not None:\n+        ret += [annex]\n+    if damage_type == 4:\n+        ret = [random_bytes(random.randrange(5))] + ret\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = ret\n+\n+def spend_alwaysvalid(tx, input_index, info, script, annex=None, damage=False):\n+    if isinstance(script, tuple):\n+        version, script = script\n+    ret = [script, info[2][script]]\n+    if damage:\n+        # With 50% chance, we bit flip the script (unless the script is an empty vector)\n+        # With 50% chance, we bit flip the control block\n+        if random.choice([True, False]) or len(ret[0]) == 0:\n+            # Annex is always required for leaf version 0x50\n+            # Unless the original version is 0x50, we couldn't convert it to 0x50 without using annex\n+            tmp = damage_bytes(ret[1])\n+            while annex is None and tmp[0] == ANNEX_TAG and ret[1][0] != ANNEX_TAG:\n+                tmp = damage_bytes(ret[1])\n+            ret[1] = tmp\n+        else:\n+            ret[0] = damage_bytes(ret[0])\n+    if annex is not None:\n+        ret += [annex]\n+    # Randomly add input witness\n+    if random.choice([True, False]):\n+        for i in range(random.randint(1, 10)):\n+            ret = [random_bytes(random.randint(0, MAX_SCRIPT_ELEMENT_SIZE * 2))] + ret\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = ret\n+\n+# N.B. Function arguments below: t(ransaction), i(ndex to spend), u(txos being spent), v(alid signature?)\n+\n+def spender_sighash_mutation(spenders, info, comment, standard=True, **kwargs):\n+    \"\"\"Mutates signature randomly when failure for the inputs is requested.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_single_sig(t, i, u, damage=not v, info=info, **kwargs)\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn))\n+\n+def spender_two_paths(spenders, info, comment, standard, success, failure):\n+    \"\"\"Gives caller a way to specify two merkle paths to test validity satisfaction: One expected success, and one failure.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_single_sig(t, i, u, damage=False, info=info, **(success if v else failure))\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn))\n+\n+def spender_alwaysvalid(spenders, info, comment, **kwargs):\n+    \"\"\"Mutates the witness when requested, intended for otherwise always true scripts.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_alwaysvalid(t, i, damage=not v, info=info, **kwargs)\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=False, sat_function=fn))\n+\n+def spender_two_paths_alwaysvalid(spenders, info, comment, standard, success, failure):\n+    \"\"\"Allows specifying both a success and failure script without any signatures or additional witness data required.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_no_sig(t, i, u, info, (success if v else failure))\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn))\n+\n+def spender_alwaysvalid_p2sh(spenders, info, comment, standard, script):\n+    \"\"\"Tests that p2sh-wrapping witness program v1 are always valid, since they are not covered by tapscript.\"\"\"\n+    spk = get_p2sh_spk(info)\n+    addr = get_version1_p2sh(info)\n+\n+    def fn(t, i, u, v):\n+        if v:\n+            t.vin[i].scriptSig = CScript([info[0]])\n+            # Empty control block is only invalid if we apply taproot rules,\n+            # which we shouldn't if the spend is wrapped in P2SH\n+            t.wit.vtxinwit[i].scriptWitness.stack = [script, bytes()]\n+        else:\n+            t.vin[i].scriptSig = CScript()\n+        return\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn))\n+\n+def spender_two_paths_no_sig(spenders, info, comment, standard, success, failure):\n+    \"\"\"Same as spender_two_paths but not support for signatures or padding witness.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    # Empty witness required\n+    def fn(t, i, u, v):\n+        return []\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn))\n+\n+def nested_script(script, depth):\n+    if depth == 0:\n+        return script\n+    return [nested_script(script, depth - 1), CScript([OP_RETURN])]\n+\n+UTXOData = namedtuple('UTXOData', 'input,output,spender')\n+\n+class TaprootTest(BitcoinTestFramework):\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.extra_args = [[\"-whitelist=127.0.0.1\", \"-par=1\"]]\n+\n+    def block_submit(self, node, txs, msg, cb_pubkey=None, fees=0, witness=False, accept=False):\n+\n+        # Deplete block of any non-tapscript sigops using a single additional 0-value coinbase output\n+        # It's physically impossible to fit enough tapscript sigops to hit the old 80k limit without\n+        # busting txin-level limits. We simply have to account for the p2pk outputs in all\n+        # transactions. N.B. this test means no spenders can ever spend non-taproot/tapscript outputs,\n+        # or those at least have to be accounted for here.\n+\n+        def MaybeIsPayToPubKey(script):\n+            return script[-1] == OP_CHECKSIG\n+\n+        legacy_checksigs = 0 if cb_pubkey is None else 1 # P2PK output in coinbase back to wallet\n+        for tx in txs:\n+            for output in tx.vout:\n+                if MaybeIsPayToPubKey(output.scriptPubKey):\n+                    legacy_checksigs += 1\n+        extra_output_script = CScript([OP_CHECKSIG]*(MAX_BLOCK_SIGOPS-legacy_checksigs))\n+\n+        block = create_block(self.tip, create_coinbase(self.lastblockheight + 1, pubkey=cb_pubkey, extra_output_script=extra_output_script, fees=fees), self.lastblocktime + 1)\n+        block.nVersion = 4\n+        for tx in txs:\n+            tx.rehash()\n+            block.vtx.append(tx)\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        witness and add_witness_commitment(block)\n+        block.rehash()\n+        block.solve()\n+        node.submitblock(block.serialize(True).hex())\n+        if (accept):\n+            assert node.getbestblockhash() == block.hash, \"Failed to accept: \" + msg\n+            self.tip = block.sha256\n+            self.lastblockhash = block.hash\n+            self.lastblocktime += 1\n+            self.lastblockheight += 1\n+        else:\n+            assert node.getbestblockhash() == self.lastblockhash, \"Failed to reject: \" + msg\n+\n+    def test_spenders(self, spenders, input_counts):\n+        \"\"\"Run randomized tests with a number of \"spenders\".\n+\n+        Steps:\n+            1) Generate an appropriate UTXO for each spender to test spend conditions\n+            2) Generate 100 random addresses of all wallet types: pkh/sh_wpkh/wpkh\n+            3) Select random number of inputs from (1)\n+            4) Select random number of addresses from (2) as outputs\n+\n+        Each spender embodies a test; in a large randomized test, it is verified\n+        that toggling the valid argument to each lambda toggles the validity of\n+        the transaction. This is accomplished by constructing transactions consisting\n+        of all valid inputs, except one invalid one.\n+        \"\"\"\n+\n+        # Construct a UTXO to spend for each of the spenders, with the script to satisfy being given by the spender\n+        self.nodes[0].generate(110)\n+        bal = self.nodes[0].getbalance() * 3 / (4 * len(spenders))\n+        random.shuffle(spenders)\n+        num_spenders = len(spenders)\n+        utxos = []\n+        while len(spenders):\n+            # Create the necessary outputs in multiple transactions, as sPKs may be repeated in test cases(which sendmany does not support)\n+            outputs = {}\n+            new_spenders = []\n+            batch = []\n+            for spender in spenders:\n+                addr = spender.address\n+                if len(batch) == 100 or addr in outputs:\n+                    new_spenders.append(spender)\n+                else:\n+                    amount = random.randrange(int(bal * 95000000), int(bal * 105000000))\n+                    outputs[addr] = amount / 100000000\n+                    batch.append(spender)\n+            self.log.info(\"Constructing %i UTXOs for spending tests\" % len(batch))\n+            tx = tx_from_hex(self.nodes[0].getrawtransaction(self.nodes[0].sendmany(\"\", outputs)))\n+            tx.rehash()\n+            spenders = new_spenders\n+            random.shuffle(spenders)\n+\n+            # Map created UTXOs back to the spenders they were created for\n+            for n, out in enumerate(tx.vout):\n+                for spender in batch:\n+                    if out.scriptPubKey == spender.script:\n+                        utxos.append(UTXOData(input=COutPoint(tx.sha256, n), output=out, spender=spender))\n+                        break\n+        assert(len(utxos) == num_spenders)\n+        random.shuffle(utxos)\n+        self.nodes[0].generate(1)\n+\n+        # Construct a bunch of sPKs that send coins back to the host wallet\n+        self.log.info(\"Constructing 100 addresses for returning coins\")\n+        host_spks = []\n+        host_pubkeys = []\n+        for i in range(100):\n+            addr = self.nodes[0].getnewaddress(address_type=random.choice([\"legacy\", \"p2sh-segwit\", \"bech32\"]))\n+            info = self.nodes[0].getaddressinfo(addr)\n+            spk = hex_str_to_bytes(info['scriptPubKey'])\n+            host_spks.append(spk)\n+            host_pubkeys.append(hex_str_to_bytes(info['pubkey']))\n+\n+        # Pick random subsets of UTXOs to construct transactions with\n+        self.lastblockhash = self.nodes[0].getbestblockhash()\n+        self.tip = int(\"0x\" + self.lastblockhash, 0)\n+        block = self.nodes[0].getblock(self.lastblockhash)\n+        self.lastblockheight = block['height']\n+        self.lastblocktime = block['time']\n+        while len(utxos):\n+            tx = CTransaction()\n+            tx.nVersion = random.choice([1, 2, random.randint(-0x80000000, 0x7fffffff)])\n+            min_sequence = (tx.nVersion != 1 and tx.nVersion != 0) * 0x80000000  # The minimum sequence number to disable relative locktime\n+            if random.choice([True, False]):\n+                tx.nLockTime = random.randrange(LOCKTIME_THRESHOLD, self.lastblocktime - 7200)  # all absolute locktimes in the past\n+            else:\n+                tx.nLockTime = random.randrange(self.lastblockheight + 1)  # all block heights in the past\n+\n+            # Pick 1 to 4 UTXOs to construct transaction inputs\n+            acceptable_input_counts = [cnt for cnt in input_counts if cnt <= len(utxos)]\n+            while True:\n+                inputs = random.choice(acceptable_input_counts)\n+                remaining = len(utxos) - inputs\n+                if remaining == 0 or remaining >= max(input_counts) or remaining in input_counts:\n+                    break\n+            input_utxos = utxos[-inputs:]\n+            utxos = utxos[:-inputs]\n+            fee = random.randrange(MIN_FEE * 2, MIN_FEE * 4)  # 10000-20000 sat fee\n+            in_value = sum(utxo.output.nValue for utxo in input_utxos) - fee\n+            tx.vin = [CTxIn(outpoint=input_utxos[i].input, nSequence=random.randint(min_sequence, 0xffffffff)) for i in range(inputs)]\n+            tx.wit.vtxinwit = [CTxInWitness() for i in range(inputs)]\n+            self.log.info(\"Test: %s\" % (\", \".join(utxo.spender.comment for utxo in input_utxos)))\n+\n+            # Add 1 to 4 outputs\n+            outputs = random.choice([1, 2, 3, 4])\n+            assert in_value >= 0 and fee - outputs * DUST_LIMIT >= MIN_FEE\n+            for i in range(outputs):\n+                tx.vout.append(CTxOut())\n+                if in_value <= DUST_LIMIT:\n+                    tx.vout[-1].nValue = DUST_LIMIT\n+                elif i < outputs - 1:\n+                    tx.vout[-1].nValue = in_value\n+                else:\n+                    tx.vout[-1].nValue = random.randint(DUST_LIMIT, in_value)\n+                in_value -= tx.vout[-1].nValue\n+                tx.vout[-1].scriptPubKey = random.choice(host_spks)\n+            fee += in_value\n+            assert(fee >= 0)\n+\n+            # Sign each input incorrectly once on each complete signing pass, except the very last\n+            for fail_input in range(inputs + 1):\n+                # Wipe scriptSig/witness\n+                for i in range(inputs):\n+                    tx.vin[i].scriptSig = CScript()\n+                    tx.wit.vtxinwit[i] = CTxInWitness()\n+                # Fill inputs/witnesses\n+                for i in range(inputs):\n+                    fn = input_utxos[i].spender.sat_function\n+                    fn(tx, i, [utxo.output for utxo in input_utxos], i != fail_input)\n+                # Submit to mempool to check standardness\n+                is_standard_tx = fail_input == inputs and all(utxo.spender.is_standard for utxo in input_utxos) and tx.nVersion >= 1 and tx.nVersion <= 2\n+                tx.rehash()\n+                if is_standard_tx:\n+                    self.nodes[0].sendrawtransaction(tx.serialize().hex(), 0)\n+                    assert(self.nodes[0].getmempoolentry(tx.hash) is not None)\n+                else:\n+                    assert_raises_rpc_error(-26, None, self.nodes[0].sendrawtransaction, tx.serialize().hex(), 0)\n+                # Submit in a block\n+                msg = ','.join(utxo.spender.comment + (\"*\" if n == fail_input else \"\") for n, utxo in enumerate(input_utxos))\n+                self.block_submit(self.nodes[0], [tx], msg, witness=True, accept=fail_input == inputs, cb_pubkey=random.choice(host_pubkeys), fees=fee)\n+\n+    def build_spenders(self):\n+        VALID_SIGHASHES = [SIGHASH_DEFAULT, SIGHASH_ALL, SIGHASH_NONE, SIGHASH_SINGLE, SIGHASH_ANYONECANPAY + SIGHASH_ALL, \\\n+                SIGHASH_ANYONECANPAY + SIGHASH_NONE, SIGHASH_ANYONECANPAY + SIGHASH_SINGLE]\n+        spenders = []\n+\n+        # Two features: No annex, and annex with random number of random bytes.\n+        for annex in [None, bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+            # Non-empty annex is non-standard\n+            no_annex = annex is None\n+            sec1, sec2 = generate_privkey(), generate_privkey()\n+            pub1, _ = compute_xonly_pubkey(sec1)\n+            pub2, _ = compute_xonly_pubkey(sec2)\n+\n+            # Sighash mutation tests (test all sighash combinations)\n+            for hashtype in VALID_SIGHASHES:\n+                # Pure pubkey\n+                info = taproot_construct(pub1)\n+                # As an example, comment argument under this line means \"Sighash test for p2tr, spent through taproot key\".\n+                spender_sighash_mutation(spenders, info, \"sighash/pk#pk\", key=sec1, hashtype=hashtype, annex=annex, standard=no_annex)\n+                # Pubkey/P2PK script combination\n+                scripts = [CScript(random_checksig_style(pub2))]\n+                info = taproot_construct(pub1, scripts)\n+                # As an example, comment argument under this line means \"Sighash test for p2pk script in p2tr pubkey, spent through taproot key\".\n+                spender_sighash_mutation(spenders, info, \"sighash/p2pk#pk\", key=sec1, hashtype=hashtype, annex=annex, standard=no_annex)\n+                # As an example, comment argument under this line means \"Sighash test for p2pk script in p2tr pubkey, spent through p2pk key\".\n+                spender_sighash_mutation(spenders, info, \"sighash/p2pk#s0\", script=scripts[0], key=sec2, hashtype=hashtype, annex=annex, standard=no_annex)\n+\n+            # For more complex scripts only test one sighash type\n+            hashtype = random.choice(VALID_SIGHASHES)\n+            scripts = [\n+                CScript(random_checksig_style(pub2) + bytes([OP_CODESEPARATOR])),  # codesep after checksig\n+                CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pub2)),  # codesep before checksig\n+                CScript([bytes([1,2,3]), OP_DROP, OP_IF, OP_CODESEPARATOR, pub1, OP_ELSE, OP_CODESEPARATOR, pub2, OP_ENDIF, OP_CHECKSIG]),  # branch dependent codesep\n+            ]\n+            info = taproot_construct(pub1, scripts)\n+            spender_sighash_mutation(spenders, info, \"sighash/codesep#pk\", key=sec1, hashtype=hashtype, annex=annex, standard=no_annex)\n+            spender_sighash_mutation(spenders, info, \"sighash/codesep#s0\", script=scripts[0], key=sec2, hashtype=hashtype, annex=annex, standard=no_annex)\n+            spender_sighash_mutation(spenders, info, \"sighash/codesep#s1\", script=scripts[1], key=sec2, hashtype=hashtype, annex=annex, pos=0, standard=no_annex)\n+            spender_sighash_mutation(spenders, info, \"sighash/codesep#s2a\", script=scripts[2], key=sec1, hashtype=hashtype, annex=annex, pos=3, suffix=[bytes([1])], standard=no_annex)\n+            spender_sighash_mutation(spenders, info, \"sighash/codesep#s2b\", script=scripts[2], key=sec2, hashtype=hashtype, annex=annex, pos=6, suffix=[bytes([])], standard=no_annex)\n+\n+            # Taproot max Merkle path length\n+            scripts = [\n+                CScript([pub2, OP_CHECKSIG]),\n+                [\n+                    CScript([pub1, OP_CHECKSIG]),\n+                    CScript([OP_RETURN])\n+                ]\n+            ]\n+            info = taproot_construct(pub1, nested_script(scripts, 127))\n+            spender_two_paths(spenders, info, \"taproot/merklelimit\", standard=no_annex, success={\"key\": sec2, \"hashtype\": hashtype, \"annex\": annex, \"script\": scripts[0]}, failure={\"key\": sec1, \"hashtype\": hashtype, \"annex\": annex, \"script\": scripts[1][0]})\n+\n+            # Above OP_16 to avoid minimal encoding complaints\n+            checksigadd_val = random.randrange(17, 100)\n+            checksigadd_arg = CScriptNum(checksigadd_val)\n+            checksigadd_result = CScriptNum(checksigadd_val+1)\n+\n+            # Illegally-large number for script arithmetic input\n+            oversize_number = 2**31\n+            assert_equal(len(CScriptNum.encode(CScriptNum(oversize_number))), 6)\n+            assert_equal(len(CScriptNum.encode(CScriptNum(oversize_number-1))), 5)\n+\n+            # Various BIP342 features\n+            scripts = [\n+                # 0) drop stack element and OP_CHECKSIG\n+                CScript([OP_DROP, pub2, OP_CHECKSIG]),\n+                # 1) normal OP_CHECKSIG\n+                CScript([pub2, OP_CHECKSIG]),\n+                # 2) normal OP_CHECKSIGVERIFY\n+                CScript([pub2, OP_CHECKSIGVERIFY, OP_1]),\n+                # 3) Hypothetical OP_CHECKMULTISIG script that takes a single sig as input\n+                CScript([OP_0, OP_SWAP, OP_1, pub2, OP_1, OP_CHECKMULTISIG]),\n+                # 4) Hypothetical OP_CHECKMULTISIGVERIFY script that takes a single sig as input\n+                CScript([OP_0, OP_SWAP, OP_1, pub2, OP_1, OP_CHECKMULTISIGVERIFY, OP_1]),\n+                # 5) OP_IF script that needs a true input\n+                CScript([OP_IF, pub2, OP_CHECKSIG, OP_ELSE, OP_RETURN, OP_ENDIF]),\n+                # 6) OP_NOTIF script that needs a true input\n+                CScript([OP_NOTIF, OP_RETURN, OP_ELSE, pub2, OP_CHECKSIG, OP_ENDIF]),\n+                # 7) OP_CHECKSIG with an empty key\n+                CScript([OP_0, OP_CHECKSIG]),\n+                # 8) OP_CHECKSIGVERIFY with an empty key\n+                CScript([OP_0, OP_CHECKSIGVERIFY, OP_1]),\n+                # 9) normal OP_CHECKSIGADD that also ensures return value is correct\n+                CScript([OP_0, pub2, OP_CHECKSIGADD, OP_1, OP_EQUAL]),\n+                # 10) OP_CHECKSIGADD with empty key\n+                CScript([OP_0, OP_0, OP_CHECKSIGADD]),\n+                # 11) OP_CHECKSIGADD with missing counter stack element\n+                CScript([pub2, OP_CHECKSIGADD]),\n+                # 12) OP_CHECKSIG that needs invalid signature\n+                CScript([pub2, OP_CHECKSIGVERIFY, pub1, OP_CHECKSIG, OP_NOT]),\n+                # 13) OP_CHECKSIG with empty key that needs invalid signature\n+                CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_CHECKSIG, OP_NOT]),\n+                # 14) OP_CHECKSIGADD that needs invalid signature\n+                CScript([pub2, OP_CHECKSIGVERIFY, OP_0, pub1, OP_CHECKSIGADD, OP_NOT]),\n+                # 15) OP_CHECKSIGADD with empty key that needs invalid signature\n+                CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGADD, OP_NOT]),\n+                # 16) OP_CHECKSIG with unknown pubkey type\n+                CScript([OP_1, OP_CHECKSIG]),\n+                # 17) OP_CHECKSIGADD with unknown pubkey type\n+                CScript([OP_0, OP_1, OP_CHECKSIGADD]),\n+                # 18) OP_CHECKSIGVERIFY with unknown pubkey type\n+                CScript([OP_1, OP_CHECKSIGVERIFY, OP_1]),\n+                # 19) script longer than 10000 bytes and over 201 non-push opcodes\n+                CScript([OP_0, OP_0, OP_2DROP] * 10001 + [pub2, OP_CHECKSIG]),\n+                # 20) OP_CHECKSIGVERIFY with empty key\n+                CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGVERIFY, OP_1]),\n+                # 21) Script that grows the stack to 1000 elements\n+                CScript([pub2, OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 999 + [OP_DROP] * 999),\n+                # 22) Script that grows the stack to 1001 elements\n+                CScript([pub2, OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 1000 + [OP_DROP] * 1000),\n+                # 23) Script that expects an input stack of 1000 elements\n+                CScript([OP_DROP] * 999 + [pub2, OP_CHECKSIG]),\n+                # 24) Script that expects an input stack of 1001 elements\n+                CScript([OP_DROP] * 1000 + [pub2, OP_CHECKSIG]),\n+                # 25) Script that pushes a 520 byte element\n+                CScript([random_bytes(520), OP_DROP, pub2, OP_CHECKSIG]),\n+                # 26) Script that pushes a 521 byte element\n+                CScript([random_bytes(521), OP_DROP, pub2, OP_CHECKSIG]),\n+                # 27) Script that pushes a 521 byte element and OP_SUCCESSX\n+                CScript([random_bytes(521), OP_DROP, pub2, OP_CHECKSIG, random_op_success()]),\n+                # 28) Pushes random CScriptNum value, checks OP_CHECKSIGADD result\n+                CScript([checksigadd_arg, pub2, OP_CHECKSIGADD, checksigadd_result, OP_EQUAL]),\n+                # 30) CHECKSIGADD that succeeds with proper sig because numeric argument number is <=4 bytes\n+                CScript([CScriptNum(oversize_number-1), pub2, OP_CHECKSIGADD]),\n+                # 29) CHECKSIGADD that must fail because numeric argument number is >4 bytes\n+                CScript([CScriptNum(oversize_number), pub2, OP_CHECKSIGADD]),\n+            ]\n+            # For the next test we must predict the exact witness size\n+            witness_size = 141 + (hashtype != 0) + (0 if annex is None else len(annex) + 1)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r456992780",
      "id" : 456992780,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk5Mjc4MA==",
      "original_commit_id" : "42bda3592c3fc4d5169b2f53e80780ed46a0854c",
      "original_line" : 701,
      "original_position" : 655,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 451238404,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/456992780",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Squashed in some more functional test improvements by @instagibbs. The failed spenders no check for expected error messages in block validation.",
      "created_at" : "2020-07-21T20:55:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-662101568",
      "id" : 662101568,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2MjEwMTU2OA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-21T20:55:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/662101568",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459503234"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459503234"
         }
      },
      "author_association" : "MEMBER",
      "body" : "41d08f5d77f52bec0e31bb081d85fff2d67d0467: let's document that `uint256 GetPrevoutHash` and `GetSequenceHash` (now) return a single SHA256 hash.\r\n\r\nPerhaps we should rename them to GetPrevout**s**Hash and GetSequence**s**Hash, consistent with `GetSpentAmountsHash` and `GetSpentScriptsHash`.\r\n\r\nIn BIP-341 the phrasing is slightly ambiguous: \"sha_prevouts (32): the SHA256 of the serialization of all input outpoints.\" It could be more clear that this means concatenate all previous and then hash them, rather than to concatenate the hashes. Changing the variable name helps with that clarity too.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-23T14:43:20Z",
      "diff_hunk" : "@@ -1265,7 +1265,7 @@ uint256 GetPrevoutHash(const T& txTo)\n     for (const auto& txin : txTo.vin) {\n         ss << txin.prevout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459503234",
      "id" : 459503234,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUwMzIzNA==",
      "original_commit_id" : "41d08f5d77f52bec0e31bb081d85fff2d67d0467",
      "original_line" : 1362,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 454191846,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459503234",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459527853"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459527853"
         }
      },
      "author_association" : "MEMBER",
      "body" : "41d08f5d77f52bec0e31bb081d85fff2d67d0467: maybe rename to `m_prevouts_hash_v0` or `m_prevouts_double_hash`?\r\n\r\nIn addition, shouldn't we skip calculating hashes we don't need depending on the witness version? Or is that negligible for validation performance (sorry, too lazy to bench this myself)?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-23T15:16:08Z",
      "diff_hunk" : "@@ -1299,9 +1317,17 @@ void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_o\n \n     // Cache is calculated only for transactions with witness\n     if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+        m_prevouts_hash = GetPrevoutHash(txTo);\n+        hashPrevouts = SHA256Uint256(m_prevouts_hash);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459527853",
      "id" : 459527853,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUyNzg1Mw==",
      "original_commit_id" : "41d08f5d77f52bec0e31bb081d85fff2d67d0467",
      "original_line" : 1321,
      "original_position" : 53,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 454191846,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459527853",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459531548"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459531548"
         }
      },
      "author_association" : "MEMBER",
      "body" : "41d08f5d77f52bec0e31bb081d85fff2d67d0467 : `TapSighash` is written in camel case (`TapSigHash`) most of the time in BIP 341 (which would be my preference too).",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-23T15:21:08Z",
      "diff_hunk" : "@@ -1319,6 +1345,76 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459531548",
      "id" : 459531548,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUzMTU0OA==",
      "original_commit_id" : "41d08f5d77f52bec0e31bb081d85fff2d67d0467",
      "original_line" : 1348,
      "original_position" : 70,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 454191846,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459531548",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459653999"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459653999"
         }
      },
      "author_association" : "MEMBER",
      "body" : "41d08f5d77f52bec0e31bb081d85fff2d67d0467: `EPOCH` is explained in BIP-341, but missing from \"the message is the concatenation of the following data, in order\"",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-23T18:42:46Z",
      "diff_hunk" : "@@ -1319,6 +1345,76 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData* cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache != nullptr && cache->m_ready && cache->m_spent_outputs_ready);\n+\n+    CHashWriter ss = HasherTapSighash;\n+\n+    // Epoch\n+    static constexpr uint8_t EPOCH = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459653999",
      "id" : 459653999,
      "line" : 1496,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY1Mzk5OQ==",
      "original_commit_id" : "41d08f5d77f52bec0e31bb081d85fff2d67d0467",
      "original_line" : 1496,
      "original_position" : 89,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 338,
      "pull_request_review_id" : 454191846,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459653999",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459663568"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459663568"
         }
      },
      "author_association" : "MEMBER",
      "body" : "41d08f5: this could lead to confusion if a later upgrade adds and permits a new SIGHASH type, given that the BIP specifies this as a negative: \"If `hash_type & 3` does not equal `SIGHASH_NONE` or `SIGHASH_SINGLE`\".",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-23T19:00:01Z",
      "diff_hunk" : "@@ -1319,6 +1345,76 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData* cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache != nullptr && cache->m_ready && cache->m_spent_outputs_ready);\n+\n+    CHashWriter ss = HasherTapSighash;\n+\n+    // Epoch\n+    static constexpr uint8_t EPOCH = 0;\n+    ss << EPOCH;\n+\n+    // Hash type\n+    const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n+    const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;\n+    if (output_type != SIGHASH_ALL && output_type != SIGHASH_SINGLE && output_type != SIGHASH_NONE) return false;\n+    if (input_type != SIGHASH_ANYONECANPAY && input_type != 0) return false;\n+    ss << hash_type;\n+\n+    // Transaction level data\n+    ss << tx_to.nVersion;\n+    ss << tx_to.nLockTime;\n+    if (input_type != SIGHASH_ANYONECANPAY) {\n+        ss << cache->m_prevouts_hash;\n+        ss << cache->m_spent_amounts_hash;\n+        ss << cache->m_spent_scripts_hash;\n+        ss << cache->m_sequences_hash;\n+    }\n+    if (output_type == SIGHASH_ALL) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459663568",
      "id" : 459663568,
      "line" : 1514,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2MzU2OA==",
      "original_commit_id" : "41d08f5d77f52bec0e31bb081d85fff2d67d0467",
      "original_line" : 1514,
      "original_position" : 108,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 356,
      "pull_request_review_id" : 454191846,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459663568",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459665027"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459665027"
         }
      },
      "author_association" : "MEMBER",
      "body" : "41d08f5: The BIP (still?) says `0x50` (I see this completely changes in a later commit, so will revisit then)",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-23T19:02:48Z",
      "diff_hunk" : "@@ -1319,6 +1345,76 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData* cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache != nullptr && cache->m_ready && cache->m_spent_outputs_ready);\n+\n+    CHashWriter ss = HasherTapSighash;\n+\n+    // Epoch\n+    static constexpr uint8_t EPOCH = 0;\n+    ss << EPOCH;\n+\n+    // Hash type\n+    const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n+    const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;\n+    if (output_type != SIGHASH_ALL && output_type != SIGHASH_SINGLE && output_type != SIGHASH_NONE) return false;\n+    if (input_type != SIGHASH_ANYONECANPAY && input_type != 0) return false;\n+    ss << hash_type;\n+\n+    // Transaction level data\n+    ss << tx_to.nVersion;\n+    ss << tx_to.nLockTime;\n+    if (input_type != SIGHASH_ANYONECANPAY) {\n+        ss << cache->m_prevouts_hash;\n+        ss << cache->m_spent_amounts_hash;\n+        ss << cache->m_spent_scripts_hash;\n+        ss << cache->m_sequences_hash;\n+    }\n+    if (output_type == SIGHASH_ALL) {\n+        ss << cache->m_outputs_hash;\n+    }\n+\n+    // Data about the input/prevout being spent\n+    const auto* witstack = &tx_to.vin[in_pos].scriptWitness.stack;\n+    bool have_annex = witstack->size() > 1 && witstack->back().size() > 0 && witstack->back()[0] == 0xff;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459665027",
      "id" : 459665027,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2NTAyNw==",
      "original_commit_id" : "41d08f5d77f52bec0e31bb081d85fff2d67d0467",
      "original_line" : 1392,
      "original_position" : 114,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 454191846,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459665027",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459669929"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459669929"
         }
      },
      "author_association" : "MEMBER",
      "body" : "41d08f5d77f52bec0e31bb081d85fff2d67d0467 : isn't this missing a `compact_size(size of annex)` prefix?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-23T19:12:16Z",
      "diff_hunk" : "@@ -1319,6 +1345,76 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData* cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache != nullptr && cache->m_ready && cache->m_spent_outputs_ready);\n+\n+    CHashWriter ss = HasherTapSighash;\n+\n+    // Epoch\n+    static constexpr uint8_t EPOCH = 0;\n+    ss << EPOCH;\n+\n+    // Hash type\n+    const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n+    const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;\n+    if (output_type != SIGHASH_ALL && output_type != SIGHASH_SINGLE && output_type != SIGHASH_NONE) return false;\n+    if (input_type != SIGHASH_ANYONECANPAY && input_type != 0) return false;\n+    ss << hash_type;\n+\n+    // Transaction level data\n+    ss << tx_to.nVersion;\n+    ss << tx_to.nLockTime;\n+    if (input_type != SIGHASH_ANYONECANPAY) {\n+        ss << cache->m_prevouts_hash;\n+        ss << cache->m_spent_amounts_hash;\n+        ss << cache->m_spent_scripts_hash;\n+        ss << cache->m_sequences_hash;\n+    }\n+    if (output_type == SIGHASH_ALL) {\n+        ss << cache->m_outputs_hash;\n+    }\n+\n+    // Data about the input/prevout being spent\n+    const auto* witstack = &tx_to.vin[in_pos].scriptWitness.stack;\n+    bool have_annex = witstack->size() > 1 && witstack->back().size() > 0 && witstack->back()[0] == 0xff;\n+    const uint8_t spend_type = (ext_flag << 1) + (have_annex ? 1 : 0); // The low bit indicates whether an annex is present.\n+    ss << spend_type;\n+    if (input_type == SIGHASH_ANYONECANPAY) {\n+        ss << tx_to.vin[in_pos].prevout;\n+        ss << cache->m_spent_outputs[in_pos];\n+        ss << tx_to.vin[in_pos].nSequence;\n+    } else {\n+        ss << in_pos;\n+    }\n+    if (have_annex) {\n+        ss << (CHashWriter(SER_GETHASH, 0) << witstack->back()).GetSHA256();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459669929",
      "id" : 459669929,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY2OTkyOQ==",
      "original_commit_id" : "41d08f5d77f52bec0e31bb081d85fff2d67d0467",
      "original_line" : 1403,
      "original_position" : 125,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 454191846,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459669929",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459677698"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459677698"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I thought that was implicit with vector serializations like this.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-23T19:26:43Z",
      "diff_hunk" : "@@ -1319,6 +1345,76 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData* cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache != nullptr && cache->m_ready && cache->m_spent_outputs_ready);\n+\n+    CHashWriter ss = HasherTapSighash;\n+\n+    // Epoch\n+    static constexpr uint8_t EPOCH = 0;\n+    ss << EPOCH;\n+\n+    // Hash type\n+    const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n+    const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;\n+    if (output_type != SIGHASH_ALL && output_type != SIGHASH_SINGLE && output_type != SIGHASH_NONE) return false;\n+    if (input_type != SIGHASH_ANYONECANPAY && input_type != 0) return false;\n+    ss << hash_type;\n+\n+    // Transaction level data\n+    ss << tx_to.nVersion;\n+    ss << tx_to.nLockTime;\n+    if (input_type != SIGHASH_ANYONECANPAY) {\n+        ss << cache->m_prevouts_hash;\n+        ss << cache->m_spent_amounts_hash;\n+        ss << cache->m_spent_scripts_hash;\n+        ss << cache->m_sequences_hash;\n+    }\n+    if (output_type == SIGHASH_ALL) {\n+        ss << cache->m_outputs_hash;\n+    }\n+\n+    // Data about the input/prevout being spent\n+    const auto* witstack = &tx_to.vin[in_pos].scriptWitness.stack;\n+    bool have_annex = witstack->size() > 1 && witstack->back().size() > 0 && witstack->back()[0] == 0xff;\n+    const uint8_t spend_type = (ext_flag << 1) + (have_annex ? 1 : 0); // The low bit indicates whether an annex is present.\n+    ss << spend_type;\n+    if (input_type == SIGHASH_ANYONECANPAY) {\n+        ss << tx_to.vin[in_pos].prevout;\n+        ss << cache->m_spent_outputs[in_pos];\n+        ss << tx_to.vin[in_pos].nSequence;\n+    } else {\n+        ss << in_pos;\n+    }\n+    if (have_annex) {\n+        ss << (CHashWriter(SER_GETHASH, 0) << witstack->back()).GetSHA256();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459677698",
      "id" : 459677698,
      "in_reply_to_id" : 459669929,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY3NzY5OA==",
      "original_commit_id" : "41d08f5d77f52bec0e31bb081d85fff2d67d0467",
      "original_line" : 1403,
      "original_position" : 125,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 454431755,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459677698",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459686936"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459686936"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Having bumped my head against (missing) size bytes in serialisations, e.g with libwally, let's at least add a comment to that effect.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-23T19:44:59Z",
      "diff_hunk" : "@@ -1319,6 +1345,76 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData* cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache != nullptr && cache->m_ready && cache->m_spent_outputs_ready);\n+\n+    CHashWriter ss = HasherTapSighash;\n+\n+    // Epoch\n+    static constexpr uint8_t EPOCH = 0;\n+    ss << EPOCH;\n+\n+    // Hash type\n+    const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n+    const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;\n+    if (output_type != SIGHASH_ALL && output_type != SIGHASH_SINGLE && output_type != SIGHASH_NONE) return false;\n+    if (input_type != SIGHASH_ANYONECANPAY && input_type != 0) return false;\n+    ss << hash_type;\n+\n+    // Transaction level data\n+    ss << tx_to.nVersion;\n+    ss << tx_to.nLockTime;\n+    if (input_type != SIGHASH_ANYONECANPAY) {\n+        ss << cache->m_prevouts_hash;\n+        ss << cache->m_spent_amounts_hash;\n+        ss << cache->m_spent_scripts_hash;\n+        ss << cache->m_sequences_hash;\n+    }\n+    if (output_type == SIGHASH_ALL) {\n+        ss << cache->m_outputs_hash;\n+    }\n+\n+    // Data about the input/prevout being spent\n+    const auto* witstack = &tx_to.vin[in_pos].scriptWitness.stack;\n+    bool have_annex = witstack->size() > 1 && witstack->back().size() > 0 && witstack->back()[0] == 0xff;\n+    const uint8_t spend_type = (ext_flag << 1) + (have_annex ? 1 : 0); // The low bit indicates whether an annex is present.\n+    ss << spend_type;\n+    if (input_type == SIGHASH_ANYONECANPAY) {\n+        ss << tx_to.vin[in_pos].prevout;\n+        ss << cache->m_spent_outputs[in_pos];\n+        ss << tx_to.vin[in_pos].nSequence;\n+    } else {\n+        ss << in_pos;\n+    }\n+    if (have_annex) {\n+        ss << (CHashWriter(SER_GETHASH, 0) << witstack->back()).GetSHA256();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459686936",
      "id" : 459686936,
      "in_reply_to_id" : 459669929,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY4NjkzNg==",
      "original_commit_id" : "41d08f5d77f52bec0e31bb081d85fff2d67d0467",
      "original_line" : 1403,
      "original_position" : 125,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 454443375,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459686936",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459689700"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459689700"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Vectors are serialized everywhere this way. Do we need to add comments also to block, transaction inputs, transaction outputs, ADDR messages, all lists in the protocol, ...?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-23T19:50:45Z",
      "diff_hunk" : "@@ -1319,6 +1345,76 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData* cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache != nullptr && cache->m_ready && cache->m_spent_outputs_ready);\n+\n+    CHashWriter ss = HasherTapSighash;\n+\n+    // Epoch\n+    static constexpr uint8_t EPOCH = 0;\n+    ss << EPOCH;\n+\n+    // Hash type\n+    const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n+    const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;\n+    if (output_type != SIGHASH_ALL && output_type != SIGHASH_SINGLE && output_type != SIGHASH_NONE) return false;\n+    if (input_type != SIGHASH_ANYONECANPAY && input_type != 0) return false;\n+    ss << hash_type;\n+\n+    // Transaction level data\n+    ss << tx_to.nVersion;\n+    ss << tx_to.nLockTime;\n+    if (input_type != SIGHASH_ANYONECANPAY) {\n+        ss << cache->m_prevouts_hash;\n+        ss << cache->m_spent_amounts_hash;\n+        ss << cache->m_spent_scripts_hash;\n+        ss << cache->m_sequences_hash;\n+    }\n+    if (output_type == SIGHASH_ALL) {\n+        ss << cache->m_outputs_hash;\n+    }\n+\n+    // Data about the input/prevout being spent\n+    const auto* witstack = &tx_to.vin[in_pos].scriptWitness.stack;\n+    bool have_annex = witstack->size() > 1 && witstack->back().size() > 0 && witstack->back()[0] == 0xff;\n+    const uint8_t spend_type = (ext_flag << 1) + (have_annex ? 1 : 0); // The low bit indicates whether an annex is present.\n+    ss << spend_type;\n+    if (input_type == SIGHASH_ANYONECANPAY) {\n+        ss << tx_to.vin[in_pos].prevout;\n+        ss << cache->m_spent_outputs[in_pos];\n+        ss << tx_to.vin[in_pos].nSequence;\n+    } else {\n+        ss << in_pos;\n+    }\n+    if (have_annex) {\n+        ss << (CHashWriter(SER_GETHASH, 0) << witstack->back()).GetSHA256();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459689700",
      "id" : 459689700,
      "in_reply_to_id" : 459669929,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY4OTcwMA==",
      "original_commit_id" : "41d08f5d77f52bec0e31bb081d85fff2d67d0467",
      "original_line" : 1403,
      "original_position" : 125,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 454447001,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459689700",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459742867"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459742867"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "@Sjors please review \r\nhttps://github.com/bitcoin/bitcoin/pull/18071/files which proposes something similar.\r\n\r\n",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-23T21:38:43Z",
      "diff_hunk" : "@@ -1265,7 +1265,7 @@ uint256 GetPrevoutHash(const T& txTo)\n     for (const auto& txin : txTo.vin) {\n         ss << txin.prevout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459742867",
      "id" : 459742867,
      "in_reply_to_id" : 459503234,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc0Mjg2Nw==",
      "original_commit_id" : "41d08f5d77f52bec0e31bb081d85fff2d67d0467",
      "original_line" : 1362,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 454513752,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459742867",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459744786"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459744786"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "these are computed at the txn level, so you'd need to add some code which detects if there is no input of that type. Maybe worthwhile?\r\n\r\nBut keep in mind that taproot isn't calculating anything new, just caching the intermediate results...",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-23T21:42:54Z",
      "diff_hunk" : "@@ -1299,9 +1317,17 @@ void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_o\n \n     // Cache is calculated only for transactions with witness\n     if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+        m_prevouts_hash = GetPrevoutHash(txTo);\n+        hashPrevouts = SHA256Uint256(m_prevouts_hash);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459744786",
      "id" : 459744786,
      "in_reply_to_id" : 459527853,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc0NDc4Ng==",
      "original_commit_id" : "41d08f5d77f52bec0e31bb081d85fff2d67d0467",
      "original_line" : 1321,
      "original_position" : 53,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 454516006,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459744786",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459769788"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459769788"
         }
      },
      "author_association" : "NONE",
      "body" : "Hate to do this: capitalisation. Tagged hash",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-23T22:47:51Z",
      "diff_hunk" : "@@ -0,0 +1,230 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len = 16;\n+        /* Remove terminating null bytes */\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32] = { 0 };\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, (void*)ndata);\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    ret &= !secp256k1_scalar_is_zero(&k);\n+    secp256k1_scalar_cmov(&k, &secp256k1_scalar_one, !ret);\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    /* We declassify r to allow using it as a branch point. This is fine\n+     * because r is not a secret. */\n+    secp256k1_declassify(ctx, &r, sizeof(r));\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize_var(&r.x);\n+    secp256k1_fe_get_b32(&sig64[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459769788",
      "id" : 459769788,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc2OTc4OA==",
      "original_commit_id" : "ad51604f57aaa311529bd302e069c26dac818ad6",
      "original_line" : 162,
      "original_position" : 161,
      "original_start_line" : null,
      "path" : "src/secp256k1/src/modules/schnorrsig/main_impl.h",
      "position" : null,
      "pull_request_review_id" : 454545537,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459769788",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/2796318?v=4",
         "events_url" : "https://api.github.com/users/brmdbr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/brmdbr/followers",
         "following_url" : "https://api.github.com/users/brmdbr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/brmdbr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/brmdbr",
         "id" : 2796318,
         "login" : "brmdbr",
         "node_id" : "MDQ6VXNlcjI3OTYzMTg=",
         "organizations_url" : "https://api.github.com/users/brmdbr/orgs",
         "received_events_url" : "https://api.github.com/users/brmdbr/received_events",
         "repos_url" : "https://api.github.com/users/brmdbr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/brmdbr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/brmdbr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/brmdbr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459946237"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459946237"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Don't `m_spent_amounts_hash` and `m_spent_scripts_hash` (below) add two extra hash operations when verifying SegWit transactions?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-24T09:25:16Z",
      "diff_hunk" : "@@ -1299,9 +1317,17 @@ void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_o\n \n     // Cache is calculated only for transactions with witness\n     if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+        m_prevouts_hash = GetPrevoutHash(txTo);\n+        hashPrevouts = SHA256Uint256(m_prevouts_hash);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459946237",
      "id" : 459946237,
      "in_reply_to_id" : 459527853,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk0NjIzNw==",
      "original_commit_id" : "41d08f5d77f52bec0e31bb081d85fff2d67d0467",
      "original_line" : 1321,
      "original_position" : 53,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 454747939,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459946237",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459946492"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459946492"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`hash` is the wrong name for this param. It should be `input` to match the header declaration (although I think `preimage` would be better still).",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-24T09:25:48Z",
      "diff_hunk" : "@@ -77,3 +78,19 @@ void BIP32Hash(const ChainCode &chainCode, unsigned int nChild, unsigned char he\n     num[3] = (nChild >>  0) & 0xFF;\n     CHMAC_SHA512(chainCode.begin(), chainCode.size()).Write(&header, 1).Write(data, 32).Write(num, 4).Finalize(output);\n }\n+\n+CHashWriter TaggedHash(const std::string& tag)\n+{\n+    CHashWriter writer(SER_GETHASH, 0);\n+    uint256 taghash;\n+    CSHA256().Write((const unsigned char*)tag.data(), tag.size()).Finalize(taghash.begin());\n+    writer << taghash << taghash;\n+    return writer;\n+}\n+\n+uint256 SHA256Uint256(const uint256& hash)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459946492",
      "id" : 459946492,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk0NjQ5Mg==",
      "original_commit_id" : "ad51604f57aaa311529bd302e069c26dac818ad6",
      "original_line" : 91,
      "original_position" : 22,
      "original_start_line" : null,
      "path" : "src/hash.cpp",
      "position" : null,
      "pull_request_review_id" : 454748239,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459946492",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459946917"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459946917"
         }
      },
      "author_association" : "MEMBER",
      "body" : "No, you're right, it's actually the BIP that explicitly mentions it only here.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-24T09:26:45Z",
      "diff_hunk" : "@@ -1319,6 +1345,76 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData* cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache != nullptr && cache->m_ready && cache->m_spent_outputs_ready);\n+\n+    CHashWriter ss = HasherTapSighash;\n+\n+    // Epoch\n+    static constexpr uint8_t EPOCH = 0;\n+    ss << EPOCH;\n+\n+    // Hash type\n+    const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n+    const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;\n+    if (output_type != SIGHASH_ALL && output_type != SIGHASH_SINGLE && output_type != SIGHASH_NONE) return false;\n+    if (input_type != SIGHASH_ANYONECANPAY && input_type != 0) return false;\n+    ss << hash_type;\n+\n+    // Transaction level data\n+    ss << tx_to.nVersion;\n+    ss << tx_to.nLockTime;\n+    if (input_type != SIGHASH_ANYONECANPAY) {\n+        ss << cache->m_prevouts_hash;\n+        ss << cache->m_spent_amounts_hash;\n+        ss << cache->m_spent_scripts_hash;\n+        ss << cache->m_sequences_hash;\n+    }\n+    if (output_type == SIGHASH_ALL) {\n+        ss << cache->m_outputs_hash;\n+    }\n+\n+    // Data about the input/prevout being spent\n+    const auto* witstack = &tx_to.vin[in_pos].scriptWitness.stack;\n+    bool have_annex = witstack->size() > 1 && witstack->back().size() > 0 && witstack->back()[0] == 0xff;\n+    const uint8_t spend_type = (ext_flag << 1) + (have_annex ? 1 : 0); // The low bit indicates whether an annex is present.\n+    ss << spend_type;\n+    if (input_type == SIGHASH_ANYONECANPAY) {\n+        ss << tx_to.vin[in_pos].prevout;\n+        ss << cache->m_spent_outputs[in_pos];\n+        ss << tx_to.vin[in_pos].nSequence;\n+    } else {\n+        ss << in_pos;\n+    }\n+    if (have_annex) {\n+        ss << (CHashWriter(SER_GETHASH, 0) << witstack->back()).GetSHA256();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459946917",
      "id" : 459946917,
      "in_reply_to_id" : 459669929,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk0NjkxNw==",
      "original_commit_id" : "41d08f5d77f52bec0e31bb081d85fff2d67d0467",
      "original_line" : 1403,
      "original_position" : 125,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 454748777,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459946917",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459954502"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459954502"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I agree with @Sjors (https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459527853) that these should be renamed. `m_prevouts_hash` and `hashPrevouts` doesn't communicate that one of these members is the SHA256 digest and the other is the dSHA256 digest. I'd propose `m_prevouts_sha256` and `m_prevouts_double_sha256`, but anything that communicates what these are would be an improvement.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-24T09:44:01Z",
      "diff_hunk" : "@@ -114,33 +120,92 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making the use of (unknown) annexes non-standard (currently no annexes are known)\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 20),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 21),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    //! Single-SHA256 versions\n+    uint256 m_prevouts_hash, m_sequences_hash, m_outputs_hash, m_spent_amounts_hash, m_spent_scripts_hash;\n+    bool m_spent_outputs_ready = false;\n+\n+    //! Double-SHA256 versions\n     uint256 hashPrevouts, hashSequence, hashOutputs;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459954502",
      "id" : 459954502,
      "line" : 155,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1NDUwMg==",
      "original_commit_id" : "ad51604f57aaa311529bd302e069c26dac818ad6",
      "original_line" : 155,
      "original_position" : 55,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : 64,
      "pull_request_review_id" : 454748239,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459954502",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459958265"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459958265"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: sort :)",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-24T09:52:15Z",
      "diff_hunk" : "@@ -7,6 +7,17 @@\n keys, and is trivially vulnerable to side channel attacks. Do not use for\n anything but tests.\"\"\"\n import random\n+import hashlib",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459958265",
      "id" : 459958265,
      "line" : 11,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1ODI2NQ==",
      "original_commit_id" : "ad51604f57aaa311529bd302e069c26dac818ad6",
      "original_line" : 11,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : 12,
      "pull_request_review_id" : 454748239,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459958265",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459959814"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459959814"
         }
      },
      "author_association" : "MEMBER",
      "body" : "should this be `tweak_add_pubkey`?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-24T09:55:32Z",
      "diff_hunk" : "@@ -384,3 +420,125 @@ def sign_ecdsa(self, msg, low_s=True):\n         rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')\n         sb = s.to_bytes((s.bit_length() + 8) // 8, 'big')\n         return b'\\x30' + bytes([4 + len(rb) + len(sb), 2, len(rb)]) + rb + bytes([2, len(sb)]) + sb\n+\n+def compute_xonly_pubkey(key):\n+    \"\"\"Compute an x-only (32 byte) public key from a (32 byte) private key.\n+\n+    This also returns whether the resulting public key was negated.\n+    \"\"\"\n+\n+    assert(len(key) == 32)\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return (None, None)\n+    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, x)]))\n+    return (P[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(P))\n+\n+def tweak_privkey(key, tweak, negated=False):\n+    \"\"\"Tweak a private key (after optionally negating it).\"\"\"\n+\n+    assert(len(key) == 32)\n+    assert(len(tweak) == 32)\n+\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return None\n+    if negated:\n+       x = SECP256K1_ORDER - x\n+    t = int.from_bytes(tweak, 'big')\n+    if t >= SECP256K1_ORDER:\n+        return None\n+    x = (x + t) % SECP256K1_ORDER\n+    if x == 0:\n+        return None\n+    return x.to_bytes(32, 'big')\n+\n+def tweak_pubkey(key, tweak):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459959814",
      "id" : 459959814,
      "in_reply_to_id" : 455059451,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1OTgxNA==",
      "original_commit_id" : "98ea8e9b9ba27e0b2725f02c92c2e3a64e4fdeab",
      "original_line" : 459,
      "original_position" : 220,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 454748239,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/459959814",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460037618"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460037618"
         }
      },
      "author_association" : "MEMBER",
      "body" : "yeah looks like this didn't change",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-24T13:01:44Z",
      "diff_hunk" : "@@ -384,3 +420,125 @@ def sign_ecdsa(self, msg, low_s=True):\n         rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')\n         sb = s.to_bytes((s.bit_length() + 8) // 8, 'big')\n         return b'\\x30' + bytes([4 + len(rb) + len(sb), 2, len(rb)]) + rb + bytes([2, len(sb)]) + sb\n+\n+def compute_xonly_pubkey(key):\n+    \"\"\"Compute an x-only (32 byte) public key from a (32 byte) private key.\n+\n+    This also returns whether the resulting public key was negated.\n+    \"\"\"\n+\n+    assert(len(key) == 32)\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return (None, None)\n+    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, x)]))\n+    return (P[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(P))\n+\n+def tweak_privkey(key, tweak, negated=False):\n+    \"\"\"Tweak a private key (after optionally negating it).\"\"\"\n+\n+    assert(len(key) == 32)\n+    assert(len(tweak) == 32)\n+\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return None\n+    if negated:\n+       x = SECP256K1_ORDER - x\n+    t = int.from_bytes(tweak, 'big')\n+    if t >= SECP256K1_ORDER:\n+        return None\n+    x = (x + t) % SECP256K1_ORDER\n+    if x == 0:\n+        return None\n+    return x.to_bytes(32, 'big')\n+\n+def tweak_pubkey(key, tweak):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460037618",
      "id" : 460037618,
      "in_reply_to_id" : 455059451,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAzNzYxOA==",
      "original_commit_id" : "98ea8e9b9ba27e0b2725f02c92c2e3a64e4fdeab",
      "original_line" : 459,
      "original_position" : 220,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 454866583,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460037618",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460079736"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460079736"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: I would prefer the `execdata` before `serror`. Would also be more consistent with `ExecuteWitnessScript`.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-24T14:15:28Z",
      "diff_hunk" : "@@ -371,7 +371,7 @@ static bool EvalChecksig(const valtype& vchSig, const valtype& vchPubKey, CScrip\n     return true;\n }\n \n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)\n+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, ScriptExecutionData execdata)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460079736",
      "id" : 460079736,
      "line" : 432,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDA3OTczNg==",
      "original_commit_id" : "cbcaab9a66f82fa5bcc2711a5fee2adc47004cc8",
      "original_line" : 432,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 92,
      "pull_request_review_id" : 454922269,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460079736",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1322187?v=4",
         "events_url" : "https://api.github.com/users/fjahr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fjahr/followers",
         "following_url" : "https://api.github.com/users/fjahr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fjahr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fjahr",
         "id" : 1322187,
         "login" : "fjahr",
         "node_id" : "MDQ6VXNlcjEzMjIxODc=",
         "organizations_url" : "https://api.github.com/users/fjahr/orgs",
         "received_events_url" : "https://api.github.com/users/fjahr/received_events",
         "repos_url" : "https://api.github.com/users/fjahr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fjahr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fjahr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fjahr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460091608"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460091608"
         }
      },
      "author_association" : "MEMBER",
      "body" : "b7a7f6ab2ccc30e323a5396c27cb82ffd613550b nit: these comments could be introduced in 41d08f5d77f52bec0e31bb081d85fff2d67d0467 (which adds `TAPROOT = 2`)",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-24T14:33:58Z",
      "diff_hunk" : "@@ -146,14 +158,21 @@ struct PrecomputedTransactionData\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n-    TAPROOT = 2,\n+    BASE = 0,        //!< Bare scripts and P2SH redeemscripts; see BIP 16",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460091608",
      "id" : 460091608,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDA5MTYwOA==",
      "original_commit_id" : "b7a7f6ab2ccc30e323a5396c27cb82ffd613550b",
      "original_line" : 177,
      "original_position" : 26,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 454937759,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460091608",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460163407"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460163407"
         }
      },
      "author_association" : "MEMBER",
      "body" : "cbcaab9a66f82fa5bcc2711a5fee2adc47004cc8 nit: `m_annex_hash` is only initialized if `m_annex_present` is `true`, though I doubt it will confuse anyone. Alternate wordings:\r\n```cpp\r\n//! Whether m_annex_present is initialized\r\n```\r\n\r\nOr:\r\n```cpp\r\n //! Whether m_annex_present and (when needed) m_annex_hash are initialized.\r\n```",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-24T16:35:39Z",
      "diff_hunk" : "@@ -163,6 +163,16 @@ enum class SigVersion\n     TAPROOT = 2,     //!< Witness v1 with non-P2SH 32 byte program (Taproot), key path spending; see BIP 341\n };\n \n+struct ScriptExecutionData\n+{\n+    //! Whether m_annex_present and m_annex_hash are initialized.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460163407",
      "id" : 460163407,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2MzQwNw==",
      "original_commit_id" : "cbcaab9a66f82fa5bcc2711a5fee2adc47004cc8",
      "original_line" : 168,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 454937759,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460163407",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460173936"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460173936"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think these runtime constants tend to be formatted like normal variables in the rest of the code base, i.e. snake case. But there does not seem to be a particular rule on these in the style guide.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-24T16:54:49Z",
      "diff_hunk" : "@@ -1319,6 +1345,76 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460173936",
      "id" : 460173936,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE3MzkzNg==",
      "original_commit_id" : "41d08f5d77f52bec0e31bb081d85fff2d67d0467",
      "original_line" : 1348,
      "original_position" : 70,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 454922269,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460173936",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1322187?v=4",
         "events_url" : "https://api.github.com/users/fjahr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fjahr/followers",
         "following_url" : "https://api.github.com/users/fjahr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fjahr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fjahr",
         "id" : 1322187,
         "login" : "fjahr",
         "node_id" : "MDQ6VXNlcjEzMjIxODc=",
         "organizations_url" : "https://api.github.com/users/fjahr/orgs",
         "received_events_url" : "https://api.github.com/users/fjahr/received_events",
         "repos_url" : "https://api.github.com/users/fjahr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fjahr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fjahr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fjahr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460174647"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460174647"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "styleguide nit:\r\n```suggestion\r\n        for (unsigned int i = 0; i < tx.vin.size(); ++i) {\r\n```",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-24T16:56:08Z",
      "diff_hunk" : "@@ -1540,13 +1540,19 @@ bool CheckInputScripts(const CTransaction& tx, TxValidationState &state, const C\n     }\n \n     if (!txdata.m_ready) {\n-        txdata.Init(tx);\n+        std::vector<CTxOut> spent_outputs;\n+        spent_outputs.reserve(tx.vin.size());\n+\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460174647",
      "id" : 460174647,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE3NDY0Nw==",
      "original_commit_id" : "14d2178048ba7aecaf2e69a283968c6554c127cb",
      "original_line" : 1546,
      "original_position" : 8,
      "original_start_line" : null,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 454922269,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460174647",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1322187?v=4",
         "events_url" : "https://api.github.com/users/fjahr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fjahr/followers",
         "following_url" : "https://api.github.com/users/fjahr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fjahr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fjahr",
         "id" : 1322187,
         "login" : "fjahr",
         "node_id" : "MDQ6VXNlcjEzMjIxODc=",
         "organizations_url" : "https://api.github.com/users/fjahr/orgs",
         "received_events_url" : "https://api.github.com/users/fjahr/received_events",
         "repos_url" : "https://api.github.com/users/fjahr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fjahr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fjahr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fjahr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460187918"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460187918"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Perhaps the comment can be expanded to clarify how `success` is used by the caller:\r\n\r\n```\r\nIf script execution doesn't trigger an error, success is added to the stack.\r\nOP_CHECKSIGVERIFY immediately fails if success is false, whereas with\r\nOP_CHECKSIG(_ADD) it's up to the rest of the script to\r\ndecide what to do with the signature result, typically based on the number\r\nof non-empty signatures.\r\n```\r\n\r\nRenaming `success` to `did_sign` makes its purpose more clear (but we're kinda stuck with this variable name).",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-24T17:22:43Z",
      "diff_hunk" : "@@ -371,6 +368,67 @@ static bool EvalChecksig(const valtype& vchSig, const valtype& vchPubKey, CScrip\n     return true;\n }\n \n+static bool EvalChecksigTapscript(const valtype& sig, const valtype& pubkey, ScriptExecutionData& execdata, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& success)\n+{\n+    assert(sigversion == SigVersion::TAPSCRIPT);\n+\n+    /*\n+     *  The following validation sequence is consensus critical. Please note how --",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460187918",
      "id" : 460187918,
      "in_reply_to_id" : 454637523,
      "line" : 376,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4NzkxOA==",
      "original_commit_id" : "7cdc010c70aa5e65e6b8e149b7f22e2fc93697fc",
      "original_line" : 376,
      "original_position" : 26,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 36,
      "pull_request_review_id" : 454937759,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460187918",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460213001"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460213001"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I would find it marginally more readable to use `!sig.empty()` in the `if` statements below and move `success = !sig.empty();` all the way to the bottom. ",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-24T18:14:20Z",
      "diff_hunk" : "@@ -371,6 +368,67 @@ static bool EvalChecksig(const valtype& vchSig, const valtype& vchPubKey, CScrip\n     return true;\n }\n \n+static bool EvalChecksigTapscript(const valtype& sig, const valtype& pubkey, ScriptExecutionData& execdata, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& success)\n+{\n+    assert(sigversion == SigVersion::TAPSCRIPT);\n+\n+    /*\n+     *  The following validation sequence is consensus critical. Please note how --\n+     *    upgradable public key versions precede other rules;\n+     *    the script execution fails when using empty signature with invalid public key;\n+     *    the script execution fails when using non-empty invalid signature.\n+     */\n+    success = !sig.empty();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460213001",
      "id" : 460213001,
      "line" : 381,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIxMzAwMQ==",
      "original_commit_id" : "988d7a795cfc29b37c3ea3359fb69412ab04de53",
      "original_line" : 381,
      "original_position" : 31,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 41,
      "pull_request_review_id" : 454937759,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460213001",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460216726"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460216726"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n/** Helper for OP_CHECKSIG, OP_CHECKSIGVERIFY and OP_CHECKSIGADD\r\n```",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-24T18:22:02Z",
      "diff_hunk" : "@@ -371,6 +368,67 @@ static bool EvalChecksig(const valtype& vchSig, const valtype& vchPubKey, CScrip\n     return true;\n }\n \n+static bool EvalChecksigTapscript(const valtype& sig, const valtype& pubkey, ScriptExecutionData& execdata, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& success)\n+{\n+    assert(sigversion == SigVersion::TAPSCRIPT);\n+\n+    /*\n+     *  The following validation sequence is consensus critical. Please note how --\n+     *    upgradable public key versions precede other rules;\n+     *    the script execution fails when using empty signature with invalid public key;\n+     *    the script execution fails when using non-empty invalid signature.\n+     */\n+    success = !sig.empty();\n+    if (success) {\n+        // Implement the sigops/witnesssize ratio test.\n+        // Passing with an upgradable public key version is also counted.\n+        assert(execdata.m_validation_weight_left_init);\n+        execdata.m_validation_weight_left -= VALIDATION_WEIGHT_PER_SIGOP_PASSED;\n+        if (execdata.m_validation_weight_left < 0) {\n+            return set_error(serror, SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT);\n+        }\n+    }\n+    if (pubkey.size() == 0) {\n+        return set_error(serror, SCRIPT_ERR_PUBKEYTYPE);\n+    } else if (pubkey.size() == 32) {\n+        if (success && !checker.CheckSigSchnorr(sig, pubkey, sigversion, execdata)) {\n+            return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);\n+        }\n+    } else {\n+        /*\n+         *  New public key version softforks should be defined before this `else` block.\n+         *  Generally, the new code should not do anything but failing the script execution. To avoid\n+         *  consensus bugs, it should not modify any existing values (including success).\n+         */\n+        if ((flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE) != 0) {\n+            return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE);\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+/** Helper for OP_CHECKSIG and OP_CHECKSIGVERIFY",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460216726",
      "id" : 460216726,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIxNjcyNg==",
      "original_commit_id" : "988d7a795cfc29b37c3ea3359fb69412ab04de53",
      "original_line" : 411,
      "original_position" : 61,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 454937759,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460216726",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460235730"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460235730"
         }
      },
      "author_association" : "MEMBER",
      "body" : "But only if `OP_SUCCESSx` occurred earlier?  Is it worth the effort to check the whole script for `OP_SUCCESSx` before and then do second pass for other conditions?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-24T19:03:07Z",
      "diff_hunk" : "@@ -1634,6 +1737,30 @@ static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CS\n {\n     std::vector<valtype> stack{stack_span.begin(), stack_span.end()};\n \n+    if (sigversion == SigVersion::TAPSCRIPT) {\n+        // OP_SUCCESSx processing overrides everything, including stack element size limits\n+        CScript::const_iterator pc = scriptPubKey.begin();\n+        while (pc < scriptPubKey.end()) {\n+            opcodetype opcode;\n+            if (!scriptPubKey.GetOp(pc, opcode)) {\n+                // Note how this condition would not be reached if an unknown OP_SUCCESSx was found",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460235730",
      "id" : 460235730,
      "line" : 1780,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIzNTczMA==",
      "original_commit_id" : "988d7a795cfc29b37c3ea3359fb69412ab04de53",
      "original_line" : 1780,
      "original_position" : 221,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 485,
      "pull_request_review_id" : 454937759,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460235730",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460248927"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460248927"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "ah yes those are extra, but only when haswitness. I suppose we could add a function hasv1witness? ",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-24T19:32:16Z",
      "diff_hunk" : "@@ -1299,9 +1317,17 @@ void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_o\n \n     // Cache is calculated only for transactions with witness\n     if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+        m_prevouts_hash = GetPrevoutHash(txTo);\n+        hashPrevouts = SHA256Uint256(m_prevouts_hash);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460248927",
      "id" : 460248927,
      "in_reply_to_id" : 459527853,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI0ODkyNw==",
      "original_commit_id" : "41d08f5d77f52bec0e31bb081d85fff2d67d0467",
      "original_line" : 1321,
      "original_position" : 53,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 455136592,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460248927",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460252562"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460252562"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Nope, the spec is defined as first parsing the script into opcodes to check for OP_SUCCESSx, and then executing.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-24T19:40:23Z",
      "diff_hunk" : "@@ -1634,6 +1737,30 @@ static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CS\n {\n     std::vector<valtype> stack{stack_span.begin(), stack_span.end()};\n \n+    if (sigversion == SigVersion::TAPSCRIPT) {\n+        // OP_SUCCESSx processing overrides everything, including stack element size limits\n+        CScript::const_iterator pc = scriptPubKey.begin();\n+        while (pc < scriptPubKey.end()) {\n+            opcodetype opcode;\n+            if (!scriptPubKey.GetOp(pc, opcode)) {\n+                // Note how this condition would not be reached if an unknown OP_SUCCESSx was found",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460252562",
      "id" : 460252562,
      "in_reply_to_id" : 460235730,
      "line" : 1780,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI1MjU2Mg==",
      "original_commit_id" : "988d7a795cfc29b37c3ea3359fb69412ab04de53",
      "original_line" : 1780,
      "original_position" : 221,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 485,
      "pull_request_review_id" : 455141238,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460252562",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460252714"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460252714"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "so you should check for e.g. unexecuted branches as well.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-24T19:40:45Z",
      "diff_hunk" : "@@ -1634,6 +1737,30 @@ static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CS\n {\n     std::vector<valtype> stack{stack_span.begin(), stack_span.end()};\n \n+    if (sigversion == SigVersion::TAPSCRIPT) {\n+        // OP_SUCCESSx processing overrides everything, including stack element size limits\n+        CScript::const_iterator pc = scriptPubKey.begin();\n+        while (pc < scriptPubKey.end()) {\n+            opcodetype opcode;\n+            if (!scriptPubKey.GetOp(pc, opcode)) {\n+                // Note how this condition would not be reached if an unknown OP_SUCCESSx was found",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460252714",
      "id" : 460252714,
      "in_reply_to_id" : 460235730,
      "line" : 1780,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI1MjcxNA==",
      "original_commit_id" : "988d7a795cfc29b37c3ea3359fb69412ab04de53",
      "original_line" : 1780,
      "original_position" : 221,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 485,
      "pull_request_review_id" : 455141439,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460252714",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> Also reviewed [8594b77](https://github.com/bitcoin/bitcoin/commit/8594b77415c290089d2e88fd2c09dbfecef995ba) (BIP 340) until [988d7a7](https://github.com/bitcoin/bitcoin/commit/988d7a795cfc29b37c3ea3359fb69412ab04de53) (BIP 342)\r\n> \r\n> There's two future anticipated features the BIPs: batch-verification and annexes. Is there any proof of concept code that can be used to sanity check this PR (and the BIPs themselves)?\r\n\r\nNot sure if this is helpful but there's https://github.com/bitcoin-core/secp256k1/pull/760.",
      "created_at" : "2020-07-24T20:25:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-663719592",
      "id" : 663719592,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2MzcxOTU5Mg==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-24T20:25:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/663719592",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/1071625?v=4",
         "events_url" : "https://api.github.com/users/real-or-random/events{/privacy}",
         "followers_url" : "https://api.github.com/users/real-or-random/followers",
         "following_url" : "https://api.github.com/users/real-or-random/following{/other_user}",
         "gists_url" : "https://api.github.com/users/real-or-random/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/real-or-random",
         "id" : 1071625,
         "login" : "real-or-random",
         "node_id" : "MDQ6VXNlcjEwNzE2MjU=",
         "organizations_url" : "https://api.github.com/users/real-or-random/orgs",
         "received_events_url" : "https://api.github.com/users/real-or-random/received_events",
         "repos_url" : "https://api.github.com/users/real-or-random/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/real-or-random/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/real-or-random/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/real-or-random"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460286926"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460286926"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "https://github.com/bitcoin/bitcoin/pull/17977#pullrequestreview-348338789",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-24T21:02:56Z",
      "diff_hunk" : "@@ -163,6 +163,16 @@ enum class SigVersion\n     TAPROOT = 2,     //!< Witness v1 with non-P2SH 32 byte program (Taproot), key path spending; see BIP 341\n };\n \n+struct ScriptExecutionData\n+{\n+    //! Whether m_annex_present and m_annex_hash are initialized.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460286926",
      "id" : 460286926,
      "in_reply_to_id" : 460163407,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI4NjkyNg==",
      "original_commit_id" : "cbcaab9a66f82fa5bcc2711a5fee2adc47004cc8",
      "original_line" : 168,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 455184101,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460286926",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460376582"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460376582"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Afaik this code fails if it finds an unknown OPCODE _before_ OP_SUCCESSx, so then it doesn't match the spec?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-25T07:23:57Z",
      "diff_hunk" : "@@ -1634,6 +1737,30 @@ static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CS\n {\n     std::vector<valtype> stack{stack_span.begin(), stack_span.end()};\n \n+    if (sigversion == SigVersion::TAPSCRIPT) {\n+        // OP_SUCCESSx processing overrides everything, including stack element size limits\n+        CScript::const_iterator pc = scriptPubKey.begin();\n+        while (pc < scriptPubKey.end()) {\n+            opcodetype opcode;\n+            if (!scriptPubKey.GetOp(pc, opcode)) {\n+                // Note how this condition would not be reached if an unknown OP_SUCCESSx was found",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460376582",
      "id" : 460376582,
      "in_reply_to_id" : 460235730,
      "line" : 1780,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM3NjU4Mg==",
      "original_commit_id" : "988d7a795cfc29b37c3ea3359fb69412ab04de53",
      "original_line" : 1780,
      "original_position" : 221,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 485,
      "pull_request_review_id" : 455268192,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460376582",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460377065"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460377065"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Assuming this is in reply to https://github.com/bitcoin/bitcoin/pull/17977#discussion_r459531548\r\nThe string \"TapSighash\" itself, not the variable name, is consensus critical, because it gets hashed into transactions. So the code style guidelines aren't relevant.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-25T07:30:09Z",
      "diff_hunk" : "@@ -1319,6 +1345,76 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460377065",
      "id" : 460377065,
      "in_reply_to_id" : 460173936,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM3NzA2NQ==",
      "original_commit_id" : "41d08f5d77f52bec0e31bb081d85fff2d67d0467",
      "original_line" : 1348,
      "original_position" : 70,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 455268480,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460377065",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460377134"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460377134"
         }
      },
      "author_association" : "MEMBER",
      "body" : "If by unknown opcode you mean undecodable, no - because if an opcode can't be decoded, there are also no other opcodes decodable after it.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-25T07:30:38Z",
      "diff_hunk" : "@@ -1634,6 +1737,30 @@ static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CS\n {\n     std::vector<valtype> stack{stack_span.begin(), stack_span.end()};\n \n+    if (sigversion == SigVersion::TAPSCRIPT) {\n+        // OP_SUCCESSx processing overrides everything, including stack element size limits\n+        CScript::const_iterator pc = scriptPubKey.begin();\n+        while (pc < scriptPubKey.end()) {\n+            opcodetype opcode;\n+            if (!scriptPubKey.GetOp(pc, opcode)) {\n+                // Note how this condition would not be reached if an unknown OP_SUCCESSx was found",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460377134",
      "id" : 460377134,
      "in_reply_to_id" : 460235730,
      "line" : 1780,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM3NzEzNA==",
      "original_commit_id" : "988d7a795cfc29b37c3ea3359fb69412ab04de53",
      "original_line" : 1780,
      "original_position" : 221,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 485,
      "pull_request_review_id" : 455268530,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460377134",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460393487"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460393487"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It wasn't entirely clear to me what `GetScriptOp` does, in particular what happens if an `opcode` does not occur in the `opcodetype` enum, but [apparently this is fine](https://stackoverflow.com/a/18195408).",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-25T10:59:58Z",
      "diff_hunk" : "@@ -1634,6 +1737,30 @@ static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CS\n {\n     std::vector<valtype> stack{stack_span.begin(), stack_span.end()};\n \n+    if (sigversion == SigVersion::TAPSCRIPT) {\n+        // OP_SUCCESSx processing overrides everything, including stack element size limits\n+        CScript::const_iterator pc = scriptPubKey.begin();\n+        while (pc < scriptPubKey.end()) {\n+            opcodetype opcode;\n+            if (!scriptPubKey.GetOp(pc, opcode)) {\n+                // Note how this condition would not be reached if an unknown OP_SUCCESSx was found",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r460393487",
      "id" : 460393487,
      "in_reply_to_id" : 460235730,
      "line" : 1780,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM5MzQ4Nw==",
      "original_commit_id" : "988d7a795cfc29b37c3ea3359fb69412ab04de53",
      "original_line" : 1780,
      "original_position" : 221,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 485,
      "pull_request_review_id" : 455278389,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/460393487",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461316019"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461316019"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I still have to do this.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-28T04:49:48Z",
      "diff_hunk" : "@@ -0,0 +1,745 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS,\n+)\n+from test_framework.messages import CTransaction, CTxIn, CTxOut, COutPoint, CTxInWitness\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_1SUB,\n+    OP_1NEGATE,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIF,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, hex_str_to_bytes, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey\n+from test_framework.address import program_to_witness, script_to_p2sh, hash160\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+import struct\n+\n+EMPTYWITNESS_ERROR = \"non-mandatory-script-verify-flag (Witness program was passed an empty witness) (code 64)\"\n+INVALIDKEYPATHSIG_ERROR = \"non-mandatory-script-verify-flag (Invalid signature for Taproot key path spending) (code 64)\"\n+UNKNOWNWITNESS_ERROR = \"non-mandatory-script-verify-flag (Witness version reserved for soft-fork upgrades) (code 64)\"\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+def tx_from_hex(hexstring):\n+    tx = CTransaction()\n+    f = BytesIO(hex_str_to_bytes(hexstring))\n+    tx.deserialize(f)\n+    return tx\n+\n+def get_taproot_bech32(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return program_to_witness(1, info[2:])\n+\n+def get_version1_p2sh(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return script_to_p2sh(info)\n+\n+def get_p2sh_spk(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return CScript([OP_HASH160, hash160(info), OP_EQUAL])\n+\n+def random_op_success():\n+    ret = 0\n+    while (not is_op_success(ret)):\n+        ret = random.randint(0x50, 0xfe)\n+    return CScriptOp(ret)\n+\n+def random_unknown_leaf_ver(no_annex_tag=True):\n+    ret = LEAF_VERSION_TAPSCRIPT\n+    while (ret == LEAF_VERSION_TAPSCRIPT or (no_annex_tag and ret == (ANNEX_TAG & 0xfe))):\n+        ret = random.randrange(128) * 2\n+    return ret\n+\n+def random_bytes(n):\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+# TODO-TAPROOT Use this in a test\n+def random_script(size, no_success=True):\n+    ret = bytes()\n+    while (len(ret) < size):\n+        remain = size - len(ret)\n+        opcode = random.randrange(256)\n+        while (no_success and is_op_success(opcode)):\n+            opcode = random.randrange(256)\n+        if opcode == 0 or opcode >= OP_1NEGATE:\n+            ret += bytes([opcode])\n+        elif opcode <= 75 and opcode <= remain - 1:\n+            ret += bytes([opcode]) + random_bytes(opcode)\n+        elif opcode == 76 and remain >= 2:\n+            pushsize = random.randint(0, min(0xff, remain - 2))\n+            ret += bytes([opcode]) + bytes([pushsize]) + random_bytes(pushsize)\n+        elif opcode == 77 and remain >= 3:\n+            pushsize = random.randint(0, min(0xffff, remain - 3))\n+            ret += bytes([opcode]) + struct.pack(b'<H', pushsize) + random_bytes(pushsize)\n+        elif opcode == 78 and remain >= 5:\n+            pushsize = random.randint(0, min(0xffffffff, remain - 5))\n+            ret += bytes([opcode]) + struct.pack(b'<I', pushsize) + random_bytes(pushsize)\n+    assert len(ret) == size\n+    return ret\n+\n+# TODO-TAPROOT Use this in a test\n+def random_invalid_push(size):\n+    assert size > 0\n+    ret = bytes()\n+    opcode = 78\n+    if size <= 75:\n+        opcode = random.randint(75, 78)\n+    elif size <= 255:\n+        opcode = random.randint(76, 78)\n+    elif size <= 0xffff:\n+        opcode = random.randint(77, 78)\n+    if opcode == 75:\n+        ret = bytes([size]) + random_bytes(size - 1)\n+    elif opcode == 76:\n+        ret = bytes([opcode]) + bytes([size]) + random_bytes(size - 2)\n+    elif opcode == 77:\n+        ret = bytes([opcode]) + struct.pack(b'<H', size) + random_bytes(max(0, size - 3))\n+    else:\n+        ret = bytes([opcode]) + struct.pack(b'<I', size) + random_bytes(max(0, size - 5))\n+    assert len(ret) >= size\n+    return ret[:size]\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def damage_bytes(b):\n+    \"\"\"Flips one bit at random in a byte string.\"\"\"\n+    return (int.from_bytes(b, 'big') ^ (1 << random.randrange(len(b) * 8))).to_bytes(len(b), 'big')\n+\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - An address for that scriptPubKey (string)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A witness stack-producing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+\n+Spender = namedtuple(\"Spender\", \"script,address,comment,is_standard,sat_function\")\n+\n+def spend_no_sig(tx, input_index, spent_utxos, info, script):\n+    \"\"\"Construct witness.\"\"\"\n+    script = script[\"script\"]\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = [script, info[2][script]]\n+\n+def spend_single_sig(tx, input_index, spent_utxos, info, key, annex=None, hashtype=0, prefix=None, suffix=None, script=None, pos=-1, damage=False):\n+    if prefix is None:\n+        prefix = []\n+    if suffix is None:\n+        suffix = []\n+\n+    ht = hashtype\n+\n+    damage_type = random.randrange(5) if damage else -1\n+    '''\n+    * 0. bit flip the sighash\n+    * 1. bit flip the signature\n+    * If the expected hashtype is 0:\n+    -- 2. append a 0 to the signature\n+    -- 3. append a random value of 1-255 to the signature\n+    * If the expected hashtype is not 0:\n+    -- 2. do not append hashtype to the signature\n+    -- 3. append a random incorrect value of 0-255 to the signature\n+    * 4. extra witness element\n+    '''\n+\n+    # Taproot key path spend: tweak key\n+    if script is None:\n+        _, negated = compute_xonly_pubkey(key)\n+        key = tweak_add_privkey(key, info[1], negated)\n+        assert(key is not None)\n+\n+    # Change SIGHASH_SINGLE into SIGHASH_ALL if no corresponding output\n+    if (ht & 3 == SIGHASH_SINGLE and input_index >= len(tx.vout)):\n+        ht ^= 2\n+    # Compute sighash\n+    if script:\n+        sighash = TaprootSignatureHash(tx, spent_utxos, ht, input_index, scriptpath=True, script=script, codeseparator_pos=pos, annex=annex)\n+    else:\n+        sighash = TaprootSignatureHash(tx, spent_utxos, ht, input_index, scriptpath=False, annex=annex)\n+    if damage_type == 0:\n+        sighash = damage_bytes(sighash)\n+    # Compute signature\n+    sig = sign_schnorr(key, sighash)\n+    if damage_type == 1:\n+        sig = damage_bytes(sig)\n+    if damage_type == 2:\n+        if ht == 0:\n+            sig += bytes([0])\n+    elif damage_type == 3:\n+        random_ht = ht\n+        while random_ht == ht:\n+            random_ht = random.randrange(256)\n+        sig += bytes([random_ht])\n+    elif ht > 0:\n+        sig += bytes([ht])\n+    # Construct witness\n+    ret = prefix + [sig] + suffix\n+    if script is not None:\n+        ret += [script, info[2][script]]\n+    if annex is not None:\n+        ret += [annex]\n+    if damage_type == 4:\n+        ret = [random_bytes(random.randrange(5))] + ret\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = ret\n+\n+def spend_alwaysvalid(tx, input_index, info, script, annex=None, damage=False):\n+    if isinstance(script, tuple):\n+        version, script = script\n+    ret = [script, info[2][script]]\n+    if damage:\n+        # With 50% chance, we bit flip the script (unless the script is an empty vector)\n+        # With 50% chance, we bit flip the control block\n+        if random.choice([True, False]) or len(ret[0]) == 0:\n+            # Annex is always required for leaf version 0x50\n+            # Unless the original version is 0x50, we couldn't convert it to 0x50 without using annex\n+            tmp = damage_bytes(ret[1])\n+            while annex is None and tmp[0] == ANNEX_TAG and ret[1][0] != ANNEX_TAG:\n+                tmp = damage_bytes(ret[1])\n+            ret[1] = tmp\n+        else:\n+            ret[0] = damage_bytes(ret[0])\n+    if annex is not None:\n+        ret += [annex]\n+    # Randomly add input witness\n+    if random.choice([True, False]):\n+        for i in range(random.randint(1, 10)):\n+            ret = [random_bytes(random.randint(0, MAX_SCRIPT_ELEMENT_SIZE * 2))] + ret\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = ret\n+\n+# N.B. Function arguments below: t(ransaction), i(ndex to spend), u(txos being spent), v(alid signature?)\n+\n+def spender_sighash_mutation(spenders, info, comment, standard=True, **kwargs):\n+    \"\"\"Mutates signature randomly when failure for the inputs is requested.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_single_sig(t, i, u, damage=not v, info=info, **kwargs)\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn))\n+\n+def spender_two_paths(spenders, info, comment, standard, success, failure):\n+    \"\"\"Gives caller a way to specify two merkle paths to test validity satisfaction: One expected success, and one failure.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_single_sig(t, i, u, damage=False, info=info, **(success if v else failure))\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn))\n+\n+def spender_alwaysvalid(spenders, info, comment, **kwargs):\n+    \"\"\"Mutates the witness when requested, intended for otherwise always true scripts.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_alwaysvalid(t, i, damage=not v, info=info, **kwargs)\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=False, sat_function=fn))\n+\n+def spender_two_paths_alwaysvalid(spenders, info, comment, standard, success, failure):\n+    \"\"\"Allows specifying both a success and failure script without any signatures or additional witness data required.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_no_sig(t, i, u, info, (success if v else failure))\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn))\n+\n+def spender_alwaysvalid_p2sh(spenders, info, comment, standard, script):\n+    \"\"\"Tests that p2sh-wrapping witness program v1 are always valid, since they are not covered by tapscript.\"\"\"\n+    spk = get_p2sh_spk(info)\n+    addr = get_version1_p2sh(info)\n+\n+    def fn(t, i, u, v):\n+        if v:\n+            t.vin[i].scriptSig = CScript([info[0]])\n+            # Empty control block is only invalid if we apply taproot rules,\n+            # which we shouldn't if the spend is wrapped in P2SH\n+            t.wit.vtxinwit[i].scriptWitness.stack = [script, bytes()]\n+        else:\n+            t.vin[i].scriptSig = CScript()\n+        return\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn))\n+\n+def spender_two_paths_no_sig(spenders, info, comment, standard, success, failure):\n+    \"\"\"Same as spender_two_paths but not support for signatures or padding witness.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    # Empty witness required\n+    def fn(t, i, u, v):\n+        return []\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn))\n+\n+def nested_script(script, depth):\n+    if depth == 0:\n+        return script\n+    return [nested_script(script, depth - 1), CScript([OP_RETURN])]\n+\n+UTXOData = namedtuple('UTXOData', 'input,output,spender')\n+\n+class TaprootTest(BitcoinTestFramework):\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.extra_args = [[\"-whitelist=127.0.0.1\", \"-par=1\"]]\n+\n+    def block_submit(self, node, txs, msg, cb_pubkey=None, fees=0, witness=False, accept=False):\n+\n+        # Deplete block of any non-tapscript sigops using a single additional 0-value coinbase output\n+        # It's physically impossible to fit enough tapscript sigops to hit the old 80k limit without\n+        # busting txin-level limits. We simply have to account for the p2pk outputs in all\n+        # transactions. N.B. this test means no spenders can ever spend non-taproot/tapscript outputs,\n+        # or those at least have to be accounted for here.\n+\n+        def MaybeIsPayToPubKey(script):\n+            return script[-1] == OP_CHECKSIG\n+\n+        legacy_checksigs = 0 if cb_pubkey is None else 1 # P2PK output in coinbase back to wallet\n+        for tx in txs:\n+            for output in tx.vout:\n+                if MaybeIsPayToPubKey(output.scriptPubKey):\n+                    legacy_checksigs += 1\n+        extra_output_script = CScript([OP_CHECKSIG]*(MAX_BLOCK_SIGOPS-legacy_checksigs))\n+\n+        block = create_block(self.tip, create_coinbase(self.lastblockheight + 1, pubkey=cb_pubkey, extra_output_script=extra_output_script, fees=fees), self.lastblocktime + 1)\n+        block.nVersion = 4\n+        for tx in txs:\n+            tx.rehash()\n+            block.vtx.append(tx)\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        witness and add_witness_commitment(block)\n+        block.rehash()\n+        block.solve()\n+        node.submitblock(block.serialize(True).hex())\n+        if (accept):\n+            assert node.getbestblockhash() == block.hash, \"Failed to accept: \" + msg\n+            self.tip = block.sha256\n+            self.lastblockhash = block.hash\n+            self.lastblocktime += 1\n+            self.lastblockheight += 1\n+        else:\n+            assert node.getbestblockhash() == self.lastblockhash, \"Failed to reject: \" + msg\n+\n+    def test_spenders(self, spenders, input_counts):\n+        \"\"\"Run randomized tests with a number of \"spenders\".\n+\n+        Steps:\n+            1) Generate an appropriate UTXO for each spender to test spend conditions\n+            2) Generate 100 random addresses of all wallet types: pkh/sh_wpkh/wpkh\n+            3) Select random number of inputs from (1)\n+            4) Select random number of addresses from (2) as outputs\n+\n+        Each spender embodies a test; in a large randomized test, it is verified\n+        that toggling the valid argument to each lambda toggles the validity of\n+        the transaction. This is accomplished by constructing transactions consisting\n+        of all valid inputs, except one invalid one.\n+        \"\"\"\n+\n+        # Construct a UTXO to spend for each of the spenders, with the script to satisfy being given by the spender\n+        self.nodes[0].generate(110)\n+        bal = self.nodes[0].getbalance() * 3 / (4 * len(spenders))\n+        random.shuffle(spenders)\n+        num_spenders = len(spenders)\n+        utxos = []\n+        while len(spenders):\n+            # Create the necessary outputs in multiple transactions, as sPKs may be repeated in test cases(which sendmany does not support)\n+            outputs = {}\n+            new_spenders = []\n+            batch = []\n+            for spender in spenders:\n+                addr = spender.address\n+                if len(batch) == 100 or addr in outputs:\n+                    new_spenders.append(spender)\n+                else:\n+                    amount = random.randrange(int(bal * 95000000), int(bal * 105000000))\n+                    outputs[addr] = amount / 100000000\n+                    batch.append(spender)\n+            self.log.info(\"Constructing %i UTXOs for spending tests\" % len(batch))\n+            tx = tx_from_hex(self.nodes[0].getrawtransaction(self.nodes[0].sendmany(\"\", outputs)))\n+            tx.rehash()\n+            spenders = new_spenders\n+            random.shuffle(spenders)\n+\n+            # Map created UTXOs back to the spenders they were created for\n+            for n, out in enumerate(tx.vout):\n+                for spender in batch:\n+                    if out.scriptPubKey == spender.script:\n+                        utxos.append(UTXOData(input=COutPoint(tx.sha256, n), output=out, spender=spender))\n+                        break\n+        assert(len(utxos) == num_spenders)\n+        random.shuffle(utxos)\n+        self.nodes[0].generate(1)\n+\n+        # Construct a bunch of sPKs that send coins back to the host wallet\n+        self.log.info(\"Constructing 100 addresses for returning coins\")\n+        host_spks = []\n+        host_pubkeys = []\n+        for i in range(100):\n+            addr = self.nodes[0].getnewaddress(address_type=random.choice([\"legacy\", \"p2sh-segwit\", \"bech32\"]))\n+            info = self.nodes[0].getaddressinfo(addr)\n+            spk = hex_str_to_bytes(info['scriptPubKey'])\n+            host_spks.append(spk)\n+            host_pubkeys.append(hex_str_to_bytes(info['pubkey']))\n+\n+        # Pick random subsets of UTXOs to construct transactions with\n+        self.lastblockhash = self.nodes[0].getbestblockhash()\n+        self.tip = int(\"0x\" + self.lastblockhash, 0)\n+        block = self.nodes[0].getblock(self.lastblockhash)\n+        self.lastblockheight = block['height']\n+        self.lastblocktime = block['time']\n+        while len(utxos):\n+            tx = CTransaction()\n+            tx.nVersion = random.choice([1, 2, random.randint(-0x80000000, 0x7fffffff)])\n+            min_sequence = (tx.nVersion != 1 and tx.nVersion != 0) * 0x80000000  # The minimum sequence number to disable relative locktime\n+            if random.choice([True, False]):\n+                tx.nLockTime = random.randrange(LOCKTIME_THRESHOLD, self.lastblocktime - 7200)  # all absolute locktimes in the past\n+            else:\n+                tx.nLockTime = random.randrange(self.lastblockheight + 1)  # all block heights in the past\n+\n+            # Pick 1 to 4 UTXOs to construct transaction inputs\n+            acceptable_input_counts = [cnt for cnt in input_counts if cnt <= len(utxos)]\n+            while True:\n+                inputs = random.choice(acceptable_input_counts)\n+                remaining = len(utxos) - inputs\n+                if remaining == 0 or remaining >= max(input_counts) or remaining in input_counts:\n+                    break\n+            input_utxos = utxos[-inputs:]\n+            utxos = utxos[:-inputs]\n+            fee = random.randrange(MIN_FEE * 2, MIN_FEE * 4)  # 10000-20000 sat fee\n+            in_value = sum(utxo.output.nValue for utxo in input_utxos) - fee\n+            tx.vin = [CTxIn(outpoint=input_utxos[i].input, nSequence=random.randint(min_sequence, 0xffffffff)) for i in range(inputs)]\n+            tx.wit.vtxinwit = [CTxInWitness() for i in range(inputs)]\n+            self.log.info(\"Test: %s\" % (\", \".join(utxo.spender.comment for utxo in input_utxos)))\n+\n+            # Add 1 to 4 outputs\n+            outputs = random.choice([1, 2, 3, 4])\n+            assert in_value >= 0 and fee - outputs * DUST_LIMIT >= MIN_FEE\n+            for i in range(outputs):\n+                tx.vout.append(CTxOut())\n+                if in_value <= DUST_LIMIT:\n+                    tx.vout[-1].nValue = DUST_LIMIT\n+                elif i < outputs - 1:\n+                    tx.vout[-1].nValue = in_value\n+                else:\n+                    tx.vout[-1].nValue = random.randint(DUST_LIMIT, in_value)\n+                in_value -= tx.vout[-1].nValue\n+                tx.vout[-1].scriptPubKey = random.choice(host_spks)\n+            fee += in_value\n+            assert(fee >= 0)\n+\n+            # Sign each input incorrectly once on each complete signing pass, except the very last\n+            for fail_input in range(inputs + 1):\n+                # Wipe scriptSig/witness\n+                for i in range(inputs):\n+                    tx.vin[i].scriptSig = CScript()\n+                    tx.wit.vtxinwit[i] = CTxInWitness()\n+                # Fill inputs/witnesses\n+                for i in range(inputs):\n+                    fn = input_utxos[i].spender.sat_function\n+                    fn(tx, i, [utxo.output for utxo in input_utxos], i != fail_input)\n+                # Submit to mempool to check standardness\n+                is_standard_tx = fail_input == inputs and all(utxo.spender.is_standard for utxo in input_utxos) and tx.nVersion >= 1 and tx.nVersion <= 2\n+                tx.rehash()\n+                if is_standard_tx:\n+                    self.nodes[0].sendrawtransaction(tx.serialize().hex(), 0)\n+                    assert(self.nodes[0].getmempoolentry(tx.hash) is not None)\n+                else:\n+                    assert_raises_rpc_error(-26, None, self.nodes[0].sendrawtransaction, tx.serialize().hex(), 0)\n+                # Submit in a block\n+                msg = ','.join(utxo.spender.comment + (\"*\" if n == fail_input else \"\") for n, utxo in enumerate(input_utxos))\n+                self.block_submit(self.nodes[0], [tx], msg, witness=True, accept=fail_input == inputs, cb_pubkey=random.choice(host_pubkeys), fees=fee)\n+\n+    def build_spenders(self):\n+        VALID_SIGHASHES = [SIGHASH_DEFAULT, SIGHASH_ALL, SIGHASH_NONE, SIGHASH_SINGLE, SIGHASH_ANYONECANPAY + SIGHASH_ALL, \\\n+                SIGHASH_ANYONECANPAY + SIGHASH_NONE, SIGHASH_ANYONECANPAY + SIGHASH_SINGLE]\n+        spenders = []\n+\n+        # Two features: No annex, and annex with random number of random bytes.\n+        for annex in [None, bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+            # Non-empty annex is non-standard\n+            no_annex = annex is None\n+            sec1, sec2 = generate_privkey(), generate_privkey()\n+            pub1, _ = compute_xonly_pubkey(sec1)\n+            pub2, _ = compute_xonly_pubkey(sec2)\n+\n+            # Sighash mutation tests (test all sighash combinations)\n+            for hashtype in VALID_SIGHASHES:\n+                # Pure pubkey\n+                info = taproot_construct(pub1)\n+                # As an example, comment argument under this line means \"Sighash test for p2tr, spent through taproot key\".\n+                spender_sighash_mutation(spenders, info, \"sighash/pk#pk\", key=sec1, hashtype=hashtype, annex=annex, standard=no_annex)\n+                # Pubkey/P2PK script combination\n+                scripts = [CScript(random_checksig_style(pub2))]\n+                info = taproot_construct(pub1, scripts)\n+                # As an example, comment argument under this line means \"Sighash test for p2pk script in p2tr pubkey, spent through taproot key\".\n+                spender_sighash_mutation(spenders, info, \"sighash/p2pk#pk\", key=sec1, hashtype=hashtype, annex=annex, standard=no_annex)\n+                # As an example, comment argument under this line means \"Sighash test for p2pk script in p2tr pubkey, spent through p2pk key\".\n+                spender_sighash_mutation(spenders, info, \"sighash/p2pk#s0\", script=scripts[0], key=sec2, hashtype=hashtype, annex=annex, standard=no_annex)\n+\n+            # For more complex scripts only test one sighash type\n+            hashtype = random.choice(VALID_SIGHASHES)\n+            scripts = [\n+                CScript(random_checksig_style(pub2) + bytes([OP_CODESEPARATOR])),  # codesep after checksig\n+                CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pub2)),  # codesep before checksig\n+                CScript([bytes([1,2,3]), OP_DROP, OP_IF, OP_CODESEPARATOR, pub1, OP_ELSE, OP_CODESEPARATOR, pub2, OP_ENDIF, OP_CHECKSIG]),  # branch dependent codesep\n+            ]\n+            info = taproot_construct(pub1, scripts)\n+            spender_sighash_mutation(spenders, info, \"sighash/codesep#pk\", key=sec1, hashtype=hashtype, annex=annex, standard=no_annex)\n+            spender_sighash_mutation(spenders, info, \"sighash/codesep#s0\", script=scripts[0], key=sec2, hashtype=hashtype, annex=annex, standard=no_annex)\n+            spender_sighash_mutation(spenders, info, \"sighash/codesep#s1\", script=scripts[1], key=sec2, hashtype=hashtype, annex=annex, pos=0, standard=no_annex)\n+            spender_sighash_mutation(spenders, info, \"sighash/codesep#s2a\", script=scripts[2], key=sec1, hashtype=hashtype, annex=annex, pos=3, suffix=[bytes([1])], standard=no_annex)\n+            spender_sighash_mutation(spenders, info, \"sighash/codesep#s2b\", script=scripts[2], key=sec2, hashtype=hashtype, annex=annex, pos=6, suffix=[bytes([])], standard=no_annex)\n+\n+            # Taproot max Merkle path length\n+            scripts = [\n+                CScript([pub2, OP_CHECKSIG]),\n+                [\n+                    CScript([pub1, OP_CHECKSIG]),\n+                    CScript([OP_RETURN])\n+                ]\n+            ]\n+            info = taproot_construct(pub1, nested_script(scripts, 127))\n+            spender_two_paths(spenders, info, \"taproot/merklelimit\", standard=no_annex, success={\"key\": sec2, \"hashtype\": hashtype, \"annex\": annex, \"script\": scripts[0]}, failure={\"key\": sec1, \"hashtype\": hashtype, \"annex\": annex, \"script\": scripts[1][0]})\n+\n+            # Above OP_16 to avoid minimal encoding complaints\n+            checksigadd_val = random.randrange(17, 100)\n+            checksigadd_arg = CScriptNum(checksigadd_val)\n+            checksigadd_result = CScriptNum(checksigadd_val+1)\n+\n+            # Illegally-large number for script arithmetic input\n+            oversize_number = 2**31\n+            assert_equal(len(CScriptNum.encode(CScriptNum(oversize_number))), 6)\n+            assert_equal(len(CScriptNum.encode(CScriptNum(oversize_number-1))), 5)\n+\n+            # Various BIP342 features\n+            scripts = [\n+                # 0) drop stack element and OP_CHECKSIG\n+                CScript([OP_DROP, pub2, OP_CHECKSIG]),\n+                # 1) normal OP_CHECKSIG\n+                CScript([pub2, OP_CHECKSIG]),\n+                # 2) normal OP_CHECKSIGVERIFY\n+                CScript([pub2, OP_CHECKSIGVERIFY, OP_1]),\n+                # 3) Hypothetical OP_CHECKMULTISIG script that takes a single sig as input\n+                CScript([OP_0, OP_SWAP, OP_1, pub2, OP_1, OP_CHECKMULTISIG]),\n+                # 4) Hypothetical OP_CHECKMULTISIGVERIFY script that takes a single sig as input\n+                CScript([OP_0, OP_SWAP, OP_1, pub2, OP_1, OP_CHECKMULTISIGVERIFY, OP_1]),\n+                # 5) OP_IF script that needs a true input\n+                CScript([OP_IF, pub2, OP_CHECKSIG, OP_ELSE, OP_RETURN, OP_ENDIF]),\n+                # 6) OP_NOTIF script that needs a true input\n+                CScript([OP_NOTIF, OP_RETURN, OP_ELSE, pub2, OP_CHECKSIG, OP_ENDIF]),\n+                # 7) OP_CHECKSIG with an empty key\n+                CScript([OP_0, OP_CHECKSIG]),\n+                # 8) OP_CHECKSIGVERIFY with an empty key\n+                CScript([OP_0, OP_CHECKSIGVERIFY, OP_1]),\n+                # 9) normal OP_CHECKSIGADD that also ensures return value is correct\n+                CScript([OP_0, pub2, OP_CHECKSIGADD, OP_1, OP_EQUAL]),\n+                # 10) OP_CHECKSIGADD with empty key\n+                CScript([OP_0, OP_0, OP_CHECKSIGADD]),\n+                # 11) OP_CHECKSIGADD with missing counter stack element\n+                CScript([pub2, OP_CHECKSIGADD]),\n+                # 12) OP_CHECKSIG that needs invalid signature\n+                CScript([pub2, OP_CHECKSIGVERIFY, pub1, OP_CHECKSIG, OP_NOT]),\n+                # 13) OP_CHECKSIG with empty key that needs invalid signature\n+                CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_CHECKSIG, OP_NOT]),\n+                # 14) OP_CHECKSIGADD that needs invalid signature\n+                CScript([pub2, OP_CHECKSIGVERIFY, OP_0, pub1, OP_CHECKSIGADD, OP_NOT]),\n+                # 15) OP_CHECKSIGADD with empty key that needs invalid signature\n+                CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGADD, OP_NOT]),\n+                # 16) OP_CHECKSIG with unknown pubkey type\n+                CScript([OP_1, OP_CHECKSIG]),\n+                # 17) OP_CHECKSIGADD with unknown pubkey type\n+                CScript([OP_0, OP_1, OP_CHECKSIGADD]),\n+                # 18) OP_CHECKSIGVERIFY with unknown pubkey type\n+                CScript([OP_1, OP_CHECKSIGVERIFY, OP_1]),\n+                # 19) script longer than 10000 bytes and over 201 non-push opcodes\n+                CScript([OP_0, OP_0, OP_2DROP] * 10001 + [pub2, OP_CHECKSIG]),\n+                # 20) OP_CHECKSIGVERIFY with empty key\n+                CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGVERIFY, OP_1]),\n+                # 21) Script that grows the stack to 1000 elements\n+                CScript([pub2, OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 999 + [OP_DROP] * 999),\n+                # 22) Script that grows the stack to 1001 elements\n+                CScript([pub2, OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 1000 + [OP_DROP] * 1000),\n+                # 23) Script that expects an input stack of 1000 elements\n+                CScript([OP_DROP] * 999 + [pub2, OP_CHECKSIG]),\n+                # 24) Script that expects an input stack of 1001 elements\n+                CScript([OP_DROP] * 1000 + [pub2, OP_CHECKSIG]),\n+                # 25) Script that pushes a 520 byte element\n+                CScript([random_bytes(520), OP_DROP, pub2, OP_CHECKSIG]),\n+                # 26) Script that pushes a 521 byte element\n+                CScript([random_bytes(521), OP_DROP, pub2, OP_CHECKSIG]),\n+                # 27) Script that pushes a 521 byte element and OP_SUCCESSX\n+                CScript([random_bytes(521), OP_DROP, pub2, OP_CHECKSIG, random_op_success()]),\n+                # 28) Pushes random CScriptNum value, checks OP_CHECKSIGADD result\n+                CScript([checksigadd_arg, pub2, OP_CHECKSIGADD, checksigadd_result, OP_EQUAL]),\n+                # 30) CHECKSIGADD that succeeds with proper sig because numeric argument number is <=4 bytes\n+                CScript([CScriptNum(oversize_number-1), pub2, OP_CHECKSIGADD]),\n+                # 29) CHECKSIGADD that must fail because numeric argument number is >4 bytes\n+                CScript([CScriptNum(oversize_number), pub2, OP_CHECKSIGADD]),\n+            ]\n+            # For the next test we must predict the exact witness size\n+            witness_size = 141 + (hashtype != 0) + (0 if annex is None else len(annex) + 1)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461316019",
      "id" : 461316019,
      "in_reply_to_id" : 456992780,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMxNjAxOQ==",
      "original_commit_id" : "42bda3592c3fc4d5169b2f53e80780ed46a0854c",
      "original_line" : 701,
      "original_position" : 655,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 456299801,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461316019",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461316101"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461316101"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Added some extra comments.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-28T04:50:02Z",
      "diff_hunk" : "@@ -1265,7 +1265,7 @@ uint256 GetPrevoutHash(const T& txTo)\n     for (const auto& txin : txTo.vin) {\n         ss << txin.prevout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461316101",
      "id" : 461316101,
      "in_reply_to_id" : 459503234,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMxNjEwMQ==",
      "original_commit_id" : "41d08f5d77f52bec0e31bb081d85fff2d67d0467",
      "original_line" : 1362,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 456299871,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461316101",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461316301"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461316301"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've made some significant changes here; the code will now detect if a transaction needs BIP341 and/or BIP143 sighashing, and then only precompute what is needed for the existing ones.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-28T04:50:53Z",
      "diff_hunk" : "@@ -1299,9 +1317,17 @@ void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_o\n \n     // Cache is calculated only for transactions with witness\n     if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+        m_prevouts_hash = GetPrevoutHash(txTo);\n+        hashPrevouts = SHA256Uint256(m_prevouts_hash);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461316301",
      "id" : 461316301,
      "in_reply_to_id" : 459527853,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMxNjMwMQ==",
      "original_commit_id" : "41d08f5d77f52bec0e31bb081d85fff2d67d0467",
      "original_line" : 1321,
      "original_position" : 53,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 456300116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461316301",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461316594"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461316594"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The constant itself is consensus-critical.\r\n\r\nThe name of the variable was a style violation; it's a constant, it should be ALL_CAPS. Did that.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-28T04:51:56Z",
      "diff_hunk" : "@@ -1319,6 +1345,76 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461316594",
      "id" : 461316594,
      "in_reply_to_id" : 459531548,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMxNjU5NA==",
      "original_commit_id" : "41d08f5d77f52bec0e31bb081d85fff2d67d0467",
      "original_line" : 1348,
      "original_position" : 70,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 456300426,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461316594",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461316813"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461316813"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The epoch is explained in footnote 19 of BIP341. Not sure what is missing.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-28T04:52:43Z",
      "diff_hunk" : "@@ -1319,6 +1345,76 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData* cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache != nullptr && cache->m_ready && cache->m_spent_outputs_ready);\n+\n+    CHashWriter ss = HasherTapSighash;\n+\n+    // Epoch\n+    static constexpr uint8_t EPOCH = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461316813",
      "id" : 461316813,
      "in_reply_to_id" : 459653999,
      "line" : 1496,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMxNjgxMw==",
      "original_commit_id" : "41d08f5d77f52bec0e31bb081d85fff2d67d0467",
      "original_line" : 1496,
      "original_position" : 89,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 338,
      "pull_request_review_id" : 456300684,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461316813",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461316943"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461316943"
         }
      },
      "author_association" : "MEMBER",
      "body" : "If this code is reused for a new sighash algorithm, this will be the least of our problems.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-28T04:53:08Z",
      "diff_hunk" : "@@ -1319,6 +1345,76 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData* cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache != nullptr && cache->m_ready && cache->m_spent_outputs_ready);\n+\n+    CHashWriter ss = HasherTapSighash;\n+\n+    // Epoch\n+    static constexpr uint8_t EPOCH = 0;\n+    ss << EPOCH;\n+\n+    // Hash type\n+    const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n+    const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;\n+    if (output_type != SIGHASH_ALL && output_type != SIGHASH_SINGLE && output_type != SIGHASH_NONE) return false;\n+    if (input_type != SIGHASH_ANYONECANPAY && input_type != 0) return false;\n+    ss << hash_type;\n+\n+    // Transaction level data\n+    ss << tx_to.nVersion;\n+    ss << tx_to.nLockTime;\n+    if (input_type != SIGHASH_ANYONECANPAY) {\n+        ss << cache->m_prevouts_hash;\n+        ss << cache->m_spent_amounts_hash;\n+        ss << cache->m_spent_scripts_hash;\n+        ss << cache->m_sequences_hash;\n+    }\n+    if (output_type == SIGHASH_ALL) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461316943",
      "id" : 461316943,
      "in_reply_to_id" : 459663568,
      "line" : 1514,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMxNjk0Mw==",
      "original_commit_id" : "41d08f5d77f52bec0e31bb081d85fff2d67d0467",
      "original_line" : 1514,
      "original_position" : 108,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 356,
      "pull_request_review_id" : 456300833,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461316943",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461316995"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461316995"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Good catch, fixed.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-28T04:53:17Z",
      "diff_hunk" : "@@ -1319,6 +1345,76 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData* cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache != nullptr && cache->m_ready && cache->m_spent_outputs_ready);\n+\n+    CHashWriter ss = HasherTapSighash;\n+\n+    // Epoch\n+    static constexpr uint8_t EPOCH = 0;\n+    ss << EPOCH;\n+\n+    // Hash type\n+    const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n+    const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;\n+    if (output_type != SIGHASH_ALL && output_type != SIGHASH_SINGLE && output_type != SIGHASH_NONE) return false;\n+    if (input_type != SIGHASH_ANYONECANPAY && input_type != 0) return false;\n+    ss << hash_type;\n+\n+    // Transaction level data\n+    ss << tx_to.nVersion;\n+    ss << tx_to.nLockTime;\n+    if (input_type != SIGHASH_ANYONECANPAY) {\n+        ss << cache->m_prevouts_hash;\n+        ss << cache->m_spent_amounts_hash;\n+        ss << cache->m_spent_scripts_hash;\n+        ss << cache->m_sequences_hash;\n+    }\n+    if (output_type == SIGHASH_ALL) {\n+        ss << cache->m_outputs_hash;\n+    }\n+\n+    // Data about the input/prevout being spent\n+    const auto* witstack = &tx_to.vin[in_pos].scriptWitness.stack;\n+    bool have_annex = witstack->size() > 1 && witstack->back().size() > 0 && witstack->back()[0] == 0xff;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461316995",
      "id" : 461316995,
      "in_reply_to_id" : 459665027,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMxNjk5NQ==",
      "original_commit_id" : "41d08f5d77f52bec0e31bb081d85fff2d67d0467",
      "original_line" : 1392,
      "original_position" : 114,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 456300870,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461316995",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461317204"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461317204"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Comments for the libsecp256k1 changes should go to the PR there: https://github.com/bitcoin-core/secp256k1/pull/558",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-28T04:54:03Z",
      "diff_hunk" : "@@ -0,0 +1,230 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Andrew Poelstra                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#ifndef _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+#define _SECP256K1_MODULE_SCHNORRSIG_MAIN_\n+\n+#include \"include/secp256k1.h\"\n+#include \"include/secp256k1_schnorrsig.h\"\n+#include \"hash.h\"\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/nonce\")||SHA256(\"BIP340/nonce\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0xa96e75cbul;\n+    sha->s[1] = 0x74f9f0acul;\n+    sha->s[2] = 0xc49e3c98ul;\n+    sha->s[3] = 0x202f99baul;\n+    sha->s[4] = 0x8946a616ul;\n+    sha->s[5] = 0x4accf415ul;\n+    sha->s[6] = 0x86e335c3ul;\n+    sha->s[7] = 0x48d0a072ul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/aux\")||SHA256(\"BIP340/aux\"). */\n+static void secp256k1_nonce_function_bip340_sha256_tagged_aux(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x5d74a872ul;\n+    sha->s[1] = 0xd57064d4ul;\n+    sha->s[2] = 0x89495becul;\n+    sha->s[3] = 0x910f46f5ul;\n+    sha->s[4] = 0xcbc6fd3eul;\n+    sha->s[5] = 0xaf05d9d0ul;\n+    sha->s[6] = 0xcb781ce6ul;\n+    sha->s[7] = 0x062930acul;\n+\n+    sha->bytes = 64;\n+}\n+\n+/* algo16 argument for nonce_function_bip340 to derive the nonce exactly as stated in BIP-340\n+ * by using the correct tagged hash function. */\n+static const unsigned char bip340_algo16[16] = \"BIP340/nonce\\0\\0\\0\\0\";\n+\n+static int nonce_function_bip340(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo16, void *data) {\n+    secp256k1_sha256 sha;\n+    unsigned char masked_key[32];\n+    int i;\n+\n+    if (algo16 == NULL) {\n+        return 0;\n+    }\n+\n+    if (data != NULL) {\n+        secp256k1_nonce_function_bip340_sha256_tagged_aux(&sha);\n+        secp256k1_sha256_write(&sha, data, 32);\n+        secp256k1_sha256_finalize(&sha, masked_key);\n+        for (i = 0; i < 32; i++) {\n+            masked_key[i] ^= key32[i];\n+        }\n+    }\n+\n+    /* Tag the hash with algo16 which is important to avoid nonce reuse across\n+     * algorithms. If this nonce function is used in BIP-340 signing as defined\n+     * in the spec, an optimized tagging implementation is used. */\n+    if (memcmp(algo16, bip340_algo16, 16) == 0) {\n+        secp256k1_nonce_function_bip340_sha256_tagged(&sha);\n+    } else {\n+        int algo16_len = 16;\n+        /* Remove terminating null bytes */\n+        while (algo16_len > 0 && !algo16[algo16_len - 1]) {\n+            algo16_len--;\n+        }\n+        secp256k1_sha256_initialize_tagged(&sha, algo16, algo16_len);\n+    }\n+\n+    /* Hash (masked-)key||pk||msg using the tagged hash as per the spec */\n+    if (data != NULL) {\n+        secp256k1_sha256_write(&sha, masked_key, 32);\n+    } else {\n+        secp256k1_sha256_write(&sha, key32, 32);\n+    }\n+    secp256k1_sha256_write(&sha, xonly_pk32, 32);\n+    secp256k1_sha256_write(&sha, msg32, 32);\n+    secp256k1_sha256_finalize(&sha, nonce32);\n+    return 1;\n+}\n+\n+const secp256k1_nonce_function_hardened secp256k1_nonce_function_bip340 = nonce_function_bip340;\n+\n+/* Initializes SHA256 with fixed midstate. This midstate was computed by applying\n+ * SHA256 to SHA256(\"BIP340/challenge\")||SHA256(\"BIP340/challenge\"). */\n+static void secp256k1_schnorrsig_sha256_tagged(secp256k1_sha256 *sha) {\n+    secp256k1_sha256_initialize(sha);\n+    sha->s[0] = 0x71985ac9ul;\n+    sha->s[1] = 0x198317a2ul;\n+    sha->s[2] = 0x60b6e581ul;\n+    sha->s[3] = 0x54c109b6ul;\n+    sha->s[4] = 0x64bac2fdul;\n+    sha->s[5] = 0x91231de2ul;\n+    sha->s[6] = 0x7301ebdeul;\n+    sha->s[7] = 0x87635f83ul;\n+    sha->bytes = 64;\n+}\n+\n+int secp256k1_schnorrsig_sign(const secp256k1_context* ctx, unsigned char *sig64, const unsigned char *msg32, const secp256k1_keypair *keypair, secp256k1_nonce_function_hardened noncefp, void *ndata) {\n+    secp256k1_scalar sk;\n+    secp256k1_scalar e;\n+    secp256k1_scalar k;\n+    secp256k1_gej rj;\n+    secp256k1_ge pk;\n+    secp256k1_ge r;\n+    secp256k1_sha256 sha;\n+    unsigned char buf[32] = { 0 };\n+    unsigned char pk_buf[32];\n+    unsigned char seckey[32];\n+    int ret = 1;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(sig64 != NULL);\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(keypair != NULL);\n+\n+    if (noncefp == NULL) {\n+        noncefp = secp256k1_nonce_function_bip340;\n+    }\n+\n+    ret &= secp256k1_keypair_load(ctx, &sk, &pk, keypair);\n+    /* Because we are signing for a x-only pubkey, the secret key is negated\n+     * before signing if the point corresponding to the secret key does not\n+     * have an even Y. */\n+    if (secp256k1_fe_is_odd(&pk.y)) {\n+        secp256k1_scalar_negate(&sk, &sk);\n+    }\n+\n+    secp256k1_scalar_get_b32(seckey, &sk);\n+    secp256k1_fe_get_b32(pk_buf, &pk.x);\n+    ret &= !!noncefp(buf, msg32, seckey, pk_buf, bip340_algo16, (void*)ndata);\n+    secp256k1_scalar_set_b32(&k, buf, NULL);\n+    ret &= !secp256k1_scalar_is_zero(&k);\n+    secp256k1_scalar_cmov(&k, &secp256k1_scalar_one, !ret);\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &rj, &k);\n+    secp256k1_ge_set_gej(&r, &rj);\n+\n+    /* We declassify r to allow using it as a branch point. This is fine\n+     * because r is not a secret. */\n+    secp256k1_declassify(ctx, &r, sizeof(r));\n+    if (!secp256k1_fe_is_quad_var(&r.y)) {\n+        secp256k1_scalar_negate(&k, &k);\n+    }\n+    secp256k1_fe_normalize_var(&r.x);\n+    secp256k1_fe_get_b32(&sig64[0], &r.x);\n+\n+    /* tagged hash(r.x, pk.x, msg32) */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461317204",
      "id" : 461317204,
      "in_reply_to_id" : 459769788,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMxNzIwNA==",
      "original_commit_id" : "ad51604f57aaa311529bd302e069c26dac818ad6",
      "original_line" : 162,
      "original_position" : 161,
      "original_start_line" : null,
      "path" : "src/secp256k1/src/modules/schnorrsig/main_impl.h",
      "position" : null,
      "pull_request_review_id" : 456301098,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461317204",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461317427"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461317427"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've changed it to `data`. I think `preimage` is more useful when you're talking about a hash input that generates a specified output.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-28T04:54:48Z",
      "diff_hunk" : "@@ -77,3 +78,19 @@ void BIP32Hash(const ChainCode &chainCode, unsigned int nChild, unsigned char he\n     num[3] = (nChild >>  0) & 0xFF;\n     CHMAC_SHA512(chainCode.begin(), chainCode.size()).Write(&header, 1).Write(data, 32).Write(num, 4).Finalize(output);\n }\n+\n+CHashWriter TaggedHash(const std::string& tag)\n+{\n+    CHashWriter writer(SER_GETHASH, 0);\n+    uint256 taghash;\n+    CSHA256().Write((const unsigned char*)tag.data(), tag.size()).Finalize(taghash.begin());\n+    writer << taghash << taghash;\n+    return writer;\n+}\n+\n+uint256 SHA256Uint256(const uint256& hash)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461317427",
      "id" : 461317427,
      "in_reply_to_id" : 459946492,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMxNzQyNw==",
      "original_commit_id" : "ad51604f57aaa311529bd302e069c26dac818ad6",
      "original_line" : 91,
      "original_position" : 22,
      "original_start_line" : null,
      "path" : "src/hash.cpp",
      "position" : null,
      "pull_request_review_id" : 456301320,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461317427",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461317688"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461317688"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Renamed the BIP341 ones with just a `_bip341_` in the name, which is as specific as it can be, I think. I'm trying not to touch too much other stuff, so the others keep their name.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-28T04:55:44Z",
      "diff_hunk" : "@@ -114,33 +120,92 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making the use of (unknown) annexes non-standard (currently no annexes are known)\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 20),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 21),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    //! Single-SHA256 versions\n+    uint256 m_prevouts_hash, m_sequences_hash, m_outputs_hash, m_spent_amounts_hash, m_spent_scripts_hash;\n+    bool m_spent_outputs_ready = false;\n+\n+    //! Double-SHA256 versions\n     uint256 hashPrevouts, hashSequence, hashOutputs;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461317688",
      "id" : 461317688,
      "in_reply_to_id" : 459954502,
      "line" : 155,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMxNzY4OA==",
      "original_commit_id" : "ad51604f57aaa311529bd302e069c26dac818ad6",
      "original_line" : 155,
      "original_position" : 55,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : 64,
      "pull_request_review_id" : 456301579,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461317688",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461317743"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461317743"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Indeed, done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-28T04:55:57Z",
      "diff_hunk" : "@@ -146,14 +158,21 @@ struct PrecomputedTransactionData\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n-    TAPROOT = 2,\n+    BASE = 0,        //!< Bare scripts and P2SH redeemscripts; see BIP 16",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461317743",
      "id" : 461317743,
      "in_reply_to_id" : 460091608,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMxNzc0Mw==",
      "original_commit_id" : "b7a7f6ab2ccc30e323a5396c27cb82ffd613550b",
      "original_line" : 177,
      "original_position" : 26,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 456301645,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461317743",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461318080"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461318080"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-28T04:57:14Z",
      "diff_hunk" : "@@ -163,6 +163,16 @@ enum class SigVersion\n     TAPROOT = 2,     //!< Witness v1 with non-P2SH 32 byte program (Taproot), key path spending; see BIP 341\n };\n \n+struct ScriptExecutionData\n+{\n+    //! Whether m_annex_present and m_annex_hash are initialized.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461318080",
      "id" : 461318080,
      "in_reply_to_id" : 460163407,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMxODA4MA==",
      "original_commit_id" : "cbcaab9a66f82fa5bcc2711a5fee2adc47004cc8",
      "original_line" : 168,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 456302046,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461318080",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461318243"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461318243"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm not sure. The result is always _exactly_ equal to `!sig.empty()` if no failure occurs, so I think this makes sense.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-28T04:57:53Z",
      "diff_hunk" : "@@ -371,6 +368,67 @@ static bool EvalChecksig(const valtype& vchSig, const valtype& vchPubKey, CScrip\n     return true;\n }\n \n+static bool EvalChecksigTapscript(const valtype& sig, const valtype& pubkey, ScriptExecutionData& execdata, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& success)\n+{\n+    assert(sigversion == SigVersion::TAPSCRIPT);\n+\n+    /*\n+     *  The following validation sequence is consensus critical. Please note how --\n+     *    upgradable public key versions precede other rules;\n+     *    the script execution fails when using empty signature with invalid public key;\n+     *    the script execution fails when using non-empty invalid signature.\n+     */\n+    success = !sig.empty();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461318243",
      "id" : 461318243,
      "in_reply_to_id" : 460213001,
      "line" : 381,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMxODI0Mw==",
      "original_commit_id" : "988d7a795cfc29b37c3ea3359fb69412ab04de53",
      "original_line" : 381,
      "original_position" : 31,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 41,
      "pull_request_review_id" : 456302269,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461318243",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461318327"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461318327"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-28T04:58:17Z",
      "diff_hunk" : "@@ -371,6 +368,67 @@ static bool EvalChecksig(const valtype& vchSig, const valtype& vchPubKey, CScrip\n     return true;\n }\n \n+static bool EvalChecksigTapscript(const valtype& sig, const valtype& pubkey, ScriptExecutionData& execdata, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& success)\n+{\n+    assert(sigversion == SigVersion::TAPSCRIPT);\n+\n+    /*\n+     *  The following validation sequence is consensus critical. Please note how --\n+     *    upgradable public key versions precede other rules;\n+     *    the script execution fails when using empty signature with invalid public key;\n+     *    the script execution fails when using non-empty invalid signature.\n+     */\n+    success = !sig.empty();\n+    if (success) {\n+        // Implement the sigops/witnesssize ratio test.\n+        // Passing with an upgradable public key version is also counted.\n+        assert(execdata.m_validation_weight_left_init);\n+        execdata.m_validation_weight_left -= VALIDATION_WEIGHT_PER_SIGOP_PASSED;\n+        if (execdata.m_validation_weight_left < 0) {\n+            return set_error(serror, SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT);\n+        }\n+    }\n+    if (pubkey.size() == 0) {\n+        return set_error(serror, SCRIPT_ERR_PUBKEYTYPE);\n+    } else if (pubkey.size() == 32) {\n+        if (success && !checker.CheckSigSchnorr(sig, pubkey, sigversion, execdata)) {\n+            return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);\n+        }\n+    } else {\n+        /*\n+         *  New public key version softforks should be defined before this `else` block.\n+         *  Generally, the new code should not do anything but failing the script execution. To avoid\n+         *  consensus bugs, it should not modify any existing values (including success).\n+         */\n+        if ((flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE) != 0) {\n+            return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE);\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+/** Helper for OP_CHECKSIG and OP_CHECKSIGVERIFY",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461318327",
      "id" : 461318327,
      "in_reply_to_id" : 460216726,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMxODMyNw==",
      "original_commit_id" : "988d7a795cfc29b37c3ea3359fb69412ab04de53",
      "original_line" : 411,
      "original_position" : 61,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 456302370,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461318327",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461318367"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461318367"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Meh.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-28T04:58:28Z",
      "diff_hunk" : "@@ -371,7 +371,7 @@ static bool EvalChecksig(const valtype& vchSig, const valtype& vchPubKey, CScrip\n     return true;\n }\n \n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)\n+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, ScriptExecutionData execdata)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461318367",
      "id" : 461318367,
      "in_reply_to_id" : 460079736,
      "line" : 432,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMxODM2Nw==",
      "original_commit_id" : "cbcaab9a66f82fa5bcc2711a5fee2adc47004cc8",
      "original_line" : 432,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 92,
      "pull_request_review_id" : 456302413,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461318367",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461318419"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461318419"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Changed the variable name.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-28T04:58:42Z",
      "diff_hunk" : "@@ -1319,6 +1345,76 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461318419",
      "id" : 461318419,
      "in_reply_to_id" : 460173936,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMxODQxOQ==",
      "original_commit_id" : "41d08f5d77f52bec0e31bb081d85fff2d67d0467",
      "original_line" : 1348,
      "original_position" : 70,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 456302488,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461318419",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461318457"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461318457"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-28T04:58:49Z",
      "diff_hunk" : "@@ -1540,13 +1540,19 @@ bool CheckInputScripts(const CTransaction& tx, TxValidationState &state, const C\n     }\n \n     if (!txdata.m_ready) {\n-        txdata.Init(tx);\n+        std::vector<CTxOut> spent_outputs;\n+        spent_outputs.reserve(tx.vin.size());\n+\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461318457",
      "id" : 461318457,
      "in_reply_to_id" : 460174647,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMxODQ1Nw==",
      "original_commit_id" : "14d2178048ba7aecaf2e69a283968c6554c127cb",
      "original_line" : 1546,
      "original_position" : 8,
      "original_start_line" : null,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 456302520,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461318457",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased, updated to latest libsecp256k1 Schnorr PR, addressed a number of comments (though there are a few left). The biggest change is that the sighash precomputation now takes into account whether a transaction contains/needs taproot precomputation or not.\r\n\r\nI also improved the functional tests. It now includes P2PKH/P2WPKH/P2SH-P2WPKH spends as well, just to make sure transactions with mixes have their sighashes computed correctly still. The framework now also tracks (pre-taproot) sigops, to accurately fill the block with them.\r\n\r\nThe BIP340 implementation in the test framework is also updated to the latest spec (including support for the auxiliary randomness), and implements/contains the BIP's test vectors now (which are verified against the secp256k1 implementation as well).",
      "created_at" : "2020-07-28T05:02:14Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-664777875",
      "id" : 664777875,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NDc3Nzg3NQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-28T05:05:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/664777875",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461603352"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461603352"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Last sentence here is outdated.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-28T14:01:11Z",
      "diff_hunk" : "@@ -0,0 +1,797 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import CTransaction, CTxIn, CTxOut, COutPoint, CTxInWitness\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_1SUB,\n+    OP_1NEGATE,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIF,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    TaprootSignatureHash,\n+    SegwitV0SignatureHash,\n+    LegacySignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, hex_str_to_bytes, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    program_to_witness,\n+    script_to_p2sh,\n+    hash160,\n+    key_to_p2wpkh,\n+    key_to_p2sh_p2wpkh,\n+    key_to_p2pkh,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+import struct\n+\n+EMPTYWITNESS_ERROR = \"non-mandatory-script-verify-flag (Witness program was passed an empty witness) (code 64)\"\n+INVALIDKEYPATHSIG_ERROR = \"non-mandatory-script-verify-flag (Invalid signature for Taproot key path spending) (code 64)\"\n+UNKNOWNWITNESS_ERROR = \"non-mandatory-script-verify-flag (Witness version reserved for soft-fork upgrades) (code 64)\"\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+def tx_from_hex(hexstring):\n+    tx = CTransaction()\n+    f = BytesIO(hex_str_to_bytes(hexstring))\n+    tx.deserialize(f)\n+    return tx\n+\n+def get_taproot_bech32(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return program_to_witness(1, info[2:])\n+\n+def get_version1_p2sh(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return script_to_p2sh(info)\n+\n+def get_p2sh_spk(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return CScript([OP_HASH160, hash160(info), OP_EQUAL])\n+\n+def random_op_success():\n+    ret = 0\n+    while (not is_op_success(ret)):\n+        ret = random.randint(0x50, 0xfe)\n+    return CScriptOp(ret)\n+\n+def random_unknown_leaf_ver(no_annex_tag=True):\n+    ret = LEAF_VERSION_TAPSCRIPT\n+    while (ret == LEAF_VERSION_TAPSCRIPT or (no_annex_tag and ret == (ANNEX_TAG & 0xfe))):\n+        ret = random.randrange(128) * 2\n+    return ret\n+\n+def random_bytes(n):\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+# TODO-TAPROOT Use this in a test\n+def random_script(size, no_success=True):\n+    ret = bytes()\n+    while (len(ret) < size):\n+        remain = size - len(ret)\n+        opcode = random.randrange(256)\n+        while (no_success and is_op_success(opcode)):\n+            opcode = random.randrange(256)\n+        if opcode == 0 or opcode >= OP_1NEGATE:\n+            ret += bytes([opcode])\n+        elif opcode <= 75 and opcode <= remain - 1:\n+            ret += bytes([opcode]) + random_bytes(opcode)\n+        elif opcode == 76 and remain >= 2:\n+            pushsize = random.randint(0, min(0xff, remain - 2))\n+            ret += bytes([opcode]) + bytes([pushsize]) + random_bytes(pushsize)\n+        elif opcode == 77 and remain >= 3:\n+            pushsize = random.randint(0, min(0xffff, remain - 3))\n+            ret += bytes([opcode]) + struct.pack(b'<H', pushsize) + random_bytes(pushsize)\n+        elif opcode == 78 and remain >= 5:\n+            pushsize = random.randint(0, min(0xffffffff, remain - 5))\n+            ret += bytes([opcode]) + struct.pack(b'<I', pushsize) + random_bytes(pushsize)\n+    assert len(ret) == size\n+    return ret\n+\n+# TODO-TAPROOT Use this in a test\n+def random_invalid_push(size):\n+    assert size > 0\n+    ret = bytes()\n+    opcode = 78\n+    if size <= 75:\n+        opcode = random.randint(75, 78)\n+    elif size <= 255:\n+        opcode = random.randint(76, 78)\n+    elif size <= 0xffff:\n+        opcode = random.randint(77, 78)\n+    if opcode == 75:\n+        ret = bytes([size]) + random_bytes(size - 1)\n+    elif opcode == 76:\n+        ret = bytes([opcode]) + bytes([size]) + random_bytes(size - 2)\n+    elif opcode == 77:\n+        ret = bytes([opcode]) + struct.pack(b'<H', size) + random_bytes(max(0, size - 3))\n+    else:\n+        ret = bytes([opcode]) + struct.pack(b'<I', size) + random_bytes(max(0, size - 5))\n+    assert len(ret) >= size\n+    return ret[:size]\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def damage_bytes(b):\n+    \"\"\"Flips one bit at random in a byte string.\"\"\"\n+    return (int.from_bytes(b, 'big') ^ (1 << random.randrange(len(b) * 8))).to_bytes(len(b), 'big')\n+\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - An address for that scriptPubKey (string)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A witness stack-producing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a succesful spend\n+\n+Spender = namedtuple(\"Spender\", \"script,address,comment,is_standard,sat_function,err_msg,sigops_weight\")\n+\n+def spend_no_sig(tx, input_index, spent_utxos, info, script):\n+    \"\"\"Construct witness.\"\"\"\n+    script = script[\"script\"]\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = [script, info[2][script]]\n+\n+def spend_single_sig(tx, input_index, spent_utxos, info, key, annex=None, hashtype=0, prefix=None, suffix=None, script=None, pos=-1, damage=False):\n+    if prefix is None:\n+        prefix = []\n+    if suffix is None:\n+        suffix = []\n+\n+    ht = hashtype\n+\n+    damage_type = random.randrange(5) if damage else -1\n+    '''\n+    * 0. bit flip the sighash\n+    * 1. bit flip the signature\n+    * If the expected hashtype is 0:\n+    -- 2. append a 0 to the signature\n+    -- 3. append a random value of 1-255 to the signature\n+    * If the expected hashtype is not 0:\n+    -- 2. do not append hashtype to the signature\n+    -- 3. append a random incorrect value of 0-255 to the signature\n+    * 4. extra witness element\n+    '''\n+\n+    # Taproot key path spend: tweak key\n+    if script is None:\n+        _, negated = compute_xonly_pubkey(key)\n+        key = tweak_add_privkey(key, info[1], negated)\n+        assert(key is not None)\n+\n+    # Change SIGHASH_SINGLE into SIGHASH_ALL if no corresponding output\n+    if (ht & 3 == SIGHASH_SINGLE and input_index >= len(tx.vout)):\n+        ht ^= 2\n+    # Compute sighash\n+    if script:\n+        sighash = TaprootSignatureHash(tx, spent_utxos, ht, input_index, scriptpath=True, script=script, codeseparator_pos=pos, annex=annex)\n+    else:\n+        sighash = TaprootSignatureHash(tx, spent_utxos, ht, input_index, scriptpath=False, annex=annex)\n+    if damage_type == 0:\n+        sighash = damage_bytes(sighash)\n+    # Compute signature\n+    sig = sign_schnorr(key, sighash)\n+    if damage_type == 1:\n+        sig = damage_bytes(sig)\n+    if damage_type == 2:\n+        if ht == 0:\n+            sig += bytes([0])\n+    elif damage_type == 3:\n+        random_ht = ht\n+        while random_ht == ht:\n+            random_ht = random.randrange(256)\n+        sig += bytes([random_ht])\n+    elif ht > 0:\n+        sig += bytes([ht])\n+    # Construct witness\n+    ret = prefix + [sig] + suffix\n+    if script is not None:\n+        ret += [script, info[2][script]]\n+    if annex is not None:\n+        ret += [annex]\n+    if damage_type == 4:\n+        ret = [random_bytes(random.randrange(5))] + ret\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = ret\n+\n+def spend_alwaysvalid(tx, input_index, info, script, annex=None, damage=False):\n+    if isinstance(script, tuple):\n+        version, script = script\n+    ret = [script, info[2][script]]\n+    if damage:\n+        # With 50% chance, we bit flip the script (unless the script is an empty vector)\n+        # With 50% chance, we bit flip the control block\n+        if random.choice([True, False]) or len(ret[0]) == 0:\n+            # Annex is always required for leaf version 0x50\n+            # Unless the original version is 0x50, we couldn't convert it to 0x50 without using annex\n+            tmp = damage_bytes(ret[1])\n+            while annex is None and tmp[0] == ANNEX_TAG and ret[1][0] != ANNEX_TAG:\n+                tmp = damage_bytes(ret[1])\n+            ret[1] = tmp\n+        else:\n+            ret[0] = damage_bytes(ret[0])\n+    if annex is not None:\n+        ret += [annex]\n+    # Randomly add input witness\n+    if random.choice([True, False]):\n+        for i in range(random.randint(1, 10)):\n+            ret = [random_bytes(random.randint(0, MAX_SCRIPT_ELEMENT_SIZE * 2))] + ret\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = ret\n+\n+# N.B. Function arguments below: t(ransaction), i(ndex to spend), u(txos being spent), v(alid signature?)\n+\n+def spender_legacy(spenders, key, comment, hashtype, segwit, p2sh):\n+    \"\"\"Legacy signing (P2PKH, P2SH-P2PKH, P2WPKH, P2SH-P2WPKH, with signatures on valid/invalid sighashes).\"\"\"\n+    eckey = ECKey()\n+    eckey.set(key, True)\n+    pubkey = eckey.get_pubkey().get_bytes()\n+    pubkeyhash = hash160(pubkey)\n+    sigops_weight = 0\n+    if segwit:\n+        sigops_weight += 1\n+        spk = CScript([OP_0, pubkeyhash])\n+        if p2sh:\n+            addr = key_to_p2sh_p2wpkh(pubkey)\n+        else:\n+            addr = key_to_p2wpkh(pubkey)\n+    else:\n+        sigops_weight += 1 * WITNESS_SCALE_FACTOR\n+        spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+        if p2sh:\n+            addr = script_to_p2sh(spk)\n+        else:\n+            addr = key_to_p2pkh(pubkey)\n+    if p2sh:\n+        redeemscript = spk\n+        spk = CScript([OP_HASH160, hash160(redeemscript), OP_EQUAL])\n+\n+    def fn(t, i, u, v):\n+        script = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+        if segwit:\n+            sig_hash = SegwitV0SignatureHash(script, t, i, hashtype, u[i].nValue)\n+        else:\n+            sig_hash = LegacySignatureHash(script, t, i, hashtype)[0]\n+        if not v:\n+            sig_hash = damage_bytes(sig_hash)\n+        sig = eckey.sign_ecdsa(sig_hash) + bytes([hashtype])\n+        if segwit:\n+            t.wit.vtxinwit[i].scriptWitness.stack = [sig, pubkey]\n+        else:\n+            t.vin[i].scriptSig = CScript([sig, pubkey])\n+        if p2sh:\n+            t.vin[i].scriptSig = bytes(t.vin[i].scriptSig) + CScript([redeemscript])\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=True, sat_function=fn, err_msg=None, sigops_weight=sigops_weight))\n+\n+def spender_sighash_mutation(spenders, info, comment, standard=True, **kwargs):\n+    \"\"\"Mutates signature randomly when failure for the inputs is requested.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_single_sig(t, i, u, damage=not v, info=info, **kwargs)\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn, err_msg=None, sigops_weight=0))\n+\n+def spender_two_paths(spenders, info, comment, standard, success, failure, err_msg=None):\n+    \"\"\"Gives caller a way to specify two merkle paths to test validity satisfaction: One expected success, and one failure.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_single_sig(t, i, u, damage=False, info=info, **(success if v else failure))\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn, err_msg=err_msg, sigops_weight=0))\n+\n+def spender_alwaysvalid(spenders, info, comment, err_msg=None, **kwargs):\n+    \"\"\"Mutates the witness when requested, intended for otherwise always true scripts.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_alwaysvalid(t, i, damage=not v, info=info, **kwargs)\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=False, sat_function=fn, err_msg=err_msg, sigops_weight=0))\n+\n+def spender_two_paths_alwaysvalid(spenders, info, comment, standard, success, failure, err_msg=None):\n+    \"\"\"Allows specifying both a success and failure script without any signatures or additional witness data required.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_no_sig(t, i, u, info, (success if v else failure))\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn, err_msg=err_msg, sigops_weight=0))\n+\n+def spender_alwaysvalid_p2sh(spenders, info, comment, standard, script, err_msg=None):\n+    \"\"\"Tests that p2sh-wrapping witness program v1 are always valid, since they are not covered by tapscript.\"\"\"\n+    spk = get_p2sh_spk(info)\n+    addr = get_version1_p2sh(info)\n+\n+    def fn(t, i, u, v):\n+        if v:\n+            t.vin[i].scriptSig = CScript([info[0]])\n+            # Empty control block is only invalid if we apply taproot rules,\n+            # which we shouldn't if the spend is wrapped in P2SH\n+            t.wit.vtxinwit[i].scriptWitness.stack = [script, bytes()]\n+        else:\n+            t.vin[i].scriptSig = CScript()\n+        return\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn, err_msg=err_msg, sigops_weight=0))\n+\n+def nested_script(script, depth):\n+    if depth == 0:\n+        return script\n+    return [nested_script(script, depth - 1), CScript([OP_RETURN])]\n+\n+UTXOData = namedtuple('UTXOData', 'input,output,spender')\n+\n+class TaprootTest(BitcoinTestFramework):\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.extra_args = [[\"-whitelist=127.0.0.1\", \"-par=1\"]]\n+\n+    def block_submit(self, node, txs, msg, err_msg, cb_pubkey=None, fees=0, sigops_weight=0, witness=False, accept=False):\n+\n+        # Deplete block of any non-tapscript sigops using a single additional 0-value coinbase output.\n+        # It is not impossible to fit enough tapscript sigops to hit the old 80k limit without\n+        # busting txin-level limits. We simply have to account for the p2pk outputs in all",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461603352",
      "id" : 461603352,
      "line" : 1156,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTYwMzM1Mg==",
      "original_commit_id" : "92d3928ed13d9287b24532e5be863fc6a505c069",
      "original_line" : 1156,
      "original_position" : 410,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : 1156,
      "pull_request_review_id" : 456661508,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461603352",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461605876"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461605876"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nice, you may get 1 to 3 sigops weight left over by chance, but tests will blow that out regularly.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-28T14:04:34Z",
      "diff_hunk" : "@@ -0,0 +1,797 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import CTransaction, CTxIn, CTxOut, COutPoint, CTxInWitness\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_1SUB,\n+    OP_1NEGATE,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIF,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    TaprootSignatureHash,\n+    SegwitV0SignatureHash,\n+    LegacySignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, hex_str_to_bytes, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    program_to_witness,\n+    script_to_p2sh,\n+    hash160,\n+    key_to_p2wpkh,\n+    key_to_p2sh_p2wpkh,\n+    key_to_p2pkh,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+import struct\n+\n+EMPTYWITNESS_ERROR = \"non-mandatory-script-verify-flag (Witness program was passed an empty witness) (code 64)\"\n+INVALIDKEYPATHSIG_ERROR = \"non-mandatory-script-verify-flag (Invalid signature for Taproot key path spending) (code 64)\"\n+UNKNOWNWITNESS_ERROR = \"non-mandatory-script-verify-flag (Witness version reserved for soft-fork upgrades) (code 64)\"\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+def tx_from_hex(hexstring):\n+    tx = CTransaction()\n+    f = BytesIO(hex_str_to_bytes(hexstring))\n+    tx.deserialize(f)\n+    return tx\n+\n+def get_taproot_bech32(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return program_to_witness(1, info[2:])\n+\n+def get_version1_p2sh(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return script_to_p2sh(info)\n+\n+def get_p2sh_spk(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return CScript([OP_HASH160, hash160(info), OP_EQUAL])\n+\n+def random_op_success():\n+    ret = 0\n+    while (not is_op_success(ret)):\n+        ret = random.randint(0x50, 0xfe)\n+    return CScriptOp(ret)\n+\n+def random_unknown_leaf_ver(no_annex_tag=True):\n+    ret = LEAF_VERSION_TAPSCRIPT\n+    while (ret == LEAF_VERSION_TAPSCRIPT or (no_annex_tag and ret == (ANNEX_TAG & 0xfe))):\n+        ret = random.randrange(128) * 2\n+    return ret\n+\n+def random_bytes(n):\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+# TODO-TAPROOT Use this in a test\n+def random_script(size, no_success=True):\n+    ret = bytes()\n+    while (len(ret) < size):\n+        remain = size - len(ret)\n+        opcode = random.randrange(256)\n+        while (no_success and is_op_success(opcode)):\n+            opcode = random.randrange(256)\n+        if opcode == 0 or opcode >= OP_1NEGATE:\n+            ret += bytes([opcode])\n+        elif opcode <= 75 and opcode <= remain - 1:\n+            ret += bytes([opcode]) + random_bytes(opcode)\n+        elif opcode == 76 and remain >= 2:\n+            pushsize = random.randint(0, min(0xff, remain - 2))\n+            ret += bytes([opcode]) + bytes([pushsize]) + random_bytes(pushsize)\n+        elif opcode == 77 and remain >= 3:\n+            pushsize = random.randint(0, min(0xffff, remain - 3))\n+            ret += bytes([opcode]) + struct.pack(b'<H', pushsize) + random_bytes(pushsize)\n+        elif opcode == 78 and remain >= 5:\n+            pushsize = random.randint(0, min(0xffffffff, remain - 5))\n+            ret += bytes([opcode]) + struct.pack(b'<I', pushsize) + random_bytes(pushsize)\n+    assert len(ret) == size\n+    return ret\n+\n+# TODO-TAPROOT Use this in a test\n+def random_invalid_push(size):\n+    assert size > 0\n+    ret = bytes()\n+    opcode = 78\n+    if size <= 75:\n+        opcode = random.randint(75, 78)\n+    elif size <= 255:\n+        opcode = random.randint(76, 78)\n+    elif size <= 0xffff:\n+        opcode = random.randint(77, 78)\n+    if opcode == 75:\n+        ret = bytes([size]) + random_bytes(size - 1)\n+    elif opcode == 76:\n+        ret = bytes([opcode]) + bytes([size]) + random_bytes(size - 2)\n+    elif opcode == 77:\n+        ret = bytes([opcode]) + struct.pack(b'<H', size) + random_bytes(max(0, size - 3))\n+    else:\n+        ret = bytes([opcode]) + struct.pack(b'<I', size) + random_bytes(max(0, size - 5))\n+    assert len(ret) >= size\n+    return ret[:size]\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def damage_bytes(b):\n+    \"\"\"Flips one bit at random in a byte string.\"\"\"\n+    return (int.from_bytes(b, 'big') ^ (1 << random.randrange(len(b) * 8))).to_bytes(len(b), 'big')\n+\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - An address for that scriptPubKey (string)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A witness stack-producing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a succesful spend\n+\n+Spender = namedtuple(\"Spender\", \"script,address,comment,is_standard,sat_function,err_msg,sigops_weight\")\n+\n+def spend_no_sig(tx, input_index, spent_utxos, info, script):\n+    \"\"\"Construct witness.\"\"\"\n+    script = script[\"script\"]\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = [script, info[2][script]]\n+\n+def spend_single_sig(tx, input_index, spent_utxos, info, key, annex=None, hashtype=0, prefix=None, suffix=None, script=None, pos=-1, damage=False):\n+    if prefix is None:\n+        prefix = []\n+    if suffix is None:\n+        suffix = []\n+\n+    ht = hashtype\n+\n+    damage_type = random.randrange(5) if damage else -1\n+    '''\n+    * 0. bit flip the sighash\n+    * 1. bit flip the signature\n+    * If the expected hashtype is 0:\n+    -- 2. append a 0 to the signature\n+    -- 3. append a random value of 1-255 to the signature\n+    * If the expected hashtype is not 0:\n+    -- 2. do not append hashtype to the signature\n+    -- 3. append a random incorrect value of 0-255 to the signature\n+    * 4. extra witness element\n+    '''\n+\n+    # Taproot key path spend: tweak key\n+    if script is None:\n+        _, negated = compute_xonly_pubkey(key)\n+        key = tweak_add_privkey(key, info[1], negated)\n+        assert(key is not None)\n+\n+    # Change SIGHASH_SINGLE into SIGHASH_ALL if no corresponding output\n+    if (ht & 3 == SIGHASH_SINGLE and input_index >= len(tx.vout)):\n+        ht ^= 2\n+    # Compute sighash\n+    if script:\n+        sighash = TaprootSignatureHash(tx, spent_utxos, ht, input_index, scriptpath=True, script=script, codeseparator_pos=pos, annex=annex)\n+    else:\n+        sighash = TaprootSignatureHash(tx, spent_utxos, ht, input_index, scriptpath=False, annex=annex)\n+    if damage_type == 0:\n+        sighash = damage_bytes(sighash)\n+    # Compute signature\n+    sig = sign_schnorr(key, sighash)\n+    if damage_type == 1:\n+        sig = damage_bytes(sig)\n+    if damage_type == 2:\n+        if ht == 0:\n+            sig += bytes([0])\n+    elif damage_type == 3:\n+        random_ht = ht\n+        while random_ht == ht:\n+            random_ht = random.randrange(256)\n+        sig += bytes([random_ht])\n+    elif ht > 0:\n+        sig += bytes([ht])\n+    # Construct witness\n+    ret = prefix + [sig] + suffix\n+    if script is not None:\n+        ret += [script, info[2][script]]\n+    if annex is not None:\n+        ret += [annex]\n+    if damage_type == 4:\n+        ret = [random_bytes(random.randrange(5))] + ret\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = ret\n+\n+def spend_alwaysvalid(tx, input_index, info, script, annex=None, damage=False):\n+    if isinstance(script, tuple):\n+        version, script = script\n+    ret = [script, info[2][script]]\n+    if damage:\n+        # With 50% chance, we bit flip the script (unless the script is an empty vector)\n+        # With 50% chance, we bit flip the control block\n+        if random.choice([True, False]) or len(ret[0]) == 0:\n+            # Annex is always required for leaf version 0x50\n+            # Unless the original version is 0x50, we couldn't convert it to 0x50 without using annex\n+            tmp = damage_bytes(ret[1])\n+            while annex is None and tmp[0] == ANNEX_TAG and ret[1][0] != ANNEX_TAG:\n+                tmp = damage_bytes(ret[1])\n+            ret[1] = tmp\n+        else:\n+            ret[0] = damage_bytes(ret[0])\n+    if annex is not None:\n+        ret += [annex]\n+    # Randomly add input witness\n+    if random.choice([True, False]):\n+        for i in range(random.randint(1, 10)):\n+            ret = [random_bytes(random.randint(0, MAX_SCRIPT_ELEMENT_SIZE * 2))] + ret\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = ret\n+\n+# N.B. Function arguments below: t(ransaction), i(ndex to spend), u(txos being spent), v(alid signature?)\n+\n+def spender_legacy(spenders, key, comment, hashtype, segwit, p2sh):\n+    \"\"\"Legacy signing (P2PKH, P2SH-P2PKH, P2WPKH, P2SH-P2WPKH, with signatures on valid/invalid sighashes).\"\"\"\n+    eckey = ECKey()\n+    eckey.set(key, True)\n+    pubkey = eckey.get_pubkey().get_bytes()\n+    pubkeyhash = hash160(pubkey)\n+    sigops_weight = 0\n+    if segwit:\n+        sigops_weight += 1\n+        spk = CScript([OP_0, pubkeyhash])\n+        if p2sh:\n+            addr = key_to_p2sh_p2wpkh(pubkey)\n+        else:\n+            addr = key_to_p2wpkh(pubkey)\n+    else:\n+        sigops_weight += 1 * WITNESS_SCALE_FACTOR\n+        spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+        if p2sh:\n+            addr = script_to_p2sh(spk)\n+        else:\n+            addr = key_to_p2pkh(pubkey)\n+    if p2sh:\n+        redeemscript = spk\n+        spk = CScript([OP_HASH160, hash160(redeemscript), OP_EQUAL])\n+\n+    def fn(t, i, u, v):\n+        script = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+        if segwit:\n+            sig_hash = SegwitV0SignatureHash(script, t, i, hashtype, u[i].nValue)\n+        else:\n+            sig_hash = LegacySignatureHash(script, t, i, hashtype)[0]\n+        if not v:\n+            sig_hash = damage_bytes(sig_hash)\n+        sig = eckey.sign_ecdsa(sig_hash) + bytes([hashtype])\n+        if segwit:\n+            t.wit.vtxinwit[i].scriptWitness.stack = [sig, pubkey]\n+        else:\n+            t.vin[i].scriptSig = CScript([sig, pubkey])\n+        if p2sh:\n+            t.vin[i].scriptSig = bytes(t.vin[i].scriptSig) + CScript([redeemscript])\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=True, sat_function=fn, err_msg=None, sigops_weight=sigops_weight))\n+\n+def spender_sighash_mutation(spenders, info, comment, standard=True, **kwargs):\n+    \"\"\"Mutates signature randomly when failure for the inputs is requested.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_single_sig(t, i, u, damage=not v, info=info, **kwargs)\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn, err_msg=None, sigops_weight=0))\n+\n+def spender_two_paths(spenders, info, comment, standard, success, failure, err_msg=None):\n+    \"\"\"Gives caller a way to specify two merkle paths to test validity satisfaction: One expected success, and one failure.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_single_sig(t, i, u, damage=False, info=info, **(success if v else failure))\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn, err_msg=err_msg, sigops_weight=0))\n+\n+def spender_alwaysvalid(spenders, info, comment, err_msg=None, **kwargs):\n+    \"\"\"Mutates the witness when requested, intended for otherwise always true scripts.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_alwaysvalid(t, i, damage=not v, info=info, **kwargs)\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=False, sat_function=fn, err_msg=err_msg, sigops_weight=0))\n+\n+def spender_two_paths_alwaysvalid(spenders, info, comment, standard, success, failure, err_msg=None):\n+    \"\"\"Allows specifying both a success and failure script without any signatures or additional witness data required.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_no_sig(t, i, u, info, (success if v else failure))\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn, err_msg=err_msg, sigops_weight=0))\n+\n+def spender_alwaysvalid_p2sh(spenders, info, comment, standard, script, err_msg=None):\n+    \"\"\"Tests that p2sh-wrapping witness program v1 are always valid, since they are not covered by tapscript.\"\"\"\n+    spk = get_p2sh_spk(info)\n+    addr = get_version1_p2sh(info)\n+\n+    def fn(t, i, u, v):\n+        if v:\n+            t.vin[i].scriptSig = CScript([info[0]])\n+            # Empty control block is only invalid if we apply taproot rules,\n+            # which we shouldn't if the spend is wrapped in P2SH\n+            t.wit.vtxinwit[i].scriptWitness.stack = [script, bytes()]\n+        else:\n+            t.vin[i].scriptSig = CScript()\n+        return\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn, err_msg=err_msg, sigops_weight=0))\n+\n+def nested_script(script, depth):\n+    if depth == 0:\n+        return script\n+    return [nested_script(script, depth - 1), CScript([OP_RETURN])]\n+\n+UTXOData = namedtuple('UTXOData', 'input,output,spender')\n+\n+class TaprootTest(BitcoinTestFramework):\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.extra_args = [[\"-whitelist=127.0.0.1\", \"-par=1\"]]\n+\n+    def block_submit(self, node, txs, msg, err_msg, cb_pubkey=None, fees=0, sigops_weight=0, witness=False, accept=False):\n+\n+        # Deplete block of any non-tapscript sigops using a single additional 0-value coinbase output.\n+        # It is not impossible to fit enough tapscript sigops to hit the old 80k limit without\n+        # busting txin-level limits. We simply have to account for the p2pk outputs in all\n+        # transactions.\n+        extra_output_script = CScript([OP_CHECKSIG]*((MAX_BLOCK_SIGOPS_WEIGHT - sigops_weight) // WITNESS_SCALE_FACTOR))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461605876",
      "id" : 461605876,
      "line" : 1158,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTYwNTg3Ng==",
      "original_commit_id" : "92d3928ed13d9287b24532e5be863fc6a505c069",
      "original_line" : 1158,
      "original_position" : 412,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : 1158,
      "pull_request_review_id" : 456661508,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461605876",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461854603"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461854603"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yeah, I know, but it's a lot harder to test that accurately (it needs creating outputs and spending them using witness spends, ...).\r\n\r\nIdeally, we'd also test that if you have one sigop too many, things also fail. Otherwise it could be the case that some of the  sigops estimates in the test are overestimates.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-28T20:21:04Z",
      "diff_hunk" : "@@ -0,0 +1,797 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import CTransaction, CTxIn, CTxOut, COutPoint, CTxInWitness\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_1SUB,\n+    OP_1NEGATE,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIF,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    TaprootSignatureHash,\n+    SegwitV0SignatureHash,\n+    LegacySignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, hex_str_to_bytes, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    program_to_witness,\n+    script_to_p2sh,\n+    hash160,\n+    key_to_p2wpkh,\n+    key_to_p2sh_p2wpkh,\n+    key_to_p2pkh,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+import struct\n+\n+EMPTYWITNESS_ERROR = \"non-mandatory-script-verify-flag (Witness program was passed an empty witness) (code 64)\"\n+INVALIDKEYPATHSIG_ERROR = \"non-mandatory-script-verify-flag (Invalid signature for Taproot key path spending) (code 64)\"\n+UNKNOWNWITNESS_ERROR = \"non-mandatory-script-verify-flag (Witness version reserved for soft-fork upgrades) (code 64)\"\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+def tx_from_hex(hexstring):\n+    tx = CTransaction()\n+    f = BytesIO(hex_str_to_bytes(hexstring))\n+    tx.deserialize(f)\n+    return tx\n+\n+def get_taproot_bech32(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return program_to_witness(1, info[2:])\n+\n+def get_version1_p2sh(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return script_to_p2sh(info)\n+\n+def get_p2sh_spk(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return CScript([OP_HASH160, hash160(info), OP_EQUAL])\n+\n+def random_op_success():\n+    ret = 0\n+    while (not is_op_success(ret)):\n+        ret = random.randint(0x50, 0xfe)\n+    return CScriptOp(ret)\n+\n+def random_unknown_leaf_ver(no_annex_tag=True):\n+    ret = LEAF_VERSION_TAPSCRIPT\n+    while (ret == LEAF_VERSION_TAPSCRIPT or (no_annex_tag and ret == (ANNEX_TAG & 0xfe))):\n+        ret = random.randrange(128) * 2\n+    return ret\n+\n+def random_bytes(n):\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+# TODO-TAPROOT Use this in a test\n+def random_script(size, no_success=True):\n+    ret = bytes()\n+    while (len(ret) < size):\n+        remain = size - len(ret)\n+        opcode = random.randrange(256)\n+        while (no_success and is_op_success(opcode)):\n+            opcode = random.randrange(256)\n+        if opcode == 0 or opcode >= OP_1NEGATE:\n+            ret += bytes([opcode])\n+        elif opcode <= 75 and opcode <= remain - 1:\n+            ret += bytes([opcode]) + random_bytes(opcode)\n+        elif opcode == 76 and remain >= 2:\n+            pushsize = random.randint(0, min(0xff, remain - 2))\n+            ret += bytes([opcode]) + bytes([pushsize]) + random_bytes(pushsize)\n+        elif opcode == 77 and remain >= 3:\n+            pushsize = random.randint(0, min(0xffff, remain - 3))\n+            ret += bytes([opcode]) + struct.pack(b'<H', pushsize) + random_bytes(pushsize)\n+        elif opcode == 78 and remain >= 5:\n+            pushsize = random.randint(0, min(0xffffffff, remain - 5))\n+            ret += bytes([opcode]) + struct.pack(b'<I', pushsize) + random_bytes(pushsize)\n+    assert len(ret) == size\n+    return ret\n+\n+# TODO-TAPROOT Use this in a test\n+def random_invalid_push(size):\n+    assert size > 0\n+    ret = bytes()\n+    opcode = 78\n+    if size <= 75:\n+        opcode = random.randint(75, 78)\n+    elif size <= 255:\n+        opcode = random.randint(76, 78)\n+    elif size <= 0xffff:\n+        opcode = random.randint(77, 78)\n+    if opcode == 75:\n+        ret = bytes([size]) + random_bytes(size - 1)\n+    elif opcode == 76:\n+        ret = bytes([opcode]) + bytes([size]) + random_bytes(size - 2)\n+    elif opcode == 77:\n+        ret = bytes([opcode]) + struct.pack(b'<H', size) + random_bytes(max(0, size - 3))\n+    else:\n+        ret = bytes([opcode]) + struct.pack(b'<I', size) + random_bytes(max(0, size - 5))\n+    assert len(ret) >= size\n+    return ret[:size]\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def damage_bytes(b):\n+    \"\"\"Flips one bit at random in a byte string.\"\"\"\n+    return (int.from_bytes(b, 'big') ^ (1 << random.randrange(len(b) * 8))).to_bytes(len(b), 'big')\n+\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - An address for that scriptPubKey (string)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A witness stack-producing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a succesful spend\n+\n+Spender = namedtuple(\"Spender\", \"script,address,comment,is_standard,sat_function,err_msg,sigops_weight\")\n+\n+def spend_no_sig(tx, input_index, spent_utxos, info, script):\n+    \"\"\"Construct witness.\"\"\"\n+    script = script[\"script\"]\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = [script, info[2][script]]\n+\n+def spend_single_sig(tx, input_index, spent_utxos, info, key, annex=None, hashtype=0, prefix=None, suffix=None, script=None, pos=-1, damage=False):\n+    if prefix is None:\n+        prefix = []\n+    if suffix is None:\n+        suffix = []\n+\n+    ht = hashtype\n+\n+    damage_type = random.randrange(5) if damage else -1\n+    '''\n+    * 0. bit flip the sighash\n+    * 1. bit flip the signature\n+    * If the expected hashtype is 0:\n+    -- 2. append a 0 to the signature\n+    -- 3. append a random value of 1-255 to the signature\n+    * If the expected hashtype is not 0:\n+    -- 2. do not append hashtype to the signature\n+    -- 3. append a random incorrect value of 0-255 to the signature\n+    * 4. extra witness element\n+    '''\n+\n+    # Taproot key path spend: tweak key\n+    if script is None:\n+        _, negated = compute_xonly_pubkey(key)\n+        key = tweak_add_privkey(key, info[1], negated)\n+        assert(key is not None)\n+\n+    # Change SIGHASH_SINGLE into SIGHASH_ALL if no corresponding output\n+    if (ht & 3 == SIGHASH_SINGLE and input_index >= len(tx.vout)):\n+        ht ^= 2\n+    # Compute sighash\n+    if script:\n+        sighash = TaprootSignatureHash(tx, spent_utxos, ht, input_index, scriptpath=True, script=script, codeseparator_pos=pos, annex=annex)\n+    else:\n+        sighash = TaprootSignatureHash(tx, spent_utxos, ht, input_index, scriptpath=False, annex=annex)\n+    if damage_type == 0:\n+        sighash = damage_bytes(sighash)\n+    # Compute signature\n+    sig = sign_schnorr(key, sighash)\n+    if damage_type == 1:\n+        sig = damage_bytes(sig)\n+    if damage_type == 2:\n+        if ht == 0:\n+            sig += bytes([0])\n+    elif damage_type == 3:\n+        random_ht = ht\n+        while random_ht == ht:\n+            random_ht = random.randrange(256)\n+        sig += bytes([random_ht])\n+    elif ht > 0:\n+        sig += bytes([ht])\n+    # Construct witness\n+    ret = prefix + [sig] + suffix\n+    if script is not None:\n+        ret += [script, info[2][script]]\n+    if annex is not None:\n+        ret += [annex]\n+    if damage_type == 4:\n+        ret = [random_bytes(random.randrange(5))] + ret\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = ret\n+\n+def spend_alwaysvalid(tx, input_index, info, script, annex=None, damage=False):\n+    if isinstance(script, tuple):\n+        version, script = script\n+    ret = [script, info[2][script]]\n+    if damage:\n+        # With 50% chance, we bit flip the script (unless the script is an empty vector)\n+        # With 50% chance, we bit flip the control block\n+        if random.choice([True, False]) or len(ret[0]) == 0:\n+            # Annex is always required for leaf version 0x50\n+            # Unless the original version is 0x50, we couldn't convert it to 0x50 without using annex\n+            tmp = damage_bytes(ret[1])\n+            while annex is None and tmp[0] == ANNEX_TAG and ret[1][0] != ANNEX_TAG:\n+                tmp = damage_bytes(ret[1])\n+            ret[1] = tmp\n+        else:\n+            ret[0] = damage_bytes(ret[0])\n+    if annex is not None:\n+        ret += [annex]\n+    # Randomly add input witness\n+    if random.choice([True, False]):\n+        for i in range(random.randint(1, 10)):\n+            ret = [random_bytes(random.randint(0, MAX_SCRIPT_ELEMENT_SIZE * 2))] + ret\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = ret\n+\n+# N.B. Function arguments below: t(ransaction), i(ndex to spend), u(txos being spent), v(alid signature?)\n+\n+def spender_legacy(spenders, key, comment, hashtype, segwit, p2sh):\n+    \"\"\"Legacy signing (P2PKH, P2SH-P2PKH, P2WPKH, P2SH-P2WPKH, with signatures on valid/invalid sighashes).\"\"\"\n+    eckey = ECKey()\n+    eckey.set(key, True)\n+    pubkey = eckey.get_pubkey().get_bytes()\n+    pubkeyhash = hash160(pubkey)\n+    sigops_weight = 0\n+    if segwit:\n+        sigops_weight += 1\n+        spk = CScript([OP_0, pubkeyhash])\n+        if p2sh:\n+            addr = key_to_p2sh_p2wpkh(pubkey)\n+        else:\n+            addr = key_to_p2wpkh(pubkey)\n+    else:\n+        sigops_weight += 1 * WITNESS_SCALE_FACTOR\n+        spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+        if p2sh:\n+            addr = script_to_p2sh(spk)\n+        else:\n+            addr = key_to_p2pkh(pubkey)\n+    if p2sh:\n+        redeemscript = spk\n+        spk = CScript([OP_HASH160, hash160(redeemscript), OP_EQUAL])\n+\n+    def fn(t, i, u, v):\n+        script = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+        if segwit:\n+            sig_hash = SegwitV0SignatureHash(script, t, i, hashtype, u[i].nValue)\n+        else:\n+            sig_hash = LegacySignatureHash(script, t, i, hashtype)[0]\n+        if not v:\n+            sig_hash = damage_bytes(sig_hash)\n+        sig = eckey.sign_ecdsa(sig_hash) + bytes([hashtype])\n+        if segwit:\n+            t.wit.vtxinwit[i].scriptWitness.stack = [sig, pubkey]\n+        else:\n+            t.vin[i].scriptSig = CScript([sig, pubkey])\n+        if p2sh:\n+            t.vin[i].scriptSig = bytes(t.vin[i].scriptSig) + CScript([redeemscript])\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=True, sat_function=fn, err_msg=None, sigops_weight=sigops_weight))\n+\n+def spender_sighash_mutation(spenders, info, comment, standard=True, **kwargs):\n+    \"\"\"Mutates signature randomly when failure for the inputs is requested.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_single_sig(t, i, u, damage=not v, info=info, **kwargs)\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn, err_msg=None, sigops_weight=0))\n+\n+def spender_two_paths(spenders, info, comment, standard, success, failure, err_msg=None):\n+    \"\"\"Gives caller a way to specify two merkle paths to test validity satisfaction: One expected success, and one failure.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_single_sig(t, i, u, damage=False, info=info, **(success if v else failure))\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn, err_msg=err_msg, sigops_weight=0))\n+\n+def spender_alwaysvalid(spenders, info, comment, err_msg=None, **kwargs):\n+    \"\"\"Mutates the witness when requested, intended for otherwise always true scripts.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_alwaysvalid(t, i, damage=not v, info=info, **kwargs)\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=False, sat_function=fn, err_msg=err_msg, sigops_weight=0))\n+\n+def spender_two_paths_alwaysvalid(spenders, info, comment, standard, success, failure, err_msg=None):\n+    \"\"\"Allows specifying both a success and failure script without any signatures or additional witness data required.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_no_sig(t, i, u, info, (success if v else failure))\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn, err_msg=err_msg, sigops_weight=0))\n+\n+def spender_alwaysvalid_p2sh(spenders, info, comment, standard, script, err_msg=None):\n+    \"\"\"Tests that p2sh-wrapping witness program v1 are always valid, since they are not covered by tapscript.\"\"\"\n+    spk = get_p2sh_spk(info)\n+    addr = get_version1_p2sh(info)\n+\n+    def fn(t, i, u, v):\n+        if v:\n+            t.vin[i].scriptSig = CScript([info[0]])\n+            # Empty control block is only invalid if we apply taproot rules,\n+            # which we shouldn't if the spend is wrapped in P2SH\n+            t.wit.vtxinwit[i].scriptWitness.stack = [script, bytes()]\n+        else:\n+            t.vin[i].scriptSig = CScript()\n+        return\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn, err_msg=err_msg, sigops_weight=0))\n+\n+def nested_script(script, depth):\n+    if depth == 0:\n+        return script\n+    return [nested_script(script, depth - 1), CScript([OP_RETURN])]\n+\n+UTXOData = namedtuple('UTXOData', 'input,output,spender')\n+\n+class TaprootTest(BitcoinTestFramework):\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.extra_args = [[\"-whitelist=127.0.0.1\", \"-par=1\"]]\n+\n+    def block_submit(self, node, txs, msg, err_msg, cb_pubkey=None, fees=0, sigops_weight=0, witness=False, accept=False):\n+\n+        # Deplete block of any non-tapscript sigops using a single additional 0-value coinbase output.\n+        # It is not impossible to fit enough tapscript sigops to hit the old 80k limit without\n+        # busting txin-level limits. We simply have to account for the p2pk outputs in all\n+        # transactions.\n+        extra_output_script = CScript([OP_CHECKSIG]*((MAX_BLOCK_SIGOPS_WEIGHT - sigops_weight) // WITNESS_SCALE_FACTOR))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461854603",
      "id" : 461854603,
      "in_reply_to_id" : 461605876,
      "line" : 1158,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg1NDYwMw==",
      "original_commit_id" : "92d3928ed13d9287b24532e5be863fc6a505c069",
      "original_line" : 1158,
      "original_position" : 412,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : 1158,
      "pull_request_review_id" : 456981742,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461854603",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461872479"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461872479"
         }
      },
      "author_association" : "MEMBER",
      "body" : "See https://github.com/bitcoin/bips/pull/954 for fixing the consensus-critical inconsistency.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-28T20:54:21Z",
      "diff_hunk" : "@@ -1319,6 +1345,76 @@ template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo,\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HasherTapSighash = TaggedHash(\"TapSighash\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461872479",
      "id" : 461872479,
      "in_reply_to_id" : 459531548,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg3MjQ3OQ==",
      "original_commit_id" : "41d08f5d77f52bec0e31bb081d85fff2d67d0467",
      "original_line" : 1348,
      "original_position" : 70,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 457004350,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461872479",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461954582"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461954582"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Better now? I've extended the test further too, and moved it to its own section.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-28T23:40:40Z",
      "diff_hunk" : "@@ -0,0 +1,745 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS,\n+)\n+from test_framework.messages import CTransaction, CTxIn, CTxOut, COutPoint, CTxInWitness\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_1SUB,\n+    OP_1NEGATE,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIF,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, hex_str_to_bytes, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey\n+from test_framework.address import program_to_witness, script_to_p2sh, hash160\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+import struct\n+\n+EMPTYWITNESS_ERROR = \"non-mandatory-script-verify-flag (Witness program was passed an empty witness) (code 64)\"\n+INVALIDKEYPATHSIG_ERROR = \"non-mandatory-script-verify-flag (Invalid signature for Taproot key path spending) (code 64)\"\n+UNKNOWNWITNESS_ERROR = \"non-mandatory-script-verify-flag (Witness version reserved for soft-fork upgrades) (code 64)\"\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+def tx_from_hex(hexstring):\n+    tx = CTransaction()\n+    f = BytesIO(hex_str_to_bytes(hexstring))\n+    tx.deserialize(f)\n+    return tx\n+\n+def get_taproot_bech32(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return program_to_witness(1, info[2:])\n+\n+def get_version1_p2sh(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return script_to_p2sh(info)\n+\n+def get_p2sh_spk(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return CScript([OP_HASH160, hash160(info), OP_EQUAL])\n+\n+def random_op_success():\n+    ret = 0\n+    while (not is_op_success(ret)):\n+        ret = random.randint(0x50, 0xfe)\n+    return CScriptOp(ret)\n+\n+def random_unknown_leaf_ver(no_annex_tag=True):\n+    ret = LEAF_VERSION_TAPSCRIPT\n+    while (ret == LEAF_VERSION_TAPSCRIPT or (no_annex_tag and ret == (ANNEX_TAG & 0xfe))):\n+        ret = random.randrange(128) * 2\n+    return ret\n+\n+def random_bytes(n):\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+# TODO-TAPROOT Use this in a test\n+def random_script(size, no_success=True):\n+    ret = bytes()\n+    while (len(ret) < size):\n+        remain = size - len(ret)\n+        opcode = random.randrange(256)\n+        while (no_success and is_op_success(opcode)):\n+            opcode = random.randrange(256)\n+        if opcode == 0 or opcode >= OP_1NEGATE:\n+            ret += bytes([opcode])\n+        elif opcode <= 75 and opcode <= remain - 1:\n+            ret += bytes([opcode]) + random_bytes(opcode)\n+        elif opcode == 76 and remain >= 2:\n+            pushsize = random.randint(0, min(0xff, remain - 2))\n+            ret += bytes([opcode]) + bytes([pushsize]) + random_bytes(pushsize)\n+        elif opcode == 77 and remain >= 3:\n+            pushsize = random.randint(0, min(0xffff, remain - 3))\n+            ret += bytes([opcode]) + struct.pack(b'<H', pushsize) + random_bytes(pushsize)\n+        elif opcode == 78 and remain >= 5:\n+            pushsize = random.randint(0, min(0xffffffff, remain - 5))\n+            ret += bytes([opcode]) + struct.pack(b'<I', pushsize) + random_bytes(pushsize)\n+    assert len(ret) == size\n+    return ret\n+\n+# TODO-TAPROOT Use this in a test\n+def random_invalid_push(size):\n+    assert size > 0\n+    ret = bytes()\n+    opcode = 78\n+    if size <= 75:\n+        opcode = random.randint(75, 78)\n+    elif size <= 255:\n+        opcode = random.randint(76, 78)\n+    elif size <= 0xffff:\n+        opcode = random.randint(77, 78)\n+    if opcode == 75:\n+        ret = bytes([size]) + random_bytes(size - 1)\n+    elif opcode == 76:\n+        ret = bytes([opcode]) + bytes([size]) + random_bytes(size - 2)\n+    elif opcode == 77:\n+        ret = bytes([opcode]) + struct.pack(b'<H', size) + random_bytes(max(0, size - 3))\n+    else:\n+        ret = bytes([opcode]) + struct.pack(b'<I', size) + random_bytes(max(0, size - 5))\n+    assert len(ret) >= size\n+    return ret[:size]\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def damage_bytes(b):\n+    \"\"\"Flips one bit at random in a byte string.\"\"\"\n+    return (int.from_bytes(b, 'big') ^ (1 << random.randrange(len(b) * 8))).to_bytes(len(b), 'big')\n+\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - An address for that scriptPubKey (string)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A witness stack-producing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+\n+Spender = namedtuple(\"Spender\", \"script,address,comment,is_standard,sat_function\")\n+\n+def spend_no_sig(tx, input_index, spent_utxos, info, script):\n+    \"\"\"Construct witness.\"\"\"\n+    script = script[\"script\"]\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = [script, info[2][script]]\n+\n+def spend_single_sig(tx, input_index, spent_utxos, info, key, annex=None, hashtype=0, prefix=None, suffix=None, script=None, pos=-1, damage=False):\n+    if prefix is None:\n+        prefix = []\n+    if suffix is None:\n+        suffix = []\n+\n+    ht = hashtype\n+\n+    damage_type = random.randrange(5) if damage else -1\n+    '''\n+    * 0. bit flip the sighash\n+    * 1. bit flip the signature\n+    * If the expected hashtype is 0:\n+    -- 2. append a 0 to the signature\n+    -- 3. append a random value of 1-255 to the signature\n+    * If the expected hashtype is not 0:\n+    -- 2. do not append hashtype to the signature\n+    -- 3. append a random incorrect value of 0-255 to the signature\n+    * 4. extra witness element\n+    '''\n+\n+    # Taproot key path spend: tweak key\n+    if script is None:\n+        _, negated = compute_xonly_pubkey(key)\n+        key = tweak_add_privkey(key, info[1], negated)\n+        assert(key is not None)\n+\n+    # Change SIGHASH_SINGLE into SIGHASH_ALL if no corresponding output\n+    if (ht & 3 == SIGHASH_SINGLE and input_index >= len(tx.vout)):\n+        ht ^= 2\n+    # Compute sighash\n+    if script:\n+        sighash = TaprootSignatureHash(tx, spent_utxos, ht, input_index, scriptpath=True, script=script, codeseparator_pos=pos, annex=annex)\n+    else:\n+        sighash = TaprootSignatureHash(tx, spent_utxos, ht, input_index, scriptpath=False, annex=annex)\n+    if damage_type == 0:\n+        sighash = damage_bytes(sighash)\n+    # Compute signature\n+    sig = sign_schnorr(key, sighash)\n+    if damage_type == 1:\n+        sig = damage_bytes(sig)\n+    if damage_type == 2:\n+        if ht == 0:\n+            sig += bytes([0])\n+    elif damage_type == 3:\n+        random_ht = ht\n+        while random_ht == ht:\n+            random_ht = random.randrange(256)\n+        sig += bytes([random_ht])\n+    elif ht > 0:\n+        sig += bytes([ht])\n+    # Construct witness\n+    ret = prefix + [sig] + suffix\n+    if script is not None:\n+        ret += [script, info[2][script]]\n+    if annex is not None:\n+        ret += [annex]\n+    if damage_type == 4:\n+        ret = [random_bytes(random.randrange(5))] + ret\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = ret\n+\n+def spend_alwaysvalid(tx, input_index, info, script, annex=None, damage=False):\n+    if isinstance(script, tuple):\n+        version, script = script\n+    ret = [script, info[2][script]]\n+    if damage:\n+        # With 50% chance, we bit flip the script (unless the script is an empty vector)\n+        # With 50% chance, we bit flip the control block\n+        if random.choice([True, False]) or len(ret[0]) == 0:\n+            # Annex is always required for leaf version 0x50\n+            # Unless the original version is 0x50, we couldn't convert it to 0x50 without using annex\n+            tmp = damage_bytes(ret[1])\n+            while annex is None and tmp[0] == ANNEX_TAG and ret[1][0] != ANNEX_TAG:\n+                tmp = damage_bytes(ret[1])\n+            ret[1] = tmp\n+        else:\n+            ret[0] = damage_bytes(ret[0])\n+    if annex is not None:\n+        ret += [annex]\n+    # Randomly add input witness\n+    if random.choice([True, False]):\n+        for i in range(random.randint(1, 10)):\n+            ret = [random_bytes(random.randint(0, MAX_SCRIPT_ELEMENT_SIZE * 2))] + ret\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = ret\n+\n+# N.B. Function arguments below: t(ransaction), i(ndex to spend), u(txos being spent), v(alid signature?)\n+\n+def spender_sighash_mutation(spenders, info, comment, standard=True, **kwargs):\n+    \"\"\"Mutates signature randomly when failure for the inputs is requested.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_single_sig(t, i, u, damage=not v, info=info, **kwargs)\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn))\n+\n+def spender_two_paths(spenders, info, comment, standard, success, failure):\n+    \"\"\"Gives caller a way to specify two merkle paths to test validity satisfaction: One expected success, and one failure.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_single_sig(t, i, u, damage=False, info=info, **(success if v else failure))\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn))\n+\n+def spender_alwaysvalid(spenders, info, comment, **kwargs):\n+    \"\"\"Mutates the witness when requested, intended for otherwise always true scripts.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_alwaysvalid(t, i, damage=not v, info=info, **kwargs)\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=False, sat_function=fn))\n+\n+def spender_two_paths_alwaysvalid(spenders, info, comment, standard, success, failure):\n+    \"\"\"Allows specifying both a success and failure script without any signatures or additional witness data required.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_no_sig(t, i, u, info, (success if v else failure))\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn))\n+\n+def spender_alwaysvalid_p2sh(spenders, info, comment, standard, script):\n+    \"\"\"Tests that p2sh-wrapping witness program v1 are always valid, since they are not covered by tapscript.\"\"\"\n+    spk = get_p2sh_spk(info)\n+    addr = get_version1_p2sh(info)\n+\n+    def fn(t, i, u, v):\n+        if v:\n+            t.vin[i].scriptSig = CScript([info[0]])\n+            # Empty control block is only invalid if we apply taproot rules,\n+            # which we shouldn't if the spend is wrapped in P2SH\n+            t.wit.vtxinwit[i].scriptWitness.stack = [script, bytes()]\n+        else:\n+            t.vin[i].scriptSig = CScript()\n+        return\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn))\n+\n+def spender_two_paths_no_sig(spenders, info, comment, standard, success, failure):\n+    \"\"\"Same as spender_two_paths but not support for signatures or padding witness.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    # Empty witness required\n+    def fn(t, i, u, v):\n+        return []\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn))\n+\n+def nested_script(script, depth):\n+    if depth == 0:\n+        return script\n+    return [nested_script(script, depth - 1), CScript([OP_RETURN])]\n+\n+UTXOData = namedtuple('UTXOData', 'input,output,spender')\n+\n+class TaprootTest(BitcoinTestFramework):\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.extra_args = [[\"-whitelist=127.0.0.1\", \"-par=1\"]]\n+\n+    def block_submit(self, node, txs, msg, cb_pubkey=None, fees=0, witness=False, accept=False):\n+\n+        # Deplete block of any non-tapscript sigops using a single additional 0-value coinbase output\n+        # It's physically impossible to fit enough tapscript sigops to hit the old 80k limit without\n+        # busting txin-level limits. We simply have to account for the p2pk outputs in all\n+        # transactions. N.B. this test means no spenders can ever spend non-taproot/tapscript outputs,\n+        # or those at least have to be accounted for here.\n+\n+        def MaybeIsPayToPubKey(script):\n+            return script[-1] == OP_CHECKSIG\n+\n+        legacy_checksigs = 0 if cb_pubkey is None else 1 # P2PK output in coinbase back to wallet\n+        for tx in txs:\n+            for output in tx.vout:\n+                if MaybeIsPayToPubKey(output.scriptPubKey):\n+                    legacy_checksigs += 1\n+        extra_output_script = CScript([OP_CHECKSIG]*(MAX_BLOCK_SIGOPS-legacy_checksigs))\n+\n+        block = create_block(self.tip, create_coinbase(self.lastblockheight + 1, pubkey=cb_pubkey, extra_output_script=extra_output_script, fees=fees), self.lastblocktime + 1)\n+        block.nVersion = 4\n+        for tx in txs:\n+            tx.rehash()\n+            block.vtx.append(tx)\n+        block.hashMerkleRoot = block.calc_merkle_root()\n+        witness and add_witness_commitment(block)\n+        block.rehash()\n+        block.solve()\n+        node.submitblock(block.serialize(True).hex())\n+        if (accept):\n+            assert node.getbestblockhash() == block.hash, \"Failed to accept: \" + msg\n+            self.tip = block.sha256\n+            self.lastblockhash = block.hash\n+            self.lastblocktime += 1\n+            self.lastblockheight += 1\n+        else:\n+            assert node.getbestblockhash() == self.lastblockhash, \"Failed to reject: \" + msg\n+\n+    def test_spenders(self, spenders, input_counts):\n+        \"\"\"Run randomized tests with a number of \"spenders\".\n+\n+        Steps:\n+            1) Generate an appropriate UTXO for each spender to test spend conditions\n+            2) Generate 100 random addresses of all wallet types: pkh/sh_wpkh/wpkh\n+            3) Select random number of inputs from (1)\n+            4) Select random number of addresses from (2) as outputs\n+\n+        Each spender embodies a test; in a large randomized test, it is verified\n+        that toggling the valid argument to each lambda toggles the validity of\n+        the transaction. This is accomplished by constructing transactions consisting\n+        of all valid inputs, except one invalid one.\n+        \"\"\"\n+\n+        # Construct a UTXO to spend for each of the spenders, with the script to satisfy being given by the spender\n+        self.nodes[0].generate(110)\n+        bal = self.nodes[0].getbalance() * 3 / (4 * len(spenders))\n+        random.shuffle(spenders)\n+        num_spenders = len(spenders)\n+        utxos = []\n+        while len(spenders):\n+            # Create the necessary outputs in multiple transactions, as sPKs may be repeated in test cases(which sendmany does not support)\n+            outputs = {}\n+            new_spenders = []\n+            batch = []\n+            for spender in spenders:\n+                addr = spender.address\n+                if len(batch) == 100 or addr in outputs:\n+                    new_spenders.append(spender)\n+                else:\n+                    amount = random.randrange(int(bal * 95000000), int(bal * 105000000))\n+                    outputs[addr] = amount / 100000000\n+                    batch.append(spender)\n+            self.log.info(\"Constructing %i UTXOs for spending tests\" % len(batch))\n+            tx = tx_from_hex(self.nodes[0].getrawtransaction(self.nodes[0].sendmany(\"\", outputs)))\n+            tx.rehash()\n+            spenders = new_spenders\n+            random.shuffle(spenders)\n+\n+            # Map created UTXOs back to the spenders they were created for\n+            for n, out in enumerate(tx.vout):\n+                for spender in batch:\n+                    if out.scriptPubKey == spender.script:\n+                        utxos.append(UTXOData(input=COutPoint(tx.sha256, n), output=out, spender=spender))\n+                        break\n+        assert(len(utxos) == num_spenders)\n+        random.shuffle(utxos)\n+        self.nodes[0].generate(1)\n+\n+        # Construct a bunch of sPKs that send coins back to the host wallet\n+        self.log.info(\"Constructing 100 addresses for returning coins\")\n+        host_spks = []\n+        host_pubkeys = []\n+        for i in range(100):\n+            addr = self.nodes[0].getnewaddress(address_type=random.choice([\"legacy\", \"p2sh-segwit\", \"bech32\"]))\n+            info = self.nodes[0].getaddressinfo(addr)\n+            spk = hex_str_to_bytes(info['scriptPubKey'])\n+            host_spks.append(spk)\n+            host_pubkeys.append(hex_str_to_bytes(info['pubkey']))\n+\n+        # Pick random subsets of UTXOs to construct transactions with\n+        self.lastblockhash = self.nodes[0].getbestblockhash()\n+        self.tip = int(\"0x\" + self.lastblockhash, 0)\n+        block = self.nodes[0].getblock(self.lastblockhash)\n+        self.lastblockheight = block['height']\n+        self.lastblocktime = block['time']\n+        while len(utxos):\n+            tx = CTransaction()\n+            tx.nVersion = random.choice([1, 2, random.randint(-0x80000000, 0x7fffffff)])\n+            min_sequence = (tx.nVersion != 1 and tx.nVersion != 0) * 0x80000000  # The minimum sequence number to disable relative locktime\n+            if random.choice([True, False]):\n+                tx.nLockTime = random.randrange(LOCKTIME_THRESHOLD, self.lastblocktime - 7200)  # all absolute locktimes in the past\n+            else:\n+                tx.nLockTime = random.randrange(self.lastblockheight + 1)  # all block heights in the past\n+\n+            # Pick 1 to 4 UTXOs to construct transaction inputs\n+            acceptable_input_counts = [cnt for cnt in input_counts if cnt <= len(utxos)]\n+            while True:\n+                inputs = random.choice(acceptable_input_counts)\n+                remaining = len(utxos) - inputs\n+                if remaining == 0 or remaining >= max(input_counts) or remaining in input_counts:\n+                    break\n+            input_utxos = utxos[-inputs:]\n+            utxos = utxos[:-inputs]\n+            fee = random.randrange(MIN_FEE * 2, MIN_FEE * 4)  # 10000-20000 sat fee\n+            in_value = sum(utxo.output.nValue for utxo in input_utxos) - fee\n+            tx.vin = [CTxIn(outpoint=input_utxos[i].input, nSequence=random.randint(min_sequence, 0xffffffff)) for i in range(inputs)]\n+            tx.wit.vtxinwit = [CTxInWitness() for i in range(inputs)]\n+            self.log.info(\"Test: %s\" % (\", \".join(utxo.spender.comment for utxo in input_utxos)))\n+\n+            # Add 1 to 4 outputs\n+            outputs = random.choice([1, 2, 3, 4])\n+            assert in_value >= 0 and fee - outputs * DUST_LIMIT >= MIN_FEE\n+            for i in range(outputs):\n+                tx.vout.append(CTxOut())\n+                if in_value <= DUST_LIMIT:\n+                    tx.vout[-1].nValue = DUST_LIMIT\n+                elif i < outputs - 1:\n+                    tx.vout[-1].nValue = in_value\n+                else:\n+                    tx.vout[-1].nValue = random.randint(DUST_LIMIT, in_value)\n+                in_value -= tx.vout[-1].nValue\n+                tx.vout[-1].scriptPubKey = random.choice(host_spks)\n+            fee += in_value\n+            assert(fee >= 0)\n+\n+            # Sign each input incorrectly once on each complete signing pass, except the very last\n+            for fail_input in range(inputs + 1):\n+                # Wipe scriptSig/witness\n+                for i in range(inputs):\n+                    tx.vin[i].scriptSig = CScript()\n+                    tx.wit.vtxinwit[i] = CTxInWitness()\n+                # Fill inputs/witnesses\n+                for i in range(inputs):\n+                    fn = input_utxos[i].spender.sat_function\n+                    fn(tx, i, [utxo.output for utxo in input_utxos], i != fail_input)\n+                # Submit to mempool to check standardness\n+                is_standard_tx = fail_input == inputs and all(utxo.spender.is_standard for utxo in input_utxos) and tx.nVersion >= 1 and tx.nVersion <= 2\n+                tx.rehash()\n+                if is_standard_tx:\n+                    self.nodes[0].sendrawtransaction(tx.serialize().hex(), 0)\n+                    assert(self.nodes[0].getmempoolentry(tx.hash) is not None)\n+                else:\n+                    assert_raises_rpc_error(-26, None, self.nodes[0].sendrawtransaction, tx.serialize().hex(), 0)\n+                # Submit in a block\n+                msg = ','.join(utxo.spender.comment + (\"*\" if n == fail_input else \"\") for n, utxo in enumerate(input_utxos))\n+                self.block_submit(self.nodes[0], [tx], msg, witness=True, accept=fail_input == inputs, cb_pubkey=random.choice(host_pubkeys), fees=fee)\n+\n+    def build_spenders(self):\n+        VALID_SIGHASHES = [SIGHASH_DEFAULT, SIGHASH_ALL, SIGHASH_NONE, SIGHASH_SINGLE, SIGHASH_ANYONECANPAY + SIGHASH_ALL, \\\n+                SIGHASH_ANYONECANPAY + SIGHASH_NONE, SIGHASH_ANYONECANPAY + SIGHASH_SINGLE]\n+        spenders = []\n+\n+        # Two features: No annex, and annex with random number of random bytes.\n+        for annex in [None, bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+            # Non-empty annex is non-standard\n+            no_annex = annex is None\n+            sec1, sec2 = generate_privkey(), generate_privkey()\n+            pub1, _ = compute_xonly_pubkey(sec1)\n+            pub2, _ = compute_xonly_pubkey(sec2)\n+\n+            # Sighash mutation tests (test all sighash combinations)\n+            for hashtype in VALID_SIGHASHES:\n+                # Pure pubkey\n+                info = taproot_construct(pub1)\n+                # As an example, comment argument under this line means \"Sighash test for p2tr, spent through taproot key\".\n+                spender_sighash_mutation(spenders, info, \"sighash/pk#pk\", key=sec1, hashtype=hashtype, annex=annex, standard=no_annex)\n+                # Pubkey/P2PK script combination\n+                scripts = [CScript(random_checksig_style(pub2))]\n+                info = taproot_construct(pub1, scripts)\n+                # As an example, comment argument under this line means \"Sighash test for p2pk script in p2tr pubkey, spent through taproot key\".\n+                spender_sighash_mutation(spenders, info, \"sighash/p2pk#pk\", key=sec1, hashtype=hashtype, annex=annex, standard=no_annex)\n+                # As an example, comment argument under this line means \"Sighash test for p2pk script in p2tr pubkey, spent through p2pk key\".\n+                spender_sighash_mutation(spenders, info, \"sighash/p2pk#s0\", script=scripts[0], key=sec2, hashtype=hashtype, annex=annex, standard=no_annex)\n+\n+            # For more complex scripts only test one sighash type\n+            hashtype = random.choice(VALID_SIGHASHES)\n+            scripts = [\n+                CScript(random_checksig_style(pub2) + bytes([OP_CODESEPARATOR])),  # codesep after checksig\n+                CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pub2)),  # codesep before checksig\n+                CScript([bytes([1,2,3]), OP_DROP, OP_IF, OP_CODESEPARATOR, pub1, OP_ELSE, OP_CODESEPARATOR, pub2, OP_ENDIF, OP_CHECKSIG]),  # branch dependent codesep\n+            ]\n+            info = taproot_construct(pub1, scripts)\n+            spender_sighash_mutation(spenders, info, \"sighash/codesep#pk\", key=sec1, hashtype=hashtype, annex=annex, standard=no_annex)\n+            spender_sighash_mutation(spenders, info, \"sighash/codesep#s0\", script=scripts[0], key=sec2, hashtype=hashtype, annex=annex, standard=no_annex)\n+            spender_sighash_mutation(spenders, info, \"sighash/codesep#s1\", script=scripts[1], key=sec2, hashtype=hashtype, annex=annex, pos=0, standard=no_annex)\n+            spender_sighash_mutation(spenders, info, \"sighash/codesep#s2a\", script=scripts[2], key=sec1, hashtype=hashtype, annex=annex, pos=3, suffix=[bytes([1])], standard=no_annex)\n+            spender_sighash_mutation(spenders, info, \"sighash/codesep#s2b\", script=scripts[2], key=sec2, hashtype=hashtype, annex=annex, pos=6, suffix=[bytes([])], standard=no_annex)\n+\n+            # Taproot max Merkle path length\n+            scripts = [\n+                CScript([pub2, OP_CHECKSIG]),\n+                [\n+                    CScript([pub1, OP_CHECKSIG]),\n+                    CScript([OP_RETURN])\n+                ]\n+            ]\n+            info = taproot_construct(pub1, nested_script(scripts, 127))\n+            spender_two_paths(spenders, info, \"taproot/merklelimit\", standard=no_annex, success={\"key\": sec2, \"hashtype\": hashtype, \"annex\": annex, \"script\": scripts[0]}, failure={\"key\": sec1, \"hashtype\": hashtype, \"annex\": annex, \"script\": scripts[1][0]})\n+\n+            # Above OP_16 to avoid minimal encoding complaints\n+            checksigadd_val = random.randrange(17, 100)\n+            checksigadd_arg = CScriptNum(checksigadd_val)\n+            checksigadd_result = CScriptNum(checksigadd_val+1)\n+\n+            # Illegally-large number for script arithmetic input\n+            oversize_number = 2**31\n+            assert_equal(len(CScriptNum.encode(CScriptNum(oversize_number))), 6)\n+            assert_equal(len(CScriptNum.encode(CScriptNum(oversize_number-1))), 5)\n+\n+            # Various BIP342 features\n+            scripts = [\n+                # 0) drop stack element and OP_CHECKSIG\n+                CScript([OP_DROP, pub2, OP_CHECKSIG]),\n+                # 1) normal OP_CHECKSIG\n+                CScript([pub2, OP_CHECKSIG]),\n+                # 2) normal OP_CHECKSIGVERIFY\n+                CScript([pub2, OP_CHECKSIGVERIFY, OP_1]),\n+                # 3) Hypothetical OP_CHECKMULTISIG script that takes a single sig as input\n+                CScript([OP_0, OP_SWAP, OP_1, pub2, OP_1, OP_CHECKMULTISIG]),\n+                # 4) Hypothetical OP_CHECKMULTISIGVERIFY script that takes a single sig as input\n+                CScript([OP_0, OP_SWAP, OP_1, pub2, OP_1, OP_CHECKMULTISIGVERIFY, OP_1]),\n+                # 5) OP_IF script that needs a true input\n+                CScript([OP_IF, pub2, OP_CHECKSIG, OP_ELSE, OP_RETURN, OP_ENDIF]),\n+                # 6) OP_NOTIF script that needs a true input\n+                CScript([OP_NOTIF, OP_RETURN, OP_ELSE, pub2, OP_CHECKSIG, OP_ENDIF]),\n+                # 7) OP_CHECKSIG with an empty key\n+                CScript([OP_0, OP_CHECKSIG]),\n+                # 8) OP_CHECKSIGVERIFY with an empty key\n+                CScript([OP_0, OP_CHECKSIGVERIFY, OP_1]),\n+                # 9) normal OP_CHECKSIGADD that also ensures return value is correct\n+                CScript([OP_0, pub2, OP_CHECKSIGADD, OP_1, OP_EQUAL]),\n+                # 10) OP_CHECKSIGADD with empty key\n+                CScript([OP_0, OP_0, OP_CHECKSIGADD]),\n+                # 11) OP_CHECKSIGADD with missing counter stack element\n+                CScript([pub2, OP_CHECKSIGADD]),\n+                # 12) OP_CHECKSIG that needs invalid signature\n+                CScript([pub2, OP_CHECKSIGVERIFY, pub1, OP_CHECKSIG, OP_NOT]),\n+                # 13) OP_CHECKSIG with empty key that needs invalid signature\n+                CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_CHECKSIG, OP_NOT]),\n+                # 14) OP_CHECKSIGADD that needs invalid signature\n+                CScript([pub2, OP_CHECKSIGVERIFY, OP_0, pub1, OP_CHECKSIGADD, OP_NOT]),\n+                # 15) OP_CHECKSIGADD with empty key that needs invalid signature\n+                CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGADD, OP_NOT]),\n+                # 16) OP_CHECKSIG with unknown pubkey type\n+                CScript([OP_1, OP_CHECKSIG]),\n+                # 17) OP_CHECKSIGADD with unknown pubkey type\n+                CScript([OP_0, OP_1, OP_CHECKSIGADD]),\n+                # 18) OP_CHECKSIGVERIFY with unknown pubkey type\n+                CScript([OP_1, OP_CHECKSIGVERIFY, OP_1]),\n+                # 19) script longer than 10000 bytes and over 201 non-push opcodes\n+                CScript([OP_0, OP_0, OP_2DROP] * 10001 + [pub2, OP_CHECKSIG]),\n+                # 20) OP_CHECKSIGVERIFY with empty key\n+                CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGVERIFY, OP_1]),\n+                # 21) Script that grows the stack to 1000 elements\n+                CScript([pub2, OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 999 + [OP_DROP] * 999),\n+                # 22) Script that grows the stack to 1001 elements\n+                CScript([pub2, OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 1000 + [OP_DROP] * 1000),\n+                # 23) Script that expects an input stack of 1000 elements\n+                CScript([OP_DROP] * 999 + [pub2, OP_CHECKSIG]),\n+                # 24) Script that expects an input stack of 1001 elements\n+                CScript([OP_DROP] * 1000 + [pub2, OP_CHECKSIG]),\n+                # 25) Script that pushes a 520 byte element\n+                CScript([random_bytes(520), OP_DROP, pub2, OP_CHECKSIG]),\n+                # 26) Script that pushes a 521 byte element\n+                CScript([random_bytes(521), OP_DROP, pub2, OP_CHECKSIG]),\n+                # 27) Script that pushes a 521 byte element and OP_SUCCESSX\n+                CScript([random_bytes(521), OP_DROP, pub2, OP_CHECKSIG, random_op_success()]),\n+                # 28) Pushes random CScriptNum value, checks OP_CHECKSIGADD result\n+                CScript([checksigadd_arg, pub2, OP_CHECKSIGADD, checksigadd_result, OP_EQUAL]),\n+                # 30) CHECKSIGADD that succeeds with proper sig because numeric argument number is <=4 bytes\n+                CScript([CScriptNum(oversize_number-1), pub2, OP_CHECKSIGADD]),\n+                # 29) CHECKSIGADD that must fail because numeric argument number is >4 bytes\n+                CScript([CScriptNum(oversize_number), pub2, OP_CHECKSIGADD]),\n+            ]\n+            # For the next test we must predict the exact witness size\n+            witness_size = 141 + (hashtype != 0) + (0 if annex is None else len(annex) + 1)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461954582",
      "id" : 461954582,
      "in_reply_to_id" : 456992780,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1NDU4Mg==",
      "original_commit_id" : "42bda3592c3fc4d5169b2f53e80780ed46a0854c",
      "original_line" : 701,
      "original_position" : 655,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 457101241,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461954582",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461954762"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461954762"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Oops, done now.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-28T23:41:16Z",
      "diff_hunk" : "@@ -384,3 +420,125 @@ def sign_ecdsa(self, msg, low_s=True):\n         rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')\n         sb = s.to_bytes((s.bit_length() + 8) // 8, 'big')\n         return b'\\x30' + bytes([4 + len(rb) + len(sb), 2, len(rb)]) + rb + bytes([2, len(sb)]) + sb\n+\n+def compute_xonly_pubkey(key):\n+    \"\"\"Compute an x-only (32 byte) public key from a (32 byte) private key.\n+\n+    This also returns whether the resulting public key was negated.\n+    \"\"\"\n+\n+    assert(len(key) == 32)\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return (None, None)\n+    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, x)]))\n+    return (P[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(P))\n+\n+def tweak_privkey(key, tweak, negated=False):\n+    \"\"\"Tweak a private key (after optionally negating it).\"\"\"\n+\n+    assert(len(key) == 32)\n+    assert(len(tweak) == 32)\n+\n+    x = int.from_bytes(key, 'big')\n+    if x == 0 or x >= SECP256K1_ORDER:\n+        return None\n+    if negated:\n+       x = SECP256K1_ORDER - x\n+    t = int.from_bytes(tweak, 'big')\n+    if t >= SECP256K1_ORDER:\n+        return None\n+    x = (x + t) % SECP256K1_ORDER\n+    if x == 0:\n+        return None\n+    return x.to_bytes(32, 'big')\n+\n+def tweak_pubkey(key, tweak):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r461954762",
      "id" : 461954762,
      "in_reply_to_id" : 455059451,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1NDc2Mg==",
      "original_commit_id" : "98ea8e9b9ba27e0b2725f02c92c2e3a64e4fdeab",
      "original_line" : 459,
      "original_position" : 220,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 457101436,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/461954762",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "im in ur codebase _0pt1miz1ng_ ur lines.\r\n\r\nu can tell diz code waz unoptimal cuz feature_taproot.py still passes with this _optimization_\r\n\r\n```diff\r\ndiff --git a/src/secp256k1/src/modules/schnorrsig/main_impl.h b/src/secp256k1/src/modules/schnorrsig/main_impl.h\r\nindex 2ec1cea5b..5efdee4b4 100644\r\n--- a/src/secp256k1/src/modules/schnorrsig/main_impl.h\r\n+++ b/src/secp256k1/src/modules/schnorrsig/main_impl.h\r\n@@ -223,8 +223,7 @@ int secp256k1_schnorrsig_verify(const secp256k1_context* ctx, const unsigned cha\r\n     secp256k1_gej_set_ge(&pkj, &pk);\r\n     secp256k1_ecmult(&ctx->ecmult_ctx, &rj, &pkj, &e, &s);\r\n \r\n-    return secp256k1_gej_has_quad_y_var(&rj) /* fails if rj is infinity */\r\n-            && secp256k1_gej_eq_x_var(&rx, &rj);\r\n+    return secp256k1_gej_eq_x_var(&rx, &rj);\r\n }\r\n \r\n #endif\r\n```\r\n\r\n(yes, libsecp256k1's tests catches this, but this an an important and easily botched consensus rule too)\r\n\r\nmoar _optimization_ \"fixes\" coming soon\r\n",
      "created_at" : "2020-07-29T02:25:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-665392921",
      "id" : 665392921,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NTM5MjkyMQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-29T05:17:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/665392921",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "node_id" : "MDQ6VXNlcjg1ODQ1NA==",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "all numb3erz r equally blessed in eyes of ur tests\r\n\r\n```diff\r\ndiff --git a/src/secp256k1/src/modules/extrakeys/main_impl.h b/src/secp256k1/src/modules/extrakeys/main_impl.h\r\nindex a2abc6afa..04c84bde5 100644\r\n--- a/src/secp256k1/src/modules/extrakeys/main_impl.h\r\n+++ b/src/secp256k1/src/modules/extrakeys/main_impl.h\r\n@@ -30,9 +30,8 @@ int secp256k1_xonly_pubkey_parse(const secp256k1_context* ctx, secp256k1_xonly_p\r\n     if (!secp256k1_fe_set_b32(&x, input32)) {\r\n         return 0;\r\n     }\r\n-    if (!secp256k1_ge_set_xo_var(&pk, &x, 0)) {\r\n-        return 0;\r\n-    }\r\n+    secp256k1_ge_set_xo_var(&pk, &x, 0);\r\n+\r\n     secp256k1_xonly_pubkey_save(pubkey, &pk);\r\n     secp256k1_ge_clear(&pk);\r\n     return 1;\r\n```\r\n",
      "created_at" : "2020-07-29T02:45:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-665398429",
      "id" : 665398429,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NTM5ODQyOQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-29T05:17:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/665398429",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "node_id" : "MDQ6VXNlcjg1ODQ1NA==",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "shrinking ur transactshuns.\r\n\r\ny send sign if ne1 no care?\r\n\r\n```diff\r\ndiff --git a/src/script/interpreter.cpp b/src/script/interpreter.cpp\r\nindex e095f0a42..1f6d4ca14 100644\r\n--- a/src/script/interpreter.cpp\r\n+++ b/src/script/interpreter.cpp\r\n@@ -1823,7 +1823,7 @@ static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, c\r\n         k = ss_branch.GetSHA256();\r\n     }\r\n     k = (CHashWriter(HASHER_TAPTWEAK) << MakeSpan(p) << k).GetSHA256();\r\n-    return q.CheckPayToContract(p, k, control[0] & 1);\r\n+    return q.CheckPayToContract(p, k, 0) || q.CheckPayToContract(p, k, 1);\r\n }\r\n \r\n static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror, bool is_p2sh)\r\n```\r\n",
      "created_at" : "2020-07-29T03:20:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-665407450",
      "id" : 665407450,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NTQwNzQ1MA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-29T05:17:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/665407450",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "node_id" : "MDQ6VXNlcjg1ODQ1NA==",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "2 many byte 4 so little bark\r\n\r\n```diff\r\ndiff --git a/src/script/interpreter.cpp b/src/script/interpreter.cpp\r\nindex e095f0a42..88093caa0 100644\r\n--- a/src/script/interpreter.cpp\r\n+++ b/src/script/interpreter.cpp\r\n@@ -1815,7 +1815,7 @@ static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, c\r\n     for (int i = 0; i < path_len; ++i) {\r\n         CHashWriter ss_branch = HASHER_TAPBRANCH;\r\n         Span<const unsigned char> node(control.data() + TAPROOT_CONTROL_BASE_SIZE + TAPROOT_CONTROL_NODE_SIZE * i, TAPROOT_CONTROL_NODE_SIZE);\r\n-        if (std::lexicographical_compare(k.begin(), k.end(), node.begin(), node.end())) {\r\n+        if (std::lexicographical_compare(k.begin(), k.begin()+2, node.begin(), node.begin()+2)) {\r\n             ss_branch << k << node;\r\n         } else {\r\n             ss_branch << node << k;\r\n```\r\n",
      "created_at" : "2020-07-29T03:56:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-665415974",
      "id" : 665415974,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NTQxNTk3NA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-29T05:17:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/665415974",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "node_id" : "MDQ6VXNlcjg1ODQ1NA==",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "big iz bootyfull\r\n\r\n```diff\r\ndiff --git a/src/script/interpreter.cpp b/src/script/interpreter.cpp\r\nindex e095f0a42..b12cd25ad 100644\r\n--- a/src/script/interpreter.cpp\r\n+++ b/src/script/interpreter.cpp\r\n@@ -1856,7 +1856,7 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\r\n         } else {\r\n             return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH);\r\n         }\r\n-    } else if (witversion == 1 && program.size() == WITNESS_V1_TAPROOT_SIZE && !is_p2sh) {\r\n+    } else if (witversion == 1 && program.size() >= WITNESS_V1_TAPROOT_SIZE && !is_p2sh) {\r\n         // BIP341 Taproot: 32-byte non-P2SH witness v1 program (which encodes a P2C-tweaked pubkey)\r\n         if (!(flags & SCRIPT_VERIFY_TAPROOT)) return set_success(serror);\r\n         if (stack.size() == 0) return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);\r\n```",
      "created_at" : "2020-07-29T04:03:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-665417632",
      "id" : 665417632,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NTQxNzYzMg==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-29T05:17:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/665417632",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "node_id" : "MDQ6VXNlcjg1ODQ1NA==",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "deez statemints r doin nuthing\r\n\r\n```diff\r\ndiff --git a/src/script/interpreter.cpp b/src/script/interpreter.cpp\r\nindex e095f0a42..e115a6a99 100644\r\n--- a/src/script/interpreter.cpp\r\n+++ b/src/script/interpreter.cpp\r\n@@ -1858,8 +1858,6 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\r\n         }\r\n     } else if (witversion == 1 && program.size() == WITNESS_V1_TAPROOT_SIZE && !is_p2sh) {\r\n         // BIP341 Taproot: 32-byte non-P2SH witness v1 program (which encodes a P2C-tweaked pubkey)\r\n-        if (!(flags & SCRIPT_VERIFY_TAPROOT)) return set_success(serror);\r\n-        if (stack.size() == 0) return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);\r\n         if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {\r\n             // Drop annex\r\n             if (flags & SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX) return set_error(serror, SCRIPT_ERR_DISCOURAGE_UNKNOWN_ANNEX);\r\n@@ -1881,7 +1879,7 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\r\n             const valtype& control = SpanPopBack(stack);\r\n             const valtype& script_bytes = SpanPopBack(stack);\r\n             scriptPubKey = CScript(script_bytes.begin(), script_bytes.end());\r\n-            if (control.size() < TAPROOT_CONTROL_BASE_SIZE || control.size() > TAPROOT_CONTROL_MAX_SIZE || ((control.size() - TAPROOT_CONTROL_BASE_SIZE) % TAPROOT_CONTROL_NODE_SIZE) != 0) {\r\n+            if (control.size() > TAPROOT_CONTROL_MAX_SIZE) {\r\n                 return set_error(serror, SCRIPT_ERR_TAPROOT_WRONG_CONTROL_SIZE);\r\n             }\r\n             if (!VerifyTaprootCommitment(control, program, scriptPubKey, &execdata.m_tapleaf_hash)) {\r\n```\r\n",
      "created_at" : "2020-07-29T04:25:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-665422851",
      "id" : 665422851,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NTQyMjg1MQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-29T05:18:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/665422851",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "node_id" : "MDQ6VXNlcjg1ODQ1NA==",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "ur gold star no offset being phat\r\n\r\n```diff\r\ndiff --git a/src/script/interpreter.cpp b/src/script/interpreter.cpp\r\nindex e095f0a42..c2823a565 100644\r\n--- a/src/script/interpreter.cpp\r\n+++ b/src/script/interpreter.cpp\r\n@@ -1770,6 +1770,10 @@ static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CS\r\n     if (sigversion == SigVersion::TAPSCRIPT) {\r\n         // OP_SUCCESSx processing overrides everything, including stack element size limits\r\n         CScript::const_iterator pc = scriptPubKey.begin();\r\n+        // Tapscript enforces initial stack size limits (altstack is empty here)\r\n+        if (stack.size() > MAX_STACK_SIZE) {\r\n+            return set_error(serror, SCRIPT_ERR_STACK_SIZE);\r\n+        }\r\n         while (pc < scriptPubKey.end()) {\r\n             opcodetype opcode;\r\n             if (!scriptPubKey.GetOp(pc, opcode)) {\r\n@@ -1785,10 +1789,6 @@ static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CS\r\n             }\r\n         }\r\n \r\n-        // Tapscript enforces initial stack size limits (altstack is empty here)\r\n-        if (stack.size() > MAX_STACK_SIZE) {\r\n-            return set_error(serror, SCRIPT_ERR_STACK_SIZE);\r\n-        }\r\n     }\r\n \r\n     // Disallow stack item size > MAX_SCRIPT_ELEMENT_SIZE in witness stack\r\n```",
      "created_at" : "2020-07-29T04:38:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-665426041",
      "id" : 665426041,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NTQyNjA0MQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-29T05:18:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/665426041",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "node_id" : "MDQ6VXNlcjg1ODQ1NA==",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "just cuz im empty inside doesnt mean i cant count\r\n\r\n```diff\r\ndiff --git a/src/script/interpreter.cpp b/src/script/interpreter.cpp\r\nindex e095f0a42..a4113be95 100644\r\n--- a/src/script/interpreter.cpp\r\n+++ b/src/script/interpreter.cpp\r\n@@ -379,7 +379,7 @@ static bool EvalChecksigTapscript(const valtype& sig, const valtype& pubkey, Scr\r\n      *    the script execution fails when using non-empty invalid signature.\r\n      */\r\n     success = !sig.empty();\r\n-    if (success) {\r\n+    {\r\n         // Implement the sigops/witnesssize ratio test.\r\n         // Passing with an upgradable public key version is also counted.\r\n         assert(execdata.m_validation_weight_left_init);\r\n```\r\n",
      "created_at" : "2020-07-29T05:18:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-665436594",
      "id" : 665436594,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NTQzNjU5NA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-29T05:21:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/665436594",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "node_id" : "MDQ6VXNlcjg1ODQ1NA==",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "dont ignore big boyz\r\n\r\n```diff\r\ndiff --git a/src/script/interpreter.cpp b/src/script/interpreter.cpp\r\nindex e095f0a42..a1f46d960 100644\r\n--- a/src/script/interpreter.cpp\r\n+++ b/src/script/interpreter.cpp\r\n@@ -390,7 +390,7 @@ static bool EvalChecksigTapscript(const valtype& sig, const valtype& pubkey, Scr\r\n     }\r\n     if (pubkey.size() == 0) {\r\n         return set_error(serror, SCRIPT_ERR_PUBKEYTYPE);\r\n-    } else if (pubkey.size() == 32) {\r\n+    } else if (pubkey.size() >= 32) {\r\n         if (success && !checker.CheckSigSchnorr(sig, pubkey, sigversion, execdata)) {\r\n             return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);\r\n         }\r\n```\r\n",
      "created_at" : "2020-07-29T05:25:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-665439046",
      "id" : 665439046,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NTQzOTA0Ng==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-29T05:33:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/665439046",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "node_id" : "MDQ6VXNlcjg1ODQ1NA==",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "tapscript iz not 4 minimalists\r\n\r\n```diff\r\ndiff --git a/src/script/interpreter.cpp b/src/script/interpreter.cpp\r\nindex e095f0a42..26dd6c036 100644\r\n--- a/src/script/interpreter.cpp\r\n+++ b/src/script/interpreter.cpp\r\n@@ -634,8 +634,6 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\r\n                             return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);\r\n                         valtype& vch = stacktop(-1);\r\n                         if (sigversion == SigVersion::TAPSCRIPT || (sigversion == SigVersion::WITNESS_V0 && (flags & SCRIPT_VERIFY_MINIMALIF))) {\r\n-                            if (vch.size() > 1)\r\n-                                return set_error(serror, SCRIPT_ERR_MINIMALIF);\r\n                             if (vch.size() == 1 && vch[0] != 1)\r\n                                 return set_error(serror, SCRIPT_ERR_MINIMALIF);\r\n                         }\r\n```",
      "created_at" : "2020-07-29T06:09:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-665453395",
      "id" : 665453395,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NTQ1MzM5NQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-29T06:10:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/665453395",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "node_id" : "MDQ6VXNlcjg1ODQ1NA==",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "why u no share with witness v0??\r\n\r\n```diff\r\ndiff --git a/src/script/interpreter.cpp b/src/script/interpreter.cpp\r\nindex e095f0a42..2697bc482 100644\r\n--- a/src/script/interpreter.cpp\r\n+++ b/src/script/interpreter.cpp\r\n@@ -1097,8 +1097,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\r\n \r\n                 case OP_CHECKSIGADD:\r\n                 {\r\n-                    // OP_CHECKSIGADD is only available in Tapscript\r\n-                    if (sigversion == SigVersion::BASE || sigversion == SigVersion::WITNESS_V0) return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\r\n+                    // OP_CHECKSIGADD is AVAILABLE TO EVERYONE!!!\r\n \r\n                     // (sig num pubkey -- num)\r\n                     if (stack.size() < 3) return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\r\n```\r\n",
      "created_at" : "2020-07-29T06:28:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-665460423",
      "id" : 665460423,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NTQ2MDQyMw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-29T06:40:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/665460423",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "node_id" : "MDQ6VXNlcjg1ODQ1NA==",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "DONT TRUST VER\r\n\r\n```diff\r\ndiff --git a/src/script/script.cpp b/src/script/script.cpp\r\nindex 8bd10f8ba..2604d5dae 100644\r\n--- a/src/script/script.cpp\r\n+++ b/src/script/script.cpp\r\n@@ -334,7 +334,7 @@ bool GetScriptOp(CScriptBase::const_iterator& pc, CScriptBase::const_iterator en\r\n \r\n bool IsOpSuccess(const opcodetype& opcode)\r\n {\r\n-    return (opcode == 0x50 || opcode == 0x62 || opcode == 0x89 ||\r\n+    return (opcode == 0x50 || opcode == 0x89 ||\r\n             opcode == 0x8a || opcode == 0x8d || opcode == 0x8e ||\r\n             (opcode >= 0x7e && opcode <= 0x81) || (opcode >= 0x83 && opcode <= 0x86) ||\r\n             (opcode >= 0x95 && opcode <= 0x99) || (opcode >= 0xbb && opcode <= 0xfe));\r\n```\r\n",
      "created_at" : "2020-07-29T09:02:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-665537097",
      "id" : 665537097,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NTUzNzA5Nw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-29T09:07:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/665537097",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "node_id" : "MDQ6VXNlcjg1ODQ1NA==",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "u haz boundary but i shifted it\r\n\r\n```\r\n-static constexpr uint64_t VALIDATION_WEIGHT_OFFSET = 50;\r\n+static constexpr uint64_t VALIDATION_WEIGHT_OFFSET = 53;\r\n```\r\n\r\n```\r\n-static constexpr uint64_t VALIDATION_WEIGHT_OFFSET = 50;\r\n+static constexpr uint64_t VALIDATION_WEIGHT_OFFSET = 47;\r\n```\r\n",
      "created_at" : "2020-07-29T09:59:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-665567544",
      "id" : 665567544,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NTU2NzU0NA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-29T09:59:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/665567544",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "node_id" : "MDQ6VXNlcjg1ODQ1NA==",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r462204524"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/462204524"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "      //! Entries are SHA256(nonce || 'E' or 'S' || 0x00 * 32 || signature hash || public key || signature)",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-07-29T10:38:19Z",
      "diff_hunk" : "@@ -23,7 +23,8 @@ class CSignatureCache\n {\n private:\n      //! Entries are SHA256(nonce || signature hash || public key || signature):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r462204524",
      "id" : 462204524,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIwNDUyNA==",
      "original_commit_id" : "066f086e966fb626321743e8e558857e9d77429e",
      "original_line" : 25,
      "original_position" : 3,
      "original_start_line" : null,
      "path" : "src/script/sigcache.cpp",
      "position" : null,
      "pull_request_review_id" : 457400282,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/462204524",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "node_id" : "MDQ6VXNlcjg1ODQ1NA==",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Okay, those are all the locations I found where breaking the code still results in the taproot tests passing (and weren't obviously due to an unreachable condition on account of a redundant consensus rule).  In some cases I could have given more examples (e.g. more success opcodes that are untested), though I hope if the tests are improved they're written more generally than is required to reject my example bugs. \r\n\r\nJust as a general comment, I found the way that things like op_success overlays on evalscript to be pretty opaque-- e.g. which opcodes still exist and which ones are turned into success?  Also interactions like the maximum script size condition in evalscript going from always applying to just applying in base and witness v0. Took a minute to convince myself that there wasn't an inadvertent consensus change due to the caller already bypassing evalscript for other witness versions.  I think it would have been easier to review if evalscript were just split for v1, but because they're so similar I could argue it either way so I understand why it wasn't. Though if this is done several more times I think the complexity will compound and a different approach will be needed (which might just be as simple as duplicating the function).\r\n\r\nThere also are a moderate number of unreachable redundant checks (e.g. signature size) but I figured I would leave that up to someone driven by branch coverage analysis to report those-- since they're harmless but for the fact that they're false positives on coverage screening.  Several of the things I reported should have been obvious on coverage analysis, so I guess no one has done that yet?\r\n\r\nAll in all it's a simpler change than I remembered, even having read it completely not that long ago. I found relatively few places that even seemed like they'd be likely mutation targets, though I did have a pretty high hitrate on the things I tried turning up limitations in the tests.",
      "created_at" : "2020-07-29T15:20:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-665729074",
      "id" : 665729074,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NTcyOTA3NA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-29T15:21:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/665729074",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "node_id" : "MDQ6VXNlcjg1ODQ1NA==",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "test changes through https://github.com/bitcoin/bitcoin/pull/17977/commits/d4260e830a0a3614f05b1bfa855f08edc1a7b39c look good.\r\n\r\n@gmaxwell : cool stuff. I suspect some of those cases are covered *sometimes* due to the random nature of some of the tests, for example the `OP_VER` one. IIRC the test randomly picks an op_success code per run. Maybe it's worth running all those cases N times when N is reasonably small to get complete coverage per run?\r\n\r\n> think it would have been easier to review if evalscript were just split for v1, but because they're so similar I could argue it either way so I understand why it wasn't. Though if this is done several more times I think the complexity will compound and a different approach will be needed (which might just be as simple as duplicating the function).\r\n\r\n+1, Peter Todd argued this back for segwit v0 even, and I found it pretty compelling if we're going to be making lots of changes in the future.\r\n\r\n",
      "created_at" : "2020-07-30T14:15:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-666391806",
      "id" : 666391806,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NjM5MTgwNg==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-30T14:15:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/666391806",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@instagibbs Indeed; the \"y send sign if ne1 no care?\" I believe is also covered by random mutations of the control block already - but it's rare to hit that exact bit.\r\n\r\nI'm reworking the tests to make sure more edge cases are always hit (or at least, making it easier to add them).\r\n\r\nUnfortunately, it will mean making the randomized Python test take significantly longer. One idea is that we could work to make it as complete as possible, then extract a set of UTXOs/spending transactions from it, use coverage analysis to minimize it, and then turn the result of that into a test vector set - which can be included as a fast unit test (in C++) and added to the BIP.",
      "created_at" : "2020-07-30T17:19:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-666539765",
      "id" : 666539765,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NjUzOTc2NQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-30T17:19:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/666539765",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "As far as the idea of having a separate EvalScript goes - indeed, I think that's a useful idea in general, and I think @theuni has also argued in favour of it.\r\n\r\nI chose not to here, because the majority of the changes isn't actually inside script execution as such. The best argument in favour would be if separation would let us get rid of the OP_SUCCESSx preprocessing step, and have a single pass execution instead. However, because of the \"presence of any OP_SUCCESSx in a script triggers success, even if not executed and even if it appears after a failing opcode\" behaviour, that isn't really doable. Other than OP_SUCCESSx handling, there are only a few fairly isolated changes.\r\n\r\nThat said, I'm not opposed to splitting if off if it aids review.\n\nEDIT: I guess it's possible to keep track of a bool \"failed\" during execution, which is set to false whenever a \"return false\" occurs in the original script execution code, and this flag causes skipping of execution of all opcodes except OP_SUCCESSx ones.",
      "created_at" : "2020-07-30T17:34:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-666549387",
      "id" : 666549387,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NjU0OTM4Nw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-30T17:56:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/666549387",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I think it's a good investment to completely split the interpreters, especially given the myriad of different upgrade mechanisms the current approach can lead to confusing code paths of what is actually getting called (imagine a future with 5 different leaf versions all passing different interpreter flags in -- better to normalize that v1 witness leaf versions have their own interpreter separate from v0 and legacy).\r\n\r\nsee discussion following here: https://github.com/bitcoin/bitcoin/pull/15969#issuecomment-492302832\r\n\r\n\r\nThe downside is that this that we end up over time having several different interpreters (e.g., imagine each leaf version having their own interpreter) which can lead to a bloated code base -- however I think it's worth it because it's much easier to audit change-to-change that remain fully consensus compatible with old implementations. The bloat becomes a problem when we, e.g., switch a representation (like Spans) and then have to mirror the change across much more code.\r\n\r\nedit: making sure all testing is consistent and applies on all interpreters might be tough right now, but maybe there's a way to make sure all tests are hitting all code paths for legacy and new interpreters. \r\n\r\nedit2: @sipa, is there also logic that we could *remove* from a v1 interpreter that is only required for legacy interpretation?",
      "created_at" : "2020-07-30T18:09:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-666573009",
      "id" : 666573009,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NjU3MzAwOQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-30T18:14:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/666573009",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> That said, I'm not opposed to splitting if off if it aids review.\r\n\r\nWell I, and presumably other reviewers, already undertook the additional cost. So I don't think doing it would aid me now.\r\n\r\nIt's a change that could be made at any time in the future too.\r\n\r\n> EDIT: I guess it's possible to keep track of a bool \"failed\" during execution, which is set to false whenever a \"return false\" occurs in the original script execution code, and this flag causes skipping of execution of all opcodes except OP_SUCCESSx ones.\r\n\r\nYes, though the interaction with size limits needs to be minded.   I don't think having two passes was that big of a deal however, but the fact that there is a bunch of code that is there but won't execute due to the first pass did take a little extra review effort.\r\n\r\nRight now there is no trivial way to prove that the changes don't change existing basic/v0 scripts.  If it were split, you could just look and see that evalscript literally doesn't change except for the v1 case.\r\n\r\nIn any case, I don't particularly think it's worth changing now.  I think it will probably get split in the future however, if not for v1 then for some other version or leaf version.\r\n\r\n> but maybe there's a way to make sure all tests are hitting all code paths for legacy and new interpreters.\r\n\r\nIt's called branch coverage analysis. :)\r\n\r\n> edit2: @sipa, is there also logic that we could remove from a v1 interpreter that is only required for legacy interpretation?\r\n\r\nAll the guts of the opcodes turned into success, as well as the guts from the checkmultisig stuff that was disabled.\r\n\r\n",
      "created_at" : "2020-08-01T02:39:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-667455901",
      "id" : 667455901,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NzQ1NTkwMQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-08-01T02:39:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/667455901",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "node_id" : "MDQ6VXNlcjg1ODQ1NA==",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I don't think branch coverage fully helps because it's conceivable we have multiple tests that cover things and coverage might not help that much...\r\n\r\n\r\n\r\nI think there might be a kinda silly way to split the interpreters for the taproot implementation without causing anyone to have to re-review much taproot related.\r\n\r\n1) take current tip of taproot\r\n2) Move the interpreter guts into a new file/dir called v1 script, update both paths to use this new location interpreter.\r\n3) check out the pre-taproot interpreter files. (reviewers can verify this step by checking out from the named commit hash)\r\n4) switch non v1 to use the old interpreter again\r\n5) (some time later) move the legacy interpreter to it's own directory\r\n6) (optional) clear out code paths in v1 interpreter that are clearly unused (can do with aid of coverage tools)\r\n\r\nThis causes a pretty small amount of new review work for what may be a substantial benefit. In terms of consensus consistency:\r\n\r\n1) Doing this *after* release would be very hard, because the risk that we accidentally had some additional rule change on legacy interpreter semantics that would get hard-fork undone on change. I think the developer community would think it's a waste of time and effort to do this after release, so it's worth at least considering now. After merge but before release is still doable as there's no consistency issue, but the git history is better bisectable if they are contiguous in git history.\r\n2) This minimizes the potential for any taproot changes that break legacy interpretation\r\n3) If there *are* behavior changes against taproot as is (which should come up in tests), this is before release, so it's OK as long as the behavior is pinned before any release\r\n4) No re-review is required as this is purely forward changes.",
      "created_at" : "2020-08-01T05:43:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-667475959",
      "id" : 667475959,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NzQ3NTk1OQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-08-01T05:43:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/667475959",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@JeremyRubin There are plenty of ways to minimize the difference with both the existing branch here, and between the new legacy interpreter and the current interpreter in master.\n\nThe question whether we want it. It at least means additional review, and code duplication. Given there has already been a decent amount of review here, I'd rather not do it unless there's wide agreement about the change.\n\nThe amount of code that can be removed from the hypothetical new interpreter is pretty minimal I think - OP_CHECKMULTISIG(VERIFY) and some accounting (201 opcode limit). All the OP_SUCCESSx codes are \"immediate failure\" in the current interpreter, so not really anything to gain from that.",
      "created_at" : "2020-08-01T06:10:10Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-667479801",
      "id" : 667479801,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NzQ3OTgwMQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-08-01T06:10:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/667479801",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\n This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2020-08-03T16:27:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-668116731",
      "id" : 668116731,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2ODExNjczMQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-08-03T16:27:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/668116731",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r464740054"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/464740054"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "don't we use these caches for any non taproot signature? Not just segwit?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-04T01:03:38Z",
      "diff_hunk" : "@@ -1258,65 +1349,208 @@ class CTransactionSignatureSerializer\n     }\n };\n \n+/** Compute the (single) SHA256 of the concatenation of all prevouts of a tx. */\n template <class T>\n uint256 GetPrevoutHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txin : txTo.vin) {\n         ss << txin.prevout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all nSequences of a tx. */\n template <class T>\n uint256 GetSequenceHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txin : txTo.vin) {\n         ss << txin.nSequence;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all txouts of a tx. */\n template <class T>\n uint256 GetOutputsHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n+    }\n+\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143 = false;\n+    bool uses_bip341 = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every native witness v1 spend as a Taproot spend. This only works if spent_outputs was\n+                // provided as well, but if it wasn't, actual validation will fail anyway.\n+                uses_bip341 = true;\n+            } else {\n+                // Treat every spend that's not known to native witness v1 as a Witness v0 spend. This branch may\n+                // also be taken for unknown witness versions, but it is harmless, and being precise would require\n+                // P2SH evaluation to find the redeemScript.\n+                uses_bip143 = true;\n+            }\n+        }\n     }\n \n-    m_ready = true;\n+    if (uses_bip143 || uses_bip341) {\n+        // Computations shared between both sighash schemes.\n+        m_bip341_prevouts_hash = GetPrevoutHash(txTo);\n+        m_bip341_sequences_hash = GetSequenceHash(txTo);\n+        m_bip341_outputs_hash = GetOutputsHash(txTo);\n+    }\n+    if (uses_bip143) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r464740054",
      "id" : 464740054,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc0MDA1NA==",
      "original_commit_id" : "d4260e830a0a3614f05b1bfa855f08edc1a7b39c",
      "original_line" : 1441,
      "original_position" : 294,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 460429732,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/464740054",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r464740393"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/464740393"
         }
      },
      "author_association" : "MEMBER",
      "body" : "No, there is nothing to be cached for pre-segwit sighashes (they're just hashing a serialized modified transaction).",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-04T01:05:01Z",
      "diff_hunk" : "@@ -1258,65 +1349,208 @@ class CTransactionSignatureSerializer\n     }\n };\n \n+/** Compute the (single) SHA256 of the concatenation of all prevouts of a tx. */\n template <class T>\n uint256 GetPrevoutHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txin : txTo.vin) {\n         ss << txin.prevout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all nSequences of a tx. */\n template <class T>\n uint256 GetSequenceHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txin : txTo.vin) {\n         ss << txin.nSequence;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all txouts of a tx. */\n template <class T>\n uint256 GetOutputsHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n+    }\n+\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143 = false;\n+    bool uses_bip341 = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every native witness v1 spend as a Taproot spend. This only works if spent_outputs was\n+                // provided as well, but if it wasn't, actual validation will fail anyway.\n+                uses_bip341 = true;\n+            } else {\n+                // Treat every spend that's not known to native witness v1 as a Witness v0 spend. This branch may\n+                // also be taken for unknown witness versions, but it is harmless, and being precise would require\n+                // P2SH evaluation to find the redeemScript.\n+                uses_bip143 = true;\n+            }\n+        }\n     }\n \n-    m_ready = true;\n+    if (uses_bip143 || uses_bip341) {\n+        // Computations shared between both sighash schemes.\n+        m_bip341_prevouts_hash = GetPrevoutHash(txTo);\n+        m_bip341_sequences_hash = GetSequenceHash(txTo);\n+        m_bip341_outputs_hash = GetOutputsHash(txTo);\n+    }\n+    if (uses_bip143) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r464740393",
      "id" : 464740393,
      "in_reply_to_id" : 464740054,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc0MDM5Mw==",
      "original_commit_id" : "d4260e830a0a3614f05b1bfa855f08edc1a7b39c",
      "original_line" : 1441,
      "original_position" : 294,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 460430151,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/464740393",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> As far as the idea of having a separate EvalScript goes - indeed, I think that's a useful idea in general, and I think @theuni has also argued in favour of it.\r\n> \r\n> I chose not to here, because the majority of the changes isn't actually inside script execution as such. The best argument in favour would be if separation would let us get rid of the OP_SUCCESSx preprocessing step, and have a single pass execution instead. However, because of the \"presence of any OP_SUCCESSx in a script triggers success, even if not executed and even if it appears after a failing opcode\" behaviour, that isn't really doable. Other than OP_SUCCESSx handling, there are only a few fairly isolated changes.\r\n> \r\n> That said, I'm not opposed to splitting if off if it aids review.\r\n\r\nI really like this idea. So much so that I have a branch with a similar split. I was hoping to get a taproot implementation done on top of it so that I could propose it before review of this PR really cranked up, but sadly I didn't make it in time and decided to just drop it.\r\n\r\nFor anyone interested, this is my attempt at split interpreters: https://github.com/theuni/bitcoin/tree/policy-split2\r\n\r\nIt splits consensus and policy, but the split could be anything. I didn't go as far as splitting out the interpreters into separate files, but I think it's easy to see where it was going.",
      "created_at" : "2020-08-04T01:20:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-668321512",
      "id" : 668321512,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2ODMyMTUxMg==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-08-04T01:20:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/668321512",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r465117136"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/465117136"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'd kind of prefer to just use `IsWitnessProgram` to grab the values for here since I know that works already.\r\n\r\nWhat about erring on the side of bip341 precomputing instead? Could just say:\r\n\r\n```\r\nif (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.IsWitnessProgram(version, witness_program) && version > 0) {\r\n```\r\nthen we can delete the \"unknown witness verison\" comment below.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-04T15:00:33Z",
      "diff_hunk" : "@@ -1258,65 +1349,208 @@ class CTransactionSignatureSerializer\n     }\n };\n \n+/** Compute the (single) SHA256 of the concatenation of all prevouts of a tx. */\n template <class T>\n uint256 GetPrevoutHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txin : txTo.vin) {\n         ss << txin.prevout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all nSequences of a tx. */\n template <class T>\n uint256 GetSequenceHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txin : txTo.vin) {\n         ss << txin.nSequence;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all txouts of a tx. */\n template <class T>\n uint256 GetOutputsHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n+    }\n+\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143 = false;\n+    bool uses_bip341 = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r465117136",
      "id" : 465117136,
      "line" : 1426,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTExNzEzNg==",
      "original_commit_id" : "d4260e830a0a3614f05b1bfa855f08edc1a7b39c",
      "original_line" : 1426,
      "original_position" : 273,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 265,
      "pull_request_review_id" : 460899787,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/465117136",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r466691211"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/466691211"
         }
      },
      "author_association" : "MEMBER",
      "body" : "How so?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-06T21:17:13Z",
      "diff_hunk" : "@@ -0,0 +1,797 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import CTransaction, CTxIn, CTxOut, COutPoint, CTxInWitness\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_1SUB,\n+    OP_1NEGATE,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIF,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    TaprootSignatureHash,\n+    SegwitV0SignatureHash,\n+    LegacySignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, hex_str_to_bytes, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    program_to_witness,\n+    script_to_p2sh,\n+    hash160,\n+    key_to_p2wpkh,\n+    key_to_p2sh_p2wpkh,\n+    key_to_p2pkh,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+import struct\n+\n+EMPTYWITNESS_ERROR = \"non-mandatory-script-verify-flag (Witness program was passed an empty witness) (code 64)\"\n+INVALIDKEYPATHSIG_ERROR = \"non-mandatory-script-verify-flag (Invalid signature for Taproot key path spending) (code 64)\"\n+UNKNOWNWITNESS_ERROR = \"non-mandatory-script-verify-flag (Witness version reserved for soft-fork upgrades) (code 64)\"\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+def tx_from_hex(hexstring):\n+    tx = CTransaction()\n+    f = BytesIO(hex_str_to_bytes(hexstring))\n+    tx.deserialize(f)\n+    return tx\n+\n+def get_taproot_bech32(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return program_to_witness(1, info[2:])\n+\n+def get_version1_p2sh(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return script_to_p2sh(info)\n+\n+def get_p2sh_spk(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return CScript([OP_HASH160, hash160(info), OP_EQUAL])\n+\n+def random_op_success():\n+    ret = 0\n+    while (not is_op_success(ret)):\n+        ret = random.randint(0x50, 0xfe)\n+    return CScriptOp(ret)\n+\n+def random_unknown_leaf_ver(no_annex_tag=True):\n+    ret = LEAF_VERSION_TAPSCRIPT\n+    while (ret == LEAF_VERSION_TAPSCRIPT or (no_annex_tag and ret == (ANNEX_TAG & 0xfe))):\n+        ret = random.randrange(128) * 2\n+    return ret\n+\n+def random_bytes(n):\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+# TODO-TAPROOT Use this in a test\n+def random_script(size, no_success=True):\n+    ret = bytes()\n+    while (len(ret) < size):\n+        remain = size - len(ret)\n+        opcode = random.randrange(256)\n+        while (no_success and is_op_success(opcode)):\n+            opcode = random.randrange(256)\n+        if opcode == 0 or opcode >= OP_1NEGATE:\n+            ret += bytes([opcode])\n+        elif opcode <= 75 and opcode <= remain - 1:\n+            ret += bytes([opcode]) + random_bytes(opcode)\n+        elif opcode == 76 and remain >= 2:\n+            pushsize = random.randint(0, min(0xff, remain - 2))\n+            ret += bytes([opcode]) + bytes([pushsize]) + random_bytes(pushsize)\n+        elif opcode == 77 and remain >= 3:\n+            pushsize = random.randint(0, min(0xffff, remain - 3))\n+            ret += bytes([opcode]) + struct.pack(b'<H', pushsize) + random_bytes(pushsize)\n+        elif opcode == 78 and remain >= 5:\n+            pushsize = random.randint(0, min(0xffffffff, remain - 5))\n+            ret += bytes([opcode]) + struct.pack(b'<I', pushsize) + random_bytes(pushsize)\n+    assert len(ret) == size\n+    return ret\n+\n+# TODO-TAPROOT Use this in a test\n+def random_invalid_push(size):\n+    assert size > 0\n+    ret = bytes()\n+    opcode = 78\n+    if size <= 75:\n+        opcode = random.randint(75, 78)\n+    elif size <= 255:\n+        opcode = random.randint(76, 78)\n+    elif size <= 0xffff:\n+        opcode = random.randint(77, 78)\n+    if opcode == 75:\n+        ret = bytes([size]) + random_bytes(size - 1)\n+    elif opcode == 76:\n+        ret = bytes([opcode]) + bytes([size]) + random_bytes(size - 2)\n+    elif opcode == 77:\n+        ret = bytes([opcode]) + struct.pack(b'<H', size) + random_bytes(max(0, size - 3))\n+    else:\n+        ret = bytes([opcode]) + struct.pack(b'<I', size) + random_bytes(max(0, size - 5))\n+    assert len(ret) >= size\n+    return ret[:size]\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def damage_bytes(b):\n+    \"\"\"Flips one bit at random in a byte string.\"\"\"\n+    return (int.from_bytes(b, 'big') ^ (1 << random.randrange(len(b) * 8))).to_bytes(len(b), 'big')\n+\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - An address for that scriptPubKey (string)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A witness stack-producing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a succesful spend\n+\n+Spender = namedtuple(\"Spender\", \"script,address,comment,is_standard,sat_function,err_msg,sigops_weight\")\n+\n+def spend_no_sig(tx, input_index, spent_utxos, info, script):\n+    \"\"\"Construct witness.\"\"\"\n+    script = script[\"script\"]\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = [script, info[2][script]]\n+\n+def spend_single_sig(tx, input_index, spent_utxos, info, key, annex=None, hashtype=0, prefix=None, suffix=None, script=None, pos=-1, damage=False):\n+    if prefix is None:\n+        prefix = []\n+    if suffix is None:\n+        suffix = []\n+\n+    ht = hashtype\n+\n+    damage_type = random.randrange(5) if damage else -1\n+    '''\n+    * 0. bit flip the sighash\n+    * 1. bit flip the signature\n+    * If the expected hashtype is 0:\n+    -- 2. append a 0 to the signature\n+    -- 3. append a random value of 1-255 to the signature\n+    * If the expected hashtype is not 0:\n+    -- 2. do not append hashtype to the signature\n+    -- 3. append a random incorrect value of 0-255 to the signature\n+    * 4. extra witness element\n+    '''\n+\n+    # Taproot key path spend: tweak key\n+    if script is None:\n+        _, negated = compute_xonly_pubkey(key)\n+        key = tweak_add_privkey(key, info[1], negated)\n+        assert(key is not None)\n+\n+    # Change SIGHASH_SINGLE into SIGHASH_ALL if no corresponding output\n+    if (ht & 3 == SIGHASH_SINGLE and input_index >= len(tx.vout)):\n+        ht ^= 2\n+    # Compute sighash\n+    if script:\n+        sighash = TaprootSignatureHash(tx, spent_utxos, ht, input_index, scriptpath=True, script=script, codeseparator_pos=pos, annex=annex)\n+    else:\n+        sighash = TaprootSignatureHash(tx, spent_utxos, ht, input_index, scriptpath=False, annex=annex)\n+    if damage_type == 0:\n+        sighash = damage_bytes(sighash)\n+    # Compute signature\n+    sig = sign_schnorr(key, sighash)\n+    if damage_type == 1:\n+        sig = damage_bytes(sig)\n+    if damage_type == 2:\n+        if ht == 0:\n+            sig += bytes([0])\n+    elif damage_type == 3:\n+        random_ht = ht\n+        while random_ht == ht:\n+            random_ht = random.randrange(256)\n+        sig += bytes([random_ht])\n+    elif ht > 0:\n+        sig += bytes([ht])\n+    # Construct witness\n+    ret = prefix + [sig] + suffix\n+    if script is not None:\n+        ret += [script, info[2][script]]\n+    if annex is not None:\n+        ret += [annex]\n+    if damage_type == 4:\n+        ret = [random_bytes(random.randrange(5))] + ret\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = ret\n+\n+def spend_alwaysvalid(tx, input_index, info, script, annex=None, damage=False):\n+    if isinstance(script, tuple):\n+        version, script = script\n+    ret = [script, info[2][script]]\n+    if damage:\n+        # With 50% chance, we bit flip the script (unless the script is an empty vector)\n+        # With 50% chance, we bit flip the control block\n+        if random.choice([True, False]) or len(ret[0]) == 0:\n+            # Annex is always required for leaf version 0x50\n+            # Unless the original version is 0x50, we couldn't convert it to 0x50 without using annex\n+            tmp = damage_bytes(ret[1])\n+            while annex is None and tmp[0] == ANNEX_TAG and ret[1][0] != ANNEX_TAG:\n+                tmp = damage_bytes(ret[1])\n+            ret[1] = tmp\n+        else:\n+            ret[0] = damage_bytes(ret[0])\n+    if annex is not None:\n+        ret += [annex]\n+    # Randomly add input witness\n+    if random.choice([True, False]):\n+        for i in range(random.randint(1, 10)):\n+            ret = [random_bytes(random.randint(0, MAX_SCRIPT_ELEMENT_SIZE * 2))] + ret\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = ret\n+\n+# N.B. Function arguments below: t(ransaction), i(ndex to spend), u(txos being spent), v(alid signature?)\n+\n+def spender_legacy(spenders, key, comment, hashtype, segwit, p2sh):\n+    \"\"\"Legacy signing (P2PKH, P2SH-P2PKH, P2WPKH, P2SH-P2WPKH, with signatures on valid/invalid sighashes).\"\"\"\n+    eckey = ECKey()\n+    eckey.set(key, True)\n+    pubkey = eckey.get_pubkey().get_bytes()\n+    pubkeyhash = hash160(pubkey)\n+    sigops_weight = 0\n+    if segwit:\n+        sigops_weight += 1\n+        spk = CScript([OP_0, pubkeyhash])\n+        if p2sh:\n+            addr = key_to_p2sh_p2wpkh(pubkey)\n+        else:\n+            addr = key_to_p2wpkh(pubkey)\n+    else:\n+        sigops_weight += 1 * WITNESS_SCALE_FACTOR\n+        spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+        if p2sh:\n+            addr = script_to_p2sh(spk)\n+        else:\n+            addr = key_to_p2pkh(pubkey)\n+    if p2sh:\n+        redeemscript = spk\n+        spk = CScript([OP_HASH160, hash160(redeemscript), OP_EQUAL])\n+\n+    def fn(t, i, u, v):\n+        script = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+        if segwit:\n+            sig_hash = SegwitV0SignatureHash(script, t, i, hashtype, u[i].nValue)\n+        else:\n+            sig_hash = LegacySignatureHash(script, t, i, hashtype)[0]\n+        if not v:\n+            sig_hash = damage_bytes(sig_hash)\n+        sig = eckey.sign_ecdsa(sig_hash) + bytes([hashtype])\n+        if segwit:\n+            t.wit.vtxinwit[i].scriptWitness.stack = [sig, pubkey]\n+        else:\n+            t.vin[i].scriptSig = CScript([sig, pubkey])\n+        if p2sh:\n+            t.vin[i].scriptSig = bytes(t.vin[i].scriptSig) + CScript([redeemscript])\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=True, sat_function=fn, err_msg=None, sigops_weight=sigops_weight))\n+\n+def spender_sighash_mutation(spenders, info, comment, standard=True, **kwargs):\n+    \"\"\"Mutates signature randomly when failure for the inputs is requested.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_single_sig(t, i, u, damage=not v, info=info, **kwargs)\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn, err_msg=None, sigops_weight=0))\n+\n+def spender_two_paths(spenders, info, comment, standard, success, failure, err_msg=None):\n+    \"\"\"Gives caller a way to specify two merkle paths to test validity satisfaction: One expected success, and one failure.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_single_sig(t, i, u, damage=False, info=info, **(success if v else failure))\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn, err_msg=err_msg, sigops_weight=0))\n+\n+def spender_alwaysvalid(spenders, info, comment, err_msg=None, **kwargs):\n+    \"\"\"Mutates the witness when requested, intended for otherwise always true scripts.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_alwaysvalid(t, i, damage=not v, info=info, **kwargs)\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=False, sat_function=fn, err_msg=err_msg, sigops_weight=0))\n+\n+def spender_two_paths_alwaysvalid(spenders, info, comment, standard, success, failure, err_msg=None):\n+    \"\"\"Allows specifying both a success and failure script without any signatures or additional witness data required.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_no_sig(t, i, u, info, (success if v else failure))\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn, err_msg=err_msg, sigops_weight=0))\n+\n+def spender_alwaysvalid_p2sh(spenders, info, comment, standard, script, err_msg=None):\n+    \"\"\"Tests that p2sh-wrapping witness program v1 are always valid, since they are not covered by tapscript.\"\"\"\n+    spk = get_p2sh_spk(info)\n+    addr = get_version1_p2sh(info)\n+\n+    def fn(t, i, u, v):\n+        if v:\n+            t.vin[i].scriptSig = CScript([info[0]])\n+            # Empty control block is only invalid if we apply taproot rules,\n+            # which we shouldn't if the spend is wrapped in P2SH\n+            t.wit.vtxinwit[i].scriptWitness.stack = [script, bytes()]\n+        else:\n+            t.vin[i].scriptSig = CScript()\n+        return\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn, err_msg=err_msg, sigops_weight=0))\n+\n+def nested_script(script, depth):\n+    if depth == 0:\n+        return script\n+    return [nested_script(script, depth - 1), CScript([OP_RETURN])]\n+\n+UTXOData = namedtuple('UTXOData', 'input,output,spender')\n+\n+class TaprootTest(BitcoinTestFramework):\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.extra_args = [[\"-whitelist=127.0.0.1\", \"-par=1\"]]\n+\n+    def block_submit(self, node, txs, msg, err_msg, cb_pubkey=None, fees=0, sigops_weight=0, witness=False, accept=False):\n+\n+        # Deplete block of any non-tapscript sigops using a single additional 0-value coinbase output.\n+        # It is not impossible to fit enough tapscript sigops to hit the old 80k limit without\n+        # busting txin-level limits. We simply have to account for the p2pk outputs in all",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r466691211",
      "id" : 466691211,
      "in_reply_to_id" : 461603352,
      "line" : 1156,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY5MTIxMQ==",
      "original_commit_id" : "92d3928ed13d9287b24532e5be863fc6a505c069",
      "original_line" : 1156,
      "original_position" : 410,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : 1156,
      "pull_request_review_id" : 462883137,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/466691211",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r466737776"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/466737776"
         }
      },
      "author_association" : "MEMBER",
      "body" : "We also need to make sure that BIP143 caching is enabled for P2SH-wrapped segwit spends (where we can't just look at the scriptPubKey, and going as far as doing P2SH decoding seems excessive here).\r\n\r\nI was trying to avoid IsWitnessProgram since it'd create an unnecessary copy of witness_program.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-06T23:24:57Z",
      "diff_hunk" : "@@ -1258,65 +1349,208 @@ class CTransactionSignatureSerializer\n     }\n };\n \n+/** Compute the (single) SHA256 of the concatenation of all prevouts of a tx. */\n template <class T>\n uint256 GetPrevoutHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txin : txTo.vin) {\n         ss << txin.prevout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all nSequences of a tx. */\n template <class T>\n uint256 GetSequenceHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txin : txTo.vin) {\n         ss << txin.nSequence;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all txouts of a tx. */\n template <class T>\n uint256 GetOutputsHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n+    }\n+\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143 = false;\n+    bool uses_bip341 = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r466737776",
      "id" : 466737776,
      "in_reply_to_id" : 465117136,
      "line" : 1426,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjczNzc3Ng==",
      "original_commit_id" : "d4260e830a0a3614f05b1bfa855f08edc1a7b39c",
      "original_line" : 1426,
      "original_position" : 273,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 265,
      "pull_request_review_id" : 462941771,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/466737776",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r466738464"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/466738464"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-06T23:27:25Z",
      "diff_hunk" : "@@ -23,7 +23,8 @@ class CSignatureCache\n {\n private:\n      //! Entries are SHA256(nonce || signature hash || public key || signature):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r466738464",
      "id" : 466738464,
      "in_reply_to_id" : 462204524,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjczODQ2NA==",
      "original_commit_id" : "066f086e966fb626321743e8e558857e9d77429e",
      "original_line" : 25,
      "original_position" : 3,
      "original_start_line" : null,
      "path" : "src/script/sigcache.cpp",
      "position" : null,
      "pull_request_review_id" : 462942590,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/466738464",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased, and big update to the functional tests.\r\n\r\nDuring test improving I discovered a discrepancy between the implemented consensus rules and the BIP: undefined hashtypes were not rejected as they should be. This is now fixed (and tested).\r\n\r\nI've addressed most of the discoveries by @gmaxwell's lolcat above:\r\n* *u haz boundary but i shifted it*: I've reworked the sigops ratio test to have much better accuracy; any divergence in the computation should now be detected.\r\n* *DONT TRUST VER*: the OP_SUCCESSx tests are now run for all changed opcodes, rather than randomly. Tests are also added to verify that all other opcodes do not have their behavior modified. (TODO: verify that OP_SUCCESSx isn't applied to non-Taproot spends)\r\n* *why u no share with witness v0??*: added an explicit test that OP_CHECKSIGADD doesn't work for legacy or witv0 spends\r\n* *tapscript iz not 4 minimalists*: added a test that feeds larger-than-1-byte truthy values to OP_IF and OP_NOTIF\r\n* *dont ignore big boyz*: added tests with larger-than-32byte pubkeys (and specifically one that uses traditional 33-byte pubkeys with 0x02/0x03 prefix)\r\n* *just cuz im empty inside doesnt mean i cant count*: tests for OP_CHECKSIG and OP_CHECKSIGADD were added to verify that 0-byte (failing) signatures do not count towards the sigops ratio test.\r\n* *ur gold star no offset being phat*: added a test that the input stacksize limit does not apply with OP_SUCCESSx (all of them)\r\n* *2 many byte 4 so little bark*: several tests now include Merkle branch elements that equal the partner hashed with, or that value +1 or -1 (both in little endian and big endian).\r\n* *im in ur codebase 0pt1miz1ng ur lines.*: the BIP340 test vectors are now also tested in a unit test, and a functional test was added that signs with incorrect R sign (and one with incorrect P sign as well)\r\n* *deez statemints r doin nuthing*:\r\n  * TODO: the return if taproot validation is off isn't tested yet, as there are no tests to verify pre-taproot-activation behavior is unaffected. Added a TODO in the PR description for that.\r\n  * A test for witness stack size 0 was added.\r\n  * A test that appends to, or truncates, the control block was added (and specifically, one that reduces it to size 1)\r\n* *big iz bootyfull*: added tests that taproot validation doesn't apply to (version != 1, p2sh, or programsize != 32) segwit outputs.\r\n* *all numb3erz r equally blessed in eyes of ur tests*: this is very hard to test, as it would require constructing a signature that validates except for not having R on the curve.\r\n* *y send sign if ne1 no care?*: this was tested before (random control block bit flips), but was only hit with very low probability. Added a test that explicitly tests negation of the sign bit.\r\n\r\n@gsanders @jnewbery In the process I've also significantly rewritten the functional tests. There is now just a single \"spend\" function and a single function constructing the \"Spender\" object; all actually injected failures happen by overwriting entries in a dict with default functions that implement aspects of the spending behavior. It's rather unconventional, but it's very easy now to add tests that modify basically any aspect of the process.\r\n",
      "created_at" : "2020-08-06T23:48:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-670245628",
      "id" : 670245628,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY3MDI0NTYyOA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-08-07T20:30:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/670245628",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r466761829"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/466761829"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I was taking `p2pk` literally but I guess it could be read more generally.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-07T00:53:59Z",
      "diff_hunk" : "@@ -0,0 +1,797 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import CTransaction, CTxIn, CTxOut, COutPoint, CTxInWitness\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_1SUB,\n+    OP_1NEGATE,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIF,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    TaprootSignatureHash,\n+    SegwitV0SignatureHash,\n+    LegacySignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, hex_str_to_bytes, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    program_to_witness,\n+    script_to_p2sh,\n+    hash160,\n+    key_to_p2wpkh,\n+    key_to_p2sh_p2wpkh,\n+    key_to_p2pkh,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+import struct\n+\n+EMPTYWITNESS_ERROR = \"non-mandatory-script-verify-flag (Witness program was passed an empty witness) (code 64)\"\n+INVALIDKEYPATHSIG_ERROR = \"non-mandatory-script-verify-flag (Invalid signature for Taproot key path spending) (code 64)\"\n+UNKNOWNWITNESS_ERROR = \"non-mandatory-script-verify-flag (Witness version reserved for soft-fork upgrades) (code 64)\"\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+def tx_from_hex(hexstring):\n+    tx = CTransaction()\n+    f = BytesIO(hex_str_to_bytes(hexstring))\n+    tx.deserialize(f)\n+    return tx\n+\n+def get_taproot_bech32(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return program_to_witness(1, info[2:])\n+\n+def get_version1_p2sh(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return script_to_p2sh(info)\n+\n+def get_p2sh_spk(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return CScript([OP_HASH160, hash160(info), OP_EQUAL])\n+\n+def random_op_success():\n+    ret = 0\n+    while (not is_op_success(ret)):\n+        ret = random.randint(0x50, 0xfe)\n+    return CScriptOp(ret)\n+\n+def random_unknown_leaf_ver(no_annex_tag=True):\n+    ret = LEAF_VERSION_TAPSCRIPT\n+    while (ret == LEAF_VERSION_TAPSCRIPT or (no_annex_tag and ret == (ANNEX_TAG & 0xfe))):\n+        ret = random.randrange(128) * 2\n+    return ret\n+\n+def random_bytes(n):\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+# TODO-TAPROOT Use this in a test\n+def random_script(size, no_success=True):\n+    ret = bytes()\n+    while (len(ret) < size):\n+        remain = size - len(ret)\n+        opcode = random.randrange(256)\n+        while (no_success and is_op_success(opcode)):\n+            opcode = random.randrange(256)\n+        if opcode == 0 or opcode >= OP_1NEGATE:\n+            ret += bytes([opcode])\n+        elif opcode <= 75 and opcode <= remain - 1:\n+            ret += bytes([opcode]) + random_bytes(opcode)\n+        elif opcode == 76 and remain >= 2:\n+            pushsize = random.randint(0, min(0xff, remain - 2))\n+            ret += bytes([opcode]) + bytes([pushsize]) + random_bytes(pushsize)\n+        elif opcode == 77 and remain >= 3:\n+            pushsize = random.randint(0, min(0xffff, remain - 3))\n+            ret += bytes([opcode]) + struct.pack(b'<H', pushsize) + random_bytes(pushsize)\n+        elif opcode == 78 and remain >= 5:\n+            pushsize = random.randint(0, min(0xffffffff, remain - 5))\n+            ret += bytes([opcode]) + struct.pack(b'<I', pushsize) + random_bytes(pushsize)\n+    assert len(ret) == size\n+    return ret\n+\n+# TODO-TAPROOT Use this in a test\n+def random_invalid_push(size):\n+    assert size > 0\n+    ret = bytes()\n+    opcode = 78\n+    if size <= 75:\n+        opcode = random.randint(75, 78)\n+    elif size <= 255:\n+        opcode = random.randint(76, 78)\n+    elif size <= 0xffff:\n+        opcode = random.randint(77, 78)\n+    if opcode == 75:\n+        ret = bytes([size]) + random_bytes(size - 1)\n+    elif opcode == 76:\n+        ret = bytes([opcode]) + bytes([size]) + random_bytes(size - 2)\n+    elif opcode == 77:\n+        ret = bytes([opcode]) + struct.pack(b'<H', size) + random_bytes(max(0, size - 3))\n+    else:\n+        ret = bytes([opcode]) + struct.pack(b'<I', size) + random_bytes(max(0, size - 5))\n+    assert len(ret) >= size\n+    return ret[:size]\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def damage_bytes(b):\n+    \"\"\"Flips one bit at random in a byte string.\"\"\"\n+    return (int.from_bytes(b, 'big') ^ (1 << random.randrange(len(b) * 8))).to_bytes(len(b), 'big')\n+\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - An address for that scriptPubKey (string)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A witness stack-producing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a succesful spend\n+\n+Spender = namedtuple(\"Spender\", \"script,address,comment,is_standard,sat_function,err_msg,sigops_weight\")\n+\n+def spend_no_sig(tx, input_index, spent_utxos, info, script):\n+    \"\"\"Construct witness.\"\"\"\n+    script = script[\"script\"]\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = [script, info[2][script]]\n+\n+def spend_single_sig(tx, input_index, spent_utxos, info, key, annex=None, hashtype=0, prefix=None, suffix=None, script=None, pos=-1, damage=False):\n+    if prefix is None:\n+        prefix = []\n+    if suffix is None:\n+        suffix = []\n+\n+    ht = hashtype\n+\n+    damage_type = random.randrange(5) if damage else -1\n+    '''\n+    * 0. bit flip the sighash\n+    * 1. bit flip the signature\n+    * If the expected hashtype is 0:\n+    -- 2. append a 0 to the signature\n+    -- 3. append a random value of 1-255 to the signature\n+    * If the expected hashtype is not 0:\n+    -- 2. do not append hashtype to the signature\n+    -- 3. append a random incorrect value of 0-255 to the signature\n+    * 4. extra witness element\n+    '''\n+\n+    # Taproot key path spend: tweak key\n+    if script is None:\n+        _, negated = compute_xonly_pubkey(key)\n+        key = tweak_add_privkey(key, info[1], negated)\n+        assert(key is not None)\n+\n+    # Change SIGHASH_SINGLE into SIGHASH_ALL if no corresponding output\n+    if (ht & 3 == SIGHASH_SINGLE and input_index >= len(tx.vout)):\n+        ht ^= 2\n+    # Compute sighash\n+    if script:\n+        sighash = TaprootSignatureHash(tx, spent_utxos, ht, input_index, scriptpath=True, script=script, codeseparator_pos=pos, annex=annex)\n+    else:\n+        sighash = TaprootSignatureHash(tx, spent_utxos, ht, input_index, scriptpath=False, annex=annex)\n+    if damage_type == 0:\n+        sighash = damage_bytes(sighash)\n+    # Compute signature\n+    sig = sign_schnorr(key, sighash)\n+    if damage_type == 1:\n+        sig = damage_bytes(sig)\n+    if damage_type == 2:\n+        if ht == 0:\n+            sig += bytes([0])\n+    elif damage_type == 3:\n+        random_ht = ht\n+        while random_ht == ht:\n+            random_ht = random.randrange(256)\n+        sig += bytes([random_ht])\n+    elif ht > 0:\n+        sig += bytes([ht])\n+    # Construct witness\n+    ret = prefix + [sig] + suffix\n+    if script is not None:\n+        ret += [script, info[2][script]]\n+    if annex is not None:\n+        ret += [annex]\n+    if damage_type == 4:\n+        ret = [random_bytes(random.randrange(5))] + ret\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = ret\n+\n+def spend_alwaysvalid(tx, input_index, info, script, annex=None, damage=False):\n+    if isinstance(script, tuple):\n+        version, script = script\n+    ret = [script, info[2][script]]\n+    if damage:\n+        # With 50% chance, we bit flip the script (unless the script is an empty vector)\n+        # With 50% chance, we bit flip the control block\n+        if random.choice([True, False]) or len(ret[0]) == 0:\n+            # Annex is always required for leaf version 0x50\n+            # Unless the original version is 0x50, we couldn't convert it to 0x50 without using annex\n+            tmp = damage_bytes(ret[1])\n+            while annex is None and tmp[0] == ANNEX_TAG and ret[1][0] != ANNEX_TAG:\n+                tmp = damage_bytes(ret[1])\n+            ret[1] = tmp\n+        else:\n+            ret[0] = damage_bytes(ret[0])\n+    if annex is not None:\n+        ret += [annex]\n+    # Randomly add input witness\n+    if random.choice([True, False]):\n+        for i in range(random.randint(1, 10)):\n+            ret = [random_bytes(random.randint(0, MAX_SCRIPT_ELEMENT_SIZE * 2))] + ret\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = ret\n+\n+# N.B. Function arguments below: t(ransaction), i(ndex to spend), u(txos being spent), v(alid signature?)\n+\n+def spender_legacy(spenders, key, comment, hashtype, segwit, p2sh):\n+    \"\"\"Legacy signing (P2PKH, P2SH-P2PKH, P2WPKH, P2SH-P2WPKH, with signatures on valid/invalid sighashes).\"\"\"\n+    eckey = ECKey()\n+    eckey.set(key, True)\n+    pubkey = eckey.get_pubkey().get_bytes()\n+    pubkeyhash = hash160(pubkey)\n+    sigops_weight = 0\n+    if segwit:\n+        sigops_weight += 1\n+        spk = CScript([OP_0, pubkeyhash])\n+        if p2sh:\n+            addr = key_to_p2sh_p2wpkh(pubkey)\n+        else:\n+            addr = key_to_p2wpkh(pubkey)\n+    else:\n+        sigops_weight += 1 * WITNESS_SCALE_FACTOR\n+        spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+        if p2sh:\n+            addr = script_to_p2sh(spk)\n+        else:\n+            addr = key_to_p2pkh(pubkey)\n+    if p2sh:\n+        redeemscript = spk\n+        spk = CScript([OP_HASH160, hash160(redeemscript), OP_EQUAL])\n+\n+    def fn(t, i, u, v):\n+        script = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+        if segwit:\n+            sig_hash = SegwitV0SignatureHash(script, t, i, hashtype, u[i].nValue)\n+        else:\n+            sig_hash = LegacySignatureHash(script, t, i, hashtype)[0]\n+        if not v:\n+            sig_hash = damage_bytes(sig_hash)\n+        sig = eckey.sign_ecdsa(sig_hash) + bytes([hashtype])\n+        if segwit:\n+            t.wit.vtxinwit[i].scriptWitness.stack = [sig, pubkey]\n+        else:\n+            t.vin[i].scriptSig = CScript([sig, pubkey])\n+        if p2sh:\n+            t.vin[i].scriptSig = bytes(t.vin[i].scriptSig) + CScript([redeemscript])\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=True, sat_function=fn, err_msg=None, sigops_weight=sigops_weight))\n+\n+def spender_sighash_mutation(spenders, info, comment, standard=True, **kwargs):\n+    \"\"\"Mutates signature randomly when failure for the inputs is requested.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_single_sig(t, i, u, damage=not v, info=info, **kwargs)\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn, err_msg=None, sigops_weight=0))\n+\n+def spender_two_paths(spenders, info, comment, standard, success, failure, err_msg=None):\n+    \"\"\"Gives caller a way to specify two merkle paths to test validity satisfaction: One expected success, and one failure.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_single_sig(t, i, u, damage=False, info=info, **(success if v else failure))\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn, err_msg=err_msg, sigops_weight=0))\n+\n+def spender_alwaysvalid(spenders, info, comment, err_msg=None, **kwargs):\n+    \"\"\"Mutates the witness when requested, intended for otherwise always true scripts.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_alwaysvalid(t, i, damage=not v, info=info, **kwargs)\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=False, sat_function=fn, err_msg=err_msg, sigops_weight=0))\n+\n+def spender_two_paths_alwaysvalid(spenders, info, comment, standard, success, failure, err_msg=None):\n+    \"\"\"Allows specifying both a success and failure script without any signatures or additional witness data required.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_no_sig(t, i, u, info, (success if v else failure))\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn, err_msg=err_msg, sigops_weight=0))\n+\n+def spender_alwaysvalid_p2sh(spenders, info, comment, standard, script, err_msg=None):\n+    \"\"\"Tests that p2sh-wrapping witness program v1 are always valid, since they are not covered by tapscript.\"\"\"\n+    spk = get_p2sh_spk(info)\n+    addr = get_version1_p2sh(info)\n+\n+    def fn(t, i, u, v):\n+        if v:\n+            t.vin[i].scriptSig = CScript([info[0]])\n+            # Empty control block is only invalid if we apply taproot rules,\n+            # which we shouldn't if the spend is wrapped in P2SH\n+            t.wit.vtxinwit[i].scriptWitness.stack = [script, bytes()]\n+        else:\n+            t.vin[i].scriptSig = CScript()\n+        return\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn, err_msg=err_msg, sigops_weight=0))\n+\n+def nested_script(script, depth):\n+    if depth == 0:\n+        return script\n+    return [nested_script(script, depth - 1), CScript([OP_RETURN])]\n+\n+UTXOData = namedtuple('UTXOData', 'input,output,spender')\n+\n+class TaprootTest(BitcoinTestFramework):\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.extra_args = [[\"-whitelist=127.0.0.1\", \"-par=1\"]]\n+\n+    def block_submit(self, node, txs, msg, err_msg, cb_pubkey=None, fees=0, sigops_weight=0, witness=False, accept=False):\n+\n+        # Deplete block of any non-tapscript sigops using a single additional 0-value coinbase output.\n+        # It is not impossible to fit enough tapscript sigops to hit the old 80k limit without\n+        # busting txin-level limits. We simply have to account for the p2pk outputs in all",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r466761829",
      "id" : 466761829,
      "in_reply_to_id" : 461603352,
      "line" : 1156,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc2MTgyOQ==",
      "original_commit_id" : "92d3928ed13d9287b24532e5be863fc6a505c069",
      "original_line" : 1156,
      "original_position" : 410,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : 1156,
      "pull_request_review_id" : 462968604,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/466761829",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r466999327"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/466999327"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Any reason not to do a range-based for loop here?\r\n\r\n```suggestion\r\n        for (const CTxIn& txin : tx.vin) {\r\n            const COutPoint &prevout = txin.prevout;\r\n```",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-07T12:08:02Z",
      "diff_hunk" : "@@ -1528,14 +1528,20 @@ bool CheckInputScripts(const CTransaction& tx, TxValidationState &state, const C\n         return true;\n     }\n \n-    if (!txdata.m_ready) {\n-        txdata.Init(tx);\n+    if (!txdata.m_spent_outputs_ready) {\n+        std::vector<CTxOut> spent_outputs;\n+        spent_outputs.reserve(tx.vin.size());\n+\n+        for (unsigned int i = 0; i < tx.vin.size(); ++i) {\n+            const COutPoint &prevout = tx.vin[i].prevout;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r466999327",
      "id" : 466999327,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk5OTMyNw==",
      "original_commit_id" : "ff9b7e6e2644f4acb76031e9d8c783ca9217e7c2",
      "original_line" : 1536,
      "original_position" : 11,
      "original_start_line" : 1535,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 463234096,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/466999327",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467084462"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467084462"
         }
      },
      "author_association" : "MEMBER",
      "body" : "There's a naming inconsistency here. `VerifySignature` changed to `VerifyECDSASignature`/`VerifySchnorrSignature`, but `CheckSig` has changed to `CheckSigSchnorr`/`CheckSig`. Would it be better to name them `CheckSchnorrSig`/`CheckECDSASig`?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-07T14:41:47Z",
      "diff_hunk" : "@@ -153,6 +227,11 @@ class BaseSignatureChecker\n         return false;\n     }\n \n+    virtual bool CheckSigSchnorr(const std::vector<unsigned char>& sig, const std::vector<unsigned char>& pubkey, SigVersion sigversion, const ScriptExecutionData& execdata) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467084462",
      "id" : 467084462,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA4NDQ2Mg==",
      "original_commit_id" : "ff9b7e6e2644f4acb76031e9d8c783ca9217e7c2",
      "original_line" : 230,
      "original_position" : 132,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 463369209,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467084462",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467121438"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467121438"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Is there any disadvantage to combining these two lines and eliminating the temporary return value:\r\n\r\n```suggestion\r\n    if !(SignatureHashSchnorr(sighash, execdata, *txTo, nIn, hashtype, sigversion, this->txdata) return false;\r\n```",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-07T15:45:55Z",
      "diff_hunk" : "@@ -1407,12 +1646,34 @@ bool GenericTransactionSignatureChecker<T>::CheckSig(const std::vector<unsigned\n \n     uint256 sighash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion, this->txdata);\n \n-    if (!VerifySignature(vchSig, pubkey, sighash))\n+    if (!VerifyECDSASignature(vchSig, pubkey, sighash))\n         return false;\n \n     return true;\n }\n \n+template <class T>\n+bool GenericTransactionSignatureChecker<T>::CheckSigSchnorr(const std::vector<unsigned char>& sig_in, const std::vector<unsigned char>& pubkey_in, SigVersion sigversion, const ScriptExecutionData& execdata) const\n+{\n+    std::vector<unsigned char> sig(sig_in);\n+    if (sig.empty()) return false;\n+\n+    if (pubkey_in.size() != 32) return false;\n+    XOnlyPubKey pubkey{uint256(pubkey_in)};\n+\n+    uint8_t hashtype = SIGHASH_DEFAULT;\n+    if (sig.size() == 65) {\n+        hashtype = sig.back();\n+        if (hashtype == SIGHASH_DEFAULT) return false;\n+        sig.pop_back();\n+    }\n+    if (sig.size() != 64) return false;\n+    uint256 sighash;\n+    bool ret = SignatureHashSchnorr(sighash, execdata, *txTo, nIn, hashtype, sigversion, this->txdata);\n+    if (!ret) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467121438",
      "id" : 467121438,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEyMTQzOA==",
      "original_commit_id" : "ff9b7e6e2644f4acb76031e9d8c783ca9217e7c2",
      "original_line" : 1673,
      "original_position" : 481,
      "original_start_line" : 1672,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 463416916,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467121438",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467195675"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467195675"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Marking as resolved.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-07T18:13:04Z",
      "diff_hunk" : "@@ -1029,9 +1098,32 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                 }\n                 break;\n \n+                case OP_CHECKSIGADD:\n+                {\n+                    // OP_CHECKSIGADD is only available in Tapscript\n+                    if (sigversion != SigVersion::TAPSCRIPT) return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n+\n+                    // (sig num pubkey -- num)\n+                    if (stack.size() < 3) return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n+\n+                    const valtype& sig = stacktop(-3);\n+                    const CScriptNum num(stacktop(-2), fRequireMinimal);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467195675",
      "id" : 467195675,
      "in_reply_to_id" : 454650575,
      "line" : 1111,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5NTY3NQ==",
      "original_commit_id" : "7cdc010c70aa5e65e6b8e149b7f22e2fc93697fc",
      "original_line" : 1111,
      "original_position" : 159,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 185,
      "pull_request_review_id" : 463509875,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467195675",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467196125"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467196125"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-07T18:13:58Z",
      "diff_hunk" : "@@ -7,6 +7,17 @@\n keys, and is trivially vulnerable to side channel attacks. Do not use for\n anything but tests.\"\"\"\n import random\n+import hashlib",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467196125",
      "id" : 467196125,
      "in_reply_to_id" : 459958265,
      "line" : 11,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5NjEyNQ==",
      "original_commit_id" : "ad51604f57aaa311529bd302e069c26dac818ad6",
      "original_line" : 11,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : 12,
      "pull_request_review_id" : 463510439,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467196125",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467197477"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467197477"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Not going to do this, as it would mean changing more call sites (which currently pass serror, but wouldn't have an execdata to pass).",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-07T18:16:51Z",
      "diff_hunk" : "@@ -371,7 +371,7 @@ static bool EvalChecksig(const valtype& vchSig, const valtype& vchPubKey, CScrip\n     return true;\n }\n \n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)\n+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, ScriptExecutionData execdata)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467197477",
      "id" : 467197477,
      "in_reply_to_id" : 460079736,
      "line" : 432,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5NzQ3Nw==",
      "original_commit_id" : "cbcaab9a66f82fa5bcc2711a5fee2adc47004cc8",
      "original_line" : 432,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 92,
      "pull_request_review_id" : 463512148,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467197477",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467198115"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467198115"
         }
      },
      "author_association" : "MEMBER",
      "body" : "You can take it literally. P2PK (and other bare-public-key-in-output types, but there aren't any of those in this test) are the only ones that cost sigops.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-07T18:18:14Z",
      "diff_hunk" : "@@ -0,0 +1,797 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import CTransaction, CTxIn, CTxOut, COutPoint, CTxInWitness\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_1SUB,\n+    OP_1NEGATE,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIF,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    TaprootSignatureHash,\n+    SegwitV0SignatureHash,\n+    LegacySignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, hex_str_to_bytes, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    program_to_witness,\n+    script_to_p2sh,\n+    hash160,\n+    key_to_p2wpkh,\n+    key_to_p2sh_p2wpkh,\n+    key_to_p2pkh,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+import struct\n+\n+EMPTYWITNESS_ERROR = \"non-mandatory-script-verify-flag (Witness program was passed an empty witness) (code 64)\"\n+INVALIDKEYPATHSIG_ERROR = \"non-mandatory-script-verify-flag (Invalid signature for Taproot key path spending) (code 64)\"\n+UNKNOWNWITNESS_ERROR = \"non-mandatory-script-verify-flag (Witness version reserved for soft-fork upgrades) (code 64)\"\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+def tx_from_hex(hexstring):\n+    tx = CTransaction()\n+    f = BytesIO(hex_str_to_bytes(hexstring))\n+    tx.deserialize(f)\n+    return tx\n+\n+def get_taproot_bech32(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return program_to_witness(1, info[2:])\n+\n+def get_version1_p2sh(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return script_to_p2sh(info)\n+\n+def get_p2sh_spk(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return CScript([OP_HASH160, hash160(info), OP_EQUAL])\n+\n+def random_op_success():\n+    ret = 0\n+    while (not is_op_success(ret)):\n+        ret = random.randint(0x50, 0xfe)\n+    return CScriptOp(ret)\n+\n+def random_unknown_leaf_ver(no_annex_tag=True):\n+    ret = LEAF_VERSION_TAPSCRIPT\n+    while (ret == LEAF_VERSION_TAPSCRIPT or (no_annex_tag and ret == (ANNEX_TAG & 0xfe))):\n+        ret = random.randrange(128) * 2\n+    return ret\n+\n+def random_bytes(n):\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+# TODO-TAPROOT Use this in a test\n+def random_script(size, no_success=True):\n+    ret = bytes()\n+    while (len(ret) < size):\n+        remain = size - len(ret)\n+        opcode = random.randrange(256)\n+        while (no_success and is_op_success(opcode)):\n+            opcode = random.randrange(256)\n+        if opcode == 0 or opcode >= OP_1NEGATE:\n+            ret += bytes([opcode])\n+        elif opcode <= 75 and opcode <= remain - 1:\n+            ret += bytes([opcode]) + random_bytes(opcode)\n+        elif opcode == 76 and remain >= 2:\n+            pushsize = random.randint(0, min(0xff, remain - 2))\n+            ret += bytes([opcode]) + bytes([pushsize]) + random_bytes(pushsize)\n+        elif opcode == 77 and remain >= 3:\n+            pushsize = random.randint(0, min(0xffff, remain - 3))\n+            ret += bytes([opcode]) + struct.pack(b'<H', pushsize) + random_bytes(pushsize)\n+        elif opcode == 78 and remain >= 5:\n+            pushsize = random.randint(0, min(0xffffffff, remain - 5))\n+            ret += bytes([opcode]) + struct.pack(b'<I', pushsize) + random_bytes(pushsize)\n+    assert len(ret) == size\n+    return ret\n+\n+# TODO-TAPROOT Use this in a test\n+def random_invalid_push(size):\n+    assert size > 0\n+    ret = bytes()\n+    opcode = 78\n+    if size <= 75:\n+        opcode = random.randint(75, 78)\n+    elif size <= 255:\n+        opcode = random.randint(76, 78)\n+    elif size <= 0xffff:\n+        opcode = random.randint(77, 78)\n+    if opcode == 75:\n+        ret = bytes([size]) + random_bytes(size - 1)\n+    elif opcode == 76:\n+        ret = bytes([opcode]) + bytes([size]) + random_bytes(size - 2)\n+    elif opcode == 77:\n+        ret = bytes([opcode]) + struct.pack(b'<H', size) + random_bytes(max(0, size - 3))\n+    else:\n+        ret = bytes([opcode]) + struct.pack(b'<I', size) + random_bytes(max(0, size - 5))\n+    assert len(ret) >= size\n+    return ret[:size]\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def damage_bytes(b):\n+    \"\"\"Flips one bit at random in a byte string.\"\"\"\n+    return (int.from_bytes(b, 'big') ^ (1 << random.randrange(len(b) * 8))).to_bytes(len(b), 'big')\n+\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - An address for that scriptPubKey (string)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A witness stack-producing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a succesful spend\n+\n+Spender = namedtuple(\"Spender\", \"script,address,comment,is_standard,sat_function,err_msg,sigops_weight\")\n+\n+def spend_no_sig(tx, input_index, spent_utxos, info, script):\n+    \"\"\"Construct witness.\"\"\"\n+    script = script[\"script\"]\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = [script, info[2][script]]\n+\n+def spend_single_sig(tx, input_index, spent_utxos, info, key, annex=None, hashtype=0, prefix=None, suffix=None, script=None, pos=-1, damage=False):\n+    if prefix is None:\n+        prefix = []\n+    if suffix is None:\n+        suffix = []\n+\n+    ht = hashtype\n+\n+    damage_type = random.randrange(5) if damage else -1\n+    '''\n+    * 0. bit flip the sighash\n+    * 1. bit flip the signature\n+    * If the expected hashtype is 0:\n+    -- 2. append a 0 to the signature\n+    -- 3. append a random value of 1-255 to the signature\n+    * If the expected hashtype is not 0:\n+    -- 2. do not append hashtype to the signature\n+    -- 3. append a random incorrect value of 0-255 to the signature\n+    * 4. extra witness element\n+    '''\n+\n+    # Taproot key path spend: tweak key\n+    if script is None:\n+        _, negated = compute_xonly_pubkey(key)\n+        key = tweak_add_privkey(key, info[1], negated)\n+        assert(key is not None)\n+\n+    # Change SIGHASH_SINGLE into SIGHASH_ALL if no corresponding output\n+    if (ht & 3 == SIGHASH_SINGLE and input_index >= len(tx.vout)):\n+        ht ^= 2\n+    # Compute sighash\n+    if script:\n+        sighash = TaprootSignatureHash(tx, spent_utxos, ht, input_index, scriptpath=True, script=script, codeseparator_pos=pos, annex=annex)\n+    else:\n+        sighash = TaprootSignatureHash(tx, spent_utxos, ht, input_index, scriptpath=False, annex=annex)\n+    if damage_type == 0:\n+        sighash = damage_bytes(sighash)\n+    # Compute signature\n+    sig = sign_schnorr(key, sighash)\n+    if damage_type == 1:\n+        sig = damage_bytes(sig)\n+    if damage_type == 2:\n+        if ht == 0:\n+            sig += bytes([0])\n+    elif damage_type == 3:\n+        random_ht = ht\n+        while random_ht == ht:\n+            random_ht = random.randrange(256)\n+        sig += bytes([random_ht])\n+    elif ht > 0:\n+        sig += bytes([ht])\n+    # Construct witness\n+    ret = prefix + [sig] + suffix\n+    if script is not None:\n+        ret += [script, info[2][script]]\n+    if annex is not None:\n+        ret += [annex]\n+    if damage_type == 4:\n+        ret = [random_bytes(random.randrange(5))] + ret\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = ret\n+\n+def spend_alwaysvalid(tx, input_index, info, script, annex=None, damage=False):\n+    if isinstance(script, tuple):\n+        version, script = script\n+    ret = [script, info[2][script]]\n+    if damage:\n+        # With 50% chance, we bit flip the script (unless the script is an empty vector)\n+        # With 50% chance, we bit flip the control block\n+        if random.choice([True, False]) or len(ret[0]) == 0:\n+            # Annex is always required for leaf version 0x50\n+            # Unless the original version is 0x50, we couldn't convert it to 0x50 without using annex\n+            tmp = damage_bytes(ret[1])\n+            while annex is None and tmp[0] == ANNEX_TAG and ret[1][0] != ANNEX_TAG:\n+                tmp = damage_bytes(ret[1])\n+            ret[1] = tmp\n+        else:\n+            ret[0] = damage_bytes(ret[0])\n+    if annex is not None:\n+        ret += [annex]\n+    # Randomly add input witness\n+    if random.choice([True, False]):\n+        for i in range(random.randint(1, 10)):\n+            ret = [random_bytes(random.randint(0, MAX_SCRIPT_ELEMENT_SIZE * 2))] + ret\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = ret\n+\n+# N.B. Function arguments below: t(ransaction), i(ndex to spend), u(txos being spent), v(alid signature?)\n+\n+def spender_legacy(spenders, key, comment, hashtype, segwit, p2sh):\n+    \"\"\"Legacy signing (P2PKH, P2SH-P2PKH, P2WPKH, P2SH-P2WPKH, with signatures on valid/invalid sighashes).\"\"\"\n+    eckey = ECKey()\n+    eckey.set(key, True)\n+    pubkey = eckey.get_pubkey().get_bytes()\n+    pubkeyhash = hash160(pubkey)\n+    sigops_weight = 0\n+    if segwit:\n+        sigops_weight += 1\n+        spk = CScript([OP_0, pubkeyhash])\n+        if p2sh:\n+            addr = key_to_p2sh_p2wpkh(pubkey)\n+        else:\n+            addr = key_to_p2wpkh(pubkey)\n+    else:\n+        sigops_weight += 1 * WITNESS_SCALE_FACTOR\n+        spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+        if p2sh:\n+            addr = script_to_p2sh(spk)\n+        else:\n+            addr = key_to_p2pkh(pubkey)\n+    if p2sh:\n+        redeemscript = spk\n+        spk = CScript([OP_HASH160, hash160(redeemscript), OP_EQUAL])\n+\n+    def fn(t, i, u, v):\n+        script = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+        if segwit:\n+            sig_hash = SegwitV0SignatureHash(script, t, i, hashtype, u[i].nValue)\n+        else:\n+            sig_hash = LegacySignatureHash(script, t, i, hashtype)[0]\n+        if not v:\n+            sig_hash = damage_bytes(sig_hash)\n+        sig = eckey.sign_ecdsa(sig_hash) + bytes([hashtype])\n+        if segwit:\n+            t.wit.vtxinwit[i].scriptWitness.stack = [sig, pubkey]\n+        else:\n+            t.vin[i].scriptSig = CScript([sig, pubkey])\n+        if p2sh:\n+            t.vin[i].scriptSig = bytes(t.vin[i].scriptSig) + CScript([redeemscript])\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=True, sat_function=fn, err_msg=None, sigops_weight=sigops_weight))\n+\n+def spender_sighash_mutation(spenders, info, comment, standard=True, **kwargs):\n+    \"\"\"Mutates signature randomly when failure for the inputs is requested.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_single_sig(t, i, u, damage=not v, info=info, **kwargs)\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn, err_msg=None, sigops_weight=0))\n+\n+def spender_two_paths(spenders, info, comment, standard, success, failure, err_msg=None):\n+    \"\"\"Gives caller a way to specify two merkle paths to test validity satisfaction: One expected success, and one failure.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_single_sig(t, i, u, damage=False, info=info, **(success if v else failure))\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn, err_msg=err_msg, sigops_weight=0))\n+\n+def spender_alwaysvalid(spenders, info, comment, err_msg=None, **kwargs):\n+    \"\"\"Mutates the witness when requested, intended for otherwise always true scripts.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_alwaysvalid(t, i, damage=not v, info=info, **kwargs)\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=False, sat_function=fn, err_msg=err_msg, sigops_weight=0))\n+\n+def spender_two_paths_alwaysvalid(spenders, info, comment, standard, success, failure, err_msg=None):\n+    \"\"\"Allows specifying both a success and failure script without any signatures or additional witness data required.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_no_sig(t, i, u, info, (success if v else failure))\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn, err_msg=err_msg, sigops_weight=0))\n+\n+def spender_alwaysvalid_p2sh(spenders, info, comment, standard, script, err_msg=None):\n+    \"\"\"Tests that p2sh-wrapping witness program v1 are always valid, since they are not covered by tapscript.\"\"\"\n+    spk = get_p2sh_spk(info)\n+    addr = get_version1_p2sh(info)\n+\n+    def fn(t, i, u, v):\n+        if v:\n+            t.vin[i].scriptSig = CScript([info[0]])\n+            # Empty control block is only invalid if we apply taproot rules,\n+            # which we shouldn't if the spend is wrapped in P2SH\n+            t.wit.vtxinwit[i].scriptWitness.stack = [script, bytes()]\n+        else:\n+            t.vin[i].scriptSig = CScript()\n+        return\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn, err_msg=err_msg, sigops_weight=0))\n+\n+def nested_script(script, depth):\n+    if depth == 0:\n+        return script\n+    return [nested_script(script, depth - 1), CScript([OP_RETURN])]\n+\n+UTXOData = namedtuple('UTXOData', 'input,output,spender')\n+\n+class TaprootTest(BitcoinTestFramework):\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.extra_args = [[\"-whitelist=127.0.0.1\", \"-par=1\"]]\n+\n+    def block_submit(self, node, txs, msg, err_msg, cb_pubkey=None, fees=0, sigops_weight=0, witness=False, accept=False):\n+\n+        # Deplete block of any non-tapscript sigops using a single additional 0-value coinbase output.\n+        # It is not impossible to fit enough tapscript sigops to hit the old 80k limit without\n+        # busting txin-level limits. We simply have to account for the p2pk outputs in all",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467198115",
      "id" : 467198115,
      "in_reply_to_id" : 461603352,
      "line" : 1156,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5ODExNQ==",
      "original_commit_id" : "92d3928ed13d9287b24532e5be863fc6a505c069",
      "original_line" : 1156,
      "original_position" : 410,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : 1156,
      "pull_request_review_id" : 463512975,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467198115",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467200141"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467200141"
         }
      },
      "author_association" : "MEMBER",
      "body" : "ok I misunderstood your comment, will just review instead.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-07T18:22:33Z",
      "diff_hunk" : "@@ -0,0 +1,797 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import CTransaction, CTxIn, CTxOut, COutPoint, CTxInWitness\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_1SUB,\n+    OP_1NEGATE,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIF,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    TaprootSignatureHash,\n+    SegwitV0SignatureHash,\n+    LegacySignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, hex_str_to_bytes, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    program_to_witness,\n+    script_to_p2sh,\n+    hash160,\n+    key_to_p2wpkh,\n+    key_to_p2sh_p2wpkh,\n+    key_to_p2pkh,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+import struct\n+\n+EMPTYWITNESS_ERROR = \"non-mandatory-script-verify-flag (Witness program was passed an empty witness) (code 64)\"\n+INVALIDKEYPATHSIG_ERROR = \"non-mandatory-script-verify-flag (Invalid signature for Taproot key path spending) (code 64)\"\n+UNKNOWNWITNESS_ERROR = \"non-mandatory-script-verify-flag (Witness version reserved for soft-fork upgrades) (code 64)\"\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+def tx_from_hex(hexstring):\n+    tx = CTransaction()\n+    f = BytesIO(hex_str_to_bytes(hexstring))\n+    tx.deserialize(f)\n+    return tx\n+\n+def get_taproot_bech32(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return program_to_witness(1, info[2:])\n+\n+def get_version1_p2sh(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return script_to_p2sh(info)\n+\n+def get_p2sh_spk(info):\n+    if isinstance(info, tuple):\n+        info = info[0]\n+    return CScript([OP_HASH160, hash160(info), OP_EQUAL])\n+\n+def random_op_success():\n+    ret = 0\n+    while (not is_op_success(ret)):\n+        ret = random.randint(0x50, 0xfe)\n+    return CScriptOp(ret)\n+\n+def random_unknown_leaf_ver(no_annex_tag=True):\n+    ret = LEAF_VERSION_TAPSCRIPT\n+    while (ret == LEAF_VERSION_TAPSCRIPT or (no_annex_tag and ret == (ANNEX_TAG & 0xfe))):\n+        ret = random.randrange(128) * 2\n+    return ret\n+\n+def random_bytes(n):\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+# TODO-TAPROOT Use this in a test\n+def random_script(size, no_success=True):\n+    ret = bytes()\n+    while (len(ret) < size):\n+        remain = size - len(ret)\n+        opcode = random.randrange(256)\n+        while (no_success and is_op_success(opcode)):\n+            opcode = random.randrange(256)\n+        if opcode == 0 or opcode >= OP_1NEGATE:\n+            ret += bytes([opcode])\n+        elif opcode <= 75 and opcode <= remain - 1:\n+            ret += bytes([opcode]) + random_bytes(opcode)\n+        elif opcode == 76 and remain >= 2:\n+            pushsize = random.randint(0, min(0xff, remain - 2))\n+            ret += bytes([opcode]) + bytes([pushsize]) + random_bytes(pushsize)\n+        elif opcode == 77 and remain >= 3:\n+            pushsize = random.randint(0, min(0xffff, remain - 3))\n+            ret += bytes([opcode]) + struct.pack(b'<H', pushsize) + random_bytes(pushsize)\n+        elif opcode == 78 and remain >= 5:\n+            pushsize = random.randint(0, min(0xffffffff, remain - 5))\n+            ret += bytes([opcode]) + struct.pack(b'<I', pushsize) + random_bytes(pushsize)\n+    assert len(ret) == size\n+    return ret\n+\n+# TODO-TAPROOT Use this in a test\n+def random_invalid_push(size):\n+    assert size > 0\n+    ret = bytes()\n+    opcode = 78\n+    if size <= 75:\n+        opcode = random.randint(75, 78)\n+    elif size <= 255:\n+        opcode = random.randint(76, 78)\n+    elif size <= 0xffff:\n+        opcode = random.randint(77, 78)\n+    if opcode == 75:\n+        ret = bytes([size]) + random_bytes(size - 1)\n+    elif opcode == 76:\n+        ret = bytes([opcode]) + bytes([size]) + random_bytes(size - 2)\n+    elif opcode == 77:\n+        ret = bytes([opcode]) + struct.pack(b'<H', size) + random_bytes(max(0, size - 3))\n+    else:\n+        ret = bytes([opcode]) + struct.pack(b'<I', size) + random_bytes(max(0, size - 5))\n+    assert len(ret) >= size\n+    return ret[:size]\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def damage_bytes(b):\n+    \"\"\"Flips one bit at random in a byte string.\"\"\"\n+    return (int.from_bytes(b, 'big') ^ (1 << random.randrange(len(b) * 8))).to_bytes(len(b), 'big')\n+\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - An address for that scriptPubKey (string)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A witness stack-producing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a succesful spend\n+\n+Spender = namedtuple(\"Spender\", \"script,address,comment,is_standard,sat_function,err_msg,sigops_weight\")\n+\n+def spend_no_sig(tx, input_index, spent_utxos, info, script):\n+    \"\"\"Construct witness.\"\"\"\n+    script = script[\"script\"]\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = [script, info[2][script]]\n+\n+def spend_single_sig(tx, input_index, spent_utxos, info, key, annex=None, hashtype=0, prefix=None, suffix=None, script=None, pos=-1, damage=False):\n+    if prefix is None:\n+        prefix = []\n+    if suffix is None:\n+        suffix = []\n+\n+    ht = hashtype\n+\n+    damage_type = random.randrange(5) if damage else -1\n+    '''\n+    * 0. bit flip the sighash\n+    * 1. bit flip the signature\n+    * If the expected hashtype is 0:\n+    -- 2. append a 0 to the signature\n+    -- 3. append a random value of 1-255 to the signature\n+    * If the expected hashtype is not 0:\n+    -- 2. do not append hashtype to the signature\n+    -- 3. append a random incorrect value of 0-255 to the signature\n+    * 4. extra witness element\n+    '''\n+\n+    # Taproot key path spend: tweak key\n+    if script is None:\n+        _, negated = compute_xonly_pubkey(key)\n+        key = tweak_add_privkey(key, info[1], negated)\n+        assert(key is not None)\n+\n+    # Change SIGHASH_SINGLE into SIGHASH_ALL if no corresponding output\n+    if (ht & 3 == SIGHASH_SINGLE and input_index >= len(tx.vout)):\n+        ht ^= 2\n+    # Compute sighash\n+    if script:\n+        sighash = TaprootSignatureHash(tx, spent_utxos, ht, input_index, scriptpath=True, script=script, codeseparator_pos=pos, annex=annex)\n+    else:\n+        sighash = TaprootSignatureHash(tx, spent_utxos, ht, input_index, scriptpath=False, annex=annex)\n+    if damage_type == 0:\n+        sighash = damage_bytes(sighash)\n+    # Compute signature\n+    sig = sign_schnorr(key, sighash)\n+    if damage_type == 1:\n+        sig = damage_bytes(sig)\n+    if damage_type == 2:\n+        if ht == 0:\n+            sig += bytes([0])\n+    elif damage_type == 3:\n+        random_ht = ht\n+        while random_ht == ht:\n+            random_ht = random.randrange(256)\n+        sig += bytes([random_ht])\n+    elif ht > 0:\n+        sig += bytes([ht])\n+    # Construct witness\n+    ret = prefix + [sig] + suffix\n+    if script is not None:\n+        ret += [script, info[2][script]]\n+    if annex is not None:\n+        ret += [annex]\n+    if damage_type == 4:\n+        ret = [random_bytes(random.randrange(5))] + ret\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = ret\n+\n+def spend_alwaysvalid(tx, input_index, info, script, annex=None, damage=False):\n+    if isinstance(script, tuple):\n+        version, script = script\n+    ret = [script, info[2][script]]\n+    if damage:\n+        # With 50% chance, we bit flip the script (unless the script is an empty vector)\n+        # With 50% chance, we bit flip the control block\n+        if random.choice([True, False]) or len(ret[0]) == 0:\n+            # Annex is always required for leaf version 0x50\n+            # Unless the original version is 0x50, we couldn't convert it to 0x50 without using annex\n+            tmp = damage_bytes(ret[1])\n+            while annex is None and tmp[0] == ANNEX_TAG and ret[1][0] != ANNEX_TAG:\n+                tmp = damage_bytes(ret[1])\n+            ret[1] = tmp\n+        else:\n+            ret[0] = damage_bytes(ret[0])\n+    if annex is not None:\n+        ret += [annex]\n+    # Randomly add input witness\n+    if random.choice([True, False]):\n+        for i in range(random.randint(1, 10)):\n+            ret = [random_bytes(random.randint(0, MAX_SCRIPT_ELEMENT_SIZE * 2))] + ret\n+    tx.wit.vtxinwit[input_index].scriptWitness.stack = ret\n+\n+# N.B. Function arguments below: t(ransaction), i(ndex to spend), u(txos being spent), v(alid signature?)\n+\n+def spender_legacy(spenders, key, comment, hashtype, segwit, p2sh):\n+    \"\"\"Legacy signing (P2PKH, P2SH-P2PKH, P2WPKH, P2SH-P2WPKH, with signatures on valid/invalid sighashes).\"\"\"\n+    eckey = ECKey()\n+    eckey.set(key, True)\n+    pubkey = eckey.get_pubkey().get_bytes()\n+    pubkeyhash = hash160(pubkey)\n+    sigops_weight = 0\n+    if segwit:\n+        sigops_weight += 1\n+        spk = CScript([OP_0, pubkeyhash])\n+        if p2sh:\n+            addr = key_to_p2sh_p2wpkh(pubkey)\n+        else:\n+            addr = key_to_p2wpkh(pubkey)\n+    else:\n+        sigops_weight += 1 * WITNESS_SCALE_FACTOR\n+        spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+        if p2sh:\n+            addr = script_to_p2sh(spk)\n+        else:\n+            addr = key_to_p2pkh(pubkey)\n+    if p2sh:\n+        redeemscript = spk\n+        spk = CScript([OP_HASH160, hash160(redeemscript), OP_EQUAL])\n+\n+    def fn(t, i, u, v):\n+        script = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+        if segwit:\n+            sig_hash = SegwitV0SignatureHash(script, t, i, hashtype, u[i].nValue)\n+        else:\n+            sig_hash = LegacySignatureHash(script, t, i, hashtype)[0]\n+        if not v:\n+            sig_hash = damage_bytes(sig_hash)\n+        sig = eckey.sign_ecdsa(sig_hash) + bytes([hashtype])\n+        if segwit:\n+            t.wit.vtxinwit[i].scriptWitness.stack = [sig, pubkey]\n+        else:\n+            t.vin[i].scriptSig = CScript([sig, pubkey])\n+        if p2sh:\n+            t.vin[i].scriptSig = bytes(t.vin[i].scriptSig) + CScript([redeemscript])\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=True, sat_function=fn, err_msg=None, sigops_weight=sigops_weight))\n+\n+def spender_sighash_mutation(spenders, info, comment, standard=True, **kwargs):\n+    \"\"\"Mutates signature randomly when failure for the inputs is requested.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_single_sig(t, i, u, damage=not v, info=info, **kwargs)\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn, err_msg=None, sigops_weight=0))\n+\n+def spender_two_paths(spenders, info, comment, standard, success, failure, err_msg=None):\n+    \"\"\"Gives caller a way to specify two merkle paths to test validity satisfaction: One expected success, and one failure.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_single_sig(t, i, u, damage=False, info=info, **(success if v else failure))\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn, err_msg=err_msg, sigops_weight=0))\n+\n+def spender_alwaysvalid(spenders, info, comment, err_msg=None, **kwargs):\n+    \"\"\"Mutates the witness when requested, intended for otherwise always true scripts.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_alwaysvalid(t, i, damage=not v, info=info, **kwargs)\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=False, sat_function=fn, err_msg=err_msg, sigops_weight=0))\n+\n+def spender_two_paths_alwaysvalid(spenders, info, comment, standard, success, failure, err_msg=None):\n+    \"\"\"Allows specifying both a success and failure script without any signatures or additional witness data required.\"\"\"\n+    spk = info[0]\n+    addr = get_taproot_bech32(info)\n+\n+    def fn(t, i, u, v):\n+        return spend_no_sig(t, i, u, info, (success if v else failure))\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn, err_msg=err_msg, sigops_weight=0))\n+\n+def spender_alwaysvalid_p2sh(spenders, info, comment, standard, script, err_msg=None):\n+    \"\"\"Tests that p2sh-wrapping witness program v1 are always valid, since they are not covered by tapscript.\"\"\"\n+    spk = get_p2sh_spk(info)\n+    addr = get_version1_p2sh(info)\n+\n+    def fn(t, i, u, v):\n+        if v:\n+            t.vin[i].scriptSig = CScript([info[0]])\n+            # Empty control block is only invalid if we apply taproot rules,\n+            # which we shouldn't if the spend is wrapped in P2SH\n+            t.wit.vtxinwit[i].scriptWitness.stack = [script, bytes()]\n+        else:\n+            t.vin[i].scriptSig = CScript()\n+        return\n+\n+    spenders.append(Spender(script=spk, address=addr, comment=comment, is_standard=standard, sat_function=fn, err_msg=err_msg, sigops_weight=0))\n+\n+def nested_script(script, depth):\n+    if depth == 0:\n+        return script\n+    return [nested_script(script, depth - 1), CScript([OP_RETURN])]\n+\n+UTXOData = namedtuple('UTXOData', 'input,output,spender')\n+\n+class TaprootTest(BitcoinTestFramework):\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+        self.extra_args = [[\"-whitelist=127.0.0.1\", \"-par=1\"]]\n+\n+    def block_submit(self, node, txs, msg, err_msg, cb_pubkey=None, fees=0, sigops_weight=0, witness=False, accept=False):\n+\n+        # Deplete block of any non-tapscript sigops using a single additional 0-value coinbase output.\n+        # It is not impossible to fit enough tapscript sigops to hit the old 80k limit without\n+        # busting txin-level limits. We simply have to account for the p2pk outputs in all",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467200141",
      "id" : 467200141,
      "in_reply_to_id" : 461603352,
      "line" : 1156,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwMDE0MQ==",
      "original_commit_id" : "92d3928ed13d9287b24532e5be863fc6a505c069",
      "original_line" : 1156,
      "original_position" : 410,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : 1156,
      "pull_request_review_id" : 463515547,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467200141",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467252062"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467252062"
         }
      },
      "author_association" : "MEMBER",
      "body" : "expression",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-07T20:23:38Z",
      "diff_hunk" : "@@ -0,0 +1,1222 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expreesion for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467252062",
      "id" : 467252062,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1MjA2Mg==",
      "original_commit_id" : "ff9b7e6e2644f4acb76031e9d8c783ca9217e7c2",
      "original_line" : 185,
      "original_position" : 185,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 463589678,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467252062",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467325769"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467325769"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-07T23:25:01Z",
      "diff_hunk" : "@@ -153,6 +227,11 @@ class BaseSignatureChecker\n         return false;\n     }\n \n+    virtual bool CheckSigSchnorr(const std::vector<unsigned char>& sig, const std::vector<unsigned char>& pubkey, SigVersion sigversion, const ScriptExecutionData& execdata) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467325769",
      "id" : 467325769,
      "in_reply_to_id" : 467084462,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyNTc2OQ==",
      "original_commit_id" : "ff9b7e6e2644f4acb76031e9d8c783ca9217e7c2",
      "original_line" : 230,
      "original_position" : 132,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 463686445,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467325769",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467325797"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467325797"
         }
      },
      "author_association" : "MEMBER",
      "body" : "None. Done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-07T23:25:08Z",
      "diff_hunk" : "@@ -1407,12 +1646,34 @@ bool GenericTransactionSignatureChecker<T>::CheckSig(const std::vector<unsigned\n \n     uint256 sighash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion, this->txdata);\n \n-    if (!VerifySignature(vchSig, pubkey, sighash))\n+    if (!VerifyECDSASignature(vchSig, pubkey, sighash))\n         return false;\n \n     return true;\n }\n \n+template <class T>\n+bool GenericTransactionSignatureChecker<T>::CheckSigSchnorr(const std::vector<unsigned char>& sig_in, const std::vector<unsigned char>& pubkey_in, SigVersion sigversion, const ScriptExecutionData& execdata) const\n+{\n+    std::vector<unsigned char> sig(sig_in);\n+    if (sig.empty()) return false;\n+\n+    if (pubkey_in.size() != 32) return false;\n+    XOnlyPubKey pubkey{uint256(pubkey_in)};\n+\n+    uint8_t hashtype = SIGHASH_DEFAULT;\n+    if (sig.size() == 65) {\n+        hashtype = sig.back();\n+        if (hashtype == SIGHASH_DEFAULT) return false;\n+        sig.pop_back();\n+    }\n+    if (sig.size() != 64) return false;\n+    uint256 sighash;\n+    bool ret = SignatureHashSchnorr(sighash, execdata, *txTo, nIn, hashtype, sigversion, this->txdata);\n+    if (!ret) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467325797",
      "id" : 467325797,
      "in_reply_to_id" : 467121438,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyNTc5Nw==",
      "original_commit_id" : "ff9b7e6e2644f4acb76031e9d8c783ca9217e7c2",
      "original_line" : 1673,
      "original_position" : 481,
      "original_start_line" : 1672,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 463686480,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467325797",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467325860"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467325860"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-07T23:25:22Z",
      "diff_hunk" : "@@ -1528,14 +1528,20 @@ bool CheckInputScripts(const CTransaction& tx, TxValidationState &state, const C\n         return true;\n     }\n \n-    if (!txdata.m_ready) {\n-        txdata.Init(tx);\n+    if (!txdata.m_spent_outputs_ready) {\n+        std::vector<CTxOut> spent_outputs;\n+        spent_outputs.reserve(tx.vin.size());\n+\n+        for (unsigned int i = 0; i < tx.vin.size(); ++i) {\n+            const COutPoint &prevout = tx.vin[i].prevout;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467325860",
      "id" : 467325860,
      "in_reply_to_id" : 466999327,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyNTg2MA==",
      "original_commit_id" : "ff9b7e6e2644f4acb76031e9d8c783ca9217e7c2",
      "original_line" : 1536,
      "original_position" : 11,
      "original_start_line" : 1535,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 463686532,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467325860",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased on top of #19620 (taproot outputs are now no longer WITNESS_UNKNOWN, as taproot spends would otherwise end up in the reject filter).\r\n\r\nAlso added some tests to verify pre-taproot activation behavior (rules enforced for standardness, but not for consensus).",
      "created_at" : "2020-08-07T23:28:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-670782944",
      "id" : 670782944,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY3MDc4Mjk0NA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-08-07T23:28:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/670782944",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467956184"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467956184"
         }
      },
      "author_association" : "MEMBER",
      "body" : "for `leafversion` anything other than `0xc0` should fail it, maybe just flip a bit of this too",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-10T14:47:24Z",
      "diff_hunk" : "@@ -0,0 +1,1271 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expreesion for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        _, negated = compute_xonly_pubkey(key)\n+        return tweak_add_privkey(key, tweak, negated)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    tx.vin[idx].scriptSig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    tx.wit.vtxinwit[idx].scriptWitness.stack = flatten(get(ctx, \"witness\"))\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert(tap is None)\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert(script is None)\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            spend(tx, idx, utxos, **conf)\n+        else:\n+            assert(failure is not None)\n+            spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+# Expected error strings\n+ERR_KEYPATH_INVALID_SIG = {\"err_msg\": \"Invalid signature for Taproot key path spending\"}\n+ERR_SCRIPTPATH_INVALID_SIG = {\"err_msg\": \"Signature must be zero for failed CHECK(MULTI)SIG operation\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Extra items left on stack after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    sec = generate_privkey()\n+    pub, _ = compute_xonly_pubkey(sec)\n+    tap = taproot_construct(pub)\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=sec, failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=sec, failure={\"sighash\": bitflipper(default_sighash)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=sec, failure={\"flag_flip_r\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=sec, failure={\"flag_flip_p\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=sec, failure={\"signature\": bitflipper(default_signature)}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+        sec1, sec2 = generate_privkey(), generate_privkey()\n+        pub1, _ = compute_xonly_pubkey(sec1)\n+        pub2, _ = compute_xonly_pubkey(sec2)\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pub1)\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pub2)))]\n+            tap = taproot_construct(pub1, scripts)\n+            add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"s0\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+        # Test OP_CODESEPARATOR impact on sighashing.\n+        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+        common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+        scripts = [\n+            (\"pk_codesep\", CScript(random_checksig_style(pub2) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig\n+            (\"codesep_pk\", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pub2))),  # codesep before checksig\n+            (\"branched_codesep\", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pub1, OP_ELSE, OP_CODESEPARATOR, pub2, OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pub1, scripts)\n+        add_spender(spenders, \"sighash/pk_codesep\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/codesep_pk\", tap=tap, leaf=\"codesep_pk\", key=sec2, codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/left\", tap=tap, leaf=\"branched_codesep\", key=sec1, codeseppos=3, **common, inputs=[getter(\"sign\"), b'\\x01'], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/right\", tap=tap, leaf=\"branched_codesep\", key=sec2, codeseppos=6, **common, inputs=[getter(\"sign\"), b''], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Reusing the scripts above, test that various features affect the sighash.\n+    add_spender(spenders, \"sighash/annex\", tap=tap, leaf=\"pk_codesep\", key=sec2, hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={\"sighash\": override(default_sighash, annex=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/script\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, script_taproot=tap.leaves[\"codesep_pk\"].script)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/leafver\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leafversion=0xc2)}, **ERR_SCRIPTPATH_INVALID_SIG)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467956184",
      "id" : 467956184,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk1NjE4NA==",
      "original_commit_id" : "8692041ef50b36ade662561371c0175a70bd8fec",
      "original_line" : 638,
      "original_position" : 638,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 463589678,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467956184",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467956844"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467956844"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm getting some strange mutation results:\r\n\r\n```\r\n--- a/src/script/interpreter.cpp\r\n+++ b/src/script/interpreter.cpp\r\n@@ -1497,7 +1497,7 @@ bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata\r\n     // Hash type\r\n     const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\r\n     const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;\r\n-    if (!(hash_type <= 0x03 || (hash_type >= 0x80 && hash_type <= 0x83))) return false;\r\n+    if (!(hash_type <= 0x04 || (hash_type >= 0x80 && hash_type <= 0x84))) return false;\r\n     ss << hash_type;\r\n``` \r\n\r\npasses even though it's definitely running the 0x04/0x84 cases. Anything beyond that seems to fail.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-10T14:48:24Z",
      "diff_hunk" : "@@ -0,0 +1,1271 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expreesion for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        _, negated = compute_xonly_pubkey(key)\n+        return tweak_add_privkey(key, tweak, negated)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    tx.vin[idx].scriptSig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    tx.wit.vtxinwit[idx].scriptWitness.stack = flatten(get(ctx, \"witness\"))\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert(tap is None)\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert(script is None)\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            spend(tx, idx, utxos, **conf)\n+        else:\n+            assert(failure is not None)\n+            spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+# Expected error strings\n+ERR_KEYPATH_INVALID_SIG = {\"err_msg\": \"Invalid signature for Taproot key path spending\"}\n+ERR_SCRIPTPATH_INVALID_SIG = {\"err_msg\": \"Signature must be zero for failed CHECK(MULTI)SIG operation\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Extra items left on stack after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    sec = generate_privkey()\n+    pub, _ = compute_xonly_pubkey(sec)\n+    tap = taproot_construct(pub)\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=sec, failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=sec, failure={\"sighash\": bitflipper(default_sighash)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=sec, failure={\"flag_flip_r\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=sec, failure={\"flag_flip_p\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=sec, failure={\"signature\": bitflipper(default_signature)}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+        sec1, sec2 = generate_privkey(), generate_privkey()\n+        pub1, _ = compute_xonly_pubkey(sec1)\n+        pub2, _ = compute_xonly_pubkey(sec2)\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pub1)\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pub2)))]\n+            tap = taproot_construct(pub1, scripts)\n+            add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"s0\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+        # Test OP_CODESEPARATOR impact on sighashing.\n+        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+        common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+        scripts = [\n+            (\"pk_codesep\", CScript(random_checksig_style(pub2) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig\n+            (\"codesep_pk\", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pub2))),  # codesep before checksig\n+            (\"branched_codesep\", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pub1, OP_ELSE, OP_CODESEPARATOR, pub2, OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pub1, scripts)\n+        add_spender(spenders, \"sighash/pk_codesep\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/codesep_pk\", tap=tap, leaf=\"codesep_pk\", key=sec2, codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/left\", tap=tap, leaf=\"branched_codesep\", key=sec1, codeseppos=3, **common, inputs=[getter(\"sign\"), b'\\x01'], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/right\", tap=tap, leaf=\"branched_codesep\", key=sec2, codeseppos=6, **common, inputs=[getter(\"sign\"), b''], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Reusing the scripts above, test that various features affect the sighash.\n+    add_spender(spenders, \"sighash/annex\", tap=tap, leaf=\"pk_codesep\", key=sec2, hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={\"sighash\": override(default_sighash, annex=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/script\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, script_taproot=tap.leaves[\"codesep_pk\"].script)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/leafver\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leafversion=0xc2)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leaf=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, failure={\"sighash\": override(default_sighash, leaf=\"pk_codesep\")}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # Test that invalid hashtypes don't work, both in key path and script path spends\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for invalid_hashtype in range(256):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467956844",
      "id" : 467956844,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk1Njg0NA==",
      "original_commit_id" : "8692041ef50b36ade662561371c0175a70bd8fec",
      "original_line" : 644,
      "original_position" : 644,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 463589678,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467956844",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467958678"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467958678"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`s/followed by a dummy/followed by a dummy push of bytes that are to be dropped/`\r\n",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-10T14:50:50Z",
      "diff_hunk" : "@@ -0,0 +1,1271 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expreesion for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        _, negated = compute_xonly_pubkey(key)\n+        return tweak_add_privkey(key, tweak, negated)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    tx.vin[idx].scriptSig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    tx.wit.vtxinwit[idx].scriptWitness.stack = flatten(get(ctx, \"witness\"))\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert(tap is None)\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert(script is None)\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            spend(tx, idx, utxos, **conf)\n+        else:\n+            assert(failure is not None)\n+            spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+# Expected error strings\n+ERR_KEYPATH_INVALID_SIG = {\"err_msg\": \"Invalid signature for Taproot key path spending\"}\n+ERR_SCRIPTPATH_INVALID_SIG = {\"err_msg\": \"Signature must be zero for failed CHECK(MULTI)SIG operation\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Extra items left on stack after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    sec = generate_privkey()\n+    pub, _ = compute_xonly_pubkey(sec)\n+    tap = taproot_construct(pub)\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=sec, failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=sec, failure={\"sighash\": bitflipper(default_sighash)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=sec, failure={\"flag_flip_r\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=sec, failure={\"flag_flip_p\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=sec, failure={\"signature\": bitflipper(default_signature)}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+        sec1, sec2 = generate_privkey(), generate_privkey()\n+        pub1, _ = compute_xonly_pubkey(sec1)\n+        pub2, _ = compute_xonly_pubkey(sec2)\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pub1)\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pub2)))]\n+            tap = taproot_construct(pub1, scripts)\n+            add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"s0\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+        # Test OP_CODESEPARATOR impact on sighashing.\n+        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+        common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+        scripts = [\n+            (\"pk_codesep\", CScript(random_checksig_style(pub2) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig\n+            (\"codesep_pk\", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pub2))),  # codesep before checksig\n+            (\"branched_codesep\", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pub1, OP_ELSE, OP_CODESEPARATOR, pub2, OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pub1, scripts)\n+        add_spender(spenders, \"sighash/pk_codesep\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/codesep_pk\", tap=tap, leaf=\"codesep_pk\", key=sec2, codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/left\", tap=tap, leaf=\"branched_codesep\", key=sec1, codeseppos=3, **common, inputs=[getter(\"sign\"), b'\\x01'], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/right\", tap=tap, leaf=\"branched_codesep\", key=sec2, codeseppos=6, **common, inputs=[getter(\"sign\"), b''], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Reusing the scripts above, test that various features affect the sighash.\n+    add_spender(spenders, \"sighash/annex\", tap=tap, leaf=\"pk_codesep\", key=sec2, hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={\"sighash\": override(default_sighash, annex=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/script\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, script_taproot=tap.leaves[\"codesep_pk\"].script)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/leafver\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leafversion=0xc2)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leaf=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, failure={\"sighash\": override(default_sighash, leaf=\"pk_codesep\")}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # Test that invalid hashtypes don't work, both in key path and script path spends\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for invalid_hashtype in range(256):\n+        if invalid_hashtype not in VALID_SIGHASHES_TAPROOT:\n+            add_spender(spenders, \"sighash/keypath_unk_hashtype\", tap=tap, key=sec1, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath_unk_hashtype\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Test that hashtype 0 cannot have a hashtype byte, and 1 must have one.\n+    add_spender(spenders, \"sighash/hashtype0_byte_keypath\", tap=tap, key=sec1, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_keypath\", tap=tap, key=sec1, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    # Test that hashtype 0 and hashtype 1 cannot be transmuted into each other.\n+    add_spender(spenders, \"sighash/hashtype0to1_keypath\", tap=tap, key=sec1, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0to1_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_keypath\", tap=tap, key=sec1, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # == Test that BIP341 spending only applies to witness version 1, program length 32, no P2SH ==\n+\n+    for p2sh in [False, True]:\n+        for witver in range(1, 17):\n+            for witlen in [20, 31, 32, 33]:\n+                def mutate(spk):\n+                    prog = spk[2:]\n+                    assert(len(prog) == 32)\n+                    if witlen < 32:\n+                        prog = prog[0:witlen]\n+                    elif witlen > 32:\n+                        prog += bytes([0 for _ in range(witlen - 32)])\n+                    return CScript([CScriptOp.encode_op_n(witver), prog])\n+                scripts = [(\"s0\", CScript([pub1, OP_CHECKSIG])), (\"dummy\", CScript([OP_RETURN]))]\n+                tap = taproot_construct(pub2, scripts)\n+                if not p2sh and witver == 1 and witlen == 32:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=sec2, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=sec1, **SINGLE_SIG, failure={\"leaf\": \"dummy\"}, **ERR_OP_RETURN)\n+                else:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=sec2, standard=False)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=sec1, **SINGLE_SIG, standard=False)\n+\n+    # == Test various aspects of BIP341 spending paths ==\n+\n+    # A set of functions that compute the hashing partner in a Merkle tree, designed to exercise\n+    # edge cases. This relies on the taproot_construct feature that a lambda can be passed in\n+    # instead of a subtree, to compute the partner to be hashed with.\n+    PARTNER_MERKLE_FN = [\n+        # Combine with itself\n+        lambda h: h,\n+        # Combine with hash 0\n+        lambda h: bytes([0 for _ in range(32)]),\n+        # Combine with hash 2^256-1\n+        lambda h: bytes([0xff for _ in range(32)]),\n+        # Combine with itself-1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') + 1).to_bytes(32, 'big'),\n+        # Combine with itself-1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') + 1).to_bytes(32, 'little'),\n+        # Combine with random bitflipped version of self.\n+        lambda h: (int.from_bytes(h, 'little') ^ (1 << random.randrange(256))).to_bytes(32, 'little')\n+    ]\n+    # Start with a tree of that has depth 1 for \"128deep\" and depth 2 for \"129deep\".\n+    scripts = [(\"128deep\", CScript([pub1, OP_CHECKSIG])), [(\"129deep\", CScript([pub1, OP_CHECKSIG])), random.choice(PARTNER_MERKLE_FN)]]\n+    # Add 127 nodes on top of that tree, so that \"128deep\" and \"129deep\" end up at their designated depths.\n+    for _ in range(127):\n+        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+    tap = taproot_construct(pub1, scripts)\n+    # Test that spends with a depth of 128 work, but 129 doesn't (even with a tree with weird Merkle branches in it).\n+    add_spender(spenders, \"spendpath/merklelimit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"leaf\": \"129deep\"}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that flipping the negation bit invalidates spends.\n+    add_spender(spenders, \"spendpath/negflag\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"negflag\": lambda ctx: 1 - default_negflag(ctx)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the Merkle branch invalidate it.\n+    add_spender(spenders, \"spendpath/bitflipmerkle\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"merklebranch\": bitflipper(default_merklebranch)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the inner pubkey invalidate it.\n+    add_spender(spenders, \"spendpath/bitflippubkey\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"pubkey_inner\": bitflipper(default_pubkey_inner)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that empty witnesses are invalid.\n+    add_spender(spenders, \"spendpath/emptywit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"witness\": []}, **ERR_EMPTY_WITNESS)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padlongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/trunclongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    scripts = [(\"s\", CScript([pub1, OP_CHECKSIG]))]\n+    tap = taproot_construct(pub2, scripts)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/truncshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block to 1 byte (\"-1 Merkle length\") invalidates it\n+    add_spender(spenders, \"spendpath/trunc1shortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:1]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    # == Test BIP342 edge cases ==\n+\n+    checksigadd_val = random.randrange(17, 100) # Above OP_16 to avoid minimal encoding complaints\n+    checksigadd_arg = CScriptNum(checksigadd_val)\n+    checksigadd_result = CScriptNum(checksigadd_val+1)\n+    OVERSIZE_NUMBER = 2**31\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER))), 6)\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER-1))), 5)\n+\n+    # Various BIP342 features\n+    scripts = [\n+        # 0) drop stack element and OP_CHECKSIG\n+        (\"t0\", CScript([OP_DROP, pub2, OP_CHECKSIG])),\n+        # 1) normal OP_CHECKSIG\n+        (\"t1\", CScript([pub2, OP_CHECKSIG])),\n+        # 2) normal OP_CHECKSIGVERIFY\n+        (\"t2\", CScript([pub2, OP_CHECKSIGVERIFY, OP_1])),\n+        # 3) Hypothetical OP_CHECKMULTISIG script that takes a single sig as input\n+        (\"t3\", CScript([OP_0, OP_SWAP, OP_1, pub2, OP_1, OP_CHECKMULTISIG])),\n+        # 4) Hypothetical OP_CHECKMULTISIGVERIFY script that takes a single sig as input\n+        (\"t4\", CScript([OP_0, OP_SWAP, OP_1, pub2, OP_1, OP_CHECKMULTISIGVERIFY, OP_1])),\n+        # 5) OP_IF script that needs a true input\n+        (\"t5\", CScript([OP_IF, pub2, OP_CHECKSIG, OP_ELSE, OP_RETURN, OP_ENDIF])),\n+        # 6) OP_NOTIF script that needs a true input\n+        (\"t6\", CScript([OP_NOTIF, OP_RETURN, OP_ELSE, pub2, OP_CHECKSIG, OP_ENDIF])),\n+        # 7) OP_CHECKSIG with an empty key\n+        (\"t7\", CScript([OP_0, OP_CHECKSIG])),\n+        # 8) OP_CHECKSIGVERIFY with an empty key\n+        (\"t8\", CScript([OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 9) normal OP_CHECKSIGADD that also ensures return value is correct\n+        (\"t9\", CScript([OP_0, pub2, OP_CHECKSIGADD, OP_1, OP_EQUAL])),\n+        # 10) OP_CHECKSIGADD with empty key\n+        (\"t10\", CScript([OP_0, OP_0, OP_CHECKSIGADD])),\n+        # 11) OP_CHECKSIGADD with missing counter stack element\n+        (\"t11\", CScript([pub2, OP_CHECKSIGADD])),\n+        # 12) OP_CHECKSIG that needs invalid signature\n+        (\"t12\", CScript([pub2, OP_CHECKSIGVERIFY, pub1, OP_CHECKSIG, OP_NOT])),\n+        # 13) OP_CHECKSIG with empty key that needs invalid signature\n+        (\"t13\", CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_CHECKSIG, OP_NOT])),\n+        # 14) OP_CHECKSIGADD that needs invalid signature\n+        (\"t14\", CScript([pub2, OP_CHECKSIGVERIFY, OP_0, pub1, OP_CHECKSIGADD, OP_NOT])),\n+        # 15) OP_CHECKSIGADD with empty key that needs invalid signature\n+        (\"t15\", CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGADD, OP_NOT])),\n+        # 16) OP_CHECKSIG with unknown pubkey type\n+        (\"t16\", CScript([OP_1, OP_CHECKSIG])),\n+        # 17) OP_CHECKSIGADD with unknown pubkey type\n+        (\"t17\", CScript([OP_0, OP_1, OP_CHECKSIGADD])),\n+        # 18) OP_CHECKSIGVERIFY with unknown pubkey type\n+        (\"t18\", CScript([OP_1, OP_CHECKSIGVERIFY, OP_1])),\n+        # 19) script longer than 10000 bytes and over 201 non-push opcodes\n+        (\"t19\", CScript([OP_0, OP_0, OP_2DROP] * 10001 + [pub2, OP_CHECKSIG])),\n+        # 20) OP_CHECKSIGVERIFY with empty key\n+        (\"t20\", CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 21) Script that grows the stack to 1000 elements\n+        (\"t21\", CScript([pub2, OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 999 + [OP_DROP] * 999)),\n+        # 22) Script that grows the stack to 1001 elements\n+        (\"t22\", CScript([pub2, OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 1000 + [OP_DROP] * 1000)),\n+        # 23) Script that expects an input stack of 1000 elements\n+        (\"t23\", CScript([OP_DROP] * 999 + [pub2, OP_CHECKSIG])),\n+        # 24) Script that expects an input stack of 1001 elements\n+        (\"t24\", CScript([OP_DROP] * 1000 + [pub2, OP_CHECKSIG])),\n+        # 25) Script that pushes a MAX_SCRIPT_ELEMENT_SIZE-bytes element\n+        (\"t25\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE), OP_DROP, pub2, OP_CHECKSIG])),\n+        # 26) Script that pushes a (MAX_SCRIPT_ELEMENT_SIZE+1)-bytes element\n+        (\"t26\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, pub2, OP_CHECKSIG])),\n+        # 27) CHECKSIGADD that must fail because numeric argument number is >4 bytes\n+        (\"t27\", CScript([CScriptNum(OVERSIZE_NUMBER), pub2, OP_CHECKSIGADD])),\n+        # 28) Pushes random CScriptNum value, checks OP_CHECKSIGADD result\n+        (\"t28\", CScript([checksigadd_arg, pub2, OP_CHECKSIGADD, checksigadd_result, OP_EQUAL])),\n+        # 29) CHECKSIGADD that succeeds with proper sig because numeric argument number is <=4 bytes\n+        (\"t29\", CScript([CScriptNum(OVERSIZE_NUMBER-1), pub2, OP_CHECKSIGADD])),\n+        # 30) Variant of t1 with \"normal\" 33-byte pubkey\n+        (\"t30\", CScript([b'\\x03' + pub2, OP_CHECKSIG])),\n+        # 31) Variant of t2 with \"normal\" 33-byte pubkey\n+        (\"t31\", CScript([b'\\x02' + pub2, OP_CHECKSIGVERIFY, OP_1])),\n+        # 32) Variant of t28 with \"normal\" 33-byte pubkey\n+        (\"t32\", CScript([checksigadd_arg, b'\\x03' + pub2, OP_CHECKSIGADD, checksigadd_result, OP_EQUAL])),\n+    ]\n+    random.shuffle(scripts)\n+    tap = taproot_construct(pub1, scripts)\n+    common = {\n+        \"hashtype\": hashtype,\n+        \"key\": sec2,\n+        \"tap\": tap,\n+    }\n+    # Test that MAX_SCRIPT_ELEMENT_SIZE byte stack element inputs are valid, but not one more (and 80 bytes is standard but 81 is not).\n+    add_spender(spenders, \"tapscript/inputmaxlimit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE)], failure={\"inputs\": [getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1)]}, **ERR_PUSH_LIMIT)\n+    add_spender(spenders, \"tapscript/input80limit\", leaf=\"t0\", **common, inputs=[getter(\"sign\"), random_bytes(80)])\n+    add_spender(spenders, \"tapscript/input81limit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(81)])\n+    # Test that OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY cause failure, but OP_CHECKSIG and OP_CHECKSIGVERIFY work.\n+    add_spender(spenders, \"tapscript/disabled_checkmultisig\", leaf=\"t1\", **common, **SINGLE_SIG, failure={\"leaf\": \"t3\"}, **ERR_DISABLED_OPCODE)\n+    add_spender(spenders, \"tapscript/disabled_checkmultisigverify\", leaf=\"t2\", **common, **SINGLE_SIG, failure={\"leaf\": \"t4\"}, **ERR_DISABLED_OPCODE)\n+    # Test that OP_IF and OP_NOTIF do not accept non-0x01 as truth value (the MINIMALIF rule is consensus in Tapscript)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x02']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x03']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0001']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0100']}, **ERR_MINIMALIF)\n+    # Test that 1-byte public keys (which are unknown) are acceptable but nonstandard with unrelated signatures, but 0-byte public keys are not valid.\n+    add_spender(spenders, \"tapscript/unkpk/checksig\", leaf=\"t16\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigadd\", leaf=\"t17\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigverify\", leaf=\"t18\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that 33-byte public keys (which are unknown) are acceptable but nonstandard with valid signatures, but normal pubkeys are not valid in that case.\n+    add_spender(spenders, \"tapscript/oldpk/checksig\", leaf=\"t30\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t1\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"tapscript/oldpk/checksigadd\", leaf=\"t31\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t2\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"tapscript/oldpk/checksigverify\", leaf=\"t32\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t28\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    # Test that 0-byte public keys are not acceptable.\n+    add_spender(spenders, \"tapscript/emptypk/checksig\", leaf=\"t1\", **SINGLE_SIG, **common, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigverify\", leaf=\"t2\", **SINGLE_SIG, **common, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigadd\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that OP_CHECKSIGADD results are as expected\n+    add_spender(spenders, \"tapscript/checksigaddresults\", leaf=\"t28\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    add_spender(spenders, \"tapscript/checksigaddoversize\", leaf=\"t29\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    # Test that OP_CHECKSIGADD requires 3 stack elements.\n+    add_spender(spenders, \"tapscript/checksigadd3args\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t11\"}, **ERR_STACK_EMPTY)\n+    # Test that empty signatures do not cause script failure in OP_CHECKSIG and OP_CHECKSIGADD (but do fail with empty pubkey, and do fail OP_CHECKSIGVERIFY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksig\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t13\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/nochecksigverify\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t20\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksigadd\", leaf=\"t14\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t15\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that scripts over 10000 bytes (and over 201 non-push ops) are acceptable.\n+    add_spender(spenders, \"tapscript/no10000limit\", leaf=\"t19\", **SINGLE_SIG, **common)\n+    # Test that a stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000stack\", leaf=\"t21\", **SINGLE_SIG, **common, failure={\"leaf\": \"t22\"}, **ERR_STACK_SIZE)\n+    # Test that an input stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000inputs\", leaf=\"t23\", **common, inputs=[getter(\"sign\")] + [b'' for _ in range(999)], failure={\"leaf\": \"t24\", \"inputs\": [getter(\"sign\")] + [b'' for _ in range(1000)]}, **ERR_STACK_SIZE)\n+    # Test that pushing a MAX_SCRIPT_ELEMENT_SIZE byte stack element is valid, but one longer is not.\n+    add_spender(spenders, \"tapscript/pushmaxlimit\", leaf=\"t25\", **common, **SINGLE_SIG, failure={\"leaf\": \"t26\"}, **ERR_PUSH_LIMIT)\n+\n+    # == Test for sigops ratio limit ==\n+\n+    # Given a number n, and a public key pk, functions that produces a (CScript, sigops). Each script takes as\n+    # input a valid signature with the passed pk followed by a dummy, and will execute sigops signature checks.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467958678",
      "id" : 467958678,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk1ODY3OA==",
      "original_commit_id" : "8692041ef50b36ade662561371c0175a70bd8fec",
      "original_line" : 865,
      "original_position" : 865,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 463589678,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467958678",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467959794"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467959794"
         }
      },
      "author_association" : "MEMBER",
      "body" : "suggestion:\r\n\r\n`\"sighash/keypath_{}\".format(hashtype)`",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-10T14:52:16Z",
      "diff_hunk" : "@@ -0,0 +1,1271 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expreesion for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        _, negated = compute_xonly_pubkey(key)\n+        return tweak_add_privkey(key, tweak, negated)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    tx.vin[idx].scriptSig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    tx.wit.vtxinwit[idx].scriptWitness.stack = flatten(get(ctx, \"witness\"))\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert(tap is None)\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert(script is None)\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            spend(tx, idx, utxos, **conf)\n+        else:\n+            assert(failure is not None)\n+            spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+# Expected error strings\n+ERR_KEYPATH_INVALID_SIG = {\"err_msg\": \"Invalid signature for Taproot key path spending\"}\n+ERR_SCRIPTPATH_INVALID_SIG = {\"err_msg\": \"Signature must be zero for failed CHECK(MULTI)SIG operation\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Extra items left on stack after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    sec = generate_privkey()\n+    pub, _ = compute_xonly_pubkey(sec)\n+    tap = taproot_construct(pub)\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=sec, failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=sec, failure={\"sighash\": bitflipper(default_sighash)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=sec, failure={\"flag_flip_r\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=sec, failure={\"flag_flip_p\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=sec, failure={\"signature\": bitflipper(default_signature)}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+        sec1, sec2 = generate_privkey(), generate_privkey()\n+        pub1, _ = compute_xonly_pubkey(sec1)\n+        pub2, _ = compute_xonly_pubkey(sec2)\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pub1)\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pub2)))]\n+            tap = taproot_construct(pub1, scripts)\n+            add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467959794",
      "id" : 467959794,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk1OTc5NA==",
      "original_commit_id" : "8692041ef50b36ade662561371c0175a70bd8fec",
      "original_line" : 617,
      "original_position" : 617,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 463589678,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467959794",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467960153"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467960153"
         }
      },
      "author_association" : "MEMBER",
      "body" : "suggestion:\r\n\r\n`\"sighash/scriptpath_{}\".format(hashtype)`",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-10T14:52:43Z",
      "diff_hunk" : "@@ -0,0 +1,1271 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expreesion for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        _, negated = compute_xonly_pubkey(key)\n+        return tweak_add_privkey(key, tweak, negated)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    tx.vin[idx].scriptSig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    tx.wit.vtxinwit[idx].scriptWitness.stack = flatten(get(ctx, \"witness\"))\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert(tap is None)\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert(script is None)\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            spend(tx, idx, utxos, **conf)\n+        else:\n+            assert(failure is not None)\n+            spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+# Expected error strings\n+ERR_KEYPATH_INVALID_SIG = {\"err_msg\": \"Invalid signature for Taproot key path spending\"}\n+ERR_SCRIPTPATH_INVALID_SIG = {\"err_msg\": \"Signature must be zero for failed CHECK(MULTI)SIG operation\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Extra items left on stack after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    sec = generate_privkey()\n+    pub, _ = compute_xonly_pubkey(sec)\n+    tap = taproot_construct(pub)\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=sec, failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=sec, failure={\"sighash\": bitflipper(default_sighash)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=sec, failure={\"flag_flip_r\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=sec, failure={\"flag_flip_p\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=sec, failure={\"signature\": bitflipper(default_signature)}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+        sec1, sec2 = generate_privkey(), generate_privkey()\n+        pub1, _ = compute_xonly_pubkey(sec1)\n+        pub2, _ = compute_xonly_pubkey(sec2)\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pub1)\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pub2)))]\n+            tap = taproot_construct(pub1, scripts)\n+            add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"s0\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467960153",
      "id" : 467960153,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk2MDE1Mw==",
      "original_commit_id" : "8692041ef50b36ade662561371c0175a70bd8fec",
      "original_line" : 618,
      "original_position" : 618,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 463589678,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467960153",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467960608"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467960608"
         }
      },
      "author_association" : "MEMBER",
      "body" : "suggestion:\r\n\r\n`\"sighash/keypath_unk_hashtype_{}\".format(invalid_hashtype)`",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-10T14:53:24Z",
      "diff_hunk" : "@@ -0,0 +1,1271 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expreesion for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        _, negated = compute_xonly_pubkey(key)\n+        return tweak_add_privkey(key, tweak, negated)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    tx.vin[idx].scriptSig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    tx.wit.vtxinwit[idx].scriptWitness.stack = flatten(get(ctx, \"witness\"))\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert(tap is None)\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert(script is None)\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            spend(tx, idx, utxos, **conf)\n+        else:\n+            assert(failure is not None)\n+            spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+# Expected error strings\n+ERR_KEYPATH_INVALID_SIG = {\"err_msg\": \"Invalid signature for Taproot key path spending\"}\n+ERR_SCRIPTPATH_INVALID_SIG = {\"err_msg\": \"Signature must be zero for failed CHECK(MULTI)SIG operation\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Extra items left on stack after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    sec = generate_privkey()\n+    pub, _ = compute_xonly_pubkey(sec)\n+    tap = taproot_construct(pub)\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=sec, failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=sec, failure={\"sighash\": bitflipper(default_sighash)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=sec, failure={\"flag_flip_r\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=sec, failure={\"flag_flip_p\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=sec, failure={\"signature\": bitflipper(default_signature)}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+        sec1, sec2 = generate_privkey(), generate_privkey()\n+        pub1, _ = compute_xonly_pubkey(sec1)\n+        pub2, _ = compute_xonly_pubkey(sec2)\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pub1)\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pub2)))]\n+            tap = taproot_construct(pub1, scripts)\n+            add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"s0\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+        # Test OP_CODESEPARATOR impact on sighashing.\n+        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+        common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+        scripts = [\n+            (\"pk_codesep\", CScript(random_checksig_style(pub2) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig\n+            (\"codesep_pk\", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pub2))),  # codesep before checksig\n+            (\"branched_codesep\", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pub1, OP_ELSE, OP_CODESEPARATOR, pub2, OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pub1, scripts)\n+        add_spender(spenders, \"sighash/pk_codesep\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/codesep_pk\", tap=tap, leaf=\"codesep_pk\", key=sec2, codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/left\", tap=tap, leaf=\"branched_codesep\", key=sec1, codeseppos=3, **common, inputs=[getter(\"sign\"), b'\\x01'], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/right\", tap=tap, leaf=\"branched_codesep\", key=sec2, codeseppos=6, **common, inputs=[getter(\"sign\"), b''], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Reusing the scripts above, test that various features affect the sighash.\n+    add_spender(spenders, \"sighash/annex\", tap=tap, leaf=\"pk_codesep\", key=sec2, hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={\"sighash\": override(default_sighash, annex=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/script\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, script_taproot=tap.leaves[\"codesep_pk\"].script)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/leafver\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leafversion=0xc2)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leaf=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, failure={\"sighash\": override(default_sighash, leaf=\"pk_codesep\")}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # Test that invalid hashtypes don't work, both in key path and script path spends\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for invalid_hashtype in range(256):\n+        if invalid_hashtype not in VALID_SIGHASHES_TAPROOT:\n+            add_spender(spenders, \"sighash/keypath_unk_hashtype\", tap=tap, key=sec1, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_KEYPATH_INVALID_SIG)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467960608",
      "id" : 467960608,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk2MDYwOA==",
      "original_commit_id" : "8692041ef50b36ade662561371c0175a70bd8fec",
      "original_line" : 646,
      "original_position" : 646,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 463589678,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467960608",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467960891"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467960891"
         }
      },
      "author_association" : "MEMBER",
      "body" : "suggestion:\r\n\r\n`\"sighash/scriptpath_unk_hashtype_{}\".format(invalid_hashtype)`",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-10T14:53:47Z",
      "diff_hunk" : "@@ -0,0 +1,1271 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expreesion for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        _, negated = compute_xonly_pubkey(key)\n+        return tweak_add_privkey(key, tweak, negated)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    tx.vin[idx].scriptSig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    tx.wit.vtxinwit[idx].scriptWitness.stack = flatten(get(ctx, \"witness\"))\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert(tap is None)\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert(script is None)\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            spend(tx, idx, utxos, **conf)\n+        else:\n+            assert(failure is not None)\n+            spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+# Expected error strings\n+ERR_KEYPATH_INVALID_SIG = {\"err_msg\": \"Invalid signature for Taproot key path spending\"}\n+ERR_SCRIPTPATH_INVALID_SIG = {\"err_msg\": \"Signature must be zero for failed CHECK(MULTI)SIG operation\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Extra items left on stack after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    sec = generate_privkey()\n+    pub, _ = compute_xonly_pubkey(sec)\n+    tap = taproot_construct(pub)\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=sec, failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=sec, failure={\"sighash\": bitflipper(default_sighash)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=sec, failure={\"flag_flip_r\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=sec, failure={\"flag_flip_p\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=sec, failure={\"signature\": bitflipper(default_signature)}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+        sec1, sec2 = generate_privkey(), generate_privkey()\n+        pub1, _ = compute_xonly_pubkey(sec1)\n+        pub2, _ = compute_xonly_pubkey(sec2)\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pub1)\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pub2)))]\n+            tap = taproot_construct(pub1, scripts)\n+            add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"s0\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+        # Test OP_CODESEPARATOR impact on sighashing.\n+        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+        common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+        scripts = [\n+            (\"pk_codesep\", CScript(random_checksig_style(pub2) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig\n+            (\"codesep_pk\", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pub2))),  # codesep before checksig\n+            (\"branched_codesep\", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pub1, OP_ELSE, OP_CODESEPARATOR, pub2, OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pub1, scripts)\n+        add_spender(spenders, \"sighash/pk_codesep\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/codesep_pk\", tap=tap, leaf=\"codesep_pk\", key=sec2, codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/left\", tap=tap, leaf=\"branched_codesep\", key=sec1, codeseppos=3, **common, inputs=[getter(\"sign\"), b'\\x01'], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/right\", tap=tap, leaf=\"branched_codesep\", key=sec2, codeseppos=6, **common, inputs=[getter(\"sign\"), b''], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Reusing the scripts above, test that various features affect the sighash.\n+    add_spender(spenders, \"sighash/annex\", tap=tap, leaf=\"pk_codesep\", key=sec2, hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={\"sighash\": override(default_sighash, annex=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/script\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, script_taproot=tap.leaves[\"codesep_pk\"].script)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/leafver\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leafversion=0xc2)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leaf=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, failure={\"sighash\": override(default_sighash, leaf=\"pk_codesep\")}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # Test that invalid hashtypes don't work, both in key path and script path spends\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for invalid_hashtype in range(256):\n+        if invalid_hashtype not in VALID_SIGHASHES_TAPROOT:\n+            add_spender(spenders, \"sighash/keypath_unk_hashtype\", tap=tap, key=sec1, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath_unk_hashtype\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_SCRIPTPATH_INVALID_SIG)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467960891",
      "id" : 467960891,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk2MDg5MQ==",
      "original_commit_id" : "8692041ef50b36ade662561371c0175a70bd8fec",
      "original_line" : 647,
      "original_position" : 647,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 463589678,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467960891",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467968687"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467968687"
         }
      },
      "author_association" : "MEMBER",
      "body" : "take-or-leave-nit: just do `[b''] * 1001`",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-10T15:04:33Z",
      "diff_hunk" : "@@ -0,0 +1,1271 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expreesion for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        _, negated = compute_xonly_pubkey(key)\n+        return tweak_add_privkey(key, tweak, negated)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    tx.vin[idx].scriptSig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    tx.wit.vtxinwit[idx].scriptWitness.stack = flatten(get(ctx, \"witness\"))\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert(tap is None)\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert(script is None)\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            spend(tx, idx, utxos, **conf)\n+        else:\n+            assert(failure is not None)\n+            spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+# Expected error strings\n+ERR_KEYPATH_INVALID_SIG = {\"err_msg\": \"Invalid signature for Taproot key path spending\"}\n+ERR_SCRIPTPATH_INVALID_SIG = {\"err_msg\": \"Signature must be zero for failed CHECK(MULTI)SIG operation\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Extra items left on stack after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    sec = generate_privkey()\n+    pub, _ = compute_xonly_pubkey(sec)\n+    tap = taproot_construct(pub)\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=sec, failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=sec, failure={\"sighash\": bitflipper(default_sighash)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=sec, failure={\"flag_flip_r\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=sec, failure={\"flag_flip_p\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=sec, failure={\"signature\": bitflipper(default_signature)}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+        sec1, sec2 = generate_privkey(), generate_privkey()\n+        pub1, _ = compute_xonly_pubkey(sec1)\n+        pub2, _ = compute_xonly_pubkey(sec2)\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pub1)\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pub2)))]\n+            tap = taproot_construct(pub1, scripts)\n+            add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"s0\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+        # Test OP_CODESEPARATOR impact on sighashing.\n+        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+        common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+        scripts = [\n+            (\"pk_codesep\", CScript(random_checksig_style(pub2) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig\n+            (\"codesep_pk\", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pub2))),  # codesep before checksig\n+            (\"branched_codesep\", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pub1, OP_ELSE, OP_CODESEPARATOR, pub2, OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pub1, scripts)\n+        add_spender(spenders, \"sighash/pk_codesep\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/codesep_pk\", tap=tap, leaf=\"codesep_pk\", key=sec2, codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/left\", tap=tap, leaf=\"branched_codesep\", key=sec1, codeseppos=3, **common, inputs=[getter(\"sign\"), b'\\x01'], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/right\", tap=tap, leaf=\"branched_codesep\", key=sec2, codeseppos=6, **common, inputs=[getter(\"sign\"), b''], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Reusing the scripts above, test that various features affect the sighash.\n+    add_spender(spenders, \"sighash/annex\", tap=tap, leaf=\"pk_codesep\", key=sec2, hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={\"sighash\": override(default_sighash, annex=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/script\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, script_taproot=tap.leaves[\"codesep_pk\"].script)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/leafver\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leafversion=0xc2)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leaf=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, failure={\"sighash\": override(default_sighash, leaf=\"pk_codesep\")}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # Test that invalid hashtypes don't work, both in key path and script path spends\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for invalid_hashtype in range(256):\n+        if invalid_hashtype not in VALID_SIGHASHES_TAPROOT:\n+            add_spender(spenders, \"sighash/keypath_unk_hashtype\", tap=tap, key=sec1, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath_unk_hashtype\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Test that hashtype 0 cannot have a hashtype byte, and 1 must have one.\n+    add_spender(spenders, \"sighash/hashtype0_byte_keypath\", tap=tap, key=sec1, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_keypath\", tap=tap, key=sec1, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    # Test that hashtype 0 and hashtype 1 cannot be transmuted into each other.\n+    add_spender(spenders, \"sighash/hashtype0to1_keypath\", tap=tap, key=sec1, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0to1_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_keypath\", tap=tap, key=sec1, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # == Test that BIP341 spending only applies to witness version 1, program length 32, no P2SH ==\n+\n+    for p2sh in [False, True]:\n+        for witver in range(1, 17):\n+            for witlen in [20, 31, 32, 33]:\n+                def mutate(spk):\n+                    prog = spk[2:]\n+                    assert(len(prog) == 32)\n+                    if witlen < 32:\n+                        prog = prog[0:witlen]\n+                    elif witlen > 32:\n+                        prog += bytes([0 for _ in range(witlen - 32)])\n+                    return CScript([CScriptOp.encode_op_n(witver), prog])\n+                scripts = [(\"s0\", CScript([pub1, OP_CHECKSIG])), (\"dummy\", CScript([OP_RETURN]))]\n+                tap = taproot_construct(pub2, scripts)\n+                if not p2sh and witver == 1 and witlen == 32:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=sec2, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=sec1, **SINGLE_SIG, failure={\"leaf\": \"dummy\"}, **ERR_OP_RETURN)\n+                else:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=sec2, standard=False)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=sec1, **SINGLE_SIG, standard=False)\n+\n+    # == Test various aspects of BIP341 spending paths ==\n+\n+    # A set of functions that compute the hashing partner in a Merkle tree, designed to exercise\n+    # edge cases. This relies on the taproot_construct feature that a lambda can be passed in\n+    # instead of a subtree, to compute the partner to be hashed with.\n+    PARTNER_MERKLE_FN = [\n+        # Combine with itself\n+        lambda h: h,\n+        # Combine with hash 0\n+        lambda h: bytes([0 for _ in range(32)]),\n+        # Combine with hash 2^256-1\n+        lambda h: bytes([0xff for _ in range(32)]),\n+        # Combine with itself-1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') + 1).to_bytes(32, 'big'),\n+        # Combine with itself-1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') + 1).to_bytes(32, 'little'),\n+        # Combine with random bitflipped version of self.\n+        lambda h: (int.from_bytes(h, 'little') ^ (1 << random.randrange(256))).to_bytes(32, 'little')\n+    ]\n+    # Start with a tree of that has depth 1 for \"128deep\" and depth 2 for \"129deep\".\n+    scripts = [(\"128deep\", CScript([pub1, OP_CHECKSIG])), [(\"129deep\", CScript([pub1, OP_CHECKSIG])), random.choice(PARTNER_MERKLE_FN)]]\n+    # Add 127 nodes on top of that tree, so that \"128deep\" and \"129deep\" end up at their designated depths.\n+    for _ in range(127):\n+        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+    tap = taproot_construct(pub1, scripts)\n+    # Test that spends with a depth of 128 work, but 129 doesn't (even with a tree with weird Merkle branches in it).\n+    add_spender(spenders, \"spendpath/merklelimit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"leaf\": \"129deep\"}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that flipping the negation bit invalidates spends.\n+    add_spender(spenders, \"spendpath/negflag\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"negflag\": lambda ctx: 1 - default_negflag(ctx)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the Merkle branch invalidate it.\n+    add_spender(spenders, \"spendpath/bitflipmerkle\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"merklebranch\": bitflipper(default_merklebranch)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the inner pubkey invalidate it.\n+    add_spender(spenders, \"spendpath/bitflippubkey\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"pubkey_inner\": bitflipper(default_pubkey_inner)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that empty witnesses are invalid.\n+    add_spender(spenders, \"spendpath/emptywit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"witness\": []}, **ERR_EMPTY_WITNESS)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padlongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/trunclongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    scripts = [(\"s\", CScript([pub1, OP_CHECKSIG]))]\n+    tap = taproot_construct(pub2, scripts)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/truncshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block to 1 byte (\"-1 Merkle length\") invalidates it\n+    add_spender(spenders, \"spendpath/trunc1shortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:1]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    # == Test BIP342 edge cases ==\n+\n+    checksigadd_val = random.randrange(17, 100) # Above OP_16 to avoid minimal encoding complaints\n+    checksigadd_arg = CScriptNum(checksigadd_val)\n+    checksigadd_result = CScriptNum(checksigadd_val+1)\n+    OVERSIZE_NUMBER = 2**31\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER))), 6)\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER-1))), 5)\n+\n+    # Various BIP342 features\n+    scripts = [\n+        # 0) drop stack element and OP_CHECKSIG\n+        (\"t0\", CScript([OP_DROP, pub2, OP_CHECKSIG])),\n+        # 1) normal OP_CHECKSIG\n+        (\"t1\", CScript([pub2, OP_CHECKSIG])),\n+        # 2) normal OP_CHECKSIGVERIFY\n+        (\"t2\", CScript([pub2, OP_CHECKSIGVERIFY, OP_1])),\n+        # 3) Hypothetical OP_CHECKMULTISIG script that takes a single sig as input\n+        (\"t3\", CScript([OP_0, OP_SWAP, OP_1, pub2, OP_1, OP_CHECKMULTISIG])),\n+        # 4) Hypothetical OP_CHECKMULTISIGVERIFY script that takes a single sig as input\n+        (\"t4\", CScript([OP_0, OP_SWAP, OP_1, pub2, OP_1, OP_CHECKMULTISIGVERIFY, OP_1])),\n+        # 5) OP_IF script that needs a true input\n+        (\"t5\", CScript([OP_IF, pub2, OP_CHECKSIG, OP_ELSE, OP_RETURN, OP_ENDIF])),\n+        # 6) OP_NOTIF script that needs a true input\n+        (\"t6\", CScript([OP_NOTIF, OP_RETURN, OP_ELSE, pub2, OP_CHECKSIG, OP_ENDIF])),\n+        # 7) OP_CHECKSIG with an empty key\n+        (\"t7\", CScript([OP_0, OP_CHECKSIG])),\n+        # 8) OP_CHECKSIGVERIFY with an empty key\n+        (\"t8\", CScript([OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 9) normal OP_CHECKSIGADD that also ensures return value is correct\n+        (\"t9\", CScript([OP_0, pub2, OP_CHECKSIGADD, OP_1, OP_EQUAL])),\n+        # 10) OP_CHECKSIGADD with empty key\n+        (\"t10\", CScript([OP_0, OP_0, OP_CHECKSIGADD])),\n+        # 11) OP_CHECKSIGADD with missing counter stack element\n+        (\"t11\", CScript([pub2, OP_CHECKSIGADD])),\n+        # 12) OP_CHECKSIG that needs invalid signature\n+        (\"t12\", CScript([pub2, OP_CHECKSIGVERIFY, pub1, OP_CHECKSIG, OP_NOT])),\n+        # 13) OP_CHECKSIG with empty key that needs invalid signature\n+        (\"t13\", CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_CHECKSIG, OP_NOT])),\n+        # 14) OP_CHECKSIGADD that needs invalid signature\n+        (\"t14\", CScript([pub2, OP_CHECKSIGVERIFY, OP_0, pub1, OP_CHECKSIGADD, OP_NOT])),\n+        # 15) OP_CHECKSIGADD with empty key that needs invalid signature\n+        (\"t15\", CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGADD, OP_NOT])),\n+        # 16) OP_CHECKSIG with unknown pubkey type\n+        (\"t16\", CScript([OP_1, OP_CHECKSIG])),\n+        # 17) OP_CHECKSIGADD with unknown pubkey type\n+        (\"t17\", CScript([OP_0, OP_1, OP_CHECKSIGADD])),\n+        # 18) OP_CHECKSIGVERIFY with unknown pubkey type\n+        (\"t18\", CScript([OP_1, OP_CHECKSIGVERIFY, OP_1])),\n+        # 19) script longer than 10000 bytes and over 201 non-push opcodes\n+        (\"t19\", CScript([OP_0, OP_0, OP_2DROP] * 10001 + [pub2, OP_CHECKSIG])),\n+        # 20) OP_CHECKSIGVERIFY with empty key\n+        (\"t20\", CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 21) Script that grows the stack to 1000 elements\n+        (\"t21\", CScript([pub2, OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 999 + [OP_DROP] * 999)),\n+        # 22) Script that grows the stack to 1001 elements\n+        (\"t22\", CScript([pub2, OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 1000 + [OP_DROP] * 1000)),\n+        # 23) Script that expects an input stack of 1000 elements\n+        (\"t23\", CScript([OP_DROP] * 999 + [pub2, OP_CHECKSIG])),\n+        # 24) Script that expects an input stack of 1001 elements\n+        (\"t24\", CScript([OP_DROP] * 1000 + [pub2, OP_CHECKSIG])),\n+        # 25) Script that pushes a MAX_SCRIPT_ELEMENT_SIZE-bytes element\n+        (\"t25\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE), OP_DROP, pub2, OP_CHECKSIG])),\n+        # 26) Script that pushes a (MAX_SCRIPT_ELEMENT_SIZE+1)-bytes element\n+        (\"t26\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, pub2, OP_CHECKSIG])),\n+        # 27) CHECKSIGADD that must fail because numeric argument number is >4 bytes\n+        (\"t27\", CScript([CScriptNum(OVERSIZE_NUMBER), pub2, OP_CHECKSIGADD])),\n+        # 28) Pushes random CScriptNum value, checks OP_CHECKSIGADD result\n+        (\"t28\", CScript([checksigadd_arg, pub2, OP_CHECKSIGADD, checksigadd_result, OP_EQUAL])),\n+        # 29) CHECKSIGADD that succeeds with proper sig because numeric argument number is <=4 bytes\n+        (\"t29\", CScript([CScriptNum(OVERSIZE_NUMBER-1), pub2, OP_CHECKSIGADD])),\n+        # 30) Variant of t1 with \"normal\" 33-byte pubkey\n+        (\"t30\", CScript([b'\\x03' + pub2, OP_CHECKSIG])),\n+        # 31) Variant of t2 with \"normal\" 33-byte pubkey\n+        (\"t31\", CScript([b'\\x02' + pub2, OP_CHECKSIGVERIFY, OP_1])),\n+        # 32) Variant of t28 with \"normal\" 33-byte pubkey\n+        (\"t32\", CScript([checksigadd_arg, b'\\x03' + pub2, OP_CHECKSIGADD, checksigadd_result, OP_EQUAL])),\n+    ]\n+    random.shuffle(scripts)\n+    tap = taproot_construct(pub1, scripts)\n+    common = {\n+        \"hashtype\": hashtype,\n+        \"key\": sec2,\n+        \"tap\": tap,\n+    }\n+    # Test that MAX_SCRIPT_ELEMENT_SIZE byte stack element inputs are valid, but not one more (and 80 bytes is standard but 81 is not).\n+    add_spender(spenders, \"tapscript/inputmaxlimit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE)], failure={\"inputs\": [getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1)]}, **ERR_PUSH_LIMIT)\n+    add_spender(spenders, \"tapscript/input80limit\", leaf=\"t0\", **common, inputs=[getter(\"sign\"), random_bytes(80)])\n+    add_spender(spenders, \"tapscript/input81limit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(81)])\n+    # Test that OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY cause failure, but OP_CHECKSIG and OP_CHECKSIGVERIFY work.\n+    add_spender(spenders, \"tapscript/disabled_checkmultisig\", leaf=\"t1\", **common, **SINGLE_SIG, failure={\"leaf\": \"t3\"}, **ERR_DISABLED_OPCODE)\n+    add_spender(spenders, \"tapscript/disabled_checkmultisigverify\", leaf=\"t2\", **common, **SINGLE_SIG, failure={\"leaf\": \"t4\"}, **ERR_DISABLED_OPCODE)\n+    # Test that OP_IF and OP_NOTIF do not accept non-0x01 as truth value (the MINIMALIF rule is consensus in Tapscript)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x02']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x03']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0001']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0100']}, **ERR_MINIMALIF)\n+    # Test that 1-byte public keys (which are unknown) are acceptable but nonstandard with unrelated signatures, but 0-byte public keys are not valid.\n+    add_spender(spenders, \"tapscript/unkpk/checksig\", leaf=\"t16\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigadd\", leaf=\"t17\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigverify\", leaf=\"t18\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that 33-byte public keys (which are unknown) are acceptable but nonstandard with valid signatures, but normal pubkeys are not valid in that case.\n+    add_spender(spenders, \"tapscript/oldpk/checksig\", leaf=\"t30\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t1\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"tapscript/oldpk/checksigadd\", leaf=\"t31\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t2\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"tapscript/oldpk/checksigverify\", leaf=\"t32\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t28\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    # Test that 0-byte public keys are not acceptable.\n+    add_spender(spenders, \"tapscript/emptypk/checksig\", leaf=\"t1\", **SINGLE_SIG, **common, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigverify\", leaf=\"t2\", **SINGLE_SIG, **common, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigadd\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that OP_CHECKSIGADD results are as expected\n+    add_spender(spenders, \"tapscript/checksigaddresults\", leaf=\"t28\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    add_spender(spenders, \"tapscript/checksigaddoversize\", leaf=\"t29\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    # Test that OP_CHECKSIGADD requires 3 stack elements.\n+    add_spender(spenders, \"tapscript/checksigadd3args\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t11\"}, **ERR_STACK_EMPTY)\n+    # Test that empty signatures do not cause script failure in OP_CHECKSIG and OP_CHECKSIGADD (but do fail with empty pubkey, and do fail OP_CHECKSIGVERIFY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksig\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t13\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/nochecksigverify\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t20\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksigadd\", leaf=\"t14\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t15\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that scripts over 10000 bytes (and over 201 non-push ops) are acceptable.\n+    add_spender(spenders, \"tapscript/no10000limit\", leaf=\"t19\", **SINGLE_SIG, **common)\n+    # Test that a stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000stack\", leaf=\"t21\", **SINGLE_SIG, **common, failure={\"leaf\": \"t22\"}, **ERR_STACK_SIZE)\n+    # Test that an input stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000inputs\", leaf=\"t23\", **common, inputs=[getter(\"sign\")] + [b'' for _ in range(999)], failure={\"leaf\": \"t24\", \"inputs\": [getter(\"sign\")] + [b'' for _ in range(1000)]}, **ERR_STACK_SIZE)\n+    # Test that pushing a MAX_SCRIPT_ELEMENT_SIZE byte stack element is valid, but one longer is not.\n+    add_spender(spenders, \"tapscript/pushmaxlimit\", leaf=\"t25\", **common, **SINGLE_SIG, failure={\"leaf\": \"t26\"}, **ERR_PUSH_LIMIT)\n+\n+    # == Test for sigops ratio limit ==\n+\n+    # Given a number n, and a public key pk, functions that produces a (CScript, sigops). Each script takes as\n+    # input a valid signature with the passed pk followed by a dummy, and will execute sigops signature checks.\n+    SIGOPS_RATIO_SCRIPTS = [\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIG.\n+        lambda n, pk: (CScript([OP_DROP, pk] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGVERIFY.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_0, OP_IF, OP_2DUP, OP_CHECKSIGVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_2, OP_SWAP, OP_CHECKSIGADD, OP_3, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIG.\n+        lambda n, pk: (CScript([random_bytes(220), OP_2DROP, pk, OP_1, OP_NOTIF, OP_2DUP, OP_CHECKSIG, OP_VERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_4, OP_SWAP, OP_CHECKSIGADD, OP_5, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGADD.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_1, OP_IF, OP_ELSE, OP_2DUP, OP_6, OP_SWAP, OP_CHECKSIGADD, OP_7, OP_EQUALVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_8, OP_SWAP, OP_CHECKSIGADD, OP_9, OP_EQUAL]), n + 1),\n+        # n+1 OP_CHECKSIGs, but also one OP_CHECKSIG with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, pk, OP_CHECKSIG, OP_NOT, OP_VERIFY, pk] + [OP_2DUP, OP_CHECKSIG, OP_VERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGADDs and 1 OP_CHECKSIG, but also an OP_CHECKSIGADD with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, OP_10, pk, OP_CHECKSIGADD, OP_10, OP_EQUALVERIFY, pk] + [OP_2DUP, OP_16, OP_SWAP, OP_CHECKSIGADD, b'\\x11', OP_EQUALVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+    ]\n+    for annex in [None, bytes([ANNEX_TAG]) + random_bytes(random.randrange(1000))]:\n+        for hashtype in [SIGHASH_DEFAULT, SIGHASH_ALL]:\n+            for pubkey in [pub2, random_bytes(random.choice([x for x in range(2, 81) if x != 32]))]:\n+                for fn_num, fn in enumerate(SIGOPS_RATIO_SCRIPTS):\n+                    merkledepth = random.randrange(129)\n+                    def predict_sigops_ratio(n, dummy_size):\n+                        script, sigops = fn(n, pubkey)\n+                        # Predict the size of the witness for a given choice of n\n+                        stacklen_size = 1\n+                        sig_size = 64 + (hashtype != SIGHASH_DEFAULT)\n+                        siglen_size = 1\n+                        dummylen_size = 1 + 2 * (dummy_size >= 253)\n+                        script_size = len(script)\n+                        scriptlen_size = 1 + 2 * (script_size >= 253)\n+                        control_size = 33 + 32 * merkledepth\n+                        controllen_size = 1 + 2 * (control_size >= 253)\n+                        annex_size = 0 if annex is None else len(annex)\n+                        annexlen_size = 0 if annex is None else 1 + 2 * (annex_size >= 253)\n+                        witsize = stacklen_size + sig_size + siglen_size + dummy_size + dummylen_size + script_size + scriptlen_size + control_size + controllen_size + annex_size + annexlen_size\n+                        # sigops ratio test\n+                        return witsize + 50 >= 50 * sigops\n+                    # Make sure n is high enough that with empty dummy, the script is not valid\n+                    n = 0\n+                    while predict_sigops_ratio(n, 0):\n+                        n += 1\n+                    # But allow picking a bit higher still\n+                    n += random.randrange(5)\n+                    # Now pick dummy size *just* large enough that the overall construction passes\n+                    dummylen = 0\n+                    while not predict_sigops_ratio(n, dummylen):\n+                        dummylen += 1\n+                    scripts = [(\"s\", fn(n, pubkey)[0])]\n+                    for _ in range(merkledepth):\n+                        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+                    tap = taproot_construct(pub1, scripts)\n+                    standard = annex is None and dummylen <= 80 and len(pubkey) == 32\n+                    add_spender(spenders, \"tapscript/sigopsratio_%i\" % fn_num, tap=tap, leaf=\"s\", annex=annex, hashtype=hashtype, key=sec2, inputs=[getter(\"sign\"), random_bytes(dummylen)], standard=standard, failure={\"inputs\": [getter(\"sign\"), random_bytes(dummylen - 1)]}, **ERR_SIGOPS_RATIO)\n+        # Future leaf versions\n+    for leafver in range(0, 0x100, 2):\n+        if leafver == LEAF_VERSION_TAPSCRIPT or leafver == ANNEX_TAG:\n+            # Skip the defined LEAF_VERSION_TAPSCRIPT, and the ANNEX_TAG which is not usable as leaf version\n+            continue\n+        scripts = [\n+            (\"bare_c0\", CScript([OP_NOP])),\n+            (\"bare_unkver\", CScript([OP_NOP]), leafver),\n+            (\"return_c0\", CScript([OP_RETURN])),\n+            (\"return_unkver\", CScript([OP_RETURN]), leafver),\n+            (\"undecodable_c0\", CScript([OP_PUSHDATA1])),\n+            (\"undecodable_unkver\", CScript([OP_PUSHDATA1]), leafver),\n+            (\"bigpush_c0\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP])),\n+            (\"bigpush_unkver\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP]), leafver),\n+            (\"1001push_c0\", CScript([OP_0] * 1001)),\n+            (\"1001push_unkver\", CScript([OP_0] * 1001), leafver),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pub1, scripts)\n+        add_spender(spenders, \"unkver/bare\", standard=False, tap=tap, leaf=\"bare_unkver\", failure={\"leaf\": \"bare_c0\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"unkver/return\", standard=False, tap=tap, leaf=\"return_unkver\", failure={\"leaf\": \"return_c0\"}, **ERR_OP_RETURN)\n+        add_spender(spenders, \"unkver/undecodable\", standard=False, tap=tap, leaf=\"undecodable_unkver\", failure={\"leaf\": \"undecodable_c0\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"unkver/bigpush\", standard=False, tap=tap, leaf=\"bigpush_unkver\", failure={\"leaf\": \"bigpush_c0\"}, **ERR_PUSH_LIMIT)\n+        add_spender(spenders, \"unkver/1001push\", standard=False, tap=tap, leaf=\"1001push_unkver\", failure={\"leaf\": \"1001push_c0\"}, **ERR_STACK_SIZE)\n+        add_spender(spenders, \"unkver/1001inputs\", standard=False, tap=tap, leaf=\"bare_unkver\", inputs=[b'' for _ in range(1001)], failure={\"leaf\": \"bare_c0\"}, **ERR_STACK_SIZE)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467968687",
      "id" : 467968687,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk2ODY4Nw==",
      "original_commit_id" : "8692041ef50b36ade662561371c0175a70bd8fec",
      "original_line" : 941,
      "original_position" : 941,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 463589678,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467968687",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467970307"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467970307"
         }
      },
      "author_association" : "MEMBER",
      "body" : "take-or-leave-nit: just do `[b''] * 1001`",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-10T15:06:50Z",
      "diff_hunk" : "@@ -0,0 +1,1271 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expreesion for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        _, negated = compute_xonly_pubkey(key)\n+        return tweak_add_privkey(key, tweak, negated)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    tx.vin[idx].scriptSig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    tx.wit.vtxinwit[idx].scriptWitness.stack = flatten(get(ctx, \"witness\"))\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert(tap is None)\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert(script is None)\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            spend(tx, idx, utxos, **conf)\n+        else:\n+            assert(failure is not None)\n+            spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+# Expected error strings\n+ERR_KEYPATH_INVALID_SIG = {\"err_msg\": \"Invalid signature for Taproot key path spending\"}\n+ERR_SCRIPTPATH_INVALID_SIG = {\"err_msg\": \"Signature must be zero for failed CHECK(MULTI)SIG operation\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Extra items left on stack after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    sec = generate_privkey()\n+    pub, _ = compute_xonly_pubkey(sec)\n+    tap = taproot_construct(pub)\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=sec, failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=sec, failure={\"sighash\": bitflipper(default_sighash)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=sec, failure={\"flag_flip_r\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=sec, failure={\"flag_flip_p\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=sec, failure={\"signature\": bitflipper(default_signature)}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+        sec1, sec2 = generate_privkey(), generate_privkey()\n+        pub1, _ = compute_xonly_pubkey(sec1)\n+        pub2, _ = compute_xonly_pubkey(sec2)\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pub1)\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pub2)))]\n+            tap = taproot_construct(pub1, scripts)\n+            add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"s0\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+        # Test OP_CODESEPARATOR impact on sighashing.\n+        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+        common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+        scripts = [\n+            (\"pk_codesep\", CScript(random_checksig_style(pub2) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig\n+            (\"codesep_pk\", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pub2))),  # codesep before checksig\n+            (\"branched_codesep\", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pub1, OP_ELSE, OP_CODESEPARATOR, pub2, OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pub1, scripts)\n+        add_spender(spenders, \"sighash/pk_codesep\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/codesep_pk\", tap=tap, leaf=\"codesep_pk\", key=sec2, codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/left\", tap=tap, leaf=\"branched_codesep\", key=sec1, codeseppos=3, **common, inputs=[getter(\"sign\"), b'\\x01'], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/right\", tap=tap, leaf=\"branched_codesep\", key=sec2, codeseppos=6, **common, inputs=[getter(\"sign\"), b''], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Reusing the scripts above, test that various features affect the sighash.\n+    add_spender(spenders, \"sighash/annex\", tap=tap, leaf=\"pk_codesep\", key=sec2, hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={\"sighash\": override(default_sighash, annex=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/script\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, script_taproot=tap.leaves[\"codesep_pk\"].script)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/leafver\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leafversion=0xc2)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leaf=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, failure={\"sighash\": override(default_sighash, leaf=\"pk_codesep\")}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # Test that invalid hashtypes don't work, both in key path and script path spends\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for invalid_hashtype in range(256):\n+        if invalid_hashtype not in VALID_SIGHASHES_TAPROOT:\n+            add_spender(spenders, \"sighash/keypath_unk_hashtype\", tap=tap, key=sec1, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath_unk_hashtype\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Test that hashtype 0 cannot have a hashtype byte, and 1 must have one.\n+    add_spender(spenders, \"sighash/hashtype0_byte_keypath\", tap=tap, key=sec1, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_keypath\", tap=tap, key=sec1, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    # Test that hashtype 0 and hashtype 1 cannot be transmuted into each other.\n+    add_spender(spenders, \"sighash/hashtype0to1_keypath\", tap=tap, key=sec1, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0to1_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_keypath\", tap=tap, key=sec1, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # == Test that BIP341 spending only applies to witness version 1, program length 32, no P2SH ==\n+\n+    for p2sh in [False, True]:\n+        for witver in range(1, 17):\n+            for witlen in [20, 31, 32, 33]:\n+                def mutate(spk):\n+                    prog = spk[2:]\n+                    assert(len(prog) == 32)\n+                    if witlen < 32:\n+                        prog = prog[0:witlen]\n+                    elif witlen > 32:\n+                        prog += bytes([0 for _ in range(witlen - 32)])\n+                    return CScript([CScriptOp.encode_op_n(witver), prog])\n+                scripts = [(\"s0\", CScript([pub1, OP_CHECKSIG])), (\"dummy\", CScript([OP_RETURN]))]\n+                tap = taproot_construct(pub2, scripts)\n+                if not p2sh and witver == 1 and witlen == 32:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=sec2, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=sec1, **SINGLE_SIG, failure={\"leaf\": \"dummy\"}, **ERR_OP_RETURN)\n+                else:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=sec2, standard=False)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=sec1, **SINGLE_SIG, standard=False)\n+\n+    # == Test various aspects of BIP341 spending paths ==\n+\n+    # A set of functions that compute the hashing partner in a Merkle tree, designed to exercise\n+    # edge cases. This relies on the taproot_construct feature that a lambda can be passed in\n+    # instead of a subtree, to compute the partner to be hashed with.\n+    PARTNER_MERKLE_FN = [\n+        # Combine with itself\n+        lambda h: h,\n+        # Combine with hash 0\n+        lambda h: bytes([0 for _ in range(32)]),\n+        # Combine with hash 2^256-1\n+        lambda h: bytes([0xff for _ in range(32)]),\n+        # Combine with itself-1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') + 1).to_bytes(32, 'big'),\n+        # Combine with itself-1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') + 1).to_bytes(32, 'little'),\n+        # Combine with random bitflipped version of self.\n+        lambda h: (int.from_bytes(h, 'little') ^ (1 << random.randrange(256))).to_bytes(32, 'little')\n+    ]\n+    # Start with a tree of that has depth 1 for \"128deep\" and depth 2 for \"129deep\".\n+    scripts = [(\"128deep\", CScript([pub1, OP_CHECKSIG])), [(\"129deep\", CScript([pub1, OP_CHECKSIG])), random.choice(PARTNER_MERKLE_FN)]]\n+    # Add 127 nodes on top of that tree, so that \"128deep\" and \"129deep\" end up at their designated depths.\n+    for _ in range(127):\n+        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+    tap = taproot_construct(pub1, scripts)\n+    # Test that spends with a depth of 128 work, but 129 doesn't (even with a tree with weird Merkle branches in it).\n+    add_spender(spenders, \"spendpath/merklelimit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"leaf\": \"129deep\"}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that flipping the negation bit invalidates spends.\n+    add_spender(spenders, \"spendpath/negflag\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"negflag\": lambda ctx: 1 - default_negflag(ctx)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the Merkle branch invalidate it.\n+    add_spender(spenders, \"spendpath/bitflipmerkle\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"merklebranch\": bitflipper(default_merklebranch)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the inner pubkey invalidate it.\n+    add_spender(spenders, \"spendpath/bitflippubkey\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"pubkey_inner\": bitflipper(default_pubkey_inner)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that empty witnesses are invalid.\n+    add_spender(spenders, \"spendpath/emptywit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"witness\": []}, **ERR_EMPTY_WITNESS)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padlongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/trunclongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    scripts = [(\"s\", CScript([pub1, OP_CHECKSIG]))]\n+    tap = taproot_construct(pub2, scripts)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/truncshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block to 1 byte (\"-1 Merkle length\") invalidates it\n+    add_spender(spenders, \"spendpath/trunc1shortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:1]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    # == Test BIP342 edge cases ==\n+\n+    checksigadd_val = random.randrange(17, 100) # Above OP_16 to avoid minimal encoding complaints\n+    checksigadd_arg = CScriptNum(checksigadd_val)\n+    checksigadd_result = CScriptNum(checksigadd_val+1)\n+    OVERSIZE_NUMBER = 2**31\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER))), 6)\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER-1))), 5)\n+\n+    # Various BIP342 features\n+    scripts = [\n+        # 0) drop stack element and OP_CHECKSIG\n+        (\"t0\", CScript([OP_DROP, pub2, OP_CHECKSIG])),\n+        # 1) normal OP_CHECKSIG\n+        (\"t1\", CScript([pub2, OP_CHECKSIG])),\n+        # 2) normal OP_CHECKSIGVERIFY\n+        (\"t2\", CScript([pub2, OP_CHECKSIGVERIFY, OP_1])),\n+        # 3) Hypothetical OP_CHECKMULTISIG script that takes a single sig as input\n+        (\"t3\", CScript([OP_0, OP_SWAP, OP_1, pub2, OP_1, OP_CHECKMULTISIG])),\n+        # 4) Hypothetical OP_CHECKMULTISIGVERIFY script that takes a single sig as input\n+        (\"t4\", CScript([OP_0, OP_SWAP, OP_1, pub2, OP_1, OP_CHECKMULTISIGVERIFY, OP_1])),\n+        # 5) OP_IF script that needs a true input\n+        (\"t5\", CScript([OP_IF, pub2, OP_CHECKSIG, OP_ELSE, OP_RETURN, OP_ENDIF])),\n+        # 6) OP_NOTIF script that needs a true input\n+        (\"t6\", CScript([OP_NOTIF, OP_RETURN, OP_ELSE, pub2, OP_CHECKSIG, OP_ENDIF])),\n+        # 7) OP_CHECKSIG with an empty key\n+        (\"t7\", CScript([OP_0, OP_CHECKSIG])),\n+        # 8) OP_CHECKSIGVERIFY with an empty key\n+        (\"t8\", CScript([OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 9) normal OP_CHECKSIGADD that also ensures return value is correct\n+        (\"t9\", CScript([OP_0, pub2, OP_CHECKSIGADD, OP_1, OP_EQUAL])),\n+        # 10) OP_CHECKSIGADD with empty key\n+        (\"t10\", CScript([OP_0, OP_0, OP_CHECKSIGADD])),\n+        # 11) OP_CHECKSIGADD with missing counter stack element\n+        (\"t11\", CScript([pub2, OP_CHECKSIGADD])),\n+        # 12) OP_CHECKSIG that needs invalid signature\n+        (\"t12\", CScript([pub2, OP_CHECKSIGVERIFY, pub1, OP_CHECKSIG, OP_NOT])),\n+        # 13) OP_CHECKSIG with empty key that needs invalid signature\n+        (\"t13\", CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_CHECKSIG, OP_NOT])),\n+        # 14) OP_CHECKSIGADD that needs invalid signature\n+        (\"t14\", CScript([pub2, OP_CHECKSIGVERIFY, OP_0, pub1, OP_CHECKSIGADD, OP_NOT])),\n+        # 15) OP_CHECKSIGADD with empty key that needs invalid signature\n+        (\"t15\", CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGADD, OP_NOT])),\n+        # 16) OP_CHECKSIG with unknown pubkey type\n+        (\"t16\", CScript([OP_1, OP_CHECKSIG])),\n+        # 17) OP_CHECKSIGADD with unknown pubkey type\n+        (\"t17\", CScript([OP_0, OP_1, OP_CHECKSIGADD])),\n+        # 18) OP_CHECKSIGVERIFY with unknown pubkey type\n+        (\"t18\", CScript([OP_1, OP_CHECKSIGVERIFY, OP_1])),\n+        # 19) script longer than 10000 bytes and over 201 non-push opcodes\n+        (\"t19\", CScript([OP_0, OP_0, OP_2DROP] * 10001 + [pub2, OP_CHECKSIG])),\n+        # 20) OP_CHECKSIGVERIFY with empty key\n+        (\"t20\", CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 21) Script that grows the stack to 1000 elements\n+        (\"t21\", CScript([pub2, OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 999 + [OP_DROP] * 999)),\n+        # 22) Script that grows the stack to 1001 elements\n+        (\"t22\", CScript([pub2, OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 1000 + [OP_DROP] * 1000)),\n+        # 23) Script that expects an input stack of 1000 elements\n+        (\"t23\", CScript([OP_DROP] * 999 + [pub2, OP_CHECKSIG])),\n+        # 24) Script that expects an input stack of 1001 elements\n+        (\"t24\", CScript([OP_DROP] * 1000 + [pub2, OP_CHECKSIG])),\n+        # 25) Script that pushes a MAX_SCRIPT_ELEMENT_SIZE-bytes element\n+        (\"t25\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE), OP_DROP, pub2, OP_CHECKSIG])),\n+        # 26) Script that pushes a (MAX_SCRIPT_ELEMENT_SIZE+1)-bytes element\n+        (\"t26\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, pub2, OP_CHECKSIG])),\n+        # 27) CHECKSIGADD that must fail because numeric argument number is >4 bytes\n+        (\"t27\", CScript([CScriptNum(OVERSIZE_NUMBER), pub2, OP_CHECKSIGADD])),\n+        # 28) Pushes random CScriptNum value, checks OP_CHECKSIGADD result\n+        (\"t28\", CScript([checksigadd_arg, pub2, OP_CHECKSIGADD, checksigadd_result, OP_EQUAL])),\n+        # 29) CHECKSIGADD that succeeds with proper sig because numeric argument number is <=4 bytes\n+        (\"t29\", CScript([CScriptNum(OVERSIZE_NUMBER-1), pub2, OP_CHECKSIGADD])),\n+        # 30) Variant of t1 with \"normal\" 33-byte pubkey\n+        (\"t30\", CScript([b'\\x03' + pub2, OP_CHECKSIG])),\n+        # 31) Variant of t2 with \"normal\" 33-byte pubkey\n+        (\"t31\", CScript([b'\\x02' + pub2, OP_CHECKSIGVERIFY, OP_1])),\n+        # 32) Variant of t28 with \"normal\" 33-byte pubkey\n+        (\"t32\", CScript([checksigadd_arg, b'\\x03' + pub2, OP_CHECKSIGADD, checksigadd_result, OP_EQUAL])),\n+    ]\n+    random.shuffle(scripts)\n+    tap = taproot_construct(pub1, scripts)\n+    common = {\n+        \"hashtype\": hashtype,\n+        \"key\": sec2,\n+        \"tap\": tap,\n+    }\n+    # Test that MAX_SCRIPT_ELEMENT_SIZE byte stack element inputs are valid, but not one more (and 80 bytes is standard but 81 is not).\n+    add_spender(spenders, \"tapscript/inputmaxlimit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE)], failure={\"inputs\": [getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1)]}, **ERR_PUSH_LIMIT)\n+    add_spender(spenders, \"tapscript/input80limit\", leaf=\"t0\", **common, inputs=[getter(\"sign\"), random_bytes(80)])\n+    add_spender(spenders, \"tapscript/input81limit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(81)])\n+    # Test that OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY cause failure, but OP_CHECKSIG and OP_CHECKSIGVERIFY work.\n+    add_spender(spenders, \"tapscript/disabled_checkmultisig\", leaf=\"t1\", **common, **SINGLE_SIG, failure={\"leaf\": \"t3\"}, **ERR_DISABLED_OPCODE)\n+    add_spender(spenders, \"tapscript/disabled_checkmultisigverify\", leaf=\"t2\", **common, **SINGLE_SIG, failure={\"leaf\": \"t4\"}, **ERR_DISABLED_OPCODE)\n+    # Test that OP_IF and OP_NOTIF do not accept non-0x01 as truth value (the MINIMALIF rule is consensus in Tapscript)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x02']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x03']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0001']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0100']}, **ERR_MINIMALIF)\n+    # Test that 1-byte public keys (which are unknown) are acceptable but nonstandard with unrelated signatures, but 0-byte public keys are not valid.\n+    add_spender(spenders, \"tapscript/unkpk/checksig\", leaf=\"t16\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigadd\", leaf=\"t17\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigverify\", leaf=\"t18\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that 33-byte public keys (which are unknown) are acceptable but nonstandard with valid signatures, but normal pubkeys are not valid in that case.\n+    add_spender(spenders, \"tapscript/oldpk/checksig\", leaf=\"t30\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t1\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"tapscript/oldpk/checksigadd\", leaf=\"t31\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t2\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"tapscript/oldpk/checksigverify\", leaf=\"t32\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t28\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    # Test that 0-byte public keys are not acceptable.\n+    add_spender(spenders, \"tapscript/emptypk/checksig\", leaf=\"t1\", **SINGLE_SIG, **common, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigverify\", leaf=\"t2\", **SINGLE_SIG, **common, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigadd\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that OP_CHECKSIGADD results are as expected\n+    add_spender(spenders, \"tapscript/checksigaddresults\", leaf=\"t28\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    add_spender(spenders, \"tapscript/checksigaddoversize\", leaf=\"t29\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    # Test that OP_CHECKSIGADD requires 3 stack elements.\n+    add_spender(spenders, \"tapscript/checksigadd3args\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t11\"}, **ERR_STACK_EMPTY)\n+    # Test that empty signatures do not cause script failure in OP_CHECKSIG and OP_CHECKSIGADD (but do fail with empty pubkey, and do fail OP_CHECKSIGVERIFY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksig\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t13\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/nochecksigverify\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t20\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksigadd\", leaf=\"t14\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t15\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that scripts over 10000 bytes (and over 201 non-push ops) are acceptable.\n+    add_spender(spenders, \"tapscript/no10000limit\", leaf=\"t19\", **SINGLE_SIG, **common)\n+    # Test that a stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000stack\", leaf=\"t21\", **SINGLE_SIG, **common, failure={\"leaf\": \"t22\"}, **ERR_STACK_SIZE)\n+    # Test that an input stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000inputs\", leaf=\"t23\", **common, inputs=[getter(\"sign\")] + [b'' for _ in range(999)], failure={\"leaf\": \"t24\", \"inputs\": [getter(\"sign\")] + [b'' for _ in range(1000)]}, **ERR_STACK_SIZE)\n+    # Test that pushing a MAX_SCRIPT_ELEMENT_SIZE byte stack element is valid, but one longer is not.\n+    add_spender(spenders, \"tapscript/pushmaxlimit\", leaf=\"t25\", **common, **SINGLE_SIG, failure={\"leaf\": \"t26\"}, **ERR_PUSH_LIMIT)\n+\n+    # == Test for sigops ratio limit ==\n+\n+    # Given a number n, and a public key pk, functions that produces a (CScript, sigops). Each script takes as\n+    # input a valid signature with the passed pk followed by a dummy, and will execute sigops signature checks.\n+    SIGOPS_RATIO_SCRIPTS = [\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIG.\n+        lambda n, pk: (CScript([OP_DROP, pk] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGVERIFY.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_0, OP_IF, OP_2DUP, OP_CHECKSIGVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_2, OP_SWAP, OP_CHECKSIGADD, OP_3, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIG.\n+        lambda n, pk: (CScript([random_bytes(220), OP_2DROP, pk, OP_1, OP_NOTIF, OP_2DUP, OP_CHECKSIG, OP_VERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_4, OP_SWAP, OP_CHECKSIGADD, OP_5, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGADD.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_1, OP_IF, OP_ELSE, OP_2DUP, OP_6, OP_SWAP, OP_CHECKSIGADD, OP_7, OP_EQUALVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_8, OP_SWAP, OP_CHECKSIGADD, OP_9, OP_EQUAL]), n + 1),\n+        # n+1 OP_CHECKSIGs, but also one OP_CHECKSIG with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, pk, OP_CHECKSIG, OP_NOT, OP_VERIFY, pk] + [OP_2DUP, OP_CHECKSIG, OP_VERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGADDs and 1 OP_CHECKSIG, but also an OP_CHECKSIGADD with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, OP_10, pk, OP_CHECKSIGADD, OP_10, OP_EQUALVERIFY, pk] + [OP_2DUP, OP_16, OP_SWAP, OP_CHECKSIGADD, b'\\x11', OP_EQUALVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+    ]\n+    for annex in [None, bytes([ANNEX_TAG]) + random_bytes(random.randrange(1000))]:\n+        for hashtype in [SIGHASH_DEFAULT, SIGHASH_ALL]:\n+            for pubkey in [pub2, random_bytes(random.choice([x for x in range(2, 81) if x != 32]))]:\n+                for fn_num, fn in enumerate(SIGOPS_RATIO_SCRIPTS):\n+                    merkledepth = random.randrange(129)\n+                    def predict_sigops_ratio(n, dummy_size):\n+                        script, sigops = fn(n, pubkey)\n+                        # Predict the size of the witness for a given choice of n\n+                        stacklen_size = 1\n+                        sig_size = 64 + (hashtype != SIGHASH_DEFAULT)\n+                        siglen_size = 1\n+                        dummylen_size = 1 + 2 * (dummy_size >= 253)\n+                        script_size = len(script)\n+                        scriptlen_size = 1 + 2 * (script_size >= 253)\n+                        control_size = 33 + 32 * merkledepth\n+                        controllen_size = 1 + 2 * (control_size >= 253)\n+                        annex_size = 0 if annex is None else len(annex)\n+                        annexlen_size = 0 if annex is None else 1 + 2 * (annex_size >= 253)\n+                        witsize = stacklen_size + sig_size + siglen_size + dummy_size + dummylen_size + script_size + scriptlen_size + control_size + controllen_size + annex_size + annexlen_size\n+                        # sigops ratio test\n+                        return witsize + 50 >= 50 * sigops\n+                    # Make sure n is high enough that with empty dummy, the script is not valid\n+                    n = 0\n+                    while predict_sigops_ratio(n, 0):\n+                        n += 1\n+                    # But allow picking a bit higher still\n+                    n += random.randrange(5)\n+                    # Now pick dummy size *just* large enough that the overall construction passes\n+                    dummylen = 0\n+                    while not predict_sigops_ratio(n, dummylen):\n+                        dummylen += 1\n+                    scripts = [(\"s\", fn(n, pubkey)[0])]\n+                    for _ in range(merkledepth):\n+                        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+                    tap = taproot_construct(pub1, scripts)\n+                    standard = annex is None and dummylen <= 80 and len(pubkey) == 32\n+                    add_spender(spenders, \"tapscript/sigopsratio_%i\" % fn_num, tap=tap, leaf=\"s\", annex=annex, hashtype=hashtype, key=sec2, inputs=[getter(\"sign\"), random_bytes(dummylen)], standard=standard, failure={\"inputs\": [getter(\"sign\"), random_bytes(dummylen - 1)]}, **ERR_SIGOPS_RATIO)\n+        # Future leaf versions\n+    for leafver in range(0, 0x100, 2):\n+        if leafver == LEAF_VERSION_TAPSCRIPT or leafver == ANNEX_TAG:\n+            # Skip the defined LEAF_VERSION_TAPSCRIPT, and the ANNEX_TAG which is not usable as leaf version\n+            continue\n+        scripts = [\n+            (\"bare_c0\", CScript([OP_NOP])),\n+            (\"bare_unkver\", CScript([OP_NOP]), leafver),\n+            (\"return_c0\", CScript([OP_RETURN])),\n+            (\"return_unkver\", CScript([OP_RETURN]), leafver),\n+            (\"undecodable_c0\", CScript([OP_PUSHDATA1])),\n+            (\"undecodable_unkver\", CScript([OP_PUSHDATA1]), leafver),\n+            (\"bigpush_c0\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP])),\n+            (\"bigpush_unkver\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP]), leafver),\n+            (\"1001push_c0\", CScript([OP_0] * 1001)),\n+            (\"1001push_unkver\", CScript([OP_0] * 1001), leafver),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pub1, scripts)\n+        add_spender(spenders, \"unkver/bare\", standard=False, tap=tap, leaf=\"bare_unkver\", failure={\"leaf\": \"bare_c0\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"unkver/return\", standard=False, tap=tap, leaf=\"return_unkver\", failure={\"leaf\": \"return_c0\"}, **ERR_OP_RETURN)\n+        add_spender(spenders, \"unkver/undecodable\", standard=False, tap=tap, leaf=\"undecodable_unkver\", failure={\"leaf\": \"undecodable_c0\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"unkver/bigpush\", standard=False, tap=tap, leaf=\"bigpush_unkver\", failure={\"leaf\": \"bigpush_c0\"}, **ERR_PUSH_LIMIT)\n+        add_spender(spenders, \"unkver/1001push\", standard=False, tap=tap, leaf=\"1001push_unkver\", failure={\"leaf\": \"1001push_c0\"}, **ERR_STACK_SIZE)\n+        add_spender(spenders, \"unkver/1001inputs\", standard=False, tap=tap, leaf=\"bare_unkver\", inputs=[b'' for _ in range(1001)], failure={\"leaf\": \"bare_c0\"}, **ERR_STACK_SIZE)\n+\n+    # OP_SUCCESSx tests.\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for opval in range(76, 0x100):\n+        opcode = CScriptOp(opval)\n+        if not is_op_success(opcode):\n+            continue\n+        scripts = [\n+            (\"bare_success\", CScript([opcode])),\n+            (\"bare_nop\", CScript([OP_NOP])),\n+            (\"unexecif_success\", CScript([OP_0, OP_IF, opcode, OP_ENDIF])),\n+            (\"unexecif_nop\", CScript([OP_0, OP_IF, OP_NOP, OP_ENDIF])),\n+            (\"return_success\", CScript([OP_RETURN, opcode])),\n+            (\"return_nop\", CScript([OP_RETURN, OP_NOP])),\n+            (\"undecodable_success\", CScript([opcode, OP_PUSHDATA1])),\n+            (\"undecodable_nop\", CScript([OP_NOP, OP_PUSHDATA1])),\n+            (\"undecodable_bypassed_success\", CScript([OP_PUSHDATA1, OP_2, opcode])),\n+            (\"bigpush_success\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, opcode])),\n+            (\"bigpush_nop\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, OP_NOP])),\n+            (\"1001push_success\", CScript([OP_0] * 1001 + [opcode])),\n+            (\"1001push_nop\", CScript([OP_0] * 1001 + [OP_NOP])),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pub1, scripts)\n+        add_spender(spenders, \"opsuccess/bare\", standard=False, tap=tap, leaf=\"bare_success\", failure={\"leaf\": \"bare_nop\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"opsuccess/exexecif\", standard=False, tap=tap, leaf=\"unexecif_success\", failure={\"leaf\": \"unexecif_nop\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"opsuccess/return\", standard=False, tap=tap, leaf=\"return_success\", failure={\"leaf\": \"return_nop\"}, **ERR_OP_RETURN)\n+        add_spender(spenders, \"opsuccess/undecodable\", standard=False, tap=tap, leaf=\"undecodable_success\", failure={\"leaf\": \"undecodable_nop\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"opsuccess/undecodable_bypass\", standard=False, tap=tap, leaf=\"undecodable_success\", failure={\"leaf\": \"undecodable_bypassed_success\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"opsuccess/bigpush\", standard=False, tap=tap, leaf=\"bigpush_success\", failure={\"leaf\": \"bigpush_nop\"}, **ERR_PUSH_LIMIT)\n+        add_spender(spenders, \"opsuccess/1001push\", standard=False, tap=tap, leaf=\"1001push_success\", failure={\"leaf\": \"1001push_nop\"}, **ERR_STACK_SIZE)\n+        add_spender(spenders, \"opsuccess/1001inputs\", standard=False, tap=tap, leaf=\"bare_success\", inputs=[b'' for _ in range(1001)], failure={\"leaf\": \"bare_nop\"}, **ERR_STACK_SIZE)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467970307",
      "id" : 467970307,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk3MDMwNw==",
      "original_commit_id" : "8692041ef50b36ade662561371c0175a70bd8fec",
      "original_line" : 973,
      "original_position" : 973,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 463589678,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467970307",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467972427"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467972427"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nice script for this check",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-10T15:09:54Z",
      "diff_hunk" : "@@ -0,0 +1,1271 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expreesion for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        _, negated = compute_xonly_pubkey(key)\n+        return tweak_add_privkey(key, tweak, negated)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    tx.vin[idx].scriptSig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    tx.wit.vtxinwit[idx].scriptWitness.stack = flatten(get(ctx, \"witness\"))\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert(tap is None)\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert(script is None)\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            spend(tx, idx, utxos, **conf)\n+        else:\n+            assert(failure is not None)\n+            spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+# Expected error strings\n+ERR_KEYPATH_INVALID_SIG = {\"err_msg\": \"Invalid signature for Taproot key path spending\"}\n+ERR_SCRIPTPATH_INVALID_SIG = {\"err_msg\": \"Signature must be zero for failed CHECK(MULTI)SIG operation\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Extra items left on stack after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    sec = generate_privkey()\n+    pub, _ = compute_xonly_pubkey(sec)\n+    tap = taproot_construct(pub)\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=sec, failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=sec, failure={\"sighash\": bitflipper(default_sighash)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=sec, failure={\"flag_flip_r\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=sec, failure={\"flag_flip_p\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=sec, failure={\"signature\": bitflipper(default_signature)}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+        sec1, sec2 = generate_privkey(), generate_privkey()\n+        pub1, _ = compute_xonly_pubkey(sec1)\n+        pub2, _ = compute_xonly_pubkey(sec2)\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pub1)\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pub2)))]\n+            tap = taproot_construct(pub1, scripts)\n+            add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"s0\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+        # Test OP_CODESEPARATOR impact on sighashing.\n+        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+        common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+        scripts = [\n+            (\"pk_codesep\", CScript(random_checksig_style(pub2) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig\n+            (\"codesep_pk\", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pub2))),  # codesep before checksig\n+            (\"branched_codesep\", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pub1, OP_ELSE, OP_CODESEPARATOR, pub2, OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pub1, scripts)\n+        add_spender(spenders, \"sighash/pk_codesep\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/codesep_pk\", tap=tap, leaf=\"codesep_pk\", key=sec2, codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/left\", tap=tap, leaf=\"branched_codesep\", key=sec1, codeseppos=3, **common, inputs=[getter(\"sign\"), b'\\x01'], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/right\", tap=tap, leaf=\"branched_codesep\", key=sec2, codeseppos=6, **common, inputs=[getter(\"sign\"), b''], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Reusing the scripts above, test that various features affect the sighash.\n+    add_spender(spenders, \"sighash/annex\", tap=tap, leaf=\"pk_codesep\", key=sec2, hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={\"sighash\": override(default_sighash, annex=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/script\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, script_taproot=tap.leaves[\"codesep_pk\"].script)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/leafver\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leafversion=0xc2)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leaf=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, failure={\"sighash\": override(default_sighash, leaf=\"pk_codesep\")}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # Test that invalid hashtypes don't work, both in key path and script path spends\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for invalid_hashtype in range(256):\n+        if invalid_hashtype not in VALID_SIGHASHES_TAPROOT:\n+            add_spender(spenders, \"sighash/keypath_unk_hashtype\", tap=tap, key=sec1, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath_unk_hashtype\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Test that hashtype 0 cannot have a hashtype byte, and 1 must have one.\n+    add_spender(spenders, \"sighash/hashtype0_byte_keypath\", tap=tap, key=sec1, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_keypath\", tap=tap, key=sec1, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    # Test that hashtype 0 and hashtype 1 cannot be transmuted into each other.\n+    add_spender(spenders, \"sighash/hashtype0to1_keypath\", tap=tap, key=sec1, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0to1_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_keypath\", tap=tap, key=sec1, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # == Test that BIP341 spending only applies to witness version 1, program length 32, no P2SH ==\n+\n+    for p2sh in [False, True]:\n+        for witver in range(1, 17):\n+            for witlen in [20, 31, 32, 33]:\n+                def mutate(spk):\n+                    prog = spk[2:]\n+                    assert(len(prog) == 32)\n+                    if witlen < 32:\n+                        prog = prog[0:witlen]\n+                    elif witlen > 32:\n+                        prog += bytes([0 for _ in range(witlen - 32)])\n+                    return CScript([CScriptOp.encode_op_n(witver), prog])\n+                scripts = [(\"s0\", CScript([pub1, OP_CHECKSIG])), (\"dummy\", CScript([OP_RETURN]))]\n+                tap = taproot_construct(pub2, scripts)\n+                if not p2sh and witver == 1 and witlen == 32:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=sec2, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=sec1, **SINGLE_SIG, failure={\"leaf\": \"dummy\"}, **ERR_OP_RETURN)\n+                else:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=sec2, standard=False)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=sec1, **SINGLE_SIG, standard=False)\n+\n+    # == Test various aspects of BIP341 spending paths ==\n+\n+    # A set of functions that compute the hashing partner in a Merkle tree, designed to exercise\n+    # edge cases. This relies on the taproot_construct feature that a lambda can be passed in\n+    # instead of a subtree, to compute the partner to be hashed with.\n+    PARTNER_MERKLE_FN = [\n+        # Combine with itself\n+        lambda h: h,\n+        # Combine with hash 0\n+        lambda h: bytes([0 for _ in range(32)]),\n+        # Combine with hash 2^256-1\n+        lambda h: bytes([0xff for _ in range(32)]),\n+        # Combine with itself-1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') + 1).to_bytes(32, 'big'),\n+        # Combine with itself-1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') + 1).to_bytes(32, 'little'),\n+        # Combine with random bitflipped version of self.\n+        lambda h: (int.from_bytes(h, 'little') ^ (1 << random.randrange(256))).to_bytes(32, 'little')\n+    ]\n+    # Start with a tree of that has depth 1 for \"128deep\" and depth 2 for \"129deep\".\n+    scripts = [(\"128deep\", CScript([pub1, OP_CHECKSIG])), [(\"129deep\", CScript([pub1, OP_CHECKSIG])), random.choice(PARTNER_MERKLE_FN)]]\n+    # Add 127 nodes on top of that tree, so that \"128deep\" and \"129deep\" end up at their designated depths.\n+    for _ in range(127):\n+        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+    tap = taproot_construct(pub1, scripts)\n+    # Test that spends with a depth of 128 work, but 129 doesn't (even with a tree with weird Merkle branches in it).\n+    add_spender(spenders, \"spendpath/merklelimit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"leaf\": \"129deep\"}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that flipping the negation bit invalidates spends.\n+    add_spender(spenders, \"spendpath/negflag\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"negflag\": lambda ctx: 1 - default_negflag(ctx)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the Merkle branch invalidate it.\n+    add_spender(spenders, \"spendpath/bitflipmerkle\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"merklebranch\": bitflipper(default_merklebranch)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the inner pubkey invalidate it.\n+    add_spender(spenders, \"spendpath/bitflippubkey\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"pubkey_inner\": bitflipper(default_pubkey_inner)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that empty witnesses are invalid.\n+    add_spender(spenders, \"spendpath/emptywit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"witness\": []}, **ERR_EMPTY_WITNESS)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padlongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/trunclongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    scripts = [(\"s\", CScript([pub1, OP_CHECKSIG]))]\n+    tap = taproot_construct(pub2, scripts)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/truncshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block to 1 byte (\"-1 Merkle length\") invalidates it\n+    add_spender(spenders, \"spendpath/trunc1shortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:1]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    # == Test BIP342 edge cases ==\n+\n+    checksigadd_val = random.randrange(17, 100) # Above OP_16 to avoid minimal encoding complaints\n+    checksigadd_arg = CScriptNum(checksigadd_val)\n+    checksigadd_result = CScriptNum(checksigadd_val+1)\n+    OVERSIZE_NUMBER = 2**31\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER))), 6)\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER-1))), 5)\n+\n+    # Various BIP342 features\n+    scripts = [\n+        # 0) drop stack element and OP_CHECKSIG\n+        (\"t0\", CScript([OP_DROP, pub2, OP_CHECKSIG])),\n+        # 1) normal OP_CHECKSIG\n+        (\"t1\", CScript([pub2, OP_CHECKSIG])),\n+        # 2) normal OP_CHECKSIGVERIFY\n+        (\"t2\", CScript([pub2, OP_CHECKSIGVERIFY, OP_1])),\n+        # 3) Hypothetical OP_CHECKMULTISIG script that takes a single sig as input\n+        (\"t3\", CScript([OP_0, OP_SWAP, OP_1, pub2, OP_1, OP_CHECKMULTISIG])),\n+        # 4) Hypothetical OP_CHECKMULTISIGVERIFY script that takes a single sig as input\n+        (\"t4\", CScript([OP_0, OP_SWAP, OP_1, pub2, OP_1, OP_CHECKMULTISIGVERIFY, OP_1])),\n+        # 5) OP_IF script that needs a true input\n+        (\"t5\", CScript([OP_IF, pub2, OP_CHECKSIG, OP_ELSE, OP_RETURN, OP_ENDIF])),\n+        # 6) OP_NOTIF script that needs a true input\n+        (\"t6\", CScript([OP_NOTIF, OP_RETURN, OP_ELSE, pub2, OP_CHECKSIG, OP_ENDIF])),\n+        # 7) OP_CHECKSIG with an empty key\n+        (\"t7\", CScript([OP_0, OP_CHECKSIG])),\n+        # 8) OP_CHECKSIGVERIFY with an empty key\n+        (\"t8\", CScript([OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 9) normal OP_CHECKSIGADD that also ensures return value is correct\n+        (\"t9\", CScript([OP_0, pub2, OP_CHECKSIGADD, OP_1, OP_EQUAL])),\n+        # 10) OP_CHECKSIGADD with empty key\n+        (\"t10\", CScript([OP_0, OP_0, OP_CHECKSIGADD])),\n+        # 11) OP_CHECKSIGADD with missing counter stack element\n+        (\"t11\", CScript([pub2, OP_CHECKSIGADD])),\n+        # 12) OP_CHECKSIG that needs invalid signature\n+        (\"t12\", CScript([pub2, OP_CHECKSIGVERIFY, pub1, OP_CHECKSIG, OP_NOT])),\n+        # 13) OP_CHECKSIG with empty key that needs invalid signature\n+        (\"t13\", CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_CHECKSIG, OP_NOT])),\n+        # 14) OP_CHECKSIGADD that needs invalid signature\n+        (\"t14\", CScript([pub2, OP_CHECKSIGVERIFY, OP_0, pub1, OP_CHECKSIGADD, OP_NOT])),\n+        # 15) OP_CHECKSIGADD with empty key that needs invalid signature\n+        (\"t15\", CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGADD, OP_NOT])),\n+        # 16) OP_CHECKSIG with unknown pubkey type\n+        (\"t16\", CScript([OP_1, OP_CHECKSIG])),\n+        # 17) OP_CHECKSIGADD with unknown pubkey type\n+        (\"t17\", CScript([OP_0, OP_1, OP_CHECKSIGADD])),\n+        # 18) OP_CHECKSIGVERIFY with unknown pubkey type\n+        (\"t18\", CScript([OP_1, OP_CHECKSIGVERIFY, OP_1])),\n+        # 19) script longer than 10000 bytes and over 201 non-push opcodes\n+        (\"t19\", CScript([OP_0, OP_0, OP_2DROP] * 10001 + [pub2, OP_CHECKSIG])),\n+        # 20) OP_CHECKSIGVERIFY with empty key\n+        (\"t20\", CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 21) Script that grows the stack to 1000 elements\n+        (\"t21\", CScript([pub2, OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 999 + [OP_DROP] * 999)),\n+        # 22) Script that grows the stack to 1001 elements\n+        (\"t22\", CScript([pub2, OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 1000 + [OP_DROP] * 1000)),\n+        # 23) Script that expects an input stack of 1000 elements\n+        (\"t23\", CScript([OP_DROP] * 999 + [pub2, OP_CHECKSIG])),\n+        # 24) Script that expects an input stack of 1001 elements\n+        (\"t24\", CScript([OP_DROP] * 1000 + [pub2, OP_CHECKSIG])),\n+        # 25) Script that pushes a MAX_SCRIPT_ELEMENT_SIZE-bytes element\n+        (\"t25\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE), OP_DROP, pub2, OP_CHECKSIG])),\n+        # 26) Script that pushes a (MAX_SCRIPT_ELEMENT_SIZE+1)-bytes element\n+        (\"t26\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, pub2, OP_CHECKSIG])),\n+        # 27) CHECKSIGADD that must fail because numeric argument number is >4 bytes\n+        (\"t27\", CScript([CScriptNum(OVERSIZE_NUMBER), pub2, OP_CHECKSIGADD])),\n+        # 28) Pushes random CScriptNum value, checks OP_CHECKSIGADD result\n+        (\"t28\", CScript([checksigadd_arg, pub2, OP_CHECKSIGADD, checksigadd_result, OP_EQUAL])),\n+        # 29) CHECKSIGADD that succeeds with proper sig because numeric argument number is <=4 bytes\n+        (\"t29\", CScript([CScriptNum(OVERSIZE_NUMBER-1), pub2, OP_CHECKSIGADD])),\n+        # 30) Variant of t1 with \"normal\" 33-byte pubkey\n+        (\"t30\", CScript([b'\\x03' + pub2, OP_CHECKSIG])),\n+        # 31) Variant of t2 with \"normal\" 33-byte pubkey\n+        (\"t31\", CScript([b'\\x02' + pub2, OP_CHECKSIGVERIFY, OP_1])),\n+        # 32) Variant of t28 with \"normal\" 33-byte pubkey\n+        (\"t32\", CScript([checksigadd_arg, b'\\x03' + pub2, OP_CHECKSIGADD, checksigadd_result, OP_EQUAL])),\n+    ]\n+    random.shuffle(scripts)\n+    tap = taproot_construct(pub1, scripts)\n+    common = {\n+        \"hashtype\": hashtype,\n+        \"key\": sec2,\n+        \"tap\": tap,\n+    }\n+    # Test that MAX_SCRIPT_ELEMENT_SIZE byte stack element inputs are valid, but not one more (and 80 bytes is standard but 81 is not).\n+    add_spender(spenders, \"tapscript/inputmaxlimit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE)], failure={\"inputs\": [getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1)]}, **ERR_PUSH_LIMIT)\n+    add_spender(spenders, \"tapscript/input80limit\", leaf=\"t0\", **common, inputs=[getter(\"sign\"), random_bytes(80)])\n+    add_spender(spenders, \"tapscript/input81limit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(81)])\n+    # Test that OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY cause failure, but OP_CHECKSIG and OP_CHECKSIGVERIFY work.\n+    add_spender(spenders, \"tapscript/disabled_checkmultisig\", leaf=\"t1\", **common, **SINGLE_SIG, failure={\"leaf\": \"t3\"}, **ERR_DISABLED_OPCODE)\n+    add_spender(spenders, \"tapscript/disabled_checkmultisigverify\", leaf=\"t2\", **common, **SINGLE_SIG, failure={\"leaf\": \"t4\"}, **ERR_DISABLED_OPCODE)\n+    # Test that OP_IF and OP_NOTIF do not accept non-0x01 as truth value (the MINIMALIF rule is consensus in Tapscript)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x02']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x03']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0001']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0100']}, **ERR_MINIMALIF)\n+    # Test that 1-byte public keys (which are unknown) are acceptable but nonstandard with unrelated signatures, but 0-byte public keys are not valid.\n+    add_spender(spenders, \"tapscript/unkpk/checksig\", leaf=\"t16\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigadd\", leaf=\"t17\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigverify\", leaf=\"t18\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that 33-byte public keys (which are unknown) are acceptable but nonstandard with valid signatures, but normal pubkeys are not valid in that case.\n+    add_spender(spenders, \"tapscript/oldpk/checksig\", leaf=\"t30\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t1\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"tapscript/oldpk/checksigadd\", leaf=\"t31\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t2\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"tapscript/oldpk/checksigverify\", leaf=\"t32\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t28\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    # Test that 0-byte public keys are not acceptable.\n+    add_spender(spenders, \"tapscript/emptypk/checksig\", leaf=\"t1\", **SINGLE_SIG, **common, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigverify\", leaf=\"t2\", **SINGLE_SIG, **common, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigadd\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that OP_CHECKSIGADD results are as expected\n+    add_spender(spenders, \"tapscript/checksigaddresults\", leaf=\"t28\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    add_spender(spenders, \"tapscript/checksigaddoversize\", leaf=\"t29\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    # Test that OP_CHECKSIGADD requires 3 stack elements.\n+    add_spender(spenders, \"tapscript/checksigadd3args\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t11\"}, **ERR_STACK_EMPTY)\n+    # Test that empty signatures do not cause script failure in OP_CHECKSIG and OP_CHECKSIGADD (but do fail with empty pubkey, and do fail OP_CHECKSIGVERIFY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksig\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t13\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/nochecksigverify\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t20\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksigadd\", leaf=\"t14\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t15\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that scripts over 10000 bytes (and over 201 non-push ops) are acceptable.\n+    add_spender(spenders, \"tapscript/no10000limit\", leaf=\"t19\", **SINGLE_SIG, **common)\n+    # Test that a stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000stack\", leaf=\"t21\", **SINGLE_SIG, **common, failure={\"leaf\": \"t22\"}, **ERR_STACK_SIZE)\n+    # Test that an input stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000inputs\", leaf=\"t23\", **common, inputs=[getter(\"sign\")] + [b'' for _ in range(999)], failure={\"leaf\": \"t24\", \"inputs\": [getter(\"sign\")] + [b'' for _ in range(1000)]}, **ERR_STACK_SIZE)\n+    # Test that pushing a MAX_SCRIPT_ELEMENT_SIZE byte stack element is valid, but one longer is not.\n+    add_spender(spenders, \"tapscript/pushmaxlimit\", leaf=\"t25\", **common, **SINGLE_SIG, failure={\"leaf\": \"t26\"}, **ERR_PUSH_LIMIT)\n+\n+    # == Test for sigops ratio limit ==\n+\n+    # Given a number n, and a public key pk, functions that produces a (CScript, sigops). Each script takes as\n+    # input a valid signature with the passed pk followed by a dummy, and will execute sigops signature checks.\n+    SIGOPS_RATIO_SCRIPTS = [\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIG.\n+        lambda n, pk: (CScript([OP_DROP, pk] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGVERIFY.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_0, OP_IF, OP_2DUP, OP_CHECKSIGVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_2, OP_SWAP, OP_CHECKSIGADD, OP_3, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIG.\n+        lambda n, pk: (CScript([random_bytes(220), OP_2DROP, pk, OP_1, OP_NOTIF, OP_2DUP, OP_CHECKSIG, OP_VERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_4, OP_SWAP, OP_CHECKSIGADD, OP_5, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGADD.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_1, OP_IF, OP_ELSE, OP_2DUP, OP_6, OP_SWAP, OP_CHECKSIGADD, OP_7, OP_EQUALVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_8, OP_SWAP, OP_CHECKSIGADD, OP_9, OP_EQUAL]), n + 1),\n+        # n+1 OP_CHECKSIGs, but also one OP_CHECKSIG with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, pk, OP_CHECKSIG, OP_NOT, OP_VERIFY, pk] + [OP_2DUP, OP_CHECKSIG, OP_VERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGADDs and 1 OP_CHECKSIG, but also an OP_CHECKSIGADD with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, OP_10, pk, OP_CHECKSIGADD, OP_10, OP_EQUALVERIFY, pk] + [OP_2DUP, OP_16, OP_SWAP, OP_CHECKSIGADD, b'\\x11', OP_EQUALVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+    ]\n+    for annex in [None, bytes([ANNEX_TAG]) + random_bytes(random.randrange(1000))]:\n+        for hashtype in [SIGHASH_DEFAULT, SIGHASH_ALL]:\n+            for pubkey in [pub2, random_bytes(random.choice([x for x in range(2, 81) if x != 32]))]:\n+                for fn_num, fn in enumerate(SIGOPS_RATIO_SCRIPTS):\n+                    merkledepth = random.randrange(129)\n+                    def predict_sigops_ratio(n, dummy_size):\n+                        script, sigops = fn(n, pubkey)\n+                        # Predict the size of the witness for a given choice of n\n+                        stacklen_size = 1\n+                        sig_size = 64 + (hashtype != SIGHASH_DEFAULT)\n+                        siglen_size = 1\n+                        dummylen_size = 1 + 2 * (dummy_size >= 253)\n+                        script_size = len(script)\n+                        scriptlen_size = 1 + 2 * (script_size >= 253)\n+                        control_size = 33 + 32 * merkledepth\n+                        controllen_size = 1 + 2 * (control_size >= 253)\n+                        annex_size = 0 if annex is None else len(annex)\n+                        annexlen_size = 0 if annex is None else 1 + 2 * (annex_size >= 253)\n+                        witsize = stacklen_size + sig_size + siglen_size + dummy_size + dummylen_size + script_size + scriptlen_size + control_size + controllen_size + annex_size + annexlen_size\n+                        # sigops ratio test\n+                        return witsize + 50 >= 50 * sigops\n+                    # Make sure n is high enough that with empty dummy, the script is not valid\n+                    n = 0\n+                    while predict_sigops_ratio(n, 0):\n+                        n += 1\n+                    # But allow picking a bit higher still\n+                    n += random.randrange(5)\n+                    # Now pick dummy size *just* large enough that the overall construction passes\n+                    dummylen = 0\n+                    while not predict_sigops_ratio(n, dummylen):\n+                        dummylen += 1\n+                    scripts = [(\"s\", fn(n, pubkey)[0])]\n+                    for _ in range(merkledepth):\n+                        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+                    tap = taproot_construct(pub1, scripts)\n+                    standard = annex is None and dummylen <= 80 and len(pubkey) == 32\n+                    add_spender(spenders, \"tapscript/sigopsratio_%i\" % fn_num, tap=tap, leaf=\"s\", annex=annex, hashtype=hashtype, key=sec2, inputs=[getter(\"sign\"), random_bytes(dummylen)], standard=standard, failure={\"inputs\": [getter(\"sign\"), random_bytes(dummylen - 1)]}, **ERR_SIGOPS_RATIO)\n+        # Future leaf versions\n+    for leafver in range(0, 0x100, 2):\n+        if leafver == LEAF_VERSION_TAPSCRIPT or leafver == ANNEX_TAG:\n+            # Skip the defined LEAF_VERSION_TAPSCRIPT, and the ANNEX_TAG which is not usable as leaf version\n+            continue\n+        scripts = [\n+            (\"bare_c0\", CScript([OP_NOP])),\n+            (\"bare_unkver\", CScript([OP_NOP]), leafver),\n+            (\"return_c0\", CScript([OP_RETURN])),\n+            (\"return_unkver\", CScript([OP_RETURN]), leafver),\n+            (\"undecodable_c0\", CScript([OP_PUSHDATA1])),\n+            (\"undecodable_unkver\", CScript([OP_PUSHDATA1]), leafver),\n+            (\"bigpush_c0\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP])),\n+            (\"bigpush_unkver\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP]), leafver),\n+            (\"1001push_c0\", CScript([OP_0] * 1001)),\n+            (\"1001push_unkver\", CScript([OP_0] * 1001), leafver),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pub1, scripts)\n+        add_spender(spenders, \"unkver/bare\", standard=False, tap=tap, leaf=\"bare_unkver\", failure={\"leaf\": \"bare_c0\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"unkver/return\", standard=False, tap=tap, leaf=\"return_unkver\", failure={\"leaf\": \"return_c0\"}, **ERR_OP_RETURN)\n+        add_spender(spenders, \"unkver/undecodable\", standard=False, tap=tap, leaf=\"undecodable_unkver\", failure={\"leaf\": \"undecodable_c0\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"unkver/bigpush\", standard=False, tap=tap, leaf=\"bigpush_unkver\", failure={\"leaf\": \"bigpush_c0\"}, **ERR_PUSH_LIMIT)\n+        add_spender(spenders, \"unkver/1001push\", standard=False, tap=tap, leaf=\"1001push_unkver\", failure={\"leaf\": \"1001push_c0\"}, **ERR_STACK_SIZE)\n+        add_spender(spenders, \"unkver/1001inputs\", standard=False, tap=tap, leaf=\"bare_unkver\", inputs=[b'' for _ in range(1001)], failure={\"leaf\": \"bare_c0\"}, **ERR_STACK_SIZE)\n+\n+    # OP_SUCCESSx tests.\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for opval in range(76, 0x100):\n+        opcode = CScriptOp(opval)\n+        if not is_op_success(opcode):\n+            continue\n+        scripts = [\n+            (\"bare_success\", CScript([opcode])),\n+            (\"bare_nop\", CScript([OP_NOP])),\n+            (\"unexecif_success\", CScript([OP_0, OP_IF, opcode, OP_ENDIF])),\n+            (\"unexecif_nop\", CScript([OP_0, OP_IF, OP_NOP, OP_ENDIF])),\n+            (\"return_success\", CScript([OP_RETURN, opcode])),\n+            (\"return_nop\", CScript([OP_RETURN, OP_NOP])),\n+            (\"undecodable_success\", CScript([opcode, OP_PUSHDATA1])),\n+            (\"undecodable_nop\", CScript([OP_NOP, OP_PUSHDATA1])),\n+            (\"undecodable_bypassed_success\", CScript([OP_PUSHDATA1, OP_2, opcode])),\n+            (\"bigpush_success\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, opcode])),\n+            (\"bigpush_nop\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, OP_NOP])),\n+            (\"1001push_success\", CScript([OP_0] * 1001 + [opcode])),\n+            (\"1001push_nop\", CScript([OP_0] * 1001 + [OP_NOP])),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pub1, scripts)\n+        add_spender(spenders, \"opsuccess/bare\", standard=False, tap=tap, leaf=\"bare_success\", failure={\"leaf\": \"bare_nop\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"opsuccess/exexecif\", standard=False, tap=tap, leaf=\"unexecif_success\", failure={\"leaf\": \"unexecif_nop\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"opsuccess/return\", standard=False, tap=tap, leaf=\"return_success\", failure={\"leaf\": \"return_nop\"}, **ERR_OP_RETURN)\n+        add_spender(spenders, \"opsuccess/undecodable\", standard=False, tap=tap, leaf=\"undecodable_success\", failure={\"leaf\": \"undecodable_nop\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"opsuccess/undecodable_bypass\", standard=False, tap=tap, leaf=\"undecodable_success\", failure={\"leaf\": \"undecodable_bypassed_success\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"opsuccess/bigpush\", standard=False, tap=tap, leaf=\"bigpush_success\", failure={\"leaf\": \"bigpush_nop\"}, **ERR_PUSH_LIMIT)\n+        add_spender(spenders, \"opsuccess/1001push\", standard=False, tap=tap, leaf=\"1001push_success\", failure={\"leaf\": \"1001push_nop\"}, **ERR_STACK_SIZE)\n+        add_spender(spenders, \"opsuccess/1001inputs\", standard=False, tap=tap, leaf=\"bare_success\", inputs=[b'' for _ in range(1001)], failure={\"leaf\": \"bare_nop\"}, **ERR_STACK_SIZE)\n+\n+    # Non-OP_SUCCESSx (verify that those aren't accidentally treated as OP_SUCCESSx)\n+    for opval in range(0, 0x100):\n+        opcode = CScriptOp(opval)\n+        if is_op_success(opcode):\n+            continue\n+        scripts = [\n+            (\"normal\", CScript([OP_RETURN, opcode] + [OP_NOP] * 75)),\n+            (\"op_success\", CScript([OP_RETURN, CScriptOp(0x50)]))\n+        ]\n+        tap = taproot_construct(pub1, scripts)\n+        add_spender(spenders, \"alwaysvalid/notsuccessx\", tap=tap, leaf=\"op_success\", inputs=[], standard=False, failure={\"leaf\": \"normal\"}) # err_msg differs based on opcode\n+\n+    # == Legacy tests ==\n+\n+    # Also add a few legacy spends into the mix, so that transactions which combine taproot and pre-taproot spends get tested too.\n+    eckey1 = ECKey()\n+    eckey1.set(generate_privkey(), True)\n+    pubkey1 = eckey1.get_pubkey().get_bytes()\n+    eckey2 = ECKey()\n+    eckey2.set(generate_privkey(), True)\n+    for p2sh in [False, True]:\n+        for witv0 in [False, True]:\n+            for hashtype in VALID_SIGHASHES_ECDSA + [random.randrange(0x04, 0x80), random.randrange(0x84, 0x100)]:\n+                standard = hashtype in VALID_SIGHASHES_ECDSA\n+                add_spender(spenders, \"legacy/pk-wrongkey\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, script=CScript([pubkey1, OP_CHECKSIG]), **SINGLE_SIG, key=eckey1, failure={\"key\": eckey2}, sigops_weight=4-3*witv0, **ERR_NO_SUCCESS)\n+                add_spender(spenders, \"legacy/pkh-sighashflip\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, pkh=pubkey1, key=eckey1, **SIGHASH_BITFLIP, sigops_weight=4-3*witv0, **ERR_NO_SUCCESS)\n+\n+    # Verify that OP_CHECKSIGADD wasn't accidentally added to pre-taproot validation logic.\n+    for p2sh in [False, True]:\n+        for witv0 in [False, True]:\n+            for hashtype in VALID_SIGHASHES_ECDSA + [random.randrange(0x04, 0x80), random.randrange(0x84, 0x100)]:\n+                standard = hashtype in VALID_SIGHASHES_ECDSA and (p2sh or witv0)\n+                add_spender(spenders, \"legacy/nocsa\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, script=CScript([OP_IF, OP_11, pubkey1, OP_CHECKSIGADD, OP_12, OP_EQUAL, OP_ELSE, pubkey1, OP_CHECKSIG, OP_ENDIF]), key=eckey1, sigops_weight=4-3*witv0, inputs=[getter(\"sign\"), b''], failure={\"inputs\": [getter(\"sign\"), b'\\x01']}, **ERR_UNDECODABLE)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r467972427",
      "id" : 467972427,
      "line" : 1104,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk3MjQyNw==",
      "original_commit_id" : "8692041ef50b36ade662561371c0175a70bd8fec",
      "original_line" : 1104,
      "original_position" : 1007,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : 1104,
      "pull_request_review_id" : 463589678,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/467972427",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r470405454"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/470405454"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-14T04:36:49Z",
      "diff_hunk" : "@@ -0,0 +1,1222 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expreesion for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r470405454",
      "id" : 470405454,
      "in_reply_to_id" : 467252062,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQwNTQ1NA==",
      "original_commit_id" : "ff9b7e6e2644f4acb76031e9d8c783ca9217e7c2",
      "original_line" : 185,
      "original_position" : 185,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 467301837,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/470405454",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r470405540"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/470405540"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Randomenized it.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-14T04:37:10Z",
      "diff_hunk" : "@@ -0,0 +1,1271 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expreesion for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        _, negated = compute_xonly_pubkey(key)\n+        return tweak_add_privkey(key, tweak, negated)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    tx.vin[idx].scriptSig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    tx.wit.vtxinwit[idx].scriptWitness.stack = flatten(get(ctx, \"witness\"))\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert(tap is None)\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert(script is None)\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            spend(tx, idx, utxos, **conf)\n+        else:\n+            assert(failure is not None)\n+            spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+# Expected error strings\n+ERR_KEYPATH_INVALID_SIG = {\"err_msg\": \"Invalid signature for Taproot key path spending\"}\n+ERR_SCRIPTPATH_INVALID_SIG = {\"err_msg\": \"Signature must be zero for failed CHECK(MULTI)SIG operation\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Extra items left on stack after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    sec = generate_privkey()\n+    pub, _ = compute_xonly_pubkey(sec)\n+    tap = taproot_construct(pub)\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=sec, failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=sec, failure={\"sighash\": bitflipper(default_sighash)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=sec, failure={\"flag_flip_r\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=sec, failure={\"flag_flip_p\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=sec, failure={\"signature\": bitflipper(default_signature)}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+        sec1, sec2 = generate_privkey(), generate_privkey()\n+        pub1, _ = compute_xonly_pubkey(sec1)\n+        pub2, _ = compute_xonly_pubkey(sec2)\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pub1)\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pub2)))]\n+            tap = taproot_construct(pub1, scripts)\n+            add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"s0\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+        # Test OP_CODESEPARATOR impact on sighashing.\n+        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+        common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+        scripts = [\n+            (\"pk_codesep\", CScript(random_checksig_style(pub2) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig\n+            (\"codesep_pk\", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pub2))),  # codesep before checksig\n+            (\"branched_codesep\", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pub1, OP_ELSE, OP_CODESEPARATOR, pub2, OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pub1, scripts)\n+        add_spender(spenders, \"sighash/pk_codesep\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/codesep_pk\", tap=tap, leaf=\"codesep_pk\", key=sec2, codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/left\", tap=tap, leaf=\"branched_codesep\", key=sec1, codeseppos=3, **common, inputs=[getter(\"sign\"), b'\\x01'], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/right\", tap=tap, leaf=\"branched_codesep\", key=sec2, codeseppos=6, **common, inputs=[getter(\"sign\"), b''], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Reusing the scripts above, test that various features affect the sighash.\n+    add_spender(spenders, \"sighash/annex\", tap=tap, leaf=\"pk_codesep\", key=sec2, hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={\"sighash\": override(default_sighash, annex=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/script\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, script_taproot=tap.leaves[\"codesep_pk\"].script)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/leafver\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leafversion=0xc2)}, **ERR_SCRIPTPATH_INVALID_SIG)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r470405540",
      "id" : 470405540,
      "in_reply_to_id" : 467956184,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQwNTU0MA==",
      "original_commit_id" : "8692041ef50b36ade662561371c0175a70bd8fec",
      "original_line" : 638,
      "original_position" : 638,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 467301934,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/470405540",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r470406363"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/470406363"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Very nice catch.\r\n\r\nIt took me a while: what happened is that the sighash code on the Python code (intentionally) supported invalid hashtypes, but implemented them slightly differently than what the C++ code did (after applying your mutation). Thus the signature for 0x04 and 0x84 (which map to output_type == 0, an invalid value) was constructed, but still rejected.\r\n\r\nI've changed the Python side to be closer to the C++ one. I'm not entirely happy with that; I think it was useful to have an implementation that worked with a somewhat different principle, but on the other hand, it served its purpose.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-14T04:40:36Z",
      "diff_hunk" : "@@ -0,0 +1,1271 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expreesion for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        _, negated = compute_xonly_pubkey(key)\n+        return tweak_add_privkey(key, tweak, negated)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    tx.vin[idx].scriptSig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    tx.wit.vtxinwit[idx].scriptWitness.stack = flatten(get(ctx, \"witness\"))\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert(tap is None)\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert(script is None)\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            spend(tx, idx, utxos, **conf)\n+        else:\n+            assert(failure is not None)\n+            spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+# Expected error strings\n+ERR_KEYPATH_INVALID_SIG = {\"err_msg\": \"Invalid signature for Taproot key path spending\"}\n+ERR_SCRIPTPATH_INVALID_SIG = {\"err_msg\": \"Signature must be zero for failed CHECK(MULTI)SIG operation\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Extra items left on stack after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    sec = generate_privkey()\n+    pub, _ = compute_xonly_pubkey(sec)\n+    tap = taproot_construct(pub)\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=sec, failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=sec, failure={\"sighash\": bitflipper(default_sighash)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=sec, failure={\"flag_flip_r\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=sec, failure={\"flag_flip_p\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=sec, failure={\"signature\": bitflipper(default_signature)}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+        sec1, sec2 = generate_privkey(), generate_privkey()\n+        pub1, _ = compute_xonly_pubkey(sec1)\n+        pub2, _ = compute_xonly_pubkey(sec2)\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pub1)\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pub2)))]\n+            tap = taproot_construct(pub1, scripts)\n+            add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"s0\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+        # Test OP_CODESEPARATOR impact on sighashing.\n+        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+        common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+        scripts = [\n+            (\"pk_codesep\", CScript(random_checksig_style(pub2) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig\n+            (\"codesep_pk\", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pub2))),  # codesep before checksig\n+            (\"branched_codesep\", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pub1, OP_ELSE, OP_CODESEPARATOR, pub2, OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pub1, scripts)\n+        add_spender(spenders, \"sighash/pk_codesep\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/codesep_pk\", tap=tap, leaf=\"codesep_pk\", key=sec2, codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/left\", tap=tap, leaf=\"branched_codesep\", key=sec1, codeseppos=3, **common, inputs=[getter(\"sign\"), b'\\x01'], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/right\", tap=tap, leaf=\"branched_codesep\", key=sec2, codeseppos=6, **common, inputs=[getter(\"sign\"), b''], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Reusing the scripts above, test that various features affect the sighash.\n+    add_spender(spenders, \"sighash/annex\", tap=tap, leaf=\"pk_codesep\", key=sec2, hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={\"sighash\": override(default_sighash, annex=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/script\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, script_taproot=tap.leaves[\"codesep_pk\"].script)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/leafver\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leafversion=0xc2)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leaf=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, failure={\"sighash\": override(default_sighash, leaf=\"pk_codesep\")}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # Test that invalid hashtypes don't work, both in key path and script path spends\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for invalid_hashtype in range(256):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r470406363",
      "id" : 470406363,
      "in_reply_to_id" : 467956844,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQwNjM2Mw==",
      "original_commit_id" : "8692041ef50b36ade662561371c0175a70bd8fec",
      "original_line" : 644,
      "original_position" : 644,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 467302825,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/470406363",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r470406385"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/470406385"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-14T04:40:46Z",
      "diff_hunk" : "@@ -0,0 +1,1271 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expreesion for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        _, negated = compute_xonly_pubkey(key)\n+        return tweak_add_privkey(key, tweak, negated)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    tx.vin[idx].scriptSig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    tx.wit.vtxinwit[idx].scriptWitness.stack = flatten(get(ctx, \"witness\"))\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert(tap is None)\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert(script is None)\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            spend(tx, idx, utxos, **conf)\n+        else:\n+            assert(failure is not None)\n+            spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+# Expected error strings\n+ERR_KEYPATH_INVALID_SIG = {\"err_msg\": \"Invalid signature for Taproot key path spending\"}\n+ERR_SCRIPTPATH_INVALID_SIG = {\"err_msg\": \"Signature must be zero for failed CHECK(MULTI)SIG operation\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Extra items left on stack after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    sec = generate_privkey()\n+    pub, _ = compute_xonly_pubkey(sec)\n+    tap = taproot_construct(pub)\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=sec, failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=sec, failure={\"sighash\": bitflipper(default_sighash)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=sec, failure={\"flag_flip_r\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=sec, failure={\"flag_flip_p\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=sec, failure={\"signature\": bitflipper(default_signature)}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+        sec1, sec2 = generate_privkey(), generate_privkey()\n+        pub1, _ = compute_xonly_pubkey(sec1)\n+        pub2, _ = compute_xonly_pubkey(sec2)\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pub1)\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pub2)))]\n+            tap = taproot_construct(pub1, scripts)\n+            add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"s0\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+        # Test OP_CODESEPARATOR impact on sighashing.\n+        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+        common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+        scripts = [\n+            (\"pk_codesep\", CScript(random_checksig_style(pub2) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig\n+            (\"codesep_pk\", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pub2))),  # codesep before checksig\n+            (\"branched_codesep\", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pub1, OP_ELSE, OP_CODESEPARATOR, pub2, OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pub1, scripts)\n+        add_spender(spenders, \"sighash/pk_codesep\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/codesep_pk\", tap=tap, leaf=\"codesep_pk\", key=sec2, codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/left\", tap=tap, leaf=\"branched_codesep\", key=sec1, codeseppos=3, **common, inputs=[getter(\"sign\"), b'\\x01'], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/right\", tap=tap, leaf=\"branched_codesep\", key=sec2, codeseppos=6, **common, inputs=[getter(\"sign\"), b''], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Reusing the scripts above, test that various features affect the sighash.\n+    add_spender(spenders, \"sighash/annex\", tap=tap, leaf=\"pk_codesep\", key=sec2, hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={\"sighash\": override(default_sighash, annex=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/script\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, script_taproot=tap.leaves[\"codesep_pk\"].script)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/leafver\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leafversion=0xc2)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leaf=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, failure={\"sighash\": override(default_sighash, leaf=\"pk_codesep\")}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # Test that invalid hashtypes don't work, both in key path and script path spends\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for invalid_hashtype in range(256):\n+        if invalid_hashtype not in VALID_SIGHASHES_TAPROOT:\n+            add_spender(spenders, \"sighash/keypath_unk_hashtype\", tap=tap, key=sec1, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath_unk_hashtype\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Test that hashtype 0 cannot have a hashtype byte, and 1 must have one.\n+    add_spender(spenders, \"sighash/hashtype0_byte_keypath\", tap=tap, key=sec1, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_keypath\", tap=tap, key=sec1, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    # Test that hashtype 0 and hashtype 1 cannot be transmuted into each other.\n+    add_spender(spenders, \"sighash/hashtype0to1_keypath\", tap=tap, key=sec1, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0to1_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_keypath\", tap=tap, key=sec1, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # == Test that BIP341 spending only applies to witness version 1, program length 32, no P2SH ==\n+\n+    for p2sh in [False, True]:\n+        for witver in range(1, 17):\n+            for witlen in [20, 31, 32, 33]:\n+                def mutate(spk):\n+                    prog = spk[2:]\n+                    assert(len(prog) == 32)\n+                    if witlen < 32:\n+                        prog = prog[0:witlen]\n+                    elif witlen > 32:\n+                        prog += bytes([0 for _ in range(witlen - 32)])\n+                    return CScript([CScriptOp.encode_op_n(witver), prog])\n+                scripts = [(\"s0\", CScript([pub1, OP_CHECKSIG])), (\"dummy\", CScript([OP_RETURN]))]\n+                tap = taproot_construct(pub2, scripts)\n+                if not p2sh and witver == 1 and witlen == 32:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=sec2, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=sec1, **SINGLE_SIG, failure={\"leaf\": \"dummy\"}, **ERR_OP_RETURN)\n+                else:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=sec2, standard=False)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=sec1, **SINGLE_SIG, standard=False)\n+\n+    # == Test various aspects of BIP341 spending paths ==\n+\n+    # A set of functions that compute the hashing partner in a Merkle tree, designed to exercise\n+    # edge cases. This relies on the taproot_construct feature that a lambda can be passed in\n+    # instead of a subtree, to compute the partner to be hashed with.\n+    PARTNER_MERKLE_FN = [\n+        # Combine with itself\n+        lambda h: h,\n+        # Combine with hash 0\n+        lambda h: bytes([0 for _ in range(32)]),\n+        # Combine with hash 2^256-1\n+        lambda h: bytes([0xff for _ in range(32)]),\n+        # Combine with itself-1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') + 1).to_bytes(32, 'big'),\n+        # Combine with itself-1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') + 1).to_bytes(32, 'little'),\n+        # Combine with random bitflipped version of self.\n+        lambda h: (int.from_bytes(h, 'little') ^ (1 << random.randrange(256))).to_bytes(32, 'little')\n+    ]\n+    # Start with a tree of that has depth 1 for \"128deep\" and depth 2 for \"129deep\".\n+    scripts = [(\"128deep\", CScript([pub1, OP_CHECKSIG])), [(\"129deep\", CScript([pub1, OP_CHECKSIG])), random.choice(PARTNER_MERKLE_FN)]]\n+    # Add 127 nodes on top of that tree, so that \"128deep\" and \"129deep\" end up at their designated depths.\n+    for _ in range(127):\n+        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+    tap = taproot_construct(pub1, scripts)\n+    # Test that spends with a depth of 128 work, but 129 doesn't (even with a tree with weird Merkle branches in it).\n+    add_spender(spenders, \"spendpath/merklelimit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"leaf\": \"129deep\"}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that flipping the negation bit invalidates spends.\n+    add_spender(spenders, \"spendpath/negflag\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"negflag\": lambda ctx: 1 - default_negflag(ctx)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the Merkle branch invalidate it.\n+    add_spender(spenders, \"spendpath/bitflipmerkle\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"merklebranch\": bitflipper(default_merklebranch)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the inner pubkey invalidate it.\n+    add_spender(spenders, \"spendpath/bitflippubkey\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"pubkey_inner\": bitflipper(default_pubkey_inner)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that empty witnesses are invalid.\n+    add_spender(spenders, \"spendpath/emptywit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"witness\": []}, **ERR_EMPTY_WITNESS)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padlongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/trunclongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    scripts = [(\"s\", CScript([pub1, OP_CHECKSIG]))]\n+    tap = taproot_construct(pub2, scripts)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/truncshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block to 1 byte (\"-1 Merkle length\") invalidates it\n+    add_spender(spenders, \"spendpath/trunc1shortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:1]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    # == Test BIP342 edge cases ==\n+\n+    checksigadd_val = random.randrange(17, 100) # Above OP_16 to avoid minimal encoding complaints\n+    checksigadd_arg = CScriptNum(checksigadd_val)\n+    checksigadd_result = CScriptNum(checksigadd_val+1)\n+    OVERSIZE_NUMBER = 2**31\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER))), 6)\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER-1))), 5)\n+\n+    # Various BIP342 features\n+    scripts = [\n+        # 0) drop stack element and OP_CHECKSIG\n+        (\"t0\", CScript([OP_DROP, pub2, OP_CHECKSIG])),\n+        # 1) normal OP_CHECKSIG\n+        (\"t1\", CScript([pub2, OP_CHECKSIG])),\n+        # 2) normal OP_CHECKSIGVERIFY\n+        (\"t2\", CScript([pub2, OP_CHECKSIGVERIFY, OP_1])),\n+        # 3) Hypothetical OP_CHECKMULTISIG script that takes a single sig as input\n+        (\"t3\", CScript([OP_0, OP_SWAP, OP_1, pub2, OP_1, OP_CHECKMULTISIG])),\n+        # 4) Hypothetical OP_CHECKMULTISIGVERIFY script that takes a single sig as input\n+        (\"t4\", CScript([OP_0, OP_SWAP, OP_1, pub2, OP_1, OP_CHECKMULTISIGVERIFY, OP_1])),\n+        # 5) OP_IF script that needs a true input\n+        (\"t5\", CScript([OP_IF, pub2, OP_CHECKSIG, OP_ELSE, OP_RETURN, OP_ENDIF])),\n+        # 6) OP_NOTIF script that needs a true input\n+        (\"t6\", CScript([OP_NOTIF, OP_RETURN, OP_ELSE, pub2, OP_CHECKSIG, OP_ENDIF])),\n+        # 7) OP_CHECKSIG with an empty key\n+        (\"t7\", CScript([OP_0, OP_CHECKSIG])),\n+        # 8) OP_CHECKSIGVERIFY with an empty key\n+        (\"t8\", CScript([OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 9) normal OP_CHECKSIGADD that also ensures return value is correct\n+        (\"t9\", CScript([OP_0, pub2, OP_CHECKSIGADD, OP_1, OP_EQUAL])),\n+        # 10) OP_CHECKSIGADD with empty key\n+        (\"t10\", CScript([OP_0, OP_0, OP_CHECKSIGADD])),\n+        # 11) OP_CHECKSIGADD with missing counter stack element\n+        (\"t11\", CScript([pub2, OP_CHECKSIGADD])),\n+        # 12) OP_CHECKSIG that needs invalid signature\n+        (\"t12\", CScript([pub2, OP_CHECKSIGVERIFY, pub1, OP_CHECKSIG, OP_NOT])),\n+        # 13) OP_CHECKSIG with empty key that needs invalid signature\n+        (\"t13\", CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_CHECKSIG, OP_NOT])),\n+        # 14) OP_CHECKSIGADD that needs invalid signature\n+        (\"t14\", CScript([pub2, OP_CHECKSIGVERIFY, OP_0, pub1, OP_CHECKSIGADD, OP_NOT])),\n+        # 15) OP_CHECKSIGADD with empty key that needs invalid signature\n+        (\"t15\", CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGADD, OP_NOT])),\n+        # 16) OP_CHECKSIG with unknown pubkey type\n+        (\"t16\", CScript([OP_1, OP_CHECKSIG])),\n+        # 17) OP_CHECKSIGADD with unknown pubkey type\n+        (\"t17\", CScript([OP_0, OP_1, OP_CHECKSIGADD])),\n+        # 18) OP_CHECKSIGVERIFY with unknown pubkey type\n+        (\"t18\", CScript([OP_1, OP_CHECKSIGVERIFY, OP_1])),\n+        # 19) script longer than 10000 bytes and over 201 non-push opcodes\n+        (\"t19\", CScript([OP_0, OP_0, OP_2DROP] * 10001 + [pub2, OP_CHECKSIG])),\n+        # 20) OP_CHECKSIGVERIFY with empty key\n+        (\"t20\", CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 21) Script that grows the stack to 1000 elements\n+        (\"t21\", CScript([pub2, OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 999 + [OP_DROP] * 999)),\n+        # 22) Script that grows the stack to 1001 elements\n+        (\"t22\", CScript([pub2, OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 1000 + [OP_DROP] * 1000)),\n+        # 23) Script that expects an input stack of 1000 elements\n+        (\"t23\", CScript([OP_DROP] * 999 + [pub2, OP_CHECKSIG])),\n+        # 24) Script that expects an input stack of 1001 elements\n+        (\"t24\", CScript([OP_DROP] * 1000 + [pub2, OP_CHECKSIG])),\n+        # 25) Script that pushes a MAX_SCRIPT_ELEMENT_SIZE-bytes element\n+        (\"t25\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE), OP_DROP, pub2, OP_CHECKSIG])),\n+        # 26) Script that pushes a (MAX_SCRIPT_ELEMENT_SIZE+1)-bytes element\n+        (\"t26\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, pub2, OP_CHECKSIG])),\n+        # 27) CHECKSIGADD that must fail because numeric argument number is >4 bytes\n+        (\"t27\", CScript([CScriptNum(OVERSIZE_NUMBER), pub2, OP_CHECKSIGADD])),\n+        # 28) Pushes random CScriptNum value, checks OP_CHECKSIGADD result\n+        (\"t28\", CScript([checksigadd_arg, pub2, OP_CHECKSIGADD, checksigadd_result, OP_EQUAL])),\n+        # 29) CHECKSIGADD that succeeds with proper sig because numeric argument number is <=4 bytes\n+        (\"t29\", CScript([CScriptNum(OVERSIZE_NUMBER-1), pub2, OP_CHECKSIGADD])),\n+        # 30) Variant of t1 with \"normal\" 33-byte pubkey\n+        (\"t30\", CScript([b'\\x03' + pub2, OP_CHECKSIG])),\n+        # 31) Variant of t2 with \"normal\" 33-byte pubkey\n+        (\"t31\", CScript([b'\\x02' + pub2, OP_CHECKSIGVERIFY, OP_1])),\n+        # 32) Variant of t28 with \"normal\" 33-byte pubkey\n+        (\"t32\", CScript([checksigadd_arg, b'\\x03' + pub2, OP_CHECKSIGADD, checksigadd_result, OP_EQUAL])),\n+    ]\n+    random.shuffle(scripts)\n+    tap = taproot_construct(pub1, scripts)\n+    common = {\n+        \"hashtype\": hashtype,\n+        \"key\": sec2,\n+        \"tap\": tap,\n+    }\n+    # Test that MAX_SCRIPT_ELEMENT_SIZE byte stack element inputs are valid, but not one more (and 80 bytes is standard but 81 is not).\n+    add_spender(spenders, \"tapscript/inputmaxlimit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE)], failure={\"inputs\": [getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1)]}, **ERR_PUSH_LIMIT)\n+    add_spender(spenders, \"tapscript/input80limit\", leaf=\"t0\", **common, inputs=[getter(\"sign\"), random_bytes(80)])\n+    add_spender(spenders, \"tapscript/input81limit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(81)])\n+    # Test that OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY cause failure, but OP_CHECKSIG and OP_CHECKSIGVERIFY work.\n+    add_spender(spenders, \"tapscript/disabled_checkmultisig\", leaf=\"t1\", **common, **SINGLE_SIG, failure={\"leaf\": \"t3\"}, **ERR_DISABLED_OPCODE)\n+    add_spender(spenders, \"tapscript/disabled_checkmultisigverify\", leaf=\"t2\", **common, **SINGLE_SIG, failure={\"leaf\": \"t4\"}, **ERR_DISABLED_OPCODE)\n+    # Test that OP_IF and OP_NOTIF do not accept non-0x01 as truth value (the MINIMALIF rule is consensus in Tapscript)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x02']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x03']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0001']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0100']}, **ERR_MINIMALIF)\n+    # Test that 1-byte public keys (which are unknown) are acceptable but nonstandard with unrelated signatures, but 0-byte public keys are not valid.\n+    add_spender(spenders, \"tapscript/unkpk/checksig\", leaf=\"t16\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigadd\", leaf=\"t17\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigverify\", leaf=\"t18\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that 33-byte public keys (which are unknown) are acceptable but nonstandard with valid signatures, but normal pubkeys are not valid in that case.\n+    add_spender(spenders, \"tapscript/oldpk/checksig\", leaf=\"t30\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t1\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"tapscript/oldpk/checksigadd\", leaf=\"t31\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t2\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"tapscript/oldpk/checksigverify\", leaf=\"t32\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t28\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    # Test that 0-byte public keys are not acceptable.\n+    add_spender(spenders, \"tapscript/emptypk/checksig\", leaf=\"t1\", **SINGLE_SIG, **common, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigverify\", leaf=\"t2\", **SINGLE_SIG, **common, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigadd\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that OP_CHECKSIGADD results are as expected\n+    add_spender(spenders, \"tapscript/checksigaddresults\", leaf=\"t28\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    add_spender(spenders, \"tapscript/checksigaddoversize\", leaf=\"t29\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    # Test that OP_CHECKSIGADD requires 3 stack elements.\n+    add_spender(spenders, \"tapscript/checksigadd3args\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t11\"}, **ERR_STACK_EMPTY)\n+    # Test that empty signatures do not cause script failure in OP_CHECKSIG and OP_CHECKSIGADD (but do fail with empty pubkey, and do fail OP_CHECKSIGVERIFY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksig\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t13\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/nochecksigverify\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t20\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksigadd\", leaf=\"t14\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t15\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that scripts over 10000 bytes (and over 201 non-push ops) are acceptable.\n+    add_spender(spenders, \"tapscript/no10000limit\", leaf=\"t19\", **SINGLE_SIG, **common)\n+    # Test that a stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000stack\", leaf=\"t21\", **SINGLE_SIG, **common, failure={\"leaf\": \"t22\"}, **ERR_STACK_SIZE)\n+    # Test that an input stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000inputs\", leaf=\"t23\", **common, inputs=[getter(\"sign\")] + [b'' for _ in range(999)], failure={\"leaf\": \"t24\", \"inputs\": [getter(\"sign\")] + [b'' for _ in range(1000)]}, **ERR_STACK_SIZE)\n+    # Test that pushing a MAX_SCRIPT_ELEMENT_SIZE byte stack element is valid, but one longer is not.\n+    add_spender(spenders, \"tapscript/pushmaxlimit\", leaf=\"t25\", **common, **SINGLE_SIG, failure={\"leaf\": \"t26\"}, **ERR_PUSH_LIMIT)\n+\n+    # == Test for sigops ratio limit ==\n+\n+    # Given a number n, and a public key pk, functions that produces a (CScript, sigops). Each script takes as\n+    # input a valid signature with the passed pk followed by a dummy, and will execute sigops signature checks.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r470406385",
      "id" : 470406385,
      "in_reply_to_id" : 467958678,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQwNjM4NQ==",
      "original_commit_id" : "8692041ef50b36ade662561371c0175a70bd8fec",
      "original_line" : 865,
      "original_position" : 865,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 467302862,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/470406385",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r470406434"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/470406434"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done (with %x).",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-14T04:41:00Z",
      "diff_hunk" : "@@ -0,0 +1,1271 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expreesion for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        _, negated = compute_xonly_pubkey(key)\n+        return tweak_add_privkey(key, tweak, negated)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    tx.vin[idx].scriptSig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    tx.wit.vtxinwit[idx].scriptWitness.stack = flatten(get(ctx, \"witness\"))\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert(tap is None)\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert(script is None)\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            spend(tx, idx, utxos, **conf)\n+        else:\n+            assert(failure is not None)\n+            spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+# Expected error strings\n+ERR_KEYPATH_INVALID_SIG = {\"err_msg\": \"Invalid signature for Taproot key path spending\"}\n+ERR_SCRIPTPATH_INVALID_SIG = {\"err_msg\": \"Signature must be zero for failed CHECK(MULTI)SIG operation\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Extra items left on stack after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    sec = generate_privkey()\n+    pub, _ = compute_xonly_pubkey(sec)\n+    tap = taproot_construct(pub)\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=sec, failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=sec, failure={\"sighash\": bitflipper(default_sighash)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=sec, failure={\"flag_flip_r\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=sec, failure={\"flag_flip_p\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=sec, failure={\"signature\": bitflipper(default_signature)}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+        sec1, sec2 = generate_privkey(), generate_privkey()\n+        pub1, _ = compute_xonly_pubkey(sec1)\n+        pub2, _ = compute_xonly_pubkey(sec2)\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pub1)\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pub2)))]\n+            tap = taproot_construct(pub1, scripts)\n+            add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r470406434",
      "id" : 470406434,
      "in_reply_to_id" : 467959794,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQwNjQzNA==",
      "original_commit_id" : "8692041ef50b36ade662561371c0175a70bd8fec",
      "original_line" : 617,
      "original_position" : 617,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 467302921,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/470406434",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r470406470"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/470406470"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done (with %x).",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-14T04:41:08Z",
      "diff_hunk" : "@@ -0,0 +1,1271 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expreesion for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        _, negated = compute_xonly_pubkey(key)\n+        return tweak_add_privkey(key, tweak, negated)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    tx.vin[idx].scriptSig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    tx.wit.vtxinwit[idx].scriptWitness.stack = flatten(get(ctx, \"witness\"))\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert(tap is None)\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert(script is None)\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            spend(tx, idx, utxos, **conf)\n+        else:\n+            assert(failure is not None)\n+            spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+# Expected error strings\n+ERR_KEYPATH_INVALID_SIG = {\"err_msg\": \"Invalid signature for Taproot key path spending\"}\n+ERR_SCRIPTPATH_INVALID_SIG = {\"err_msg\": \"Signature must be zero for failed CHECK(MULTI)SIG operation\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Extra items left on stack after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    sec = generate_privkey()\n+    pub, _ = compute_xonly_pubkey(sec)\n+    tap = taproot_construct(pub)\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=sec, failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=sec, failure={\"sighash\": bitflipper(default_sighash)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=sec, failure={\"flag_flip_r\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=sec, failure={\"flag_flip_p\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=sec, failure={\"signature\": bitflipper(default_signature)}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+        sec1, sec2 = generate_privkey(), generate_privkey()\n+        pub1, _ = compute_xonly_pubkey(sec1)\n+        pub2, _ = compute_xonly_pubkey(sec2)\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pub1)\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pub2)))]\n+            tap = taproot_construct(pub1, scripts)\n+            add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"s0\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r470406470",
      "id" : 470406470,
      "in_reply_to_id" : 467960153,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQwNjQ3MA==",
      "original_commit_id" : "8692041ef50b36ade662561371c0175a70bd8fec",
      "original_line" : 618,
      "original_position" : 618,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 467302964,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/470406470",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r470406507"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/470406507"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done (with %x).",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-14T04:41:19Z",
      "diff_hunk" : "@@ -0,0 +1,1271 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expreesion for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        _, negated = compute_xonly_pubkey(key)\n+        return tweak_add_privkey(key, tweak, negated)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    tx.vin[idx].scriptSig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    tx.wit.vtxinwit[idx].scriptWitness.stack = flatten(get(ctx, \"witness\"))\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert(tap is None)\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert(script is None)\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            spend(tx, idx, utxos, **conf)\n+        else:\n+            assert(failure is not None)\n+            spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+# Expected error strings\n+ERR_KEYPATH_INVALID_SIG = {\"err_msg\": \"Invalid signature for Taproot key path spending\"}\n+ERR_SCRIPTPATH_INVALID_SIG = {\"err_msg\": \"Signature must be zero for failed CHECK(MULTI)SIG operation\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Extra items left on stack after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    sec = generate_privkey()\n+    pub, _ = compute_xonly_pubkey(sec)\n+    tap = taproot_construct(pub)\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=sec, failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=sec, failure={\"sighash\": bitflipper(default_sighash)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=sec, failure={\"flag_flip_r\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=sec, failure={\"flag_flip_p\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=sec, failure={\"signature\": bitflipper(default_signature)}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+        sec1, sec2 = generate_privkey(), generate_privkey()\n+        pub1, _ = compute_xonly_pubkey(sec1)\n+        pub2, _ = compute_xonly_pubkey(sec2)\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pub1)\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pub2)))]\n+            tap = taproot_construct(pub1, scripts)\n+            add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"s0\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+        # Test OP_CODESEPARATOR impact on sighashing.\n+        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+        common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+        scripts = [\n+            (\"pk_codesep\", CScript(random_checksig_style(pub2) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig\n+            (\"codesep_pk\", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pub2))),  # codesep before checksig\n+            (\"branched_codesep\", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pub1, OP_ELSE, OP_CODESEPARATOR, pub2, OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pub1, scripts)\n+        add_spender(spenders, \"sighash/pk_codesep\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/codesep_pk\", tap=tap, leaf=\"codesep_pk\", key=sec2, codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/left\", tap=tap, leaf=\"branched_codesep\", key=sec1, codeseppos=3, **common, inputs=[getter(\"sign\"), b'\\x01'], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/right\", tap=tap, leaf=\"branched_codesep\", key=sec2, codeseppos=6, **common, inputs=[getter(\"sign\"), b''], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Reusing the scripts above, test that various features affect the sighash.\n+    add_spender(spenders, \"sighash/annex\", tap=tap, leaf=\"pk_codesep\", key=sec2, hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={\"sighash\": override(default_sighash, annex=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/script\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, script_taproot=tap.leaves[\"codesep_pk\"].script)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/leafver\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leafversion=0xc2)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leaf=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, failure={\"sighash\": override(default_sighash, leaf=\"pk_codesep\")}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # Test that invalid hashtypes don't work, both in key path and script path spends\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for invalid_hashtype in range(256):\n+        if invalid_hashtype not in VALID_SIGHASHES_TAPROOT:\n+            add_spender(spenders, \"sighash/keypath_unk_hashtype\", tap=tap, key=sec1, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_KEYPATH_INVALID_SIG)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r470406507",
      "id" : 470406507,
      "in_reply_to_id" : 467960608,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQwNjUwNw==",
      "original_commit_id" : "8692041ef50b36ade662561371c0175a70bd8fec",
      "original_line" : 646,
      "original_position" : 646,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 467303005,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/470406507",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r470406543"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/470406543"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done, with %x.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-14T04:41:28Z",
      "diff_hunk" : "@@ -0,0 +1,1271 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expreesion for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        _, negated = compute_xonly_pubkey(key)\n+        return tweak_add_privkey(key, tweak, negated)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    tx.vin[idx].scriptSig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    tx.wit.vtxinwit[idx].scriptWitness.stack = flatten(get(ctx, \"witness\"))\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert(tap is None)\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert(script is None)\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            spend(tx, idx, utxos, **conf)\n+        else:\n+            assert(failure is not None)\n+            spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+# Expected error strings\n+ERR_KEYPATH_INVALID_SIG = {\"err_msg\": \"Invalid signature for Taproot key path spending\"}\n+ERR_SCRIPTPATH_INVALID_SIG = {\"err_msg\": \"Signature must be zero for failed CHECK(MULTI)SIG operation\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Extra items left on stack after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    sec = generate_privkey()\n+    pub, _ = compute_xonly_pubkey(sec)\n+    tap = taproot_construct(pub)\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=sec, failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=sec, failure={\"sighash\": bitflipper(default_sighash)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=sec, failure={\"flag_flip_r\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=sec, failure={\"flag_flip_p\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=sec, failure={\"signature\": bitflipper(default_signature)}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+        sec1, sec2 = generate_privkey(), generate_privkey()\n+        pub1, _ = compute_xonly_pubkey(sec1)\n+        pub2, _ = compute_xonly_pubkey(sec2)\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pub1)\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pub2)))]\n+            tap = taproot_construct(pub1, scripts)\n+            add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"s0\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+        # Test OP_CODESEPARATOR impact on sighashing.\n+        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+        common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+        scripts = [\n+            (\"pk_codesep\", CScript(random_checksig_style(pub2) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig\n+            (\"codesep_pk\", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pub2))),  # codesep before checksig\n+            (\"branched_codesep\", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pub1, OP_ELSE, OP_CODESEPARATOR, pub2, OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pub1, scripts)\n+        add_spender(spenders, \"sighash/pk_codesep\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/codesep_pk\", tap=tap, leaf=\"codesep_pk\", key=sec2, codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/left\", tap=tap, leaf=\"branched_codesep\", key=sec1, codeseppos=3, **common, inputs=[getter(\"sign\"), b'\\x01'], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/right\", tap=tap, leaf=\"branched_codesep\", key=sec2, codeseppos=6, **common, inputs=[getter(\"sign\"), b''], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Reusing the scripts above, test that various features affect the sighash.\n+    add_spender(spenders, \"sighash/annex\", tap=tap, leaf=\"pk_codesep\", key=sec2, hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={\"sighash\": override(default_sighash, annex=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/script\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, script_taproot=tap.leaves[\"codesep_pk\"].script)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/leafver\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leafversion=0xc2)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leaf=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, failure={\"sighash\": override(default_sighash, leaf=\"pk_codesep\")}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # Test that invalid hashtypes don't work, both in key path and script path spends\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for invalid_hashtype in range(256):\n+        if invalid_hashtype not in VALID_SIGHASHES_TAPROOT:\n+            add_spender(spenders, \"sighash/keypath_unk_hashtype\", tap=tap, key=sec1, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath_unk_hashtype\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_SCRIPTPATH_INVALID_SIG)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r470406543",
      "id" : 470406543,
      "in_reply_to_id" : 467960891,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQwNjU0Mw==",
      "original_commit_id" : "8692041ef50b36ade662561371c0175a70bd8fec",
      "original_line" : 647,
      "original_position" : 647,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 467303047,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/470406543",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r470406595"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/470406595"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ah yes, I forgot you could do that.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-14T04:41:40Z",
      "diff_hunk" : "@@ -0,0 +1,1271 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expreesion for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        _, negated = compute_xonly_pubkey(key)\n+        return tweak_add_privkey(key, tweak, negated)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    tx.vin[idx].scriptSig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    tx.wit.vtxinwit[idx].scriptWitness.stack = flatten(get(ctx, \"witness\"))\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert(tap is None)\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert(script is None)\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            spend(tx, idx, utxos, **conf)\n+        else:\n+            assert(failure is not None)\n+            spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+# Expected error strings\n+ERR_KEYPATH_INVALID_SIG = {\"err_msg\": \"Invalid signature for Taproot key path spending\"}\n+ERR_SCRIPTPATH_INVALID_SIG = {\"err_msg\": \"Signature must be zero for failed CHECK(MULTI)SIG operation\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Extra items left on stack after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    sec = generate_privkey()\n+    pub, _ = compute_xonly_pubkey(sec)\n+    tap = taproot_construct(pub)\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=sec, failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=sec, failure={\"sighash\": bitflipper(default_sighash)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=sec, failure={\"flag_flip_r\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=sec, failure={\"flag_flip_p\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=sec, failure={\"signature\": bitflipper(default_signature)}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+        sec1, sec2 = generate_privkey(), generate_privkey()\n+        pub1, _ = compute_xonly_pubkey(sec1)\n+        pub2, _ = compute_xonly_pubkey(sec2)\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pub1)\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pub2)))]\n+            tap = taproot_construct(pub1, scripts)\n+            add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"s0\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+        # Test OP_CODESEPARATOR impact on sighashing.\n+        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+        common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+        scripts = [\n+            (\"pk_codesep\", CScript(random_checksig_style(pub2) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig\n+            (\"codesep_pk\", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pub2))),  # codesep before checksig\n+            (\"branched_codesep\", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pub1, OP_ELSE, OP_CODESEPARATOR, pub2, OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pub1, scripts)\n+        add_spender(spenders, \"sighash/pk_codesep\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/codesep_pk\", tap=tap, leaf=\"codesep_pk\", key=sec2, codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/left\", tap=tap, leaf=\"branched_codesep\", key=sec1, codeseppos=3, **common, inputs=[getter(\"sign\"), b'\\x01'], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/right\", tap=tap, leaf=\"branched_codesep\", key=sec2, codeseppos=6, **common, inputs=[getter(\"sign\"), b''], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Reusing the scripts above, test that various features affect the sighash.\n+    add_spender(spenders, \"sighash/annex\", tap=tap, leaf=\"pk_codesep\", key=sec2, hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={\"sighash\": override(default_sighash, annex=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/script\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, script_taproot=tap.leaves[\"codesep_pk\"].script)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/leafver\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leafversion=0xc2)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leaf=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, failure={\"sighash\": override(default_sighash, leaf=\"pk_codesep\")}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # Test that invalid hashtypes don't work, both in key path and script path spends\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for invalid_hashtype in range(256):\n+        if invalid_hashtype not in VALID_SIGHASHES_TAPROOT:\n+            add_spender(spenders, \"sighash/keypath_unk_hashtype\", tap=tap, key=sec1, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath_unk_hashtype\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Test that hashtype 0 cannot have a hashtype byte, and 1 must have one.\n+    add_spender(spenders, \"sighash/hashtype0_byte_keypath\", tap=tap, key=sec1, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_keypath\", tap=tap, key=sec1, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    # Test that hashtype 0 and hashtype 1 cannot be transmuted into each other.\n+    add_spender(spenders, \"sighash/hashtype0to1_keypath\", tap=tap, key=sec1, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0to1_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_keypath\", tap=tap, key=sec1, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # == Test that BIP341 spending only applies to witness version 1, program length 32, no P2SH ==\n+\n+    for p2sh in [False, True]:\n+        for witver in range(1, 17):\n+            for witlen in [20, 31, 32, 33]:\n+                def mutate(spk):\n+                    prog = spk[2:]\n+                    assert(len(prog) == 32)\n+                    if witlen < 32:\n+                        prog = prog[0:witlen]\n+                    elif witlen > 32:\n+                        prog += bytes([0 for _ in range(witlen - 32)])\n+                    return CScript([CScriptOp.encode_op_n(witver), prog])\n+                scripts = [(\"s0\", CScript([pub1, OP_CHECKSIG])), (\"dummy\", CScript([OP_RETURN]))]\n+                tap = taproot_construct(pub2, scripts)\n+                if not p2sh and witver == 1 and witlen == 32:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=sec2, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=sec1, **SINGLE_SIG, failure={\"leaf\": \"dummy\"}, **ERR_OP_RETURN)\n+                else:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=sec2, standard=False)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=sec1, **SINGLE_SIG, standard=False)\n+\n+    # == Test various aspects of BIP341 spending paths ==\n+\n+    # A set of functions that compute the hashing partner in a Merkle tree, designed to exercise\n+    # edge cases. This relies on the taproot_construct feature that a lambda can be passed in\n+    # instead of a subtree, to compute the partner to be hashed with.\n+    PARTNER_MERKLE_FN = [\n+        # Combine with itself\n+        lambda h: h,\n+        # Combine with hash 0\n+        lambda h: bytes([0 for _ in range(32)]),\n+        # Combine with hash 2^256-1\n+        lambda h: bytes([0xff for _ in range(32)]),\n+        # Combine with itself-1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') + 1).to_bytes(32, 'big'),\n+        # Combine with itself-1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') + 1).to_bytes(32, 'little'),\n+        # Combine with random bitflipped version of self.\n+        lambda h: (int.from_bytes(h, 'little') ^ (1 << random.randrange(256))).to_bytes(32, 'little')\n+    ]\n+    # Start with a tree of that has depth 1 for \"128deep\" and depth 2 for \"129deep\".\n+    scripts = [(\"128deep\", CScript([pub1, OP_CHECKSIG])), [(\"129deep\", CScript([pub1, OP_CHECKSIG])), random.choice(PARTNER_MERKLE_FN)]]\n+    # Add 127 nodes on top of that tree, so that \"128deep\" and \"129deep\" end up at their designated depths.\n+    for _ in range(127):\n+        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+    tap = taproot_construct(pub1, scripts)\n+    # Test that spends with a depth of 128 work, but 129 doesn't (even with a tree with weird Merkle branches in it).\n+    add_spender(spenders, \"spendpath/merklelimit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"leaf\": \"129deep\"}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that flipping the negation bit invalidates spends.\n+    add_spender(spenders, \"spendpath/negflag\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"negflag\": lambda ctx: 1 - default_negflag(ctx)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the Merkle branch invalidate it.\n+    add_spender(spenders, \"spendpath/bitflipmerkle\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"merklebranch\": bitflipper(default_merklebranch)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the inner pubkey invalidate it.\n+    add_spender(spenders, \"spendpath/bitflippubkey\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"pubkey_inner\": bitflipper(default_pubkey_inner)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that empty witnesses are invalid.\n+    add_spender(spenders, \"spendpath/emptywit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"witness\": []}, **ERR_EMPTY_WITNESS)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padlongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/trunclongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    scripts = [(\"s\", CScript([pub1, OP_CHECKSIG]))]\n+    tap = taproot_construct(pub2, scripts)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/truncshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block to 1 byte (\"-1 Merkle length\") invalidates it\n+    add_spender(spenders, \"spendpath/trunc1shortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:1]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    # == Test BIP342 edge cases ==\n+\n+    checksigadd_val = random.randrange(17, 100) # Above OP_16 to avoid minimal encoding complaints\n+    checksigadd_arg = CScriptNum(checksigadd_val)\n+    checksigadd_result = CScriptNum(checksigadd_val+1)\n+    OVERSIZE_NUMBER = 2**31\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER))), 6)\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER-1))), 5)\n+\n+    # Various BIP342 features\n+    scripts = [\n+        # 0) drop stack element and OP_CHECKSIG\n+        (\"t0\", CScript([OP_DROP, pub2, OP_CHECKSIG])),\n+        # 1) normal OP_CHECKSIG\n+        (\"t1\", CScript([pub2, OP_CHECKSIG])),\n+        # 2) normal OP_CHECKSIGVERIFY\n+        (\"t2\", CScript([pub2, OP_CHECKSIGVERIFY, OP_1])),\n+        # 3) Hypothetical OP_CHECKMULTISIG script that takes a single sig as input\n+        (\"t3\", CScript([OP_0, OP_SWAP, OP_1, pub2, OP_1, OP_CHECKMULTISIG])),\n+        # 4) Hypothetical OP_CHECKMULTISIGVERIFY script that takes a single sig as input\n+        (\"t4\", CScript([OP_0, OP_SWAP, OP_1, pub2, OP_1, OP_CHECKMULTISIGVERIFY, OP_1])),\n+        # 5) OP_IF script that needs a true input\n+        (\"t5\", CScript([OP_IF, pub2, OP_CHECKSIG, OP_ELSE, OP_RETURN, OP_ENDIF])),\n+        # 6) OP_NOTIF script that needs a true input\n+        (\"t6\", CScript([OP_NOTIF, OP_RETURN, OP_ELSE, pub2, OP_CHECKSIG, OP_ENDIF])),\n+        # 7) OP_CHECKSIG with an empty key\n+        (\"t7\", CScript([OP_0, OP_CHECKSIG])),\n+        # 8) OP_CHECKSIGVERIFY with an empty key\n+        (\"t8\", CScript([OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 9) normal OP_CHECKSIGADD that also ensures return value is correct\n+        (\"t9\", CScript([OP_0, pub2, OP_CHECKSIGADD, OP_1, OP_EQUAL])),\n+        # 10) OP_CHECKSIGADD with empty key\n+        (\"t10\", CScript([OP_0, OP_0, OP_CHECKSIGADD])),\n+        # 11) OP_CHECKSIGADD with missing counter stack element\n+        (\"t11\", CScript([pub2, OP_CHECKSIGADD])),\n+        # 12) OP_CHECKSIG that needs invalid signature\n+        (\"t12\", CScript([pub2, OP_CHECKSIGVERIFY, pub1, OP_CHECKSIG, OP_NOT])),\n+        # 13) OP_CHECKSIG with empty key that needs invalid signature\n+        (\"t13\", CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_CHECKSIG, OP_NOT])),\n+        # 14) OP_CHECKSIGADD that needs invalid signature\n+        (\"t14\", CScript([pub2, OP_CHECKSIGVERIFY, OP_0, pub1, OP_CHECKSIGADD, OP_NOT])),\n+        # 15) OP_CHECKSIGADD with empty key that needs invalid signature\n+        (\"t15\", CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGADD, OP_NOT])),\n+        # 16) OP_CHECKSIG with unknown pubkey type\n+        (\"t16\", CScript([OP_1, OP_CHECKSIG])),\n+        # 17) OP_CHECKSIGADD with unknown pubkey type\n+        (\"t17\", CScript([OP_0, OP_1, OP_CHECKSIGADD])),\n+        # 18) OP_CHECKSIGVERIFY with unknown pubkey type\n+        (\"t18\", CScript([OP_1, OP_CHECKSIGVERIFY, OP_1])),\n+        # 19) script longer than 10000 bytes and over 201 non-push opcodes\n+        (\"t19\", CScript([OP_0, OP_0, OP_2DROP] * 10001 + [pub2, OP_CHECKSIG])),\n+        # 20) OP_CHECKSIGVERIFY with empty key\n+        (\"t20\", CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 21) Script that grows the stack to 1000 elements\n+        (\"t21\", CScript([pub2, OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 999 + [OP_DROP] * 999)),\n+        # 22) Script that grows the stack to 1001 elements\n+        (\"t22\", CScript([pub2, OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 1000 + [OP_DROP] * 1000)),\n+        # 23) Script that expects an input stack of 1000 elements\n+        (\"t23\", CScript([OP_DROP] * 999 + [pub2, OP_CHECKSIG])),\n+        # 24) Script that expects an input stack of 1001 elements\n+        (\"t24\", CScript([OP_DROP] * 1000 + [pub2, OP_CHECKSIG])),\n+        # 25) Script that pushes a MAX_SCRIPT_ELEMENT_SIZE-bytes element\n+        (\"t25\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE), OP_DROP, pub2, OP_CHECKSIG])),\n+        # 26) Script that pushes a (MAX_SCRIPT_ELEMENT_SIZE+1)-bytes element\n+        (\"t26\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, pub2, OP_CHECKSIG])),\n+        # 27) CHECKSIGADD that must fail because numeric argument number is >4 bytes\n+        (\"t27\", CScript([CScriptNum(OVERSIZE_NUMBER), pub2, OP_CHECKSIGADD])),\n+        # 28) Pushes random CScriptNum value, checks OP_CHECKSIGADD result\n+        (\"t28\", CScript([checksigadd_arg, pub2, OP_CHECKSIGADD, checksigadd_result, OP_EQUAL])),\n+        # 29) CHECKSIGADD that succeeds with proper sig because numeric argument number is <=4 bytes\n+        (\"t29\", CScript([CScriptNum(OVERSIZE_NUMBER-1), pub2, OP_CHECKSIGADD])),\n+        # 30) Variant of t1 with \"normal\" 33-byte pubkey\n+        (\"t30\", CScript([b'\\x03' + pub2, OP_CHECKSIG])),\n+        # 31) Variant of t2 with \"normal\" 33-byte pubkey\n+        (\"t31\", CScript([b'\\x02' + pub2, OP_CHECKSIGVERIFY, OP_1])),\n+        # 32) Variant of t28 with \"normal\" 33-byte pubkey\n+        (\"t32\", CScript([checksigadd_arg, b'\\x03' + pub2, OP_CHECKSIGADD, checksigadd_result, OP_EQUAL])),\n+    ]\n+    random.shuffle(scripts)\n+    tap = taproot_construct(pub1, scripts)\n+    common = {\n+        \"hashtype\": hashtype,\n+        \"key\": sec2,\n+        \"tap\": tap,\n+    }\n+    # Test that MAX_SCRIPT_ELEMENT_SIZE byte stack element inputs are valid, but not one more (and 80 bytes is standard but 81 is not).\n+    add_spender(spenders, \"tapscript/inputmaxlimit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE)], failure={\"inputs\": [getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1)]}, **ERR_PUSH_LIMIT)\n+    add_spender(spenders, \"tapscript/input80limit\", leaf=\"t0\", **common, inputs=[getter(\"sign\"), random_bytes(80)])\n+    add_spender(spenders, \"tapscript/input81limit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(81)])\n+    # Test that OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY cause failure, but OP_CHECKSIG and OP_CHECKSIGVERIFY work.\n+    add_spender(spenders, \"tapscript/disabled_checkmultisig\", leaf=\"t1\", **common, **SINGLE_SIG, failure={\"leaf\": \"t3\"}, **ERR_DISABLED_OPCODE)\n+    add_spender(spenders, \"tapscript/disabled_checkmultisigverify\", leaf=\"t2\", **common, **SINGLE_SIG, failure={\"leaf\": \"t4\"}, **ERR_DISABLED_OPCODE)\n+    # Test that OP_IF and OP_NOTIF do not accept non-0x01 as truth value (the MINIMALIF rule is consensus in Tapscript)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x02']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x03']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0001']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0100']}, **ERR_MINIMALIF)\n+    # Test that 1-byte public keys (which are unknown) are acceptable but nonstandard with unrelated signatures, but 0-byte public keys are not valid.\n+    add_spender(spenders, \"tapscript/unkpk/checksig\", leaf=\"t16\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigadd\", leaf=\"t17\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigverify\", leaf=\"t18\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that 33-byte public keys (which are unknown) are acceptable but nonstandard with valid signatures, but normal pubkeys are not valid in that case.\n+    add_spender(spenders, \"tapscript/oldpk/checksig\", leaf=\"t30\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t1\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"tapscript/oldpk/checksigadd\", leaf=\"t31\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t2\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"tapscript/oldpk/checksigverify\", leaf=\"t32\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t28\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    # Test that 0-byte public keys are not acceptable.\n+    add_spender(spenders, \"tapscript/emptypk/checksig\", leaf=\"t1\", **SINGLE_SIG, **common, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigverify\", leaf=\"t2\", **SINGLE_SIG, **common, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigadd\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that OP_CHECKSIGADD results are as expected\n+    add_spender(spenders, \"tapscript/checksigaddresults\", leaf=\"t28\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    add_spender(spenders, \"tapscript/checksigaddoversize\", leaf=\"t29\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    # Test that OP_CHECKSIGADD requires 3 stack elements.\n+    add_spender(spenders, \"tapscript/checksigadd3args\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t11\"}, **ERR_STACK_EMPTY)\n+    # Test that empty signatures do not cause script failure in OP_CHECKSIG and OP_CHECKSIGADD (but do fail with empty pubkey, and do fail OP_CHECKSIGVERIFY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksig\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t13\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/nochecksigverify\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t20\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksigadd\", leaf=\"t14\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t15\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that scripts over 10000 bytes (and over 201 non-push ops) are acceptable.\n+    add_spender(spenders, \"tapscript/no10000limit\", leaf=\"t19\", **SINGLE_SIG, **common)\n+    # Test that a stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000stack\", leaf=\"t21\", **SINGLE_SIG, **common, failure={\"leaf\": \"t22\"}, **ERR_STACK_SIZE)\n+    # Test that an input stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000inputs\", leaf=\"t23\", **common, inputs=[getter(\"sign\")] + [b'' for _ in range(999)], failure={\"leaf\": \"t24\", \"inputs\": [getter(\"sign\")] + [b'' for _ in range(1000)]}, **ERR_STACK_SIZE)\n+    # Test that pushing a MAX_SCRIPT_ELEMENT_SIZE byte stack element is valid, but one longer is not.\n+    add_spender(spenders, \"tapscript/pushmaxlimit\", leaf=\"t25\", **common, **SINGLE_SIG, failure={\"leaf\": \"t26\"}, **ERR_PUSH_LIMIT)\n+\n+    # == Test for sigops ratio limit ==\n+\n+    # Given a number n, and a public key pk, functions that produces a (CScript, sigops). Each script takes as\n+    # input a valid signature with the passed pk followed by a dummy, and will execute sigops signature checks.\n+    SIGOPS_RATIO_SCRIPTS = [\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIG.\n+        lambda n, pk: (CScript([OP_DROP, pk] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGVERIFY.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_0, OP_IF, OP_2DUP, OP_CHECKSIGVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_2, OP_SWAP, OP_CHECKSIGADD, OP_3, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIG.\n+        lambda n, pk: (CScript([random_bytes(220), OP_2DROP, pk, OP_1, OP_NOTIF, OP_2DUP, OP_CHECKSIG, OP_VERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_4, OP_SWAP, OP_CHECKSIGADD, OP_5, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGADD.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_1, OP_IF, OP_ELSE, OP_2DUP, OP_6, OP_SWAP, OP_CHECKSIGADD, OP_7, OP_EQUALVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_8, OP_SWAP, OP_CHECKSIGADD, OP_9, OP_EQUAL]), n + 1),\n+        # n+1 OP_CHECKSIGs, but also one OP_CHECKSIG with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, pk, OP_CHECKSIG, OP_NOT, OP_VERIFY, pk] + [OP_2DUP, OP_CHECKSIG, OP_VERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGADDs and 1 OP_CHECKSIG, but also an OP_CHECKSIGADD with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, OP_10, pk, OP_CHECKSIGADD, OP_10, OP_EQUALVERIFY, pk] + [OP_2DUP, OP_16, OP_SWAP, OP_CHECKSIGADD, b'\\x11', OP_EQUALVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+    ]\n+    for annex in [None, bytes([ANNEX_TAG]) + random_bytes(random.randrange(1000))]:\n+        for hashtype in [SIGHASH_DEFAULT, SIGHASH_ALL]:\n+            for pubkey in [pub2, random_bytes(random.choice([x for x in range(2, 81) if x != 32]))]:\n+                for fn_num, fn in enumerate(SIGOPS_RATIO_SCRIPTS):\n+                    merkledepth = random.randrange(129)\n+                    def predict_sigops_ratio(n, dummy_size):\n+                        script, sigops = fn(n, pubkey)\n+                        # Predict the size of the witness for a given choice of n\n+                        stacklen_size = 1\n+                        sig_size = 64 + (hashtype != SIGHASH_DEFAULT)\n+                        siglen_size = 1\n+                        dummylen_size = 1 + 2 * (dummy_size >= 253)\n+                        script_size = len(script)\n+                        scriptlen_size = 1 + 2 * (script_size >= 253)\n+                        control_size = 33 + 32 * merkledepth\n+                        controllen_size = 1 + 2 * (control_size >= 253)\n+                        annex_size = 0 if annex is None else len(annex)\n+                        annexlen_size = 0 if annex is None else 1 + 2 * (annex_size >= 253)\n+                        witsize = stacklen_size + sig_size + siglen_size + dummy_size + dummylen_size + script_size + scriptlen_size + control_size + controllen_size + annex_size + annexlen_size\n+                        # sigops ratio test\n+                        return witsize + 50 >= 50 * sigops\n+                    # Make sure n is high enough that with empty dummy, the script is not valid\n+                    n = 0\n+                    while predict_sigops_ratio(n, 0):\n+                        n += 1\n+                    # But allow picking a bit higher still\n+                    n += random.randrange(5)\n+                    # Now pick dummy size *just* large enough that the overall construction passes\n+                    dummylen = 0\n+                    while not predict_sigops_ratio(n, dummylen):\n+                        dummylen += 1\n+                    scripts = [(\"s\", fn(n, pubkey)[0])]\n+                    for _ in range(merkledepth):\n+                        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+                    tap = taproot_construct(pub1, scripts)\n+                    standard = annex is None and dummylen <= 80 and len(pubkey) == 32\n+                    add_spender(spenders, \"tapscript/sigopsratio_%i\" % fn_num, tap=tap, leaf=\"s\", annex=annex, hashtype=hashtype, key=sec2, inputs=[getter(\"sign\"), random_bytes(dummylen)], standard=standard, failure={\"inputs\": [getter(\"sign\"), random_bytes(dummylen - 1)]}, **ERR_SIGOPS_RATIO)\n+        # Future leaf versions\n+    for leafver in range(0, 0x100, 2):\n+        if leafver == LEAF_VERSION_TAPSCRIPT or leafver == ANNEX_TAG:\n+            # Skip the defined LEAF_VERSION_TAPSCRIPT, and the ANNEX_TAG which is not usable as leaf version\n+            continue\n+        scripts = [\n+            (\"bare_c0\", CScript([OP_NOP])),\n+            (\"bare_unkver\", CScript([OP_NOP]), leafver),\n+            (\"return_c0\", CScript([OP_RETURN])),\n+            (\"return_unkver\", CScript([OP_RETURN]), leafver),\n+            (\"undecodable_c0\", CScript([OP_PUSHDATA1])),\n+            (\"undecodable_unkver\", CScript([OP_PUSHDATA1]), leafver),\n+            (\"bigpush_c0\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP])),\n+            (\"bigpush_unkver\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP]), leafver),\n+            (\"1001push_c0\", CScript([OP_0] * 1001)),\n+            (\"1001push_unkver\", CScript([OP_0] * 1001), leafver),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pub1, scripts)\n+        add_spender(spenders, \"unkver/bare\", standard=False, tap=tap, leaf=\"bare_unkver\", failure={\"leaf\": \"bare_c0\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"unkver/return\", standard=False, tap=tap, leaf=\"return_unkver\", failure={\"leaf\": \"return_c0\"}, **ERR_OP_RETURN)\n+        add_spender(spenders, \"unkver/undecodable\", standard=False, tap=tap, leaf=\"undecodable_unkver\", failure={\"leaf\": \"undecodable_c0\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"unkver/bigpush\", standard=False, tap=tap, leaf=\"bigpush_unkver\", failure={\"leaf\": \"bigpush_c0\"}, **ERR_PUSH_LIMIT)\n+        add_spender(spenders, \"unkver/1001push\", standard=False, tap=tap, leaf=\"1001push_unkver\", failure={\"leaf\": \"1001push_c0\"}, **ERR_STACK_SIZE)\n+        add_spender(spenders, \"unkver/1001inputs\", standard=False, tap=tap, leaf=\"bare_unkver\", inputs=[b'' for _ in range(1001)], failure={\"leaf\": \"bare_c0\"}, **ERR_STACK_SIZE)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r470406595",
      "id" : 470406595,
      "in_reply_to_id" : 467968687,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQwNjU5NQ==",
      "original_commit_id" : "8692041ef50b36ade662561371c0175a70bd8fec",
      "original_line" : 941,
      "original_position" : 941,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 467303102,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/470406595",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r470406642"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/470406642"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-14T04:41:49Z",
      "diff_hunk" : "@@ -0,0 +1,1271 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expreesion for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        _, negated = compute_xonly_pubkey(key)\n+        return tweak_add_privkey(key, tweak, negated)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    tx.vin[idx].scriptSig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    tx.wit.vtxinwit[idx].scriptWitness.stack = flatten(get(ctx, \"witness\"))\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert(tap is None)\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert(script is None)\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            spend(tx, idx, utxos, **conf)\n+        else:\n+            assert(failure is not None)\n+            spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+# Expected error strings\n+ERR_KEYPATH_INVALID_SIG = {\"err_msg\": \"Invalid signature for Taproot key path spending\"}\n+ERR_SCRIPTPATH_INVALID_SIG = {\"err_msg\": \"Signature must be zero for failed CHECK(MULTI)SIG operation\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Extra items left on stack after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    sec = generate_privkey()\n+    pub, _ = compute_xonly_pubkey(sec)\n+    tap = taproot_construct(pub)\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=sec, failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=sec, failure={\"sighash\": bitflipper(default_sighash)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=sec, failure={\"flag_flip_r\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=sec, failure={\"flag_flip_p\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=sec, failure={\"signature\": bitflipper(default_signature)}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+        sec1, sec2 = generate_privkey(), generate_privkey()\n+        pub1, _ = compute_xonly_pubkey(sec1)\n+        pub2, _ = compute_xonly_pubkey(sec2)\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pub1)\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pub2)))]\n+            tap = taproot_construct(pub1, scripts)\n+            add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"s0\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+        # Test OP_CODESEPARATOR impact on sighashing.\n+        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+        common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+        scripts = [\n+            (\"pk_codesep\", CScript(random_checksig_style(pub2) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig\n+            (\"codesep_pk\", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pub2))),  # codesep before checksig\n+            (\"branched_codesep\", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pub1, OP_ELSE, OP_CODESEPARATOR, pub2, OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pub1, scripts)\n+        add_spender(spenders, \"sighash/pk_codesep\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/codesep_pk\", tap=tap, leaf=\"codesep_pk\", key=sec2, codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/left\", tap=tap, leaf=\"branched_codesep\", key=sec1, codeseppos=3, **common, inputs=[getter(\"sign\"), b'\\x01'], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/right\", tap=tap, leaf=\"branched_codesep\", key=sec2, codeseppos=6, **common, inputs=[getter(\"sign\"), b''], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Reusing the scripts above, test that various features affect the sighash.\n+    add_spender(spenders, \"sighash/annex\", tap=tap, leaf=\"pk_codesep\", key=sec2, hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={\"sighash\": override(default_sighash, annex=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/script\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, script_taproot=tap.leaves[\"codesep_pk\"].script)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/leafver\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leafversion=0xc2)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leaf=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, failure={\"sighash\": override(default_sighash, leaf=\"pk_codesep\")}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # Test that invalid hashtypes don't work, both in key path and script path spends\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for invalid_hashtype in range(256):\n+        if invalid_hashtype not in VALID_SIGHASHES_TAPROOT:\n+            add_spender(spenders, \"sighash/keypath_unk_hashtype\", tap=tap, key=sec1, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath_unk_hashtype\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Test that hashtype 0 cannot have a hashtype byte, and 1 must have one.\n+    add_spender(spenders, \"sighash/hashtype0_byte_keypath\", tap=tap, key=sec1, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_keypath\", tap=tap, key=sec1, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    # Test that hashtype 0 and hashtype 1 cannot be transmuted into each other.\n+    add_spender(spenders, \"sighash/hashtype0to1_keypath\", tap=tap, key=sec1, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0to1_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_keypath\", tap=tap, key=sec1, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # == Test that BIP341 spending only applies to witness version 1, program length 32, no P2SH ==\n+\n+    for p2sh in [False, True]:\n+        for witver in range(1, 17):\n+            for witlen in [20, 31, 32, 33]:\n+                def mutate(spk):\n+                    prog = spk[2:]\n+                    assert(len(prog) == 32)\n+                    if witlen < 32:\n+                        prog = prog[0:witlen]\n+                    elif witlen > 32:\n+                        prog += bytes([0 for _ in range(witlen - 32)])\n+                    return CScript([CScriptOp.encode_op_n(witver), prog])\n+                scripts = [(\"s0\", CScript([pub1, OP_CHECKSIG])), (\"dummy\", CScript([OP_RETURN]))]\n+                tap = taproot_construct(pub2, scripts)\n+                if not p2sh and witver == 1 and witlen == 32:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=sec2, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=sec1, **SINGLE_SIG, failure={\"leaf\": \"dummy\"}, **ERR_OP_RETURN)\n+                else:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=sec2, standard=False)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=sec1, **SINGLE_SIG, standard=False)\n+\n+    # == Test various aspects of BIP341 spending paths ==\n+\n+    # A set of functions that compute the hashing partner in a Merkle tree, designed to exercise\n+    # edge cases. This relies on the taproot_construct feature that a lambda can be passed in\n+    # instead of a subtree, to compute the partner to be hashed with.\n+    PARTNER_MERKLE_FN = [\n+        # Combine with itself\n+        lambda h: h,\n+        # Combine with hash 0\n+        lambda h: bytes([0 for _ in range(32)]),\n+        # Combine with hash 2^256-1\n+        lambda h: bytes([0xff for _ in range(32)]),\n+        # Combine with itself-1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') + 1).to_bytes(32, 'big'),\n+        # Combine with itself-1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') + 1).to_bytes(32, 'little'),\n+        # Combine with random bitflipped version of self.\n+        lambda h: (int.from_bytes(h, 'little') ^ (1 << random.randrange(256))).to_bytes(32, 'little')\n+    ]\n+    # Start with a tree of that has depth 1 for \"128deep\" and depth 2 for \"129deep\".\n+    scripts = [(\"128deep\", CScript([pub1, OP_CHECKSIG])), [(\"129deep\", CScript([pub1, OP_CHECKSIG])), random.choice(PARTNER_MERKLE_FN)]]\n+    # Add 127 nodes on top of that tree, so that \"128deep\" and \"129deep\" end up at their designated depths.\n+    for _ in range(127):\n+        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+    tap = taproot_construct(pub1, scripts)\n+    # Test that spends with a depth of 128 work, but 129 doesn't (even with a tree with weird Merkle branches in it).\n+    add_spender(spenders, \"spendpath/merklelimit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"leaf\": \"129deep\"}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that flipping the negation bit invalidates spends.\n+    add_spender(spenders, \"spendpath/negflag\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"negflag\": lambda ctx: 1 - default_negflag(ctx)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the Merkle branch invalidate it.\n+    add_spender(spenders, \"spendpath/bitflipmerkle\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"merklebranch\": bitflipper(default_merklebranch)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the inner pubkey invalidate it.\n+    add_spender(spenders, \"spendpath/bitflippubkey\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"pubkey_inner\": bitflipper(default_pubkey_inner)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that empty witnesses are invalid.\n+    add_spender(spenders, \"spendpath/emptywit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"witness\": []}, **ERR_EMPTY_WITNESS)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padlongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/trunclongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    scripts = [(\"s\", CScript([pub1, OP_CHECKSIG]))]\n+    tap = taproot_construct(pub2, scripts)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/truncshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block to 1 byte (\"-1 Merkle length\") invalidates it\n+    add_spender(spenders, \"spendpath/trunc1shortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:1]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    # == Test BIP342 edge cases ==\n+\n+    checksigadd_val = random.randrange(17, 100) # Above OP_16 to avoid minimal encoding complaints\n+    checksigadd_arg = CScriptNum(checksigadd_val)\n+    checksigadd_result = CScriptNum(checksigadd_val+1)\n+    OVERSIZE_NUMBER = 2**31\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER))), 6)\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER-1))), 5)\n+\n+    # Various BIP342 features\n+    scripts = [\n+        # 0) drop stack element and OP_CHECKSIG\n+        (\"t0\", CScript([OP_DROP, pub2, OP_CHECKSIG])),\n+        # 1) normal OP_CHECKSIG\n+        (\"t1\", CScript([pub2, OP_CHECKSIG])),\n+        # 2) normal OP_CHECKSIGVERIFY\n+        (\"t2\", CScript([pub2, OP_CHECKSIGVERIFY, OP_1])),\n+        # 3) Hypothetical OP_CHECKMULTISIG script that takes a single sig as input\n+        (\"t3\", CScript([OP_0, OP_SWAP, OP_1, pub2, OP_1, OP_CHECKMULTISIG])),\n+        # 4) Hypothetical OP_CHECKMULTISIGVERIFY script that takes a single sig as input\n+        (\"t4\", CScript([OP_0, OP_SWAP, OP_1, pub2, OP_1, OP_CHECKMULTISIGVERIFY, OP_1])),\n+        # 5) OP_IF script that needs a true input\n+        (\"t5\", CScript([OP_IF, pub2, OP_CHECKSIG, OP_ELSE, OP_RETURN, OP_ENDIF])),\n+        # 6) OP_NOTIF script that needs a true input\n+        (\"t6\", CScript([OP_NOTIF, OP_RETURN, OP_ELSE, pub2, OP_CHECKSIG, OP_ENDIF])),\n+        # 7) OP_CHECKSIG with an empty key\n+        (\"t7\", CScript([OP_0, OP_CHECKSIG])),\n+        # 8) OP_CHECKSIGVERIFY with an empty key\n+        (\"t8\", CScript([OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 9) normal OP_CHECKSIGADD that also ensures return value is correct\n+        (\"t9\", CScript([OP_0, pub2, OP_CHECKSIGADD, OP_1, OP_EQUAL])),\n+        # 10) OP_CHECKSIGADD with empty key\n+        (\"t10\", CScript([OP_0, OP_0, OP_CHECKSIGADD])),\n+        # 11) OP_CHECKSIGADD with missing counter stack element\n+        (\"t11\", CScript([pub2, OP_CHECKSIGADD])),\n+        # 12) OP_CHECKSIG that needs invalid signature\n+        (\"t12\", CScript([pub2, OP_CHECKSIGVERIFY, pub1, OP_CHECKSIG, OP_NOT])),\n+        # 13) OP_CHECKSIG with empty key that needs invalid signature\n+        (\"t13\", CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_CHECKSIG, OP_NOT])),\n+        # 14) OP_CHECKSIGADD that needs invalid signature\n+        (\"t14\", CScript([pub2, OP_CHECKSIGVERIFY, OP_0, pub1, OP_CHECKSIGADD, OP_NOT])),\n+        # 15) OP_CHECKSIGADD with empty key that needs invalid signature\n+        (\"t15\", CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGADD, OP_NOT])),\n+        # 16) OP_CHECKSIG with unknown pubkey type\n+        (\"t16\", CScript([OP_1, OP_CHECKSIG])),\n+        # 17) OP_CHECKSIGADD with unknown pubkey type\n+        (\"t17\", CScript([OP_0, OP_1, OP_CHECKSIGADD])),\n+        # 18) OP_CHECKSIGVERIFY with unknown pubkey type\n+        (\"t18\", CScript([OP_1, OP_CHECKSIGVERIFY, OP_1])),\n+        # 19) script longer than 10000 bytes and over 201 non-push opcodes\n+        (\"t19\", CScript([OP_0, OP_0, OP_2DROP] * 10001 + [pub2, OP_CHECKSIG])),\n+        # 20) OP_CHECKSIGVERIFY with empty key\n+        (\"t20\", CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 21) Script that grows the stack to 1000 elements\n+        (\"t21\", CScript([pub2, OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 999 + [OP_DROP] * 999)),\n+        # 22) Script that grows the stack to 1001 elements\n+        (\"t22\", CScript([pub2, OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 1000 + [OP_DROP] * 1000)),\n+        # 23) Script that expects an input stack of 1000 elements\n+        (\"t23\", CScript([OP_DROP] * 999 + [pub2, OP_CHECKSIG])),\n+        # 24) Script that expects an input stack of 1001 elements\n+        (\"t24\", CScript([OP_DROP] * 1000 + [pub2, OP_CHECKSIG])),\n+        # 25) Script that pushes a MAX_SCRIPT_ELEMENT_SIZE-bytes element\n+        (\"t25\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE), OP_DROP, pub2, OP_CHECKSIG])),\n+        # 26) Script that pushes a (MAX_SCRIPT_ELEMENT_SIZE+1)-bytes element\n+        (\"t26\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, pub2, OP_CHECKSIG])),\n+        # 27) CHECKSIGADD that must fail because numeric argument number is >4 bytes\n+        (\"t27\", CScript([CScriptNum(OVERSIZE_NUMBER), pub2, OP_CHECKSIGADD])),\n+        # 28) Pushes random CScriptNum value, checks OP_CHECKSIGADD result\n+        (\"t28\", CScript([checksigadd_arg, pub2, OP_CHECKSIGADD, checksigadd_result, OP_EQUAL])),\n+        # 29) CHECKSIGADD that succeeds with proper sig because numeric argument number is <=4 bytes\n+        (\"t29\", CScript([CScriptNum(OVERSIZE_NUMBER-1), pub2, OP_CHECKSIGADD])),\n+        # 30) Variant of t1 with \"normal\" 33-byte pubkey\n+        (\"t30\", CScript([b'\\x03' + pub2, OP_CHECKSIG])),\n+        # 31) Variant of t2 with \"normal\" 33-byte pubkey\n+        (\"t31\", CScript([b'\\x02' + pub2, OP_CHECKSIGVERIFY, OP_1])),\n+        # 32) Variant of t28 with \"normal\" 33-byte pubkey\n+        (\"t32\", CScript([checksigadd_arg, b'\\x03' + pub2, OP_CHECKSIGADD, checksigadd_result, OP_EQUAL])),\n+    ]\n+    random.shuffle(scripts)\n+    tap = taproot_construct(pub1, scripts)\n+    common = {\n+        \"hashtype\": hashtype,\n+        \"key\": sec2,\n+        \"tap\": tap,\n+    }\n+    # Test that MAX_SCRIPT_ELEMENT_SIZE byte stack element inputs are valid, but not one more (and 80 bytes is standard but 81 is not).\n+    add_spender(spenders, \"tapscript/inputmaxlimit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE)], failure={\"inputs\": [getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1)]}, **ERR_PUSH_LIMIT)\n+    add_spender(spenders, \"tapscript/input80limit\", leaf=\"t0\", **common, inputs=[getter(\"sign\"), random_bytes(80)])\n+    add_spender(spenders, \"tapscript/input81limit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(81)])\n+    # Test that OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY cause failure, but OP_CHECKSIG and OP_CHECKSIGVERIFY work.\n+    add_spender(spenders, \"tapscript/disabled_checkmultisig\", leaf=\"t1\", **common, **SINGLE_SIG, failure={\"leaf\": \"t3\"}, **ERR_DISABLED_OPCODE)\n+    add_spender(spenders, \"tapscript/disabled_checkmultisigverify\", leaf=\"t2\", **common, **SINGLE_SIG, failure={\"leaf\": \"t4\"}, **ERR_DISABLED_OPCODE)\n+    # Test that OP_IF and OP_NOTIF do not accept non-0x01 as truth value (the MINIMALIF rule is consensus in Tapscript)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x02']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x03']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0001']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0100']}, **ERR_MINIMALIF)\n+    # Test that 1-byte public keys (which are unknown) are acceptable but nonstandard with unrelated signatures, but 0-byte public keys are not valid.\n+    add_spender(spenders, \"tapscript/unkpk/checksig\", leaf=\"t16\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigadd\", leaf=\"t17\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigverify\", leaf=\"t18\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that 33-byte public keys (which are unknown) are acceptable but nonstandard with valid signatures, but normal pubkeys are not valid in that case.\n+    add_spender(spenders, \"tapscript/oldpk/checksig\", leaf=\"t30\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t1\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"tapscript/oldpk/checksigadd\", leaf=\"t31\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t2\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"tapscript/oldpk/checksigverify\", leaf=\"t32\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t28\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    # Test that 0-byte public keys are not acceptable.\n+    add_spender(spenders, \"tapscript/emptypk/checksig\", leaf=\"t1\", **SINGLE_SIG, **common, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigverify\", leaf=\"t2\", **SINGLE_SIG, **common, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigadd\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that OP_CHECKSIGADD results are as expected\n+    add_spender(spenders, \"tapscript/checksigaddresults\", leaf=\"t28\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    add_spender(spenders, \"tapscript/checksigaddoversize\", leaf=\"t29\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    # Test that OP_CHECKSIGADD requires 3 stack elements.\n+    add_spender(spenders, \"tapscript/checksigadd3args\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t11\"}, **ERR_STACK_EMPTY)\n+    # Test that empty signatures do not cause script failure in OP_CHECKSIG and OP_CHECKSIGADD (but do fail with empty pubkey, and do fail OP_CHECKSIGVERIFY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksig\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t13\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/nochecksigverify\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t20\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksigadd\", leaf=\"t14\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t15\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that scripts over 10000 bytes (and over 201 non-push ops) are acceptable.\n+    add_spender(spenders, \"tapscript/no10000limit\", leaf=\"t19\", **SINGLE_SIG, **common)\n+    # Test that a stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000stack\", leaf=\"t21\", **SINGLE_SIG, **common, failure={\"leaf\": \"t22\"}, **ERR_STACK_SIZE)\n+    # Test that an input stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000inputs\", leaf=\"t23\", **common, inputs=[getter(\"sign\")] + [b'' for _ in range(999)], failure={\"leaf\": \"t24\", \"inputs\": [getter(\"sign\")] + [b'' for _ in range(1000)]}, **ERR_STACK_SIZE)\n+    # Test that pushing a MAX_SCRIPT_ELEMENT_SIZE byte stack element is valid, but one longer is not.\n+    add_spender(spenders, \"tapscript/pushmaxlimit\", leaf=\"t25\", **common, **SINGLE_SIG, failure={\"leaf\": \"t26\"}, **ERR_PUSH_LIMIT)\n+\n+    # == Test for sigops ratio limit ==\n+\n+    # Given a number n, and a public key pk, functions that produces a (CScript, sigops). Each script takes as\n+    # input a valid signature with the passed pk followed by a dummy, and will execute sigops signature checks.\n+    SIGOPS_RATIO_SCRIPTS = [\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIG.\n+        lambda n, pk: (CScript([OP_DROP, pk] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGVERIFY.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_0, OP_IF, OP_2DUP, OP_CHECKSIGVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_2, OP_SWAP, OP_CHECKSIGADD, OP_3, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIG.\n+        lambda n, pk: (CScript([random_bytes(220), OP_2DROP, pk, OP_1, OP_NOTIF, OP_2DUP, OP_CHECKSIG, OP_VERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_4, OP_SWAP, OP_CHECKSIGADD, OP_5, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGADD.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_1, OP_IF, OP_ELSE, OP_2DUP, OP_6, OP_SWAP, OP_CHECKSIGADD, OP_7, OP_EQUALVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_8, OP_SWAP, OP_CHECKSIGADD, OP_9, OP_EQUAL]), n + 1),\n+        # n+1 OP_CHECKSIGs, but also one OP_CHECKSIG with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, pk, OP_CHECKSIG, OP_NOT, OP_VERIFY, pk] + [OP_2DUP, OP_CHECKSIG, OP_VERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGADDs and 1 OP_CHECKSIG, but also an OP_CHECKSIGADD with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, OP_10, pk, OP_CHECKSIGADD, OP_10, OP_EQUALVERIFY, pk] + [OP_2DUP, OP_16, OP_SWAP, OP_CHECKSIGADD, b'\\x11', OP_EQUALVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+    ]\n+    for annex in [None, bytes([ANNEX_TAG]) + random_bytes(random.randrange(1000))]:\n+        for hashtype in [SIGHASH_DEFAULT, SIGHASH_ALL]:\n+            for pubkey in [pub2, random_bytes(random.choice([x for x in range(2, 81) if x != 32]))]:\n+                for fn_num, fn in enumerate(SIGOPS_RATIO_SCRIPTS):\n+                    merkledepth = random.randrange(129)\n+                    def predict_sigops_ratio(n, dummy_size):\n+                        script, sigops = fn(n, pubkey)\n+                        # Predict the size of the witness for a given choice of n\n+                        stacklen_size = 1\n+                        sig_size = 64 + (hashtype != SIGHASH_DEFAULT)\n+                        siglen_size = 1\n+                        dummylen_size = 1 + 2 * (dummy_size >= 253)\n+                        script_size = len(script)\n+                        scriptlen_size = 1 + 2 * (script_size >= 253)\n+                        control_size = 33 + 32 * merkledepth\n+                        controllen_size = 1 + 2 * (control_size >= 253)\n+                        annex_size = 0 if annex is None else len(annex)\n+                        annexlen_size = 0 if annex is None else 1 + 2 * (annex_size >= 253)\n+                        witsize = stacklen_size + sig_size + siglen_size + dummy_size + dummylen_size + script_size + scriptlen_size + control_size + controllen_size + annex_size + annexlen_size\n+                        # sigops ratio test\n+                        return witsize + 50 >= 50 * sigops\n+                    # Make sure n is high enough that with empty dummy, the script is not valid\n+                    n = 0\n+                    while predict_sigops_ratio(n, 0):\n+                        n += 1\n+                    # But allow picking a bit higher still\n+                    n += random.randrange(5)\n+                    # Now pick dummy size *just* large enough that the overall construction passes\n+                    dummylen = 0\n+                    while not predict_sigops_ratio(n, dummylen):\n+                        dummylen += 1\n+                    scripts = [(\"s\", fn(n, pubkey)[0])]\n+                    for _ in range(merkledepth):\n+                        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+                    tap = taproot_construct(pub1, scripts)\n+                    standard = annex is None and dummylen <= 80 and len(pubkey) == 32\n+                    add_spender(spenders, \"tapscript/sigopsratio_%i\" % fn_num, tap=tap, leaf=\"s\", annex=annex, hashtype=hashtype, key=sec2, inputs=[getter(\"sign\"), random_bytes(dummylen)], standard=standard, failure={\"inputs\": [getter(\"sign\"), random_bytes(dummylen - 1)]}, **ERR_SIGOPS_RATIO)\n+        # Future leaf versions\n+    for leafver in range(0, 0x100, 2):\n+        if leafver == LEAF_VERSION_TAPSCRIPT or leafver == ANNEX_TAG:\n+            # Skip the defined LEAF_VERSION_TAPSCRIPT, and the ANNEX_TAG which is not usable as leaf version\n+            continue\n+        scripts = [\n+            (\"bare_c0\", CScript([OP_NOP])),\n+            (\"bare_unkver\", CScript([OP_NOP]), leafver),\n+            (\"return_c0\", CScript([OP_RETURN])),\n+            (\"return_unkver\", CScript([OP_RETURN]), leafver),\n+            (\"undecodable_c0\", CScript([OP_PUSHDATA1])),\n+            (\"undecodable_unkver\", CScript([OP_PUSHDATA1]), leafver),\n+            (\"bigpush_c0\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP])),\n+            (\"bigpush_unkver\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP]), leafver),\n+            (\"1001push_c0\", CScript([OP_0] * 1001)),\n+            (\"1001push_unkver\", CScript([OP_0] * 1001), leafver),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pub1, scripts)\n+        add_spender(spenders, \"unkver/bare\", standard=False, tap=tap, leaf=\"bare_unkver\", failure={\"leaf\": \"bare_c0\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"unkver/return\", standard=False, tap=tap, leaf=\"return_unkver\", failure={\"leaf\": \"return_c0\"}, **ERR_OP_RETURN)\n+        add_spender(spenders, \"unkver/undecodable\", standard=False, tap=tap, leaf=\"undecodable_unkver\", failure={\"leaf\": \"undecodable_c0\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"unkver/bigpush\", standard=False, tap=tap, leaf=\"bigpush_unkver\", failure={\"leaf\": \"bigpush_c0\"}, **ERR_PUSH_LIMIT)\n+        add_spender(spenders, \"unkver/1001push\", standard=False, tap=tap, leaf=\"1001push_unkver\", failure={\"leaf\": \"1001push_c0\"}, **ERR_STACK_SIZE)\n+        add_spender(spenders, \"unkver/1001inputs\", standard=False, tap=tap, leaf=\"bare_unkver\", inputs=[b'' for _ in range(1001)], failure={\"leaf\": \"bare_c0\"}, **ERR_STACK_SIZE)\n+\n+    # OP_SUCCESSx tests.\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for opval in range(76, 0x100):\n+        opcode = CScriptOp(opval)\n+        if not is_op_success(opcode):\n+            continue\n+        scripts = [\n+            (\"bare_success\", CScript([opcode])),\n+            (\"bare_nop\", CScript([OP_NOP])),\n+            (\"unexecif_success\", CScript([OP_0, OP_IF, opcode, OP_ENDIF])),\n+            (\"unexecif_nop\", CScript([OP_0, OP_IF, OP_NOP, OP_ENDIF])),\n+            (\"return_success\", CScript([OP_RETURN, opcode])),\n+            (\"return_nop\", CScript([OP_RETURN, OP_NOP])),\n+            (\"undecodable_success\", CScript([opcode, OP_PUSHDATA1])),\n+            (\"undecodable_nop\", CScript([OP_NOP, OP_PUSHDATA1])),\n+            (\"undecodable_bypassed_success\", CScript([OP_PUSHDATA1, OP_2, opcode])),\n+            (\"bigpush_success\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, opcode])),\n+            (\"bigpush_nop\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, OP_NOP])),\n+            (\"1001push_success\", CScript([OP_0] * 1001 + [opcode])),\n+            (\"1001push_nop\", CScript([OP_0] * 1001 + [OP_NOP])),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pub1, scripts)\n+        add_spender(spenders, \"opsuccess/bare\", standard=False, tap=tap, leaf=\"bare_success\", failure={\"leaf\": \"bare_nop\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"opsuccess/exexecif\", standard=False, tap=tap, leaf=\"unexecif_success\", failure={\"leaf\": \"unexecif_nop\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"opsuccess/return\", standard=False, tap=tap, leaf=\"return_success\", failure={\"leaf\": \"return_nop\"}, **ERR_OP_RETURN)\n+        add_spender(spenders, \"opsuccess/undecodable\", standard=False, tap=tap, leaf=\"undecodable_success\", failure={\"leaf\": \"undecodable_nop\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"opsuccess/undecodable_bypass\", standard=False, tap=tap, leaf=\"undecodable_success\", failure={\"leaf\": \"undecodable_bypassed_success\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"opsuccess/bigpush\", standard=False, tap=tap, leaf=\"bigpush_success\", failure={\"leaf\": \"bigpush_nop\"}, **ERR_PUSH_LIMIT)\n+        add_spender(spenders, \"opsuccess/1001push\", standard=False, tap=tap, leaf=\"1001push_success\", failure={\"leaf\": \"1001push_nop\"}, **ERR_STACK_SIZE)\n+        add_spender(spenders, \"opsuccess/1001inputs\", standard=False, tap=tap, leaf=\"bare_success\", inputs=[b'' for _ in range(1001)], failure={\"leaf\": \"bare_nop\"}, **ERR_STACK_SIZE)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r470406642",
      "id" : 470406642,
      "in_reply_to_id" : 467970307,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQwNjY0Mg==",
      "original_commit_id" : "8692041ef50b36ade662561371c0175a70bd8fec",
      "original_line" : 973,
      "original_position" : 973,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 467303128,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/470406642",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r470406730"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/470406730"
         }
      },
      "author_association" : "MEMBER",
      "body" : "thanks I wrote it myself",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-14T04:42:15Z",
      "diff_hunk" : "@@ -0,0 +1,1271 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expreesion for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        _, negated = compute_xonly_pubkey(key)\n+        return tweak_add_privkey(key, tweak, negated)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    tx.vin[idx].scriptSig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    tx.wit.vtxinwit[idx].scriptWitness.stack = flatten(get(ctx, \"witness\"))\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert(tap is None)\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert(script is None)\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            spend(tx, idx, utxos, **conf)\n+        else:\n+            assert(failure is not None)\n+            spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+# Expected error strings\n+ERR_KEYPATH_INVALID_SIG = {\"err_msg\": \"Invalid signature for Taproot key path spending\"}\n+ERR_SCRIPTPATH_INVALID_SIG = {\"err_msg\": \"Signature must be zero for failed CHECK(MULTI)SIG operation\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Extra items left on stack after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 5000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    sec = generate_privkey()\n+    pub, _ = compute_xonly_pubkey(sec)\n+    tap = taproot_construct(pub)\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=sec, failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=sec, failure={\"sighash\": bitflipper(default_sighash)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=sec, failure={\"flag_flip_r\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=sec, failure={\"flag_flip_p\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=sec, failure={\"signature\": bitflipper(default_signature)}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+        sec1, sec2 = generate_privkey(), generate_privkey()\n+        pub1, _ = compute_xonly_pubkey(sec1)\n+        pub2, _ = compute_xonly_pubkey(sec2)\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pub1)\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pub2)))]\n+            tap = taproot_construct(pub1, scripts)\n+            add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"s0\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+        # Test OP_CODESEPARATOR impact on sighashing.\n+        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+        common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+        scripts = [\n+            (\"pk_codesep\", CScript(random_checksig_style(pub2) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig\n+            (\"codesep_pk\", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pub2))),  # codesep before checksig\n+            (\"branched_codesep\", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pub1, OP_ELSE, OP_CODESEPARATOR, pub2, OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pub1, scripts)\n+        add_spender(spenders, \"sighash/pk_codesep\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/codesep_pk\", tap=tap, leaf=\"codesep_pk\", key=sec2, codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/left\", tap=tap, leaf=\"branched_codesep\", key=sec1, codeseppos=3, **common, inputs=[getter(\"sign\"), b'\\x01'], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/right\", tap=tap, leaf=\"branched_codesep\", key=sec2, codeseppos=6, **common, inputs=[getter(\"sign\"), b''], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Reusing the scripts above, test that various features affect the sighash.\n+    add_spender(spenders, \"sighash/annex\", tap=tap, leaf=\"pk_codesep\", key=sec2, hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={\"sighash\": override(default_sighash, annex=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/script\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, script_taproot=tap.leaves[\"codesep_pk\"].script)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/leafver\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leafversion=0xc2)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leaf=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/keypath\", tap=tap, key=sec1, **common, failure={\"sighash\": override(default_sighash, leaf=\"pk_codesep\")}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # Test that invalid hashtypes don't work, both in key path and script path spends\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for invalid_hashtype in range(256):\n+        if invalid_hashtype not in VALID_SIGHASHES_TAPROOT:\n+            add_spender(spenders, \"sighash/keypath_unk_hashtype\", tap=tap, key=sec1, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath_unk_hashtype\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Test that hashtype 0 cannot have a hashtype byte, and 1 must have one.\n+    add_spender(spenders, \"sighash/hashtype0_byte_keypath\", tap=tap, key=sec1, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_keypath\", tap=tap, key=sec1, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    # Test that hashtype 0 and hashtype 1 cannot be transmuted into each other.\n+    add_spender(spenders, \"sighash/hashtype0to1_keypath\", tap=tap, key=sec1, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0to1_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_keypath\", tap=tap, key=sec1, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=sec2, **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # == Test that BIP341 spending only applies to witness version 1, program length 32, no P2SH ==\n+\n+    for p2sh in [False, True]:\n+        for witver in range(1, 17):\n+            for witlen in [20, 31, 32, 33]:\n+                def mutate(spk):\n+                    prog = spk[2:]\n+                    assert(len(prog) == 32)\n+                    if witlen < 32:\n+                        prog = prog[0:witlen]\n+                    elif witlen > 32:\n+                        prog += bytes([0 for _ in range(witlen - 32)])\n+                    return CScript([CScriptOp.encode_op_n(witver), prog])\n+                scripts = [(\"s0\", CScript([pub1, OP_CHECKSIG])), (\"dummy\", CScript([OP_RETURN]))]\n+                tap = taproot_construct(pub2, scripts)\n+                if not p2sh and witver == 1 and witlen == 32:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=sec2, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=sec1, **SINGLE_SIG, failure={\"leaf\": \"dummy\"}, **ERR_OP_RETURN)\n+                else:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=sec2, standard=False)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=sec1, **SINGLE_SIG, standard=False)\n+\n+    # == Test various aspects of BIP341 spending paths ==\n+\n+    # A set of functions that compute the hashing partner in a Merkle tree, designed to exercise\n+    # edge cases. This relies on the taproot_construct feature that a lambda can be passed in\n+    # instead of a subtree, to compute the partner to be hashed with.\n+    PARTNER_MERKLE_FN = [\n+        # Combine with itself\n+        lambda h: h,\n+        # Combine with hash 0\n+        lambda h: bytes([0 for _ in range(32)]),\n+        # Combine with hash 2^256-1\n+        lambda h: bytes([0xff for _ in range(32)]),\n+        # Combine with itself-1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') + 1).to_bytes(32, 'big'),\n+        # Combine with itself-1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') + 1).to_bytes(32, 'little'),\n+        # Combine with random bitflipped version of self.\n+        lambda h: (int.from_bytes(h, 'little') ^ (1 << random.randrange(256))).to_bytes(32, 'little')\n+    ]\n+    # Start with a tree of that has depth 1 for \"128deep\" and depth 2 for \"129deep\".\n+    scripts = [(\"128deep\", CScript([pub1, OP_CHECKSIG])), [(\"129deep\", CScript([pub1, OP_CHECKSIG])), random.choice(PARTNER_MERKLE_FN)]]\n+    # Add 127 nodes on top of that tree, so that \"128deep\" and \"129deep\" end up at their designated depths.\n+    for _ in range(127):\n+        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+    tap = taproot_construct(pub1, scripts)\n+    # Test that spends with a depth of 128 work, but 129 doesn't (even with a tree with weird Merkle branches in it).\n+    add_spender(spenders, \"spendpath/merklelimit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"leaf\": \"129deep\"}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that flipping the negation bit invalidates spends.\n+    add_spender(spenders, \"spendpath/negflag\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"negflag\": lambda ctx: 1 - default_negflag(ctx)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the Merkle branch invalidate it.\n+    add_spender(spenders, \"spendpath/bitflipmerkle\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"merklebranch\": bitflipper(default_merklebranch)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the inner pubkey invalidate it.\n+    add_spender(spenders, \"spendpath/bitflippubkey\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"pubkey_inner\": bitflipper(default_pubkey_inner)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that empty witnesses are invalid.\n+    add_spender(spenders, \"spendpath/emptywit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"witness\": []}, **ERR_EMPTY_WITNESS)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padlongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/trunclongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    scripts = [(\"s\", CScript([pub1, OP_CHECKSIG]))]\n+    tap = taproot_construct(pub2, scripts)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/truncshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block to 1 byte (\"-1 Merkle length\") invalidates it\n+    add_spender(spenders, \"spendpath/trunc1shortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=sec1, failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:1]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    # == Test BIP342 edge cases ==\n+\n+    checksigadd_val = random.randrange(17, 100) # Above OP_16 to avoid minimal encoding complaints\n+    checksigadd_arg = CScriptNum(checksigadd_val)\n+    checksigadd_result = CScriptNum(checksigadd_val+1)\n+    OVERSIZE_NUMBER = 2**31\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER))), 6)\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER-1))), 5)\n+\n+    # Various BIP342 features\n+    scripts = [\n+        # 0) drop stack element and OP_CHECKSIG\n+        (\"t0\", CScript([OP_DROP, pub2, OP_CHECKSIG])),\n+        # 1) normal OP_CHECKSIG\n+        (\"t1\", CScript([pub2, OP_CHECKSIG])),\n+        # 2) normal OP_CHECKSIGVERIFY\n+        (\"t2\", CScript([pub2, OP_CHECKSIGVERIFY, OP_1])),\n+        # 3) Hypothetical OP_CHECKMULTISIG script that takes a single sig as input\n+        (\"t3\", CScript([OP_0, OP_SWAP, OP_1, pub2, OP_1, OP_CHECKMULTISIG])),\n+        # 4) Hypothetical OP_CHECKMULTISIGVERIFY script that takes a single sig as input\n+        (\"t4\", CScript([OP_0, OP_SWAP, OP_1, pub2, OP_1, OP_CHECKMULTISIGVERIFY, OP_1])),\n+        # 5) OP_IF script that needs a true input\n+        (\"t5\", CScript([OP_IF, pub2, OP_CHECKSIG, OP_ELSE, OP_RETURN, OP_ENDIF])),\n+        # 6) OP_NOTIF script that needs a true input\n+        (\"t6\", CScript([OP_NOTIF, OP_RETURN, OP_ELSE, pub2, OP_CHECKSIG, OP_ENDIF])),\n+        # 7) OP_CHECKSIG with an empty key\n+        (\"t7\", CScript([OP_0, OP_CHECKSIG])),\n+        # 8) OP_CHECKSIGVERIFY with an empty key\n+        (\"t8\", CScript([OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 9) normal OP_CHECKSIGADD that also ensures return value is correct\n+        (\"t9\", CScript([OP_0, pub2, OP_CHECKSIGADD, OP_1, OP_EQUAL])),\n+        # 10) OP_CHECKSIGADD with empty key\n+        (\"t10\", CScript([OP_0, OP_0, OP_CHECKSIGADD])),\n+        # 11) OP_CHECKSIGADD with missing counter stack element\n+        (\"t11\", CScript([pub2, OP_CHECKSIGADD])),\n+        # 12) OP_CHECKSIG that needs invalid signature\n+        (\"t12\", CScript([pub2, OP_CHECKSIGVERIFY, pub1, OP_CHECKSIG, OP_NOT])),\n+        # 13) OP_CHECKSIG with empty key that needs invalid signature\n+        (\"t13\", CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_CHECKSIG, OP_NOT])),\n+        # 14) OP_CHECKSIGADD that needs invalid signature\n+        (\"t14\", CScript([pub2, OP_CHECKSIGVERIFY, OP_0, pub1, OP_CHECKSIGADD, OP_NOT])),\n+        # 15) OP_CHECKSIGADD with empty key that needs invalid signature\n+        (\"t15\", CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGADD, OP_NOT])),\n+        # 16) OP_CHECKSIG with unknown pubkey type\n+        (\"t16\", CScript([OP_1, OP_CHECKSIG])),\n+        # 17) OP_CHECKSIGADD with unknown pubkey type\n+        (\"t17\", CScript([OP_0, OP_1, OP_CHECKSIGADD])),\n+        # 18) OP_CHECKSIGVERIFY with unknown pubkey type\n+        (\"t18\", CScript([OP_1, OP_CHECKSIGVERIFY, OP_1])),\n+        # 19) script longer than 10000 bytes and over 201 non-push opcodes\n+        (\"t19\", CScript([OP_0, OP_0, OP_2DROP] * 10001 + [pub2, OP_CHECKSIG])),\n+        # 20) OP_CHECKSIGVERIFY with empty key\n+        (\"t20\", CScript([pub2, OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGVERIFY, OP_1])),\n+        # 21) Script that grows the stack to 1000 elements\n+        (\"t21\", CScript([pub2, OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 999 + [OP_DROP] * 999)),\n+        # 22) Script that grows the stack to 1001 elements\n+        (\"t22\", CScript([pub2, OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 1000 + [OP_DROP] * 1000)),\n+        # 23) Script that expects an input stack of 1000 elements\n+        (\"t23\", CScript([OP_DROP] * 999 + [pub2, OP_CHECKSIG])),\n+        # 24) Script that expects an input stack of 1001 elements\n+        (\"t24\", CScript([OP_DROP] * 1000 + [pub2, OP_CHECKSIG])),\n+        # 25) Script that pushes a MAX_SCRIPT_ELEMENT_SIZE-bytes element\n+        (\"t25\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE), OP_DROP, pub2, OP_CHECKSIG])),\n+        # 26) Script that pushes a (MAX_SCRIPT_ELEMENT_SIZE+1)-bytes element\n+        (\"t26\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, pub2, OP_CHECKSIG])),\n+        # 27) CHECKSIGADD that must fail because numeric argument number is >4 bytes\n+        (\"t27\", CScript([CScriptNum(OVERSIZE_NUMBER), pub2, OP_CHECKSIGADD])),\n+        # 28) Pushes random CScriptNum value, checks OP_CHECKSIGADD result\n+        (\"t28\", CScript([checksigadd_arg, pub2, OP_CHECKSIGADD, checksigadd_result, OP_EQUAL])),\n+        # 29) CHECKSIGADD that succeeds with proper sig because numeric argument number is <=4 bytes\n+        (\"t29\", CScript([CScriptNum(OVERSIZE_NUMBER-1), pub2, OP_CHECKSIGADD])),\n+        # 30) Variant of t1 with \"normal\" 33-byte pubkey\n+        (\"t30\", CScript([b'\\x03' + pub2, OP_CHECKSIG])),\n+        # 31) Variant of t2 with \"normal\" 33-byte pubkey\n+        (\"t31\", CScript([b'\\x02' + pub2, OP_CHECKSIGVERIFY, OP_1])),\n+        # 32) Variant of t28 with \"normal\" 33-byte pubkey\n+        (\"t32\", CScript([checksigadd_arg, b'\\x03' + pub2, OP_CHECKSIGADD, checksigadd_result, OP_EQUAL])),\n+    ]\n+    random.shuffle(scripts)\n+    tap = taproot_construct(pub1, scripts)\n+    common = {\n+        \"hashtype\": hashtype,\n+        \"key\": sec2,\n+        \"tap\": tap,\n+    }\n+    # Test that MAX_SCRIPT_ELEMENT_SIZE byte stack element inputs are valid, but not one more (and 80 bytes is standard but 81 is not).\n+    add_spender(spenders, \"tapscript/inputmaxlimit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE)], failure={\"inputs\": [getter(\"sign\"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1)]}, **ERR_PUSH_LIMIT)\n+    add_spender(spenders, \"tapscript/input80limit\", leaf=\"t0\", **common, inputs=[getter(\"sign\"), random_bytes(80)])\n+    add_spender(spenders, \"tapscript/input81limit\", leaf=\"t0\", **common, standard=False, inputs=[getter(\"sign\"), random_bytes(81)])\n+    # Test that OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY cause failure, but OP_CHECKSIG and OP_CHECKSIGVERIFY work.\n+    add_spender(spenders, \"tapscript/disabled_checkmultisig\", leaf=\"t1\", **common, **SINGLE_SIG, failure={\"leaf\": \"t3\"}, **ERR_DISABLED_OPCODE)\n+    add_spender(spenders, \"tapscript/disabled_checkmultisigverify\", leaf=\"t2\", **common, **SINGLE_SIG, failure={\"leaf\": \"t4\"}, **ERR_DISABLED_OPCODE)\n+    # Test that OP_IF and OP_NOTIF do not accept non-0x01 as truth value (the MINIMALIF rule is consensus in Tapscript)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x02']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x03']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalif\", leaf=\"t5\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0001']}, **ERR_MINIMALIF)\n+    add_spender(spenders, \"tapscript/minimalnotif\", leaf=\"t6\", **common, inputs=[getter(\"sign\"), b'\\x01'], failure={\"inputs\": [getter(\"sign\"), b'\\x0100']}, **ERR_MINIMALIF)\n+    # Test that 1-byte public keys (which are unknown) are acceptable but nonstandard with unrelated signatures, but 0-byte public keys are not valid.\n+    add_spender(spenders, \"tapscript/unkpk/checksig\", leaf=\"t16\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigadd\", leaf=\"t17\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/unkpk/checksigverify\", leaf=\"t18\", standard=False, **common, **SINGLE_SIG, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that 33-byte public keys (which are unknown) are acceptable but nonstandard with valid signatures, but normal pubkeys are not valid in that case.\n+    add_spender(spenders, \"tapscript/oldpk/checksig\", leaf=\"t30\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t1\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"tapscript/oldpk/checksigadd\", leaf=\"t31\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t2\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"tapscript/oldpk/checksigverify\", leaf=\"t32\", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={\"leaf\": \"t28\"}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    # Test that 0-byte public keys are not acceptable.\n+    add_spender(spenders, \"tapscript/emptypk/checksig\", leaf=\"t1\", **SINGLE_SIG, **common, failure={\"leaf\": \"t7\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigverify\", leaf=\"t2\", **SINGLE_SIG, **common, failure={\"leaf\": \"t8\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptypk/checksigadd\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t10\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that OP_CHECKSIGADD results are as expected\n+    add_spender(spenders, \"tapscript/checksigaddresults\", leaf=\"t28\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    add_spender(spenders, \"tapscript/checksigaddoversize\", leaf=\"t29\", **SINGLE_SIG, **common, failure={\"leaf\": \"t27\"}, err_msg=\"unknown error\")\n+    # Test that OP_CHECKSIGADD requires 3 stack elements.\n+    add_spender(spenders, \"tapscript/checksigadd3args\", leaf=\"t9\", **SINGLE_SIG, **common, failure={\"leaf\": \"t11\"}, **ERR_STACK_EMPTY)\n+    # Test that empty signatures do not cause script failure in OP_CHECKSIG and OP_CHECKSIGADD (but do fail with empty pubkey, and do fail OP_CHECKSIGVERIFY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksig\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t13\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/nochecksigverify\", leaf=\"t12\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t20\"}, **ERR_UNKNOWN_PUBKEY)\n+    add_spender(spenders, \"tapscript/emptysigs/checksigadd\", leaf=\"t14\", **common, inputs=[b'', getter(\"sign\")], failure={\"leaf\": \"t15\"}, **ERR_UNKNOWN_PUBKEY)\n+    # Test that scripts over 10000 bytes (and over 201 non-push ops) are acceptable.\n+    add_spender(spenders, \"tapscript/no10000limit\", leaf=\"t19\", **SINGLE_SIG, **common)\n+    # Test that a stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000stack\", leaf=\"t21\", **SINGLE_SIG, **common, failure={\"leaf\": \"t22\"}, **ERR_STACK_SIZE)\n+    # Test that an input stack size of 1000 elements is permitted, but 1001 isn't.\n+    add_spender(spenders, \"tapscript/1000inputs\", leaf=\"t23\", **common, inputs=[getter(\"sign\")] + [b'' for _ in range(999)], failure={\"leaf\": \"t24\", \"inputs\": [getter(\"sign\")] + [b'' for _ in range(1000)]}, **ERR_STACK_SIZE)\n+    # Test that pushing a MAX_SCRIPT_ELEMENT_SIZE byte stack element is valid, but one longer is not.\n+    add_spender(spenders, \"tapscript/pushmaxlimit\", leaf=\"t25\", **common, **SINGLE_SIG, failure={\"leaf\": \"t26\"}, **ERR_PUSH_LIMIT)\n+\n+    # == Test for sigops ratio limit ==\n+\n+    # Given a number n, and a public key pk, functions that produces a (CScript, sigops). Each script takes as\n+    # input a valid signature with the passed pk followed by a dummy, and will execute sigops signature checks.\n+    SIGOPS_RATIO_SCRIPTS = [\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIG.\n+        lambda n, pk: (CScript([OP_DROP, pk] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGVERIFY.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_0, OP_IF, OP_2DUP, OP_CHECKSIGVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_2, OP_SWAP, OP_CHECKSIGADD, OP_3, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIG.\n+        lambda n, pk: (CScript([random_bytes(220), OP_2DROP, pk, OP_1, OP_NOTIF, OP_2DUP, OP_CHECKSIG, OP_VERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_4, OP_SWAP, OP_CHECKSIGADD, OP_5, OP_EQUAL]), n + 1),\n+        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGADD.\n+        lambda n, pk: (CScript([OP_DROP, pk, OP_1, OP_IF, OP_ELSE, OP_2DUP, OP_6, OP_SWAP, OP_CHECKSIGADD, OP_7, OP_EQUALVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_8, OP_SWAP, OP_CHECKSIGADD, OP_9, OP_EQUAL]), n + 1),\n+        # n+1 OP_CHECKSIGs, but also one OP_CHECKSIG with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, pk, OP_CHECKSIG, OP_NOT, OP_VERIFY, pk] + [OP_2DUP, OP_CHECKSIG, OP_VERIFY] * n + [OP_CHECKSIG]), n + 1),\n+        # n OP_CHECKSIGADDs and 1 OP_CHECKSIG, but also an OP_CHECKSIGADD with an empty signature.\n+        lambda n, pk: (CScript([OP_DROP, OP_0, OP_10, pk, OP_CHECKSIGADD, OP_10, OP_EQUALVERIFY, pk] + [OP_2DUP, OP_16, OP_SWAP, OP_CHECKSIGADD, b'\\x11', OP_EQUALVERIFY] * n + [OP_CHECKSIG]), n + 1),\n+    ]\n+    for annex in [None, bytes([ANNEX_TAG]) + random_bytes(random.randrange(1000))]:\n+        for hashtype in [SIGHASH_DEFAULT, SIGHASH_ALL]:\n+            for pubkey in [pub2, random_bytes(random.choice([x for x in range(2, 81) if x != 32]))]:\n+                for fn_num, fn in enumerate(SIGOPS_RATIO_SCRIPTS):\n+                    merkledepth = random.randrange(129)\n+                    def predict_sigops_ratio(n, dummy_size):\n+                        script, sigops = fn(n, pubkey)\n+                        # Predict the size of the witness for a given choice of n\n+                        stacklen_size = 1\n+                        sig_size = 64 + (hashtype != SIGHASH_DEFAULT)\n+                        siglen_size = 1\n+                        dummylen_size = 1 + 2 * (dummy_size >= 253)\n+                        script_size = len(script)\n+                        scriptlen_size = 1 + 2 * (script_size >= 253)\n+                        control_size = 33 + 32 * merkledepth\n+                        controllen_size = 1 + 2 * (control_size >= 253)\n+                        annex_size = 0 if annex is None else len(annex)\n+                        annexlen_size = 0 if annex is None else 1 + 2 * (annex_size >= 253)\n+                        witsize = stacklen_size + sig_size + siglen_size + dummy_size + dummylen_size + script_size + scriptlen_size + control_size + controllen_size + annex_size + annexlen_size\n+                        # sigops ratio test\n+                        return witsize + 50 >= 50 * sigops\n+                    # Make sure n is high enough that with empty dummy, the script is not valid\n+                    n = 0\n+                    while predict_sigops_ratio(n, 0):\n+                        n += 1\n+                    # But allow picking a bit higher still\n+                    n += random.randrange(5)\n+                    # Now pick dummy size *just* large enough that the overall construction passes\n+                    dummylen = 0\n+                    while not predict_sigops_ratio(n, dummylen):\n+                        dummylen += 1\n+                    scripts = [(\"s\", fn(n, pubkey)[0])]\n+                    for _ in range(merkledepth):\n+                        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+                    tap = taproot_construct(pub1, scripts)\n+                    standard = annex is None and dummylen <= 80 and len(pubkey) == 32\n+                    add_spender(spenders, \"tapscript/sigopsratio_%i\" % fn_num, tap=tap, leaf=\"s\", annex=annex, hashtype=hashtype, key=sec2, inputs=[getter(\"sign\"), random_bytes(dummylen)], standard=standard, failure={\"inputs\": [getter(\"sign\"), random_bytes(dummylen - 1)]}, **ERR_SIGOPS_RATIO)\n+        # Future leaf versions\n+    for leafver in range(0, 0x100, 2):\n+        if leafver == LEAF_VERSION_TAPSCRIPT or leafver == ANNEX_TAG:\n+            # Skip the defined LEAF_VERSION_TAPSCRIPT, and the ANNEX_TAG which is not usable as leaf version\n+            continue\n+        scripts = [\n+            (\"bare_c0\", CScript([OP_NOP])),\n+            (\"bare_unkver\", CScript([OP_NOP]), leafver),\n+            (\"return_c0\", CScript([OP_RETURN])),\n+            (\"return_unkver\", CScript([OP_RETURN]), leafver),\n+            (\"undecodable_c0\", CScript([OP_PUSHDATA1])),\n+            (\"undecodable_unkver\", CScript([OP_PUSHDATA1]), leafver),\n+            (\"bigpush_c0\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP])),\n+            (\"bigpush_unkver\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP]), leafver),\n+            (\"1001push_c0\", CScript([OP_0] * 1001)),\n+            (\"1001push_unkver\", CScript([OP_0] * 1001), leafver),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pub1, scripts)\n+        add_spender(spenders, \"unkver/bare\", standard=False, tap=tap, leaf=\"bare_unkver\", failure={\"leaf\": \"bare_c0\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"unkver/return\", standard=False, tap=tap, leaf=\"return_unkver\", failure={\"leaf\": \"return_c0\"}, **ERR_OP_RETURN)\n+        add_spender(spenders, \"unkver/undecodable\", standard=False, tap=tap, leaf=\"undecodable_unkver\", failure={\"leaf\": \"undecodable_c0\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"unkver/bigpush\", standard=False, tap=tap, leaf=\"bigpush_unkver\", failure={\"leaf\": \"bigpush_c0\"}, **ERR_PUSH_LIMIT)\n+        add_spender(spenders, \"unkver/1001push\", standard=False, tap=tap, leaf=\"1001push_unkver\", failure={\"leaf\": \"1001push_c0\"}, **ERR_STACK_SIZE)\n+        add_spender(spenders, \"unkver/1001inputs\", standard=False, tap=tap, leaf=\"bare_unkver\", inputs=[b'' for _ in range(1001)], failure={\"leaf\": \"bare_c0\"}, **ERR_STACK_SIZE)\n+\n+    # OP_SUCCESSx tests.\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for opval in range(76, 0x100):\n+        opcode = CScriptOp(opval)\n+        if not is_op_success(opcode):\n+            continue\n+        scripts = [\n+            (\"bare_success\", CScript([opcode])),\n+            (\"bare_nop\", CScript([OP_NOP])),\n+            (\"unexecif_success\", CScript([OP_0, OP_IF, opcode, OP_ENDIF])),\n+            (\"unexecif_nop\", CScript([OP_0, OP_IF, OP_NOP, OP_ENDIF])),\n+            (\"return_success\", CScript([OP_RETURN, opcode])),\n+            (\"return_nop\", CScript([OP_RETURN, OP_NOP])),\n+            (\"undecodable_success\", CScript([opcode, OP_PUSHDATA1])),\n+            (\"undecodable_nop\", CScript([OP_NOP, OP_PUSHDATA1])),\n+            (\"undecodable_bypassed_success\", CScript([OP_PUSHDATA1, OP_2, opcode])),\n+            (\"bigpush_success\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, opcode])),\n+            (\"bigpush_nop\", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, OP_NOP])),\n+            (\"1001push_success\", CScript([OP_0] * 1001 + [opcode])),\n+            (\"1001push_nop\", CScript([OP_0] * 1001 + [OP_NOP])),\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pub1, scripts)\n+        add_spender(spenders, \"opsuccess/bare\", standard=False, tap=tap, leaf=\"bare_success\", failure={\"leaf\": \"bare_nop\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"opsuccess/exexecif\", standard=False, tap=tap, leaf=\"unexecif_success\", failure={\"leaf\": \"unexecif_nop\"}, **ERR_CLEANSTACK)\n+        add_spender(spenders, \"opsuccess/return\", standard=False, tap=tap, leaf=\"return_success\", failure={\"leaf\": \"return_nop\"}, **ERR_OP_RETURN)\n+        add_spender(spenders, \"opsuccess/undecodable\", standard=False, tap=tap, leaf=\"undecodable_success\", failure={\"leaf\": \"undecodable_nop\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"opsuccess/undecodable_bypass\", standard=False, tap=tap, leaf=\"undecodable_success\", failure={\"leaf\": \"undecodable_bypassed_success\"}, **ERR_UNDECODABLE)\n+        add_spender(spenders, \"opsuccess/bigpush\", standard=False, tap=tap, leaf=\"bigpush_success\", failure={\"leaf\": \"bigpush_nop\"}, **ERR_PUSH_LIMIT)\n+        add_spender(spenders, \"opsuccess/1001push\", standard=False, tap=tap, leaf=\"1001push_success\", failure={\"leaf\": \"1001push_nop\"}, **ERR_STACK_SIZE)\n+        add_spender(spenders, \"opsuccess/1001inputs\", standard=False, tap=tap, leaf=\"bare_success\", inputs=[b'' for _ in range(1001)], failure={\"leaf\": \"bare_nop\"}, **ERR_STACK_SIZE)\n+\n+    # Non-OP_SUCCESSx (verify that those aren't accidentally treated as OP_SUCCESSx)\n+    for opval in range(0, 0x100):\n+        opcode = CScriptOp(opval)\n+        if is_op_success(opcode):\n+            continue\n+        scripts = [\n+            (\"normal\", CScript([OP_RETURN, opcode] + [OP_NOP] * 75)),\n+            (\"op_success\", CScript([OP_RETURN, CScriptOp(0x50)]))\n+        ]\n+        tap = taproot_construct(pub1, scripts)\n+        add_spender(spenders, \"alwaysvalid/notsuccessx\", tap=tap, leaf=\"op_success\", inputs=[], standard=False, failure={\"leaf\": \"normal\"}) # err_msg differs based on opcode\n+\n+    # == Legacy tests ==\n+\n+    # Also add a few legacy spends into the mix, so that transactions which combine taproot and pre-taproot spends get tested too.\n+    eckey1 = ECKey()\n+    eckey1.set(generate_privkey(), True)\n+    pubkey1 = eckey1.get_pubkey().get_bytes()\n+    eckey2 = ECKey()\n+    eckey2.set(generate_privkey(), True)\n+    for p2sh in [False, True]:\n+        for witv0 in [False, True]:\n+            for hashtype in VALID_SIGHASHES_ECDSA + [random.randrange(0x04, 0x80), random.randrange(0x84, 0x100)]:\n+                standard = hashtype in VALID_SIGHASHES_ECDSA\n+                add_spender(spenders, \"legacy/pk-wrongkey\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, script=CScript([pubkey1, OP_CHECKSIG]), **SINGLE_SIG, key=eckey1, failure={\"key\": eckey2}, sigops_weight=4-3*witv0, **ERR_NO_SUCCESS)\n+                add_spender(spenders, \"legacy/pkh-sighashflip\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, pkh=pubkey1, key=eckey1, **SIGHASH_BITFLIP, sigops_weight=4-3*witv0, **ERR_NO_SUCCESS)\n+\n+    # Verify that OP_CHECKSIGADD wasn't accidentally added to pre-taproot validation logic.\n+    for p2sh in [False, True]:\n+        for witv0 in [False, True]:\n+            for hashtype in VALID_SIGHASHES_ECDSA + [random.randrange(0x04, 0x80), random.randrange(0x84, 0x100)]:\n+                standard = hashtype in VALID_SIGHASHES_ECDSA and (p2sh or witv0)\n+                add_spender(spenders, \"legacy/nocsa\", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, script=CScript([OP_IF, OP_11, pubkey1, OP_CHECKSIGADD, OP_12, OP_EQUAL, OP_ELSE, pubkey1, OP_CHECKSIG, OP_ENDIF]), key=eckey1, sigops_weight=4-3*witv0, inputs=[getter(\"sign\"), b''], failure={\"inputs\": [getter(\"sign\"), b'\\x01']}, **ERR_UNDECODABLE)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r470406730",
      "id" : 470406730,
      "in_reply_to_id" : 467972427,
      "line" : 1104,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQwNjczMA==",
      "original_commit_id" : "8692041ef50b36ade662561371c0175a70bd8fec",
      "original_line" : 1104,
      "original_position" : 1007,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : 1104,
      "pull_request_review_id" : 467303236,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/470406730",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "utACK https://github.com/bitcoin/bitcoin/pull/17977/commits/b0d2a3a788222fa6770ffe9eee132f829199275f the non-sighash changes, I think there still might be issues on that front since tests are failing\r\n\r\n```\r\nAssertionError: Missing error message 'Signature must be zero for failed CHECK(MULTI)SIG operation' from block response '(None)': applic/scriptpath,sighash/keypath_unk_hashtype_90,sighash/scriptpath_unk_hashtype_80*\r\n```",
      "created_at" : "2020-08-14T13:37:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-674078920",
      "id" : 674078920,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY3NDA3ODkyMA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-08-14T13:38:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/674078920",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@instagibbs ... and that was an actual bug in the sighash code. It wasn't rejecting 0x80 as hashtype.\r\n\r\nFixed:\r\n\r\n```diff\r\n--- a/src/script/interpreter.cpp\r\n+++ b/src/script/interpreter.cpp\r\n@@ -1497,7 +1497,7 @@ bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata\r\n     // Hash type\r\n     const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\r\n     const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;\r\n-    if (!(hash_type <= 0x03 || (hash_type >= 0x80 && hash_type <= 0x83))) return false;\r\n+    if (!(hash_type <= 0x03 || (hash_type >= 0x81 && hash_type <= 0x83))) return false;\r\n```\r\n",
      "created_at" : "2020-08-14T17:32:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-674183128",
      "id" : 674183128,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY3NDE4MzEyOA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-08-14T17:34:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/674183128",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r473553826"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/473553826"
         }
      },
      "author_association" : "MEMBER",
      "body" : "If I want to taproot-sign a transaction, it will not have any ScriptWitness data when I try to obtain the signature hash, which means `m_bip341_ready` will not be set after the `PrecomputedTransactionData::Init()` call has been made.\r\n\r\nThis means I have to put in junk data in the vin's scriptwitness in order to obtain the sighash, which seems off.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-20T02:39:59Z",
      "diff_hunk" : "@@ -1258,65 +1349,207 @@ class CTransactionSignatureSerializer\n     }\n };\n \n+/** Compute the (single) SHA256 of the concatenation of all prevouts of a tx. */\n template <class T>\n uint256 GetPrevoutHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txin : txTo.vin) {\n         ss << txin.prevout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all nSequences of a tx. */\n template <class T>\n uint256 GetSequenceHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txin : txTo.vin) {\n         ss << txin.nSequence;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all txouts of a tx. */\n template <class T>\n uint256 GetOutputsHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n+    }\n+\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143 = false;\n+    bool uses_bip341 = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every native witness v1 spend as a Taproot spend. This only works if spent_outputs was\n+                // provided as well, but if it wasn't, actual validation will fail anyway.\n+                uses_bip341 = true;\n+            } else {\n+                // Treat every spend that's not known to native witness v1 as a Witness v0 spend. This branch may\n+                // also be taken for unknown witness versions, but it is harmless, and being precise would require\n+                // P2SH evaluation to find the redeemScript.\n+                uses_bip143 = true;\n+            }\n+        }\n     }\n \n-    m_ready = true;\n+    if (uses_bip143 || uses_bip341) {\n+        // Computations shared between both sighash schemes.\n+        m_bip341_prevouts_hash = GetPrevoutHash(txTo);\n+        m_bip341_sequences_hash = GetSequenceHash(txTo);\n+        m_bip341_outputs_hash = GetOutputsHash(txTo);\n+    }\n+    if (uses_bip143) {\n+        hashPrevouts = SHA256Uint256(m_bip341_prevouts_hash);\n+        hashSequence = SHA256Uint256(m_bip341_sequences_hash);\n+        hashOutputs = SHA256Uint256(m_bip341_outputs_hash);\n+        m_bip143_ready = true;\n+    }\n+    if (uses_bip341) {\n+        m_bip341_spent_amounts_hash = GetSpentAmountsHash(m_spent_outputs);\n+        m_bip341_spent_scripts_hash = GetSpentScriptsHash(m_spent_outputs);\n+        m_bip341_ready = true;\n+    }\n }\n \n template <class T>\n PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n {\n-    Init(txTo);\n+    Init(txTo, {});\n }\n \n // explicit instantiation\n-template void PrecomputedTransactionData::Init(const CTransaction& txTo);\n-template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo);\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+static const CHashWriter HASHER_TAPLEAF = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HASHER_TAPBRANCH = TaggedHash(\"TapBranch\");\n+static const CHashWriter HASHER_TAPTWEAK = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData* cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    case SigVersion::TAPSCRIPT:\n+        ext_flag = 1;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache != nullptr && cache->m_bip341_ready && cache->m_spent_outputs_ready);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r473553826",
      "id" : 473553826,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzU1MzgyNg==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 1486,
      "original_position" : 360,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 471088698,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/473553826",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r474210335"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/474210335"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Will you be using a cache when signing a tx? I figured no.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-20T19:11:00Z",
      "diff_hunk" : "@@ -1258,65 +1349,207 @@ class CTransactionSignatureSerializer\n     }\n };\n \n+/** Compute the (single) SHA256 of the concatenation of all prevouts of a tx. */\n template <class T>\n uint256 GetPrevoutHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txin : txTo.vin) {\n         ss << txin.prevout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all nSequences of a tx. */\n template <class T>\n uint256 GetSequenceHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txin : txTo.vin) {\n         ss << txin.nSequence;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all txouts of a tx. */\n template <class T>\n uint256 GetOutputsHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n+    }\n+\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143 = false;\n+    bool uses_bip341 = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every native witness v1 spend as a Taproot spend. This only works if spent_outputs was\n+                // provided as well, but if it wasn't, actual validation will fail anyway.\n+                uses_bip341 = true;\n+            } else {\n+                // Treat every spend that's not known to native witness v1 as a Witness v0 spend. This branch may\n+                // also be taken for unknown witness versions, but it is harmless, and being precise would require\n+                // P2SH evaluation to find the redeemScript.\n+                uses_bip143 = true;\n+            }\n+        }\n     }\n \n-    m_ready = true;\n+    if (uses_bip143 || uses_bip341) {\n+        // Computations shared between both sighash schemes.\n+        m_bip341_prevouts_hash = GetPrevoutHash(txTo);\n+        m_bip341_sequences_hash = GetSequenceHash(txTo);\n+        m_bip341_outputs_hash = GetOutputsHash(txTo);\n+    }\n+    if (uses_bip143) {\n+        hashPrevouts = SHA256Uint256(m_bip341_prevouts_hash);\n+        hashSequence = SHA256Uint256(m_bip341_sequences_hash);\n+        hashOutputs = SHA256Uint256(m_bip341_outputs_hash);\n+        m_bip143_ready = true;\n+    }\n+    if (uses_bip341) {\n+        m_bip341_spent_amounts_hash = GetSpentAmountsHash(m_spent_outputs);\n+        m_bip341_spent_scripts_hash = GetSpentScriptsHash(m_spent_outputs);\n+        m_bip341_ready = true;\n+    }\n }\n \n template <class T>\n PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n {\n-    Init(txTo);\n+    Init(txTo, {});\n }\n \n // explicit instantiation\n-template void PrecomputedTransactionData::Init(const CTransaction& txTo);\n-template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo);\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+static const CHashWriter HASHER_TAPLEAF = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HASHER_TAPBRANCH = TaggedHash(\"TapBranch\");\n+static const CHashWriter HASHER_TAPTWEAK = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData* cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    case SigVersion::TAPSCRIPT:\n+        ext_flag = 1;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache != nullptr && cache->m_bip341_ready && cache->m_spent_outputs_ready);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r474210335",
      "id" : 474210335,
      "in_reply_to_id" : 473553826,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxMDMzNQ==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 1486,
      "original_position" : 360,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 471905702,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/474210335",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r474385753"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/474385753"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I need the sighash to sign the transaction, and I need the cache to get the sighash.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-21T03:17:46Z",
      "diff_hunk" : "@@ -1258,65 +1349,207 @@ class CTransactionSignatureSerializer\n     }\n };\n \n+/** Compute the (single) SHA256 of the concatenation of all prevouts of a tx. */\n template <class T>\n uint256 GetPrevoutHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txin : txTo.vin) {\n         ss << txin.prevout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all nSequences of a tx. */\n template <class T>\n uint256 GetSequenceHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txin : txTo.vin) {\n         ss << txin.nSequence;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all txouts of a tx. */\n template <class T>\n uint256 GetOutputsHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n+    }\n+\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143 = false;\n+    bool uses_bip341 = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every native witness v1 spend as a Taproot spend. This only works if spent_outputs was\n+                // provided as well, but if it wasn't, actual validation will fail anyway.\n+                uses_bip341 = true;\n+            } else {\n+                // Treat every spend that's not known to native witness v1 as a Witness v0 spend. This branch may\n+                // also be taken for unknown witness versions, but it is harmless, and being precise would require\n+                // P2SH evaluation to find the redeemScript.\n+                uses_bip143 = true;\n+            }\n+        }\n     }\n \n-    m_ready = true;\n+    if (uses_bip143 || uses_bip341) {\n+        // Computations shared between both sighash schemes.\n+        m_bip341_prevouts_hash = GetPrevoutHash(txTo);\n+        m_bip341_sequences_hash = GetSequenceHash(txTo);\n+        m_bip341_outputs_hash = GetOutputsHash(txTo);\n+    }\n+    if (uses_bip143) {\n+        hashPrevouts = SHA256Uint256(m_bip341_prevouts_hash);\n+        hashSequence = SHA256Uint256(m_bip341_sequences_hash);\n+        hashOutputs = SHA256Uint256(m_bip341_outputs_hash);\n+        m_bip143_ready = true;\n+    }\n+    if (uses_bip341) {\n+        m_bip341_spent_amounts_hash = GetSpentAmountsHash(m_spent_outputs);\n+        m_bip341_spent_scripts_hash = GetSpentScriptsHash(m_spent_outputs);\n+        m_bip341_ready = true;\n+    }\n }\n \n template <class T>\n PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n {\n-    Init(txTo);\n+    Init(txTo, {});\n }\n \n // explicit instantiation\n-template void PrecomputedTransactionData::Init(const CTransaction& txTo);\n-template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo);\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+static const CHashWriter HASHER_TAPLEAF = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HASHER_TAPBRANCH = TaggedHash(\"TapBranch\");\n+static const CHashWriter HASHER_TAPTWEAK = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData* cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    case SigVersion::TAPSCRIPT:\n+        ext_flag = 1;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache != nullptr && cache->m_bip341_ready && cache->m_spent_outputs_ready);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r474385753",
      "id" : 474385753,
      "in_reply_to_id" : 473553826,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM4NTc1Mw==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 1486,
      "original_position" : 360,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 472119514,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/474385753",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r474390723"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/474390723"
         }
      },
      "author_association" : "MEMBER",
      "body" : "There is no signing code yet, so this may go in a number of different ways, but I was imagining that the cache would indeed be used for signing as well, as it becomes increasingly inconvenient to pass all arguments (including all spent UTXOs now!) along down into the signing function.\r\n\r\nIn fact, I think after the change to use the cache to pass that information along, we can stop passing scriptPubKey/amount/txFrom to `SignSignature`... but that's for much later.\r\n\r\n@kallewoof It's indeed ugly in the signing case that the scriptWitness is used to determine if a transaction is a witness input. I'll change that for now to just default to BIP143 caching unless it's clearly a BIP341 spend, instead of relying on there being a non-empty witness.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-21T03:39:36Z",
      "diff_hunk" : "@@ -1258,65 +1349,207 @@ class CTransactionSignatureSerializer\n     }\n };\n \n+/** Compute the (single) SHA256 of the concatenation of all prevouts of a tx. */\n template <class T>\n uint256 GetPrevoutHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txin : txTo.vin) {\n         ss << txin.prevout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all nSequences of a tx. */\n template <class T>\n uint256 GetSequenceHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txin : txTo.vin) {\n         ss << txin.nSequence;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all txouts of a tx. */\n template <class T>\n uint256 GetOutputsHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n+    }\n+\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143 = false;\n+    bool uses_bip341 = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every native witness v1 spend as a Taproot spend. This only works if spent_outputs was\n+                // provided as well, but if it wasn't, actual validation will fail anyway.\n+                uses_bip341 = true;\n+            } else {\n+                // Treat every spend that's not known to native witness v1 as a Witness v0 spend. This branch may\n+                // also be taken for unknown witness versions, but it is harmless, and being precise would require\n+                // P2SH evaluation to find the redeemScript.\n+                uses_bip143 = true;\n+            }\n+        }\n     }\n \n-    m_ready = true;\n+    if (uses_bip143 || uses_bip341) {\n+        // Computations shared between both sighash schemes.\n+        m_bip341_prevouts_hash = GetPrevoutHash(txTo);\n+        m_bip341_sequences_hash = GetSequenceHash(txTo);\n+        m_bip341_outputs_hash = GetOutputsHash(txTo);\n+    }\n+    if (uses_bip143) {\n+        hashPrevouts = SHA256Uint256(m_bip341_prevouts_hash);\n+        hashSequence = SHA256Uint256(m_bip341_sequences_hash);\n+        hashOutputs = SHA256Uint256(m_bip341_outputs_hash);\n+        m_bip143_ready = true;\n+    }\n+    if (uses_bip341) {\n+        m_bip341_spent_amounts_hash = GetSpentAmountsHash(m_spent_outputs);\n+        m_bip341_spent_scripts_hash = GetSpentScriptsHash(m_spent_outputs);\n+        m_bip341_ready = true;\n+    }\n }\n \n template <class T>\n PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n {\n-    Init(txTo);\n+    Init(txTo, {});\n }\n \n // explicit instantiation\n-template void PrecomputedTransactionData::Init(const CTransaction& txTo);\n-template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo);\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+static const CHashWriter HASHER_TAPLEAF = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HASHER_TAPBRANCH = TaggedHash(\"TapBranch\");\n+static const CHashWriter HASHER_TAPTWEAK = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData* cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    case SigVersion::TAPSCRIPT:\n+        ext_flag = 1;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache != nullptr && cache->m_bip341_ready && cache->m_spent_outputs_ready);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r474390723",
      "id" : 474390723,
      "in_reply_to_id" : 473553826,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM5MDcyMw==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 1486,
      "original_position" : 360,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 472124884,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/474390723",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r474392228"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/474392228"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@sipa I worked around it on my end, so feel free to leave it as is until a decision is made on how signing should work!",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-21T03:46:35Z",
      "diff_hunk" : "@@ -1258,65 +1349,207 @@ class CTransactionSignatureSerializer\n     }\n };\n \n+/** Compute the (single) SHA256 of the concatenation of all prevouts of a tx. */\n template <class T>\n uint256 GetPrevoutHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txin : txTo.vin) {\n         ss << txin.prevout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all nSequences of a tx. */\n template <class T>\n uint256 GetSequenceHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txin : txTo.vin) {\n         ss << txin.nSequence;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all txouts of a tx. */\n template <class T>\n uint256 GetOutputsHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n+    }\n+\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143 = false;\n+    bool uses_bip341 = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every native witness v1 spend as a Taproot spend. This only works if spent_outputs was\n+                // provided as well, but if it wasn't, actual validation will fail anyway.\n+                uses_bip341 = true;\n+            } else {\n+                // Treat every spend that's not known to native witness v1 as a Witness v0 spend. This branch may\n+                // also be taken for unknown witness versions, but it is harmless, and being precise would require\n+                // P2SH evaluation to find the redeemScript.\n+                uses_bip143 = true;\n+            }\n+        }\n     }\n \n-    m_ready = true;\n+    if (uses_bip143 || uses_bip341) {\n+        // Computations shared between both sighash schemes.\n+        m_bip341_prevouts_hash = GetPrevoutHash(txTo);\n+        m_bip341_sequences_hash = GetSequenceHash(txTo);\n+        m_bip341_outputs_hash = GetOutputsHash(txTo);\n+    }\n+    if (uses_bip143) {\n+        hashPrevouts = SHA256Uint256(m_bip341_prevouts_hash);\n+        hashSequence = SHA256Uint256(m_bip341_sequences_hash);\n+        hashOutputs = SHA256Uint256(m_bip341_outputs_hash);\n+        m_bip143_ready = true;\n+    }\n+    if (uses_bip341) {\n+        m_bip341_spent_amounts_hash = GetSpentAmountsHash(m_spent_outputs);\n+        m_bip341_spent_scripts_hash = GetSpentScriptsHash(m_spent_outputs);\n+        m_bip341_ready = true;\n+    }\n }\n \n template <class T>\n PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n {\n-    Init(txTo);\n+    Init(txTo, {});\n }\n \n // explicit instantiation\n-template void PrecomputedTransactionData::Init(const CTransaction& txTo);\n-template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo);\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+static const CHashWriter HASHER_TAPLEAF = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HASHER_TAPBRANCH = TaggedHash(\"TapBranch\");\n+static const CHashWriter HASHER_TAPTWEAK = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData* cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    case SigVersion::TAPSCRIPT:\n+        ext_flag = 1;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache != nullptr && cache->m_bip341_ready && cache->m_spent_outputs_ready);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r474392228",
      "id" : 474392228,
      "in_reply_to_id" : 473553826,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM5MjIyOA==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 1486,
      "original_position" : 360,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 472126516,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/474392228",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r475112530"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/475112530"
         }
      },
      "author_association" : "MEMBER",
      "body" : "oh I was having a special brain moment thinking it was a conditional check on if the cache existed.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-22T17:31:38Z",
      "diff_hunk" : "@@ -1258,65 +1349,207 @@ class CTransactionSignatureSerializer\n     }\n };\n \n+/** Compute the (single) SHA256 of the concatenation of all prevouts of a tx. */\n template <class T>\n uint256 GetPrevoutHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txin : txTo.vin) {\n         ss << txin.prevout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all nSequences of a tx. */\n template <class T>\n uint256 GetSequenceHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txin : txTo.vin) {\n         ss << txin.nSequence;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all txouts of a tx. */\n template <class T>\n uint256 GetOutputsHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n+    }\n+\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143 = false;\n+    bool uses_bip341 = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every native witness v1 spend as a Taproot spend. This only works if spent_outputs was\n+                // provided as well, but if it wasn't, actual validation will fail anyway.\n+                uses_bip341 = true;\n+            } else {\n+                // Treat every spend that's not known to native witness v1 as a Witness v0 spend. This branch may\n+                // also be taken for unknown witness versions, but it is harmless, and being precise would require\n+                // P2SH evaluation to find the redeemScript.\n+                uses_bip143 = true;\n+            }\n+        }\n     }\n \n-    m_ready = true;\n+    if (uses_bip143 || uses_bip341) {\n+        // Computations shared between both sighash schemes.\n+        m_bip341_prevouts_hash = GetPrevoutHash(txTo);\n+        m_bip341_sequences_hash = GetSequenceHash(txTo);\n+        m_bip341_outputs_hash = GetOutputsHash(txTo);\n+    }\n+    if (uses_bip143) {\n+        hashPrevouts = SHA256Uint256(m_bip341_prevouts_hash);\n+        hashSequence = SHA256Uint256(m_bip341_sequences_hash);\n+        hashOutputs = SHA256Uint256(m_bip341_outputs_hash);\n+        m_bip143_ready = true;\n+    }\n+    if (uses_bip341) {\n+        m_bip341_spent_amounts_hash = GetSpentAmountsHash(m_spent_outputs);\n+        m_bip341_spent_scripts_hash = GetSpentScriptsHash(m_spent_outputs);\n+        m_bip341_ready = true;\n+    }\n }\n \n template <class T>\n PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n {\n-    Init(txTo);\n+    Init(txTo, {});\n }\n \n // explicit instantiation\n-template void PrecomputedTransactionData::Init(const CTransaction& txTo);\n-template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo);\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+static const CHashWriter HASHER_TAPLEAF = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HASHER_TAPBRANCH = TaggedHash(\"TapBranch\");\n+static const CHashWriter HASHER_TAPTWEAK = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData* cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    case SigVersion::TAPSCRIPT:\n+        ext_flag = 1;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache != nullptr && cache->m_bip341_ready && cache->m_spent_outputs_ready);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r475112530",
      "id" : 475112530,
      "in_reply_to_id" : 473553826,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTExMjUzMA==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 1486,
      "original_position" : 360,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 472940286,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/475112530",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r475863712"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/475863712"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think we should probably require `spent_outputs` in the constructor. That gets us a compile-time error rather than a runtime surprise, if any code is missing an update.\r\n\r\nAside from tests (which have a mere 4 uses), it's only used in libbitcoinconsensus, where the omission is arguably a bug (impossible to use existing APIs for Taproot verification).",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-24T20:06:56Z",
      "diff_hunk" : "@@ -1258,65 +1349,207 @@ class CTransactionSignatureSerializer\n     }\n };\n \n+/** Compute the (single) SHA256 of the concatenation of all prevouts of a tx. */\n template <class T>\n uint256 GetPrevoutHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txin : txTo.vin) {\n         ss << txin.prevout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all nSequences of a tx. */\n template <class T>\n uint256 GetSequenceHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txin : txTo.vin) {\n         ss << txin.nSequence;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all txouts of a tx. */\n template <class T>\n uint256 GetOutputsHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n+    }\n+\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143 = false;\n+    bool uses_bip341 = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every native witness v1 spend as a Taproot spend. This only works if spent_outputs was\n+                // provided as well, but if it wasn't, actual validation will fail anyway.\n+                uses_bip341 = true;\n+            } else {\n+                // Treat every spend that's not known to native witness v1 as a Witness v0 spend. This branch may\n+                // also be taken for unknown witness versions, but it is harmless, and being precise would require\n+                // P2SH evaluation to find the redeemScript.\n+                uses_bip143 = true;\n+            }\n+        }\n     }\n \n-    m_ready = true;\n+    if (uses_bip143 || uses_bip341) {\n+        // Computations shared between both sighash schemes.\n+        m_bip341_prevouts_hash = GetPrevoutHash(txTo);\n+        m_bip341_sequences_hash = GetSequenceHash(txTo);\n+        m_bip341_outputs_hash = GetOutputsHash(txTo);\n+    }\n+    if (uses_bip143) {\n+        hashPrevouts = SHA256Uint256(m_bip341_prevouts_hash);\n+        hashSequence = SHA256Uint256(m_bip341_sequences_hash);\n+        hashOutputs = SHA256Uint256(m_bip341_outputs_hash);\n+        m_bip143_ready = true;\n+    }\n+    if (uses_bip341) {\n+        m_bip341_spent_amounts_hash = GetSpentAmountsHash(m_spent_outputs);\n+        m_bip341_spent_scripts_hash = GetSpentScriptsHash(m_spent_outputs);\n+        m_bip341_ready = true;\n+    }\n }\n \n template <class T>\n PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n {\n-    Init(txTo);\n+    Init(txTo, {});",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r475863712",
      "id" : 475863712,
      "line" : 1462,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg2MzcxMg==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 1462,
      "original_position" : 329,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 302,
      "pull_request_review_id" : 473818660,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/475863712",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r475947567"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/475947567"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Please rename things that change meaning. eg, `GetPrevoutSHA256`",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-24T23:13:32Z",
      "diff_hunk" : "@@ -1258,65 +1349,207 @@ class CTransactionSignatureSerializer\n     }\n };\n \n+/** Compute the (single) SHA256 of the concatenation of all prevouts of a tx. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r475947567",
      "id" : 475947567,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk0NzU2Nw==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 1354,
      "original_position" : 209,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 473818660,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/475947567",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r475951884"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/475951884"
         }
      },
      "author_association" : "MEMBER",
      "body" : "(Review TODO: Check that this is actually true, even when no signature checking occurs.)",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-24T23:19:41Z",
      "diff_hunk" : "@@ -1258,65 +1349,207 @@ class CTransactionSignatureSerializer\n     }\n };\n \n+/** Compute the (single) SHA256 of the concatenation of all prevouts of a tx. */\n template <class T>\n uint256 GetPrevoutHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txin : txTo.vin) {\n         ss << txin.prevout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all nSequences of a tx. */\n template <class T>\n uint256 GetSequenceHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txin : txTo.vin) {\n         ss << txin.nSequence;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all txouts of a tx. */\n template <class T>\n uint256 GetOutputsHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n+    }\n+\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143 = false;\n+    bool uses_bip341 = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every native witness v1 spend as a Taproot spend. This only works if spent_outputs was\n+                // provided as well, but if it wasn't, actual validation will fail anyway.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r475951884",
      "id" : 475951884,
      "line" : 1429,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk1MTg4NA==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 1429,
      "original_position" : 294,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 268,
      "pull_request_review_id" : 473818660,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/475951884",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r475978120"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/475978120"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Technically, Tapscript itself is a form of P2SH, just not BIP16 P2SH.\r\n\r\nThe comment here confused me. Perhaps \"non-BIP16-wrapped\"?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-24T23:56:52Z",
      "diff_hunk" : "@@ -114,41 +120,115 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making the use of (unknown) annexes non-standard (currently no annexes are known)\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 20),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 21),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    // BIP341 precomputed data.\n+    // These are single-SHA256, see https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-15.\n+    uint256 m_bip341_prevouts_hash;\n+    uint256 m_bip341_sequences_hash;\n+    uint256 m_bip341_outputs_hash;\n+    uint256 m_bip341_spent_amounts_hash;\n+    uint256 m_bip341_spent_scripts_hash;\n+    //! Whether the 5 fields above are initialized.\n+    bool m_bip341_ready = false;\n+\n+    // BIP143 precomputed data (double-SHA256).\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n-    bool m_ready = false;\n+    //! Whether the 3 fields above are initialized.\n+    bool m_bip143_ready = false;\n+\n+    std::vector<CTxOut> m_spent_outputs;\n+    //! Whether m_spent_outputs is initialized.\n+    bool m_spent_outputs_ready = false;\n \n     PrecomputedTransactionData() = default;\n \n     template <class T>\n-    void Init(const T& tx);\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and P2SH redeemscripts; see BIP 16\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with non-P2SH 32 byte program (Taproot), key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with non-P2SH 32 byte program (Taproot), script path spending, leaf version 0xc0 (Tapscript); see BIP 342",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r475978120",
      "id" : 475978120,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk3ODEyMA==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 180,
      "original_position" : 87,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 473818660,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/475978120",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r475990462"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/475990462"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should this be non-experimental before merging?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-25T00:15:09Z",
      "diff_hunk" : "@@ -1610,7 +1610,7 @@ if test x$need_bundled_univalue = xyes; then\n   AC_CONFIG_SUBDIRS([src/univalue])\n fi\n \n-ac_configure_args=\"${ac_configure_args} --disable-shared --with-pic --enable-benchmark=no --with-bignum=no --enable-module-recovery\"\n+ac_configure_args=\"${ac_configure_args} --disable-shared --with-pic --enable-benchmark=no --with-bignum=no --enable-module-recovery --enable-module-schnorrsig --enable-experimental\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r475990462",
      "id" : 475990462,
      "line" : 1648,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk5MDQ2Mg==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 1648,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "configure.ac",
      "position" : 5,
      "pull_request_review_id" : 473818660,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/475990462",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r475992610"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/475992610"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Suggest moving `CheckSig` -> `CheckECDSASignature` rename to a dedicated commit",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-25T00:18:27Z",
      "diff_hunk" : "@@ -176,20 +256,22 @@ class GenericTransactionSignatureChecker : public BaseSignatureChecker\n     const PrecomputedTransactionData* txdata;\n \n protected:\n-    virtual bool VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& vchPubKey, const uint256& sighash) const;\n+    virtual bool VerifyECDSASignature(const std::vector<unsigned char>& vchSig, const CPubKey& vchPubKey, const uint256& sighash) const;\n+    virtual bool VerifySchnorrSignature(const std::vector<unsigned char>& sig, const XOnlyPubKey& pubkey, const uint256& sighash) const;\n \n public:\n     GenericTransactionSignatureChecker(const T* txToIn, unsigned int nInIn, const CAmount& amountIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(nullptr) {}\n     GenericTransactionSignatureChecker(const T* txToIn, unsigned int nInIn, const CAmount& amountIn, const PrecomputedTransactionData& txdataIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(&txdataIn) {}\n-    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override;\n+    bool CheckECDSASignature(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r475992610",
      "id" : 475992610,
      "line" : 262,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk5MjYxMA==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 262,
      "original_position" : 155,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : 158,
      "pull_request_review_id" : 473818660,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/475992610",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r475993339"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/475993339"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: \"is not *exactly* 64 bytes\"",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-25T00:19:34Z",
      "diff_hunk" : "@@ -206,6 +206,25 @@ class CPubKey\n     bool Derive(CPubKey& pubkeyChild, ChainCode &ccChild, unsigned int nChild, const ChainCode& cc) const;\n };\n \n+class XOnlyPubKey {\n+private:\n+    uint256 m_keydata;\n+\n+public:\n+    XOnlyPubKey(const uint256& in) : m_keydata(in) {}\n+\n+    /** Verify a 64-byte Schnorr signature.\n+     *\n+     * If the signature is not 64 bytes, or the public key is not fully valid, false is returned.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r475993339",
      "id" : 475993339,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk5MzMzOQ==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 218,
      "original_position" : 22,
      "original_start_line" : null,
      "path" : "src/pubkey.h",
      "position" : null,
      "pull_request_review_id" : 473818660,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/475993339",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r475997847"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/475997847"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Suggest moving the size check and uint256 cast into `XOnlyPubKey` construction & `IsValid`, like `CheckECDSASignature` does",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-25T00:26:13Z",
      "diff_hunk" : "@@ -1407,12 +1646,33 @@ bool GenericTransactionSignatureChecker<T>::CheckSig(const std::vector<unsigned\n \n     uint256 sighash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion, this->txdata);\n \n-    if (!VerifySignature(vchSig, pubkey, sighash))\n+    if (!VerifyECDSASignature(vchSig, pubkey, sighash))\n         return false;\n \n     return true;\n }\n \n+template <class T>\n+bool GenericTransactionSignatureChecker<T>::CheckSchnorrSignature(const std::vector<unsigned char>& sig_in, const std::vector<unsigned char>& pubkey_in, SigVersion sigversion, const ScriptExecutionData& execdata) const\n+{\n+    std::vector<unsigned char> sig(sig_in);\n+    if (sig.empty()) return false;\n+\n+    if (pubkey_in.size() != 32) return false;\n+    XOnlyPubKey pubkey{uint256(pubkey_in)};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r475997847",
      "id" : 475997847,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk5Nzg0Nw==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 1662,
      "original_position" : 491,
      "original_start_line" : 1661,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 473818660,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/475997847",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r476002693"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/476002693"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Inaccuracy in previous comment aside, seems like it would be best to correct the new one (with 31 null bytes after E/S)",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-25T00:34:02Z",
      "diff_hunk" : "@@ -22,8 +22,9 @@ namespace {\n class CSignatureCache\n {\n private:\n-     //! Entries are SHA256(nonce || signature hash || public key || signature):\n-    CSHA256 m_salted_hasher;\n+     //! Entries are SHA256(nonce || 'E' or 'S' || signature hash || public key || signature):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r476002693",
      "id" : 476002693,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjAwMjY5Mw==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 25,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "src/script/sigcache.cpp",
      "position" : null,
      "pull_request_review_id" : 473818660,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/476002693",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r476003576"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/476003576"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Probable premature optimisation: Copy `m_salted_hasher_ecdsa` before adding the padding?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-25T00:35:17Z",
      "diff_hunk" : "@@ -34,18 +35,30 @@ class CSignatureCache\n         uint256 nonce = GetRandHash();\n         // We want the nonce to be 64 bytes long to force the hasher to process\n         // this chunk, which makes later hash computations more efficient. We\n-        // just write our 32-byte entropy twice to fill the 64 bytes.\n-        m_salted_hasher.Write(nonce.begin(), 32);\n-        m_salted_hasher.Write(nonce.begin(), 32);\n+        // just write our 32-byte entropy, and then pad with 'E' for ECDSA and\n+        // 'S' for Schnorr (followed by 0 bytes).\n+        static const unsigned char PADDING_ECDSA[32] = {'E'};\n+        static const unsigned char PADDING_SCHNORR[32] = {'S'};\n+        m_salted_hasher_ecdsa.Write(nonce.begin(), 32);\n+        m_salted_hasher_ecdsa.Write(PADDING_ECDSA, 32);\n+        m_salted_hasher_schnorr.Write(nonce.begin(), 32);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r476003576",
      "id" : 476003576,
      "line" : 44,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjAwMzU3Ng==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 44,
      "original_position" : 25,
      "original_start_line" : null,
      "path" : "src/script/sigcache.cpp",
      "position" : 25,
      "pull_request_review_id" : 473818660,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/476003576",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r476142106"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/476142106"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Prefer `assert(false);` for unreachable conditions",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-25T04:08:19Z",
      "diff_hunk" : "@@ -363,15 +360,76 @@ static bool EvalChecksig(const valtype& vchSig, const valtype& vchPubKey, CScrip\n         //serror is set\n         return false;\n     }\n-    fSuccess = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion);\n+    fSuccess = checker.CheckECDSASignature(vchSig, vchPubKey, scriptCode, sigversion);\n \n     if (!fSuccess && (flags & SCRIPT_VERIFY_NULLFAIL) && vchSig.size())\n         return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);\n \n     return true;\n }\n \n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)\n+static bool EvalChecksigTapscript(const valtype& sig, const valtype& pubkey, ScriptExecutionData& execdata, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& success)\n+{\n+    assert(sigversion == SigVersion::TAPSCRIPT);\n+\n+    /*\n+     *  The following validation sequence is consensus critical. Please note how --\n+     *    upgradable public key versions precede other rules;\n+     *    the script execution fails when using empty signature with invalid public key;\n+     *    the script execution fails when using non-empty invalid signature.\n+     */\n+    success = !sig.empty();\n+    if (success) {\n+        // Implement the sigops/witnesssize ratio test.\n+        // Passing with an upgradable public key version is also counted.\n+        assert(execdata.m_validation_weight_left_init);\n+        execdata.m_validation_weight_left -= VALIDATION_WEIGHT_PER_SIGOP_PASSED;\n+        if (execdata.m_validation_weight_left < 0) {\n+            return set_error(serror, SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT);\n+        }\n+    }\n+    if (pubkey.size() == 0) {\n+        return set_error(serror, SCRIPT_ERR_PUBKEYTYPE);\n+    } else if (pubkey.size() == 32) {\n+        if (success && !checker.CheckSchnorrSignature(sig, pubkey, sigversion, execdata)) {\n+            return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);\n+        }\n+    } else {\n+        /*\n+         *  New public key version softforks should be defined before this `else` block.\n+         *  Generally, the new code should not do anything but failing the script execution. To avoid\n+         *  consensus bugs, it should not modify any existing values (including success).\n+         */\n+        if ((flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE) != 0) {\n+            return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE);\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+/** Helper for OP_CHECKSIG, OP_CHECKSIGVERIFY, and (in Tapscript) OP_CHECKSIGADD.\n+ *\n+ * A return value of false means the script fails entirely. When true is returned, the\n+ * fSuccess variable indicates whether the signature check itself succeeded.\n+ */\n+static bool EvalChecksig(const valtype& sig, const valtype& pubkey, CScript::const_iterator pbegincodehash, CScript::const_iterator pend, ScriptExecutionData& execdata, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& success)\n+{\n+    switch (sigversion) {\n+    case SigVersion::BASE:\n+    case SigVersion::WITNESS_V0:\n+        return EvalChecksigPreTapscript(sig, pubkey, pbegincodehash, pend, flags, checker, sigversion, serror, success);\n+    case SigVersion::TAPSCRIPT:\n+        return EvalChecksigTapscript(sig, pubkey, execdata, flags, checker, sigversion, serror, success);\n+    case SigVersion::TAPROOT:\n+        // Key path spending in Taproot has no script, so this is unreachable.\n+        break;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r476142106",
      "id" : 476142106,
      "line" : 426,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjE0MjEwNg==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 426,
      "original_position" : 86,
      "original_start_line" : 425,
      "path" : "src/script/interpreter.cpp",
      "position" : 86,
      "pull_request_review_id" : 473818660,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : 425,
      "start_side" : "RIGHT",
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/476142106",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r476154468"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/476154468"
         }
      },
      "author_association" : "MEMBER",
      "body" : "If we ever had a `continue`, this would get skipped. Seems like a code footgun.\r\n\r\nWe could replace `while (pc < pend)` with `for ( ; pc < pend; ++opcode_pos)` perhaps?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-25T04:25:43Z",
      "diff_hunk" : "@@ -1146,6 +1235,8 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n             // Size limits\n             if (stack.size() + altstack.size() > MAX_STACK_SIZE)\n                 return set_error(serror, SCRIPT_ERR_STACK_SIZE);\n+\n+            ++opcode_pos;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r476154468",
      "id" : 476154468,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjE1NDQ2OA==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 1239,
      "original_position" : 201,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 473818660,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/476154468",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r476157648"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/476157648"
         }
      },
      "author_association" : "MEMBER",
      "body" : "All existing disabled opcodes trigger `SCRIPT_ERR_DISABLED_OPCODE` unconditionally, even if their branch isn't taken. Do we want to preserve that for CHECKMULTISIG? If not, do we still want to use the same error code?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-25T04:30:06Z",
      "diff_hunk" : "@@ -1029,9 +1095,32 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                 }\n                 break;\n \n+                case OP_CHECKSIGADD:\n+                {\n+                    // OP_CHECKSIGADD is only available in Tapscript\n+                    if (sigversion == SigVersion::BASE || sigversion == SigVersion::WITNESS_V0) return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n+\n+                    // (sig num pubkey -- num)\n+                    if (stack.size() < 3) return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n+\n+                    const valtype& sig = stacktop(-3);\n+                    const CScriptNum num(stacktop(-2), fRequireMinimal);\n+                    const valtype& pubkey = stacktop(-1);\n+\n+                    bool success = true;\n+                    if (!EvalChecksig(sig, pubkey, pbegincodehash, pend, execdata, flags, checker, sigversion, serror, success)) return false;\n+                    popstack(stack);\n+                    popstack(stack);\n+                    popstack(stack);\n+                    stack.push_back((num + (success ? 1 : 0)).getvch());\n+                }\n+                break;\n+\n                 case OP_CHECKMULTISIG:\n                 case OP_CHECKMULTISIGVERIFY:\n                 {\n+                    if (sigversion == SigVersion::TAPSCRIPT) return set_error(serror, SCRIPT_ERR_DISABLED_OPCODE);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r476157648",
      "id" : 476157648,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjE1NzY0OA==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 1122,
      "original_position" : 182,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 473818660,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/476157648",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r476166522"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/476166522"
         }
      },
      "author_association" : "MEMBER",
      "body" : "We should probably policy-reject annex here for now?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-25T04:42:21Z",
      "diff_hunk" : "@@ -237,6 +239,34 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check MAX_STANDARD_TAPSCRIPT_STACK_ITEM_SIZE policy limit for Taproot spends.\n+        if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE && !p2sh) {\n+            // Taproot spend (non-P2SH-wrapped, version 1, witness program size 32; see BIP 341)\n+            auto stack = MakeSpan(tx.vin[i].scriptWitness.stack);\n+            if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {\n+                // Drop annex",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r476166522",
      "id" : 476166522,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjE2NjUyMg==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 248,
      "original_position" : 35,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : null,
      "pull_request_review_id" : 473818660,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/476166522",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r476264893"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/476264893"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "#19601 ",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-25T08:18:08Z",
      "diff_hunk" : "@@ -1258,65 +1349,207 @@ class CTransactionSignatureSerializer\n     }\n };\n \n+/** Compute the (single) SHA256 of the concatenation of all prevouts of a tx. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r476264893",
      "id" : 476264893,
      "in_reply_to_id" : 475947567,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI2NDg5Mw==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 1354,
      "original_position" : 209,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 474244041,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/476264893",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r476268491"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/476268491"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "it only happens on startup right now, so :man_shrugging: ",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-25T08:23:44Z",
      "diff_hunk" : "@@ -34,18 +35,30 @@ class CSignatureCache\n         uint256 nonce = GetRandHash();\n         // We want the nonce to be 64 bytes long to force the hasher to process\n         // this chunk, which makes later hash computations more efficient. We\n-        // just write our 32-byte entropy twice to fill the 64 bytes.\n-        m_salted_hasher.Write(nonce.begin(), 32);\n-        m_salted_hasher.Write(nonce.begin(), 32);\n+        // just write our 32-byte entropy, and then pad with 'E' for ECDSA and\n+        // 'S' for Schnorr (followed by 0 bytes).\n+        static const unsigned char PADDING_ECDSA[32] = {'E'};\n+        static const unsigned char PADDING_SCHNORR[32] = {'S'};\n+        m_salted_hasher_ecdsa.Write(nonce.begin(), 32);\n+        m_salted_hasher_ecdsa.Write(PADDING_ECDSA, 32);\n+        m_salted_hasher_schnorr.Write(nonce.begin(), 32);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r476268491",
      "id" : 476268491,
      "in_reply_to_id" : 476003576,
      "line" : 44,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI2ODQ5MQ==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 44,
      "original_position" : 25,
      "original_start_line" : null,
      "path" : "src/script/sigcache.cpp",
      "position" : 25,
      "pull_request_review_id" : 474248688,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/476268491",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r476270164"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/476270164"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "the previous one is not incorrect AFIACT, because the nonce is just required to be 64 bytes long with at least 256 bits of entropy, which it has (nonce, signature hash, and public key are not variable names).",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-25T08:26:26Z",
      "diff_hunk" : "@@ -22,8 +22,9 @@ namespace {\n class CSignatureCache\n {\n private:\n-     //! Entries are SHA256(nonce || signature hash || public key || signature):\n-    CSHA256 m_salted_hasher;\n+     //! Entries are SHA256(nonce || 'E' or 'S' || signature hash || public key || signature):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r476270164",
      "id" : 476270164,
      "in_reply_to_id" : 476002693,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI3MDE2NA==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 25,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "src/script/sigcache.cpp",
      "position" : null,
      "pull_request_review_id" : 474251082,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/476270164",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\n This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2020-08-25T14:10:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-680049358",
      "id" : 680049358,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY4MDA0OTM1OA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-08-25T14:10:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/680049358",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478699201"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478699201"
         }
      },
      "author_association" : "MEMBER",
      "body" : "They are policy-invalid, though it's implemented as a script verification flag (`SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX`). Any particular reason why you prefer it here?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-27T21:13:27Z",
      "diff_hunk" : "@@ -237,6 +239,34 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check MAX_STANDARD_TAPSCRIPT_STACK_ITEM_SIZE policy limit for Taproot spends.\n+        if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE && !p2sh) {\n+            // Taproot spend (non-P2SH-wrapped, version 1, witness program size 32; see BIP 341)\n+            auto stack = MakeSpan(tx.vin[i].scriptWitness.stack);\n+            if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {\n+                // Drop annex",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478699201",
      "id" : 478699201,
      "in_reply_to_id" : 476166522,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY5OTIwMQ==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 248,
      "original_position" : 35,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : null,
      "pull_request_review_id" : 477088239,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478699201",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478710190"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478710190"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This case will cause the `assert(false)` below to be triggered. Is that sufficient?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-27T21:38:05Z",
      "diff_hunk" : "@@ -363,15 +360,76 @@ static bool EvalChecksig(const valtype& vchSig, const valtype& vchPubKey, CScrip\n         //serror is set\n         return false;\n     }\n-    fSuccess = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion);\n+    fSuccess = checker.CheckECDSASignature(vchSig, vchPubKey, scriptCode, sigversion);\n \n     if (!fSuccess && (flags & SCRIPT_VERIFY_NULLFAIL) && vchSig.size())\n         return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);\n \n     return true;\n }\n \n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)\n+static bool EvalChecksigTapscript(const valtype& sig, const valtype& pubkey, ScriptExecutionData& execdata, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& success)\n+{\n+    assert(sigversion == SigVersion::TAPSCRIPT);\n+\n+    /*\n+     *  The following validation sequence is consensus critical. Please note how --\n+     *    upgradable public key versions precede other rules;\n+     *    the script execution fails when using empty signature with invalid public key;\n+     *    the script execution fails when using non-empty invalid signature.\n+     */\n+    success = !sig.empty();\n+    if (success) {\n+        // Implement the sigops/witnesssize ratio test.\n+        // Passing with an upgradable public key version is also counted.\n+        assert(execdata.m_validation_weight_left_init);\n+        execdata.m_validation_weight_left -= VALIDATION_WEIGHT_PER_SIGOP_PASSED;\n+        if (execdata.m_validation_weight_left < 0) {\n+            return set_error(serror, SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT);\n+        }\n+    }\n+    if (pubkey.size() == 0) {\n+        return set_error(serror, SCRIPT_ERR_PUBKEYTYPE);\n+    } else if (pubkey.size() == 32) {\n+        if (success && !checker.CheckSchnorrSignature(sig, pubkey, sigversion, execdata)) {\n+            return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);\n+        }\n+    } else {\n+        /*\n+         *  New public key version softforks should be defined before this `else` block.\n+         *  Generally, the new code should not do anything but failing the script execution. To avoid\n+         *  consensus bugs, it should not modify any existing values (including success).\n+         */\n+        if ((flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE) != 0) {\n+            return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE);\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+/** Helper for OP_CHECKSIG, OP_CHECKSIGVERIFY, and (in Tapscript) OP_CHECKSIGADD.\n+ *\n+ * A return value of false means the script fails entirely. When true is returned, the\n+ * fSuccess variable indicates whether the signature check itself succeeded.\n+ */\n+static bool EvalChecksig(const valtype& sig, const valtype& pubkey, CScript::const_iterator pbegincodehash, CScript::const_iterator pend, ScriptExecutionData& execdata, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& success)\n+{\n+    switch (sigversion) {\n+    case SigVersion::BASE:\n+    case SigVersion::WITNESS_V0:\n+        return EvalChecksigPreTapscript(sig, pubkey, pbegincodehash, pend, flags, checker, sigversion, serror, success);\n+    case SigVersion::TAPSCRIPT:\n+        return EvalChecksigTapscript(sig, pubkey, execdata, flags, checker, sigversion, serror, success);\n+    case SigVersion::TAPROOT:\n+        // Key path spending in Taproot has no script, so this is unreachable.\n+        break;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478710190",
      "id" : 478710190,
      "in_reply_to_id" : 476142106,
      "line" : 426,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcxMDE5MA==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 426,
      "original_position" : 86,
      "original_start_line" : 425,
      "path" : "src/script/interpreter.cpp",
      "position" : 86,
      "pull_request_review_id" : 477102272,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : 425,
      "start_side" : "RIGHT",
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478710190",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478710629"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478710629"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@luke-jr SHA256's blocksize is 64 bytes; if you've written less than that, there isn't anything to gain from duplicating the state (also, as @JeremyRubin says, it only runs once on startup).",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-27T21:39:01Z",
      "diff_hunk" : "@@ -34,18 +35,30 @@ class CSignatureCache\n         uint256 nonce = GetRandHash();\n         // We want the nonce to be 64 bytes long to force the hasher to process\n         // this chunk, which makes later hash computations more efficient. We\n-        // just write our 32-byte entropy twice to fill the 64 bytes.\n-        m_salted_hasher.Write(nonce.begin(), 32);\n-        m_salted_hasher.Write(nonce.begin(), 32);\n+        // just write our 32-byte entropy, and then pad with 'E' for ECDSA and\n+        // 'S' for Schnorr (followed by 0 bytes).\n+        static const unsigned char PADDING_ECDSA[32] = {'E'};\n+        static const unsigned char PADDING_SCHNORR[32] = {'S'};\n+        m_salted_hasher_ecdsa.Write(nonce.begin(), 32);\n+        m_salted_hasher_ecdsa.Write(PADDING_ECDSA, 32);\n+        m_salted_hasher_schnorr.Write(nonce.begin(), 32);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478710629",
      "id" : 478710629,
      "in_reply_to_id" : 476003576,
      "line" : 44,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcxMDYyOQ==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 44,
      "original_position" : 25,
      "original_start_line" : null,
      "path" : "src/script/sigcache.cpp",
      "position" : 25,
      "pull_request_review_id" : 477102827,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478710629",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478740119"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478740119"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Less expensive/faster to reject?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-27T22:57:28Z",
      "diff_hunk" : "@@ -237,6 +239,34 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check MAX_STANDARD_TAPSCRIPT_STACK_ITEM_SIZE policy limit for Taproot spends.\n+        if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE && !p2sh) {\n+            // Taproot spend (non-P2SH-wrapped, version 1, witness program size 32; see BIP 341)\n+            auto stack = MakeSpan(tx.vin[i].scriptWitness.stack);\n+            if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {\n+                // Drop annex",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478740119",
      "id" : 478740119,
      "in_reply_to_id" : 476166522,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0MDExOQ==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 248,
      "original_position" : 35,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : null,
      "pull_request_review_id" : 477138263,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478740119",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478740581"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478740581"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm not sure about this. BIP340 public keys are just 32-byte arrays, not abstract objects that require serialization. So there shouldn't be a concept of an \"invalid public key\" that's distinct from signature validation failure, and I'd prefer not to introduce such a concept to XOnlyPubKey.\r\n\r\nArguably, this could be an `assert(pubkey_in.size() == 32);` even. If a different length is used, it's a code error.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-27T22:58:52Z",
      "diff_hunk" : "@@ -1407,12 +1646,33 @@ bool GenericTransactionSignatureChecker<T>::CheckSig(const std::vector<unsigned\n \n     uint256 sighash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion, this->txdata);\n \n-    if (!VerifySignature(vchSig, pubkey, sighash))\n+    if (!VerifyECDSASignature(vchSig, pubkey, sighash))\n         return false;\n \n     return true;\n }\n \n+template <class T>\n+bool GenericTransactionSignatureChecker<T>::CheckSchnorrSignature(const std::vector<unsigned char>& sig_in, const std::vector<unsigned char>& pubkey_in, SigVersion sigversion, const ScriptExecutionData& execdata) const\n+{\n+    std::vector<unsigned char> sig(sig_in);\n+    if (sig.empty()) return false;\n+\n+    if (pubkey_in.size() != 32) return false;\n+    XOnlyPubKey pubkey{uint256(pubkey_in)};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478740581",
      "id" : 478740581,
      "in_reply_to_id" : 475997847,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0MDU4MQ==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 1662,
      "original_position" : 491,
      "original_start_line" : 1661,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 477138775,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478740581",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478762492"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478762492"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I don't think so: It probably shouldn't be marked non-experimental until after it deployed for activation in Bitcoin because it wouldn't be good to encourage third party users of it while it is still easy to make incompatible changes in Bitcoin (e.g. as was just done. :) )",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-28T00:14:58Z",
      "diff_hunk" : "@@ -1610,7 +1610,7 @@ if test x$need_bundled_univalue = xyes; then\n   AC_CONFIG_SUBDIRS([src/univalue])\n fi\n \n-ac_configure_args=\"${ac_configure_args} --disable-shared --with-pic --enable-benchmark=no --with-bignum=no --enable-module-recovery\"\n+ac_configure_args=\"${ac_configure_args} --disable-shared --with-pic --enable-benchmark=no --with-bignum=no --enable-module-recovery --enable-module-schnorrsig --enable-experimental\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478762492",
      "id" : 478762492,
      "in_reply_to_id" : 475990462,
      "line" : 1648,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc2MjQ5Mg==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 1648,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "configure.ac",
      "position" : 5,
      "pull_request_review_id" : 477163370,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478762492",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "node_id" : "MDQ6VXNlcjg1ODQ1NA==",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478763561"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478763561"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Or, maybe more likely: the API in libsecp256k1 may change still significantly in the near future (e.g. support for variable-length messages, batch validation, ...) even after we treat the scheme itself final.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-28T00:19:08Z",
      "diff_hunk" : "@@ -1610,7 +1610,7 @@ if test x$need_bundled_univalue = xyes; then\n   AC_CONFIG_SUBDIRS([src/univalue])\n fi\n \n-ac_configure_args=\"${ac_configure_args} --disable-shared --with-pic --enable-benchmark=no --with-bignum=no --enable-module-recovery\"\n+ac_configure_args=\"${ac_configure_args} --disable-shared --with-pic --enable-benchmark=no --with-bignum=no --enable-module-recovery --enable-module-schnorrsig --enable-experimental\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478763561",
      "id" : 478763561,
      "in_reply_to_id" : 475990462,
      "line" : 1648,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc2MzU2MQ==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 1648,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "configure.ac",
      "position" : 5,
      "pull_request_review_id" : 477164496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478763561",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478766683"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478766683"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I tend to think of P2SH as referring to BIP16 based script hashing specifically, not the abstract concept.\r\n\r\nAnd arguably, it's not exactly true that taproot script path spending is paying to a script hash - it's paying to a tweaked public key (where the tweak happens to be indirectly a hash of a script). ",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-28T00:31:49Z",
      "diff_hunk" : "@@ -114,41 +120,115 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making the use of (unknown) annexes non-standard (currently no annexes are known)\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 20),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 21),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    // BIP341 precomputed data.\n+    // These are single-SHA256, see https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-15.\n+    uint256 m_bip341_prevouts_hash;\n+    uint256 m_bip341_sequences_hash;\n+    uint256 m_bip341_outputs_hash;\n+    uint256 m_bip341_spent_amounts_hash;\n+    uint256 m_bip341_spent_scripts_hash;\n+    //! Whether the 5 fields above are initialized.\n+    bool m_bip341_ready = false;\n+\n+    // BIP143 precomputed data (double-SHA256).\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n-    bool m_ready = false;\n+    //! Whether the 3 fields above are initialized.\n+    bool m_bip143_ready = false;\n+\n+    std::vector<CTxOut> m_spent_outputs;\n+    //! Whether m_spent_outputs is initialized.\n+    bool m_spent_outputs_ready = false;\n \n     PrecomputedTransactionData() = default;\n \n     template <class T>\n-    void Init(const T& tx);\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and P2SH redeemscripts; see BIP 16\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with non-P2SH 32 byte program (Taproot), key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with non-P2SH 32 byte program (Taproot), script path spending, leaf version 0xc0 (Tapscript); see BIP 342",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478766683",
      "id" : 478766683,
      "in_reply_to_id" : 475978120,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc2NjY4Mw==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 180,
      "original_position" : 87,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 477168086,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478766683",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478781629"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478781629"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I would very much like that, but I think we inevitably need a few states in it at least.\r\n\r\nThe `PrecomputedTransactionData` objects used for block validation are constructed once up front, and then initialized simultaneously with other checks in `CheckInputScripts`. This means they need some sort of \"uninitialized\" state which can detect incorrect use before initialization. A cleaner solution would be to move the construction of these objects out of `CheckInputScripts` and do it up front, so they can be constructed with all available information once and for all. I think that makes sense, but it's a bigger change to validation logic that I'd like to avoid in this PR.\r\n\r\nThe other reason is indeed libconsensus, which has no API for taproot validation. There is also no problem, as it doesn't expose a taproot validation flag (yet). A future extension to it would add a new call that lets you pass in the spent UTXOs, and let you enable taproot validation. But as of right now, changing things to require the UTXOs whenever initializing the `PrecomputedTransactionData` would mean that libconsensus would need to construct mock UTXOs and pass those in... which I think is worse than having an explicit uninitialized state that'd trigger an error on misuse.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-28T01:30:10Z",
      "diff_hunk" : "@@ -1258,65 +1349,207 @@ class CTransactionSignatureSerializer\n     }\n };\n \n+/** Compute the (single) SHA256 of the concatenation of all prevouts of a tx. */\n template <class T>\n uint256 GetPrevoutHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txin : txTo.vin) {\n         ss << txin.prevout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all nSequences of a tx. */\n template <class T>\n uint256 GetSequenceHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txin : txTo.vin) {\n         ss << txin.nSequence;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all txouts of a tx. */\n template <class T>\n uint256 GetOutputsHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n+    }\n+\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143 = false;\n+    bool uses_bip341 = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every native witness v1 spend as a Taproot spend. This only works if spent_outputs was\n+                // provided as well, but if it wasn't, actual validation will fail anyway.\n+                uses_bip341 = true;\n+            } else {\n+                // Treat every spend that's not known to native witness v1 as a Witness v0 spend. This branch may\n+                // also be taken for unknown witness versions, but it is harmless, and being precise would require\n+                // P2SH evaluation to find the redeemScript.\n+                uses_bip143 = true;\n+            }\n+        }\n     }\n \n-    m_ready = true;\n+    if (uses_bip143 || uses_bip341) {\n+        // Computations shared between both sighash schemes.\n+        m_bip341_prevouts_hash = GetPrevoutHash(txTo);\n+        m_bip341_sequences_hash = GetSequenceHash(txTo);\n+        m_bip341_outputs_hash = GetOutputsHash(txTo);\n+    }\n+    if (uses_bip143) {\n+        hashPrevouts = SHA256Uint256(m_bip341_prevouts_hash);\n+        hashSequence = SHA256Uint256(m_bip341_sequences_hash);\n+        hashOutputs = SHA256Uint256(m_bip341_outputs_hash);\n+        m_bip143_ready = true;\n+    }\n+    if (uses_bip341) {\n+        m_bip341_spent_amounts_hash = GetSpentAmountsHash(m_spent_outputs);\n+        m_bip341_spent_scripts_hash = GetSpentScriptsHash(m_spent_outputs);\n+        m_bip341_ready = true;\n+    }\n }\n \n template <class T>\n PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n {\n-    Init(txTo);\n+    Init(txTo, {});",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478781629",
      "id" : 478781629,
      "in_reply_to_id" : 475863712,
      "line" : 1462,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc4MTYyOQ==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 1462,
      "original_position" : 329,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 302,
      "pull_request_review_id" : 477185050,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478781629",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478781929"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478781929"
         }
      },
      "author_association" : "MEMBER",
      "body" : "If no signature checking occurs none of the code in interpreter.cpp matters.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-28T01:31:22Z",
      "diff_hunk" : "@@ -1258,65 +1349,207 @@ class CTransactionSignatureSerializer\n     }\n };\n \n+/** Compute the (single) SHA256 of the concatenation of all prevouts of a tx. */\n template <class T>\n uint256 GetPrevoutHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txin : txTo.vin) {\n         ss << txin.prevout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all nSequences of a tx. */\n template <class T>\n uint256 GetSequenceHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txin : txTo.vin) {\n         ss << txin.nSequence;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all txouts of a tx. */\n template <class T>\n uint256 GetOutputsHash(const T& txTo)\n {\n     CHashWriter ss(SER_GETHASH, 0);\n     for (const auto& txout : txTo.vout) {\n         ss << txout;\n     }\n-    return ss.GetHash();\n+    return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsHash(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n+    }\n+\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143 = false;\n+    bool uses_bip341 = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every native witness v1 spend as a Taproot spend. This only works if spent_outputs was\n+                // provided as well, but if it wasn't, actual validation will fail anyway.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478781929",
      "id" : 478781929,
      "in_reply_to_id" : 475951884,
      "line" : 1429,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc4MTkyOQ==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 1429,
      "original_position" : 294,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 268,
      "pull_request_review_id" : 477185405,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478781929",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478786156"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478786156"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done, by virtue of rebasing on master which includes #19601 now.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-28T01:48:03Z",
      "diff_hunk" : "@@ -1258,65 +1349,207 @@ class CTransactionSignatureSerializer\n     }\n };\n \n+/** Compute the (single) SHA256 of the concatenation of all prevouts of a tx. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478786156",
      "id" : 478786156,
      "in_reply_to_id" : 475947567,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc4NjE1Ng==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 1354,
      "original_position" : 209,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 477189966,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478786156",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478786347"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478786347"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Addressed by changing the comments to \"Witness v1 with 32-byte program, not BIP16 P2SH-wrapped, ...\"",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-28T01:48:47Z",
      "diff_hunk" : "@@ -114,41 +120,115 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making the use of (unknown) annexes non-standard (currently no annexes are known)\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UNKNOWN_ANNEX = (1U << 19),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 20),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 21),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    // BIP341 precomputed data.\n+    // These are single-SHA256, see https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-15.\n+    uint256 m_bip341_prevouts_hash;\n+    uint256 m_bip341_sequences_hash;\n+    uint256 m_bip341_outputs_hash;\n+    uint256 m_bip341_spent_amounts_hash;\n+    uint256 m_bip341_spent_scripts_hash;\n+    //! Whether the 5 fields above are initialized.\n+    bool m_bip341_ready = false;\n+\n+    // BIP143 precomputed data (double-SHA256).\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n-    bool m_ready = false;\n+    //! Whether the 3 fields above are initialized.\n+    bool m_bip143_ready = false;\n+\n+    std::vector<CTxOut> m_spent_outputs;\n+    //! Whether m_spent_outputs is initialized.\n+    bool m_spent_outputs_ready = false;\n \n     PrecomputedTransactionData() = default;\n \n     template <class T>\n-    void Init(const T& tx);\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and P2SH redeemscripts; see BIP 16\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with non-P2SH 32 byte program (Taproot), key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with non-P2SH 32 byte program (Taproot), script path spending, leaf version 0xc0 (Tapscript); see BIP 342",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478786347",
      "id" : 478786347,
      "in_reply_to_id" : 475978120,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc4NjM0Nw==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 180,
      "original_position" : 87,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 477190193,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478786347",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478786391"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478786391"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Good idea, done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-28T01:48:58Z",
      "diff_hunk" : "@@ -176,20 +256,22 @@ class GenericTransactionSignatureChecker : public BaseSignatureChecker\n     const PrecomputedTransactionData* txdata;\n \n protected:\n-    virtual bool VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& vchPubKey, const uint256& sighash) const;\n+    virtual bool VerifyECDSASignature(const std::vector<unsigned char>& vchSig, const CPubKey& vchPubKey, const uint256& sighash) const;\n+    virtual bool VerifySchnorrSignature(const std::vector<unsigned char>& sig, const XOnlyPubKey& pubkey, const uint256& sighash) const;\n \n public:\n     GenericTransactionSignatureChecker(const T* txToIn, unsigned int nInIn, const CAmount& amountIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(nullptr) {}\n     GenericTransactionSignatureChecker(const T* txToIn, unsigned int nInIn, const CAmount& amountIn, const PrecomputedTransactionData& txdataIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(&txdataIn) {}\n-    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override;\n+    bool CheckECDSASignature(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478786391",
      "id" : 478786391,
      "in_reply_to_id" : 475992610,
      "line" : 262,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc4NjM5MQ==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 262,
      "original_position" : 155,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : 158,
      "pull_request_review_id" : 477190250,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478786391",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478786414"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478786414"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-28T01:49:05Z",
      "diff_hunk" : "@@ -206,6 +206,25 @@ class CPubKey\n     bool Derive(CPubKey& pubkeyChild, ChainCode &ccChild, unsigned int nChild, const ChainCode& cc) const;\n };\n \n+class XOnlyPubKey {\n+private:\n+    uint256 m_keydata;\n+\n+public:\n+    XOnlyPubKey(const uint256& in) : m_keydata(in) {}\n+\n+    /** Verify a 64-byte Schnorr signature.\n+     *\n+     * If the signature is not 64 bytes, or the public key is not fully valid, false is returned.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478786414",
      "id" : 478786414,
      "in_reply_to_id" : 475993339,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc4NjQxNA==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 218,
      "original_position" : 22,
      "original_start_line" : null,
      "path" : "src/pubkey.h",
      "position" : null,
      "pull_request_review_id" : 477190287,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478786414",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478786843"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478786843"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Made a few changes here, including passing pubkey/signature as a Span (which means one less useless vector copy during signature validation). The size is now asserted to be 32 bytes (both in XOnlyPubKey (where it's required), and in CheckSchnorrSignature (which makes decisions based on the length).",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-28T01:50:35Z",
      "diff_hunk" : "@@ -1407,12 +1646,33 @@ bool GenericTransactionSignatureChecker<T>::CheckSig(const std::vector<unsigned\n \n     uint256 sighash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion, this->txdata);\n \n-    if (!VerifySignature(vchSig, pubkey, sighash))\n+    if (!VerifyECDSASignature(vchSig, pubkey, sighash))\n         return false;\n \n     return true;\n }\n \n+template <class T>\n+bool GenericTransactionSignatureChecker<T>::CheckSchnorrSignature(const std::vector<unsigned char>& sig_in, const std::vector<unsigned char>& pubkey_in, SigVersion sigversion, const ScriptExecutionData& execdata) const\n+{\n+    std::vector<unsigned char> sig(sig_in);\n+    if (sig.empty()) return false;\n+\n+    if (pubkey_in.size() != 32) return false;\n+    XOnlyPubKey pubkey{uint256(pubkey_in)};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478786843",
      "id" : 478786843,
      "in_reply_to_id" : 475997847,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc4Njg0Mw==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 1662,
      "original_position" : 491,
      "original_start_line" : 1661,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 477190706,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478786843",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478786925"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478786925"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed by adding \"31 zero bytes\" explicitly in the comment.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-28T01:50:53Z",
      "diff_hunk" : "@@ -22,8 +22,9 @@ namespace {\n class CSignatureCache\n {\n private:\n-     //! Entries are SHA256(nonce || signature hash || public key || signature):\n-    CSHA256 m_salted_hasher;\n+     //! Entries are SHA256(nonce || 'E' or 'S' || signature hash || public key || signature):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478786925",
      "id" : 478786925,
      "in_reply_to_id" : 476002693,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc4NjkyNQ==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 25,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "src/script/sigcache.cpp",
      "position" : null,
      "pull_request_review_id" : 477190809,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478786925",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478787176"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478787176"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think there are bigger footguns already if there ever was a continue (like the stack size check just above), but regardless: good idea, done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-28T01:51:55Z",
      "diff_hunk" : "@@ -1146,6 +1235,8 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n             // Size limits\n             if (stack.size() + altstack.size() > MAX_STACK_SIZE)\n                 return set_error(serror, SCRIPT_ERR_STACK_SIZE);\n+\n+            ++opcode_pos;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478787176",
      "id" : 478787176,
      "in_reply_to_id" : 476154468,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc4NzE3Ng==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 1239,
      "original_position" : 201,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 477191067,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478787176",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478787773"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478787773"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nice catch, I didn't realize there was a discrepancy here. As BIP342 explicitly states that CMS/CMSV behave as OP_RETURN, namely failing the script if executed, I'm not going to change semantics, but I've changed it to have a separate dedicated error code.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-28T01:54:32Z",
      "diff_hunk" : "@@ -1029,9 +1095,32 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                 }\n                 break;\n \n+                case OP_CHECKSIGADD:\n+                {\n+                    // OP_CHECKSIGADD is only available in Tapscript\n+                    if (sigversion == SigVersion::BASE || sigversion == SigVersion::WITNESS_V0) return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n+\n+                    // (sig num pubkey -- num)\n+                    if (stack.size() < 3) return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n+\n+                    const valtype& sig = stacktop(-3);\n+                    const CScriptNum num(stacktop(-2), fRequireMinimal);\n+                    const valtype& pubkey = stacktop(-1);\n+\n+                    bool success = true;\n+                    if (!EvalChecksig(sig, pubkey, pbegincodehash, pend, execdata, flags, checker, sigversion, serror, success)) return false;\n+                    popstack(stack);\n+                    popstack(stack);\n+                    popstack(stack);\n+                    stack.push_back((num + (success ? 1 : 0)).getvch());\n+                }\n+                break;\n+\n                 case OP_CHECKMULTISIG:\n                 case OP_CHECKMULTISIGVERIFY:\n                 {\n+                    if (sigversion == SigVersion::TAPSCRIPT) return set_error(serror, SCRIPT_ERR_DISABLED_OPCODE);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478787773",
      "id" : 478787773,
      "in_reply_to_id" : 476157648,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc4Nzc3Mw==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 1122,
      "original_position" : 182,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 477191809,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478787773",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478788457"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478788457"
         }
      },
      "author_association" : "MEMBER",
      "body" : "My thinking was initially that there wouldn't be a performance benefit, as taproot execution to the point where the annex is reached is very cheap - but then again, there may be a valid, expensive input, and another one with an annex.\r\n\r\nI've moved the annex policy rule to policy/policy.cpp (which also removes a validation flag).\r\n\r\nThis makes me wonder if we'd want the same with unknown leaf versions, but a reason not to may be that that would mean putting knowledge about defined/valid leaf versions in two places. So I'm going to stick with the rule \"implement it where it's simplest\", which means annex here, and leaf versions there.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-28T01:57:07Z",
      "diff_hunk" : "@@ -237,6 +239,34 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check MAX_STANDARD_TAPSCRIPT_STACK_ITEM_SIZE policy limit for Taproot spends.\n+        if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE && !p2sh) {\n+            // Taproot spend (non-P2SH-wrapped, version 1, witness program size 32; see BIP 341)\n+            auto stack = MakeSpan(tx.vin[i].scriptWitness.stack);\n+            if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {\n+                // Drop annex",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478788457",
      "id" : 478788457,
      "in_reply_to_id" : 476166522,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc4ODQ1Nw==",
      "original_commit_id" : "c18ba5afa6cd6f7a14b0b4aa8c0fc5943f188b67",
      "original_line" : 248,
      "original_position" : 35,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : null,
      "pull_request_review_id" : 477192573,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478788457",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased, updated to latest https://github.com/bitcoin-core/secp256k1/pull/558 (including the even-R BIP change), and addressed a number of @luke-jr's comments above.\r\n\r\nI made one additional somewhat significant change on top, the signature/pubkey is now passed into validation routines using a Span (which means one less vector copy per script). A change like this would also make sense for ECDSA, but isn't done here yet.\r\n\r\nSo far I've been eagerly rewriting commits to address comments without good overview of the code history, but as the code stabilizes, I think it makes sense to stop doing so. My idea is that at some point (perhaps as soon as the libsecp256k1 changes are merged), I'll close this PR, and open 2 different new ones - one with just fixups, and one with the final squashed state (like #7910 and #8149 for segwit). Thoughts?",
      "created_at" : "2020-08-28T02:15:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-682285983",
      "id" : 682285983,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY4MjI4NTk4Mw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-08-28T02:15:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/682285983",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478805764"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478805764"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think it's after this comment that the hash names began containing bip341?\r\n\r\nI don't think it's worth changing at this point, but I don't love that naming convention because it's more clear to name them based on what they are (e.g., m_prevouts_sha256 or m_prevouts_d_sha256) than to name based on a BIP, especially since 143 and 341 are digit wise reversed it tripped me up a bit when re-reviewing.\r\n\r\nThis is also confusing because CTV & anyprevout will also use these same single hashes, so then it's not even really accurate to call them bip341 hashes -- that's actually why I noticed, because rebasing CTV on taproot needed to be adjusted for the new names.\r\n\r\nAgain, not worth changing at this point, but if you decide to rename them again later might be worth going to non bip name.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-28T03:09:16Z",
      "diff_hunk" : "@@ -1299,9 +1317,17 @@ void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_o\n \n     // Cache is calculated only for transactions with witness\n     if (txTo.HasWitness()) {\n-        hashPrevouts = GetPrevoutHash(txTo);\n-        hashSequence = GetSequenceHash(txTo);\n-        hashOutputs = GetOutputsHash(txTo);\n+        m_prevouts_hash = GetPrevoutHash(txTo);\n+        hashPrevouts = SHA256Uint256(m_prevouts_hash);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r478805764",
      "id" : 478805764,
      "in_reply_to_id" : 459527853,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgwNTc2NA==",
      "original_commit_id" : "41d08f5d77f52bec0e31bb081d85fff2d67d0467",
      "original_line" : 1321,
      "original_position" : 53,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 477212245,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/478805764",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> My idea is that at some point (perhaps as soon as the libsecp256k1 changes are merged), I'll close this PR, and open 2 different new ones - one with just fixups, and one with the final squashed state (like #7910 and #8149 for segwit). Thoughts?\r\n\r\nSounds good to me!\r\n\r\n[aside: I often get unicorns when loading this PR on mobile, so starting afresh would be useful if only to make interacting with the PR more manageable]",
      "created_at" : "2020-08-28T07:20:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-682371471",
      "id" : 682371471,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY4MjM3MTQ3MQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-08-28T07:20:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/682371471",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r479591694"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/479591694"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`r = random.randrange(len(pubs))` ?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-29T01:39:51Z",
      "diff_hunk" : "@@ -0,0 +1,1301 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expression for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        _, negated = compute_xonly_pubkey(key)\n+        return tweak_add_privkey(key, tweak, negated)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    tx.vin[idx].scriptSig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    tx.wit.vtxinwit[idx].scriptWitness.stack = flatten(get(ctx, \"witness\"))\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert(tap is None)\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert(script is None)\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            spend(tx, idx, utxos, **conf)\n+        else:\n+            assert(failure is not None)\n+            spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+# Expected error strings\n+ERR_KEYPATH_INVALID_SIG = {\"err_msg\": \"Invalid signature for Taproot key path spending\"}\n+ERR_SCRIPTPATH_INVALID_SIG = {\"err_msg\": \"Signature must be zero for failed CHECK(MULTI)SIG operation\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_TAPSCRIPT_CHECKMULTISIG = {\"err_msg\": \"OP_CHECKMULTISIG(VERIFY) is not available in tapscript\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Extra items left on stack after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 50000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    secs = [generate_privkey() for _ in range(4)]\n+    pubs = [compute_xonly_pubkey(sec)[0] for sec in secs]\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    tap = taproot_construct(pubs[0])\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=secs[0], failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=secs[0], failure={\"sighash\": bitflipper(default_sighash)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=secs[0], failure={\"flag_flip_r\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=secs[0], failure={\"flag_flip_p\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=secs[0], failure={\"signature\": bitflipper(default_signature)}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pubs[0])\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pubs[1])))]\n+            tap = taproot_construct(pubs[0], scripts)\n+            add_spender(spenders, \"sighash/keypath_hashtype_%x\" % hashtype, tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath_hashtype_%x\" % hashtype, tap=tap, leaf=\"s0\", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+        # Test OP_CODESEPARATOR impact on sighashing.\n+        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+        common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+        scripts = [\n+            (\"pk_codesep\", CScript(random_checksig_style(pubs[1]) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig\n+            (\"codesep_pk\", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pubs[1]))),  # codesep before checksig\n+            (\"branched_codesep\", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pubs[0], OP_ELSE, OP_CODESEPARATOR, pubs[1], OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"sighash/pk_codesep\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/codesep_pk\", tap=tap, leaf=\"codesep_pk\", key=secs[1], codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/left\", tap=tap, leaf=\"branched_codesep\", key=secs[0], codeseppos=3, **common, inputs=[getter(\"sign\"), b'\\x01'], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/right\", tap=tap, leaf=\"branched_codesep\", key=secs[1], codeseppos=6, **common, inputs=[getter(\"sign\"), b''], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Reusing the scripts above, test that various features affect the sighash.\n+    add_spender(spenders, \"sighash/annex\", tap=tap, leaf=\"pk_codesep\", key=secs[1], hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={\"sighash\": override(default_sighash, annex=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/script\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, script_taproot=tap.leaves[\"codesep_pk\"].script)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/leafver\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leafversion=random.choice([x & 0xFE for x in range(0x100) if x & 0xFE != 0xC0]))}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leaf=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/keypath\", tap=tap, key=secs[0], **common, failure={\"sighash\": override(default_sighash, leaf=\"pk_codesep\")}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # Test that invalid hashtypes don't work, both in key path and script path spends\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for invalid_hashtype in [x for x in range(0x100) if x not in VALID_SIGHASHES_TAPROOT]:\n+        add_spender(spenders, \"sighash/keypath_unk_hashtype_%x\" % invalid_hashtype, tap=tap, key=secs[0], hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_KEYPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/scriptpath_unk_hashtype_%x\" % invalid_hashtype, tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Test that hashtype 0 cannot have a hashtype byte, and 1 must have one.\n+    add_spender(spenders, \"sighash/hashtype0_byte_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    # Test that hashtype 0 and hashtype 1 cannot be transmuted into each other.\n+    add_spender(spenders, \"sighash/hashtype0to1_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0to1_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # == Test that BIP341 spending only applies to witness version 1, program length 32, no P2SH ==\n+\n+    for p2sh in [False, True]:\n+        for witver in range(1, 17):\n+            for witlen in [20, 31, 32, 33]:\n+                def mutate(spk):\n+                    prog = spk[2:]\n+                    assert(len(prog) == 32)\n+                    if witlen < 32:\n+                        prog = prog[0:witlen]\n+                    elif witlen > 32:\n+                        prog += bytes([0 for _ in range(witlen - 32)])\n+                    return CScript([CScriptOp.encode_op_n(witver), prog])\n+                scripts = [(\"s0\", CScript([pubs[0], OP_CHECKSIG])), (\"dummy\", CScript([OP_RETURN]))]\n+                tap = taproot_construct(pubs[1], scripts)\n+                if not p2sh and witver == 1 and witlen == 32:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, failure={\"leaf\": \"dummy\"}, **ERR_OP_RETURN)\n+                else:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], standard=False)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, standard=False)\n+\n+    # == Test various aspects of BIP341 spending paths ==\n+\n+    # A set of functions that compute the hashing partner in a Merkle tree, designed to exercise\n+    # edge cases. This relies on the taproot_construct feature that a lambda can be passed in\n+    # instead of a subtree, to compute the partner to be hashed with.\n+    PARTNER_MERKLE_FN = [\n+        # Combine with itself\n+        lambda h: h,\n+        # Combine with hash 0\n+        lambda h: bytes([0 for _ in range(32)]),\n+        # Combine with hash 2^256-1\n+        lambda h: bytes([0xff for _ in range(32)]),\n+        # Combine with itself-1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') + 1).to_bytes(32, 'big'),\n+        # Combine with itself-1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') + 1).to_bytes(32, 'little'),\n+        # Combine with random bitflipped version of self.\n+        lambda h: (int.from_bytes(h, 'little') ^ (1 << random.randrange(256))).to_bytes(32, 'little')\n+    ]\n+    # Start with a tree of that has depth 1 for \"128deep\" and depth 2 for \"129deep\".\n+    scripts = [(\"128deep\", CScript([pubs[0], OP_CHECKSIG])), [(\"129deep\", CScript([pubs[0], OP_CHECKSIG])), random.choice(PARTNER_MERKLE_FN)]]\n+    # Add 127 nodes on top of that tree, so that \"128deep\" and \"129deep\" end up at their designated depths.\n+    for _ in range(127):\n+        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+    tap = taproot_construct(pubs[0], scripts)\n+    # Test that spends with a depth of 128 work, but 129 doesn't (even with a tree with weird Merkle branches in it).\n+    add_spender(spenders, \"spendpath/merklelimit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"leaf\": \"129deep\"}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that flipping the negation bit invalidates spends.\n+    add_spender(spenders, \"spendpath/negflag\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"negflag\": lambda ctx: 1 - default_negflag(ctx)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the Merkle branch invalidate it.\n+    add_spender(spenders, \"spendpath/bitflipmerkle\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"merklebranch\": bitflipper(default_merklebranch)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the inner pubkey invalidate it.\n+    add_spender(spenders, \"spendpath/bitflippubkey\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"pubkey_inner\": bitflipper(default_pubkey_inner)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that empty witnesses are invalid.\n+    add_spender(spenders, \"spendpath/emptywit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"witness\": []}, **ERR_EMPTY_WITNESS)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padlongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/trunclongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    scripts = [(\"s\", CScript([pubs[0], OP_CHECKSIG]))]\n+    tap = taproot_construct(pubs[1], scripts)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/truncshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block to 1 byte (\"-1 Merkle length\") invalidates it\n+    add_spender(spenders, \"spendpath/trunc1shortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:1]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    # == Test BIP342 edge cases ==\n+\n+    checksigadd_val = random.randrange(17, 100) # Above OP_16 to avoid minimal encoding complaints\n+    checksigadd_arg = CScriptNum(checksigadd_val)\n+    checksigadd_result = CScriptNum(checksigadd_val+1)\n+    OVERSIZE_NUMBER = 2**31\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER))), 6)\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER-1))), 5)\n+\n+    big_choices = []\n+    big_scriptops = []\n+    for i in range(1000):\n+        r = random.randrange(4)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r479591694",
      "id" : 479591694,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5MTY5NA==",
      "original_commit_id" : "619ceebd4d84e9fd9a16c5aed6c4a328da44381c",
      "original_line" : 745,
      "original_position" : 745,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 478087687,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/479591694",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r479591776"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/479591776"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`for k in range(len(pubs)):` ?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-29T01:40:20Z",
      "diff_hunk" : "@@ -0,0 +1,1301 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expression for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        _, negated = compute_xonly_pubkey(key)\n+        return tweak_add_privkey(key, tweak, negated)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    tx.vin[idx].scriptSig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    tx.wit.vtxinwit[idx].scriptWitness.stack = flatten(get(ctx, \"witness\"))\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert(tap is None)\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert(script is None)\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            spend(tx, idx, utxos, **conf)\n+        else:\n+            assert(failure is not None)\n+            spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+# Expected error strings\n+ERR_KEYPATH_INVALID_SIG = {\"err_msg\": \"Invalid signature for Taproot key path spending\"}\n+ERR_SCRIPTPATH_INVALID_SIG = {\"err_msg\": \"Signature must be zero for failed CHECK(MULTI)SIG operation\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_TAPSCRIPT_CHECKMULTISIG = {\"err_msg\": \"OP_CHECKMULTISIG(VERIFY) is not available in tapscript\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Extra items left on stack after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 50000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    secs = [generate_privkey() for _ in range(4)]\n+    pubs = [compute_xonly_pubkey(sec)[0] for sec in secs]\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    tap = taproot_construct(pubs[0])\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=secs[0], failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=secs[0], failure={\"sighash\": bitflipper(default_sighash)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=secs[0], failure={\"flag_flip_r\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=secs[0], failure={\"flag_flip_p\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=secs[0], failure={\"signature\": bitflipper(default_signature)}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pubs[0])\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pubs[1])))]\n+            tap = taproot_construct(pubs[0], scripts)\n+            add_spender(spenders, \"sighash/keypath_hashtype_%x\" % hashtype, tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath_hashtype_%x\" % hashtype, tap=tap, leaf=\"s0\", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+        # Test OP_CODESEPARATOR impact on sighashing.\n+        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+        common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+        scripts = [\n+            (\"pk_codesep\", CScript(random_checksig_style(pubs[1]) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig\n+            (\"codesep_pk\", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pubs[1]))),  # codesep before checksig\n+            (\"branched_codesep\", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pubs[0], OP_ELSE, OP_CODESEPARATOR, pubs[1], OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"sighash/pk_codesep\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/codesep_pk\", tap=tap, leaf=\"codesep_pk\", key=secs[1], codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/left\", tap=tap, leaf=\"branched_codesep\", key=secs[0], codeseppos=3, **common, inputs=[getter(\"sign\"), b'\\x01'], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/right\", tap=tap, leaf=\"branched_codesep\", key=secs[1], codeseppos=6, **common, inputs=[getter(\"sign\"), b''], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Reusing the scripts above, test that various features affect the sighash.\n+    add_spender(spenders, \"sighash/annex\", tap=tap, leaf=\"pk_codesep\", key=secs[1], hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={\"sighash\": override(default_sighash, annex=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/script\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, script_taproot=tap.leaves[\"codesep_pk\"].script)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/leafver\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leafversion=random.choice([x & 0xFE for x in range(0x100) if x & 0xFE != 0xC0]))}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leaf=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/keypath\", tap=tap, key=secs[0], **common, failure={\"sighash\": override(default_sighash, leaf=\"pk_codesep\")}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # Test that invalid hashtypes don't work, both in key path and script path spends\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for invalid_hashtype in [x for x in range(0x100) if x not in VALID_SIGHASHES_TAPROOT]:\n+        add_spender(spenders, \"sighash/keypath_unk_hashtype_%x\" % invalid_hashtype, tap=tap, key=secs[0], hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_KEYPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/scriptpath_unk_hashtype_%x\" % invalid_hashtype, tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Test that hashtype 0 cannot have a hashtype byte, and 1 must have one.\n+    add_spender(spenders, \"sighash/hashtype0_byte_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    # Test that hashtype 0 and hashtype 1 cannot be transmuted into each other.\n+    add_spender(spenders, \"sighash/hashtype0to1_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0to1_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # == Test that BIP341 spending only applies to witness version 1, program length 32, no P2SH ==\n+\n+    for p2sh in [False, True]:\n+        for witver in range(1, 17):\n+            for witlen in [20, 31, 32, 33]:\n+                def mutate(spk):\n+                    prog = spk[2:]\n+                    assert(len(prog) == 32)\n+                    if witlen < 32:\n+                        prog = prog[0:witlen]\n+                    elif witlen > 32:\n+                        prog += bytes([0 for _ in range(witlen - 32)])\n+                    return CScript([CScriptOp.encode_op_n(witver), prog])\n+                scripts = [(\"s0\", CScript([pubs[0], OP_CHECKSIG])), (\"dummy\", CScript([OP_RETURN]))]\n+                tap = taproot_construct(pubs[1], scripts)\n+                if not p2sh and witver == 1 and witlen == 32:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, failure={\"leaf\": \"dummy\"}, **ERR_OP_RETURN)\n+                else:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], standard=False)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, standard=False)\n+\n+    # == Test various aspects of BIP341 spending paths ==\n+\n+    # A set of functions that compute the hashing partner in a Merkle tree, designed to exercise\n+    # edge cases. This relies on the taproot_construct feature that a lambda can be passed in\n+    # instead of a subtree, to compute the partner to be hashed with.\n+    PARTNER_MERKLE_FN = [\n+        # Combine with itself\n+        lambda h: h,\n+        # Combine with hash 0\n+        lambda h: bytes([0 for _ in range(32)]),\n+        # Combine with hash 2^256-1\n+        lambda h: bytes([0xff for _ in range(32)]),\n+        # Combine with itself-1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') + 1).to_bytes(32, 'big'),\n+        # Combine with itself-1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') + 1).to_bytes(32, 'little'),\n+        # Combine with random bitflipped version of self.\n+        lambda h: (int.from_bytes(h, 'little') ^ (1 << random.randrange(256))).to_bytes(32, 'little')\n+    ]\n+    # Start with a tree of that has depth 1 for \"128deep\" and depth 2 for \"129deep\".\n+    scripts = [(\"128deep\", CScript([pubs[0], OP_CHECKSIG])), [(\"129deep\", CScript([pubs[0], OP_CHECKSIG])), random.choice(PARTNER_MERKLE_FN)]]\n+    # Add 127 nodes on top of that tree, so that \"128deep\" and \"129deep\" end up at their designated depths.\n+    for _ in range(127):\n+        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+    tap = taproot_construct(pubs[0], scripts)\n+    # Test that spends with a depth of 128 work, but 129 doesn't (even with a tree with weird Merkle branches in it).\n+    add_spender(spenders, \"spendpath/merklelimit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"leaf\": \"129deep\"}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that flipping the negation bit invalidates spends.\n+    add_spender(spenders, \"spendpath/negflag\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"negflag\": lambda ctx: 1 - default_negflag(ctx)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the Merkle branch invalidate it.\n+    add_spender(spenders, \"spendpath/bitflipmerkle\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"merklebranch\": bitflipper(default_merklebranch)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the inner pubkey invalidate it.\n+    add_spender(spenders, \"spendpath/bitflippubkey\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"pubkey_inner\": bitflipper(default_pubkey_inner)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that empty witnesses are invalid.\n+    add_spender(spenders, \"spendpath/emptywit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"witness\": []}, **ERR_EMPTY_WITNESS)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padlongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/trunclongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    scripts = [(\"s\", CScript([pubs[0], OP_CHECKSIG]))]\n+    tap = taproot_construct(pubs[1], scripts)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/truncshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block to 1 byte (\"-1 Merkle length\") invalidates it\n+    add_spender(spenders, \"spendpath/trunc1shortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:1]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    # == Test BIP342 edge cases ==\n+\n+    checksigadd_val = random.randrange(17, 100) # Above OP_16 to avoid minimal encoding complaints\n+    checksigadd_arg = CScriptNum(checksigadd_val)\n+    checksigadd_result = CScriptNum(checksigadd_val+1)\n+    OVERSIZE_NUMBER = 2**31\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER))), 6)\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER-1))), 5)\n+\n+    big_choices = []\n+    big_scriptops = []\n+    for i in range(1000):\n+        r = random.randrange(4)\n+        big_choices.append(r)\n+        big_scriptops += [pubs[r], OP_CHECKSIGVERIFY]\n+\n+\n+    def big_spend_inputs(ctx):\n+        \"\"\"Helper function to construct the script input for t33/t34 below.\"\"\"\n+        # Instead of signing 999 times, precompute signatures for every (key, hashtype) combination\n+        sigs = {}\n+        for ht in VALID_SIGHASHES_TAPROOT:\n+            for k in range(4):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r479591776",
      "id" : 479591776,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5MTc3Ng==",
      "original_commit_id" : "619ceebd4d84e9fd9a16c5aed6c4a328da44381c",
      "original_line" : 755,
      "original_position" : 755,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 478087687,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/479591776",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r479595186"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/479595186"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-29T02:16:55Z",
      "diff_hunk" : "@@ -0,0 +1,1301 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expression for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        _, negated = compute_xonly_pubkey(key)\n+        return tweak_add_privkey(key, tweak, negated)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    tx.vin[idx].scriptSig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    tx.wit.vtxinwit[idx].scriptWitness.stack = flatten(get(ctx, \"witness\"))\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert(tap is None)\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert(script is None)\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            spend(tx, idx, utxos, **conf)\n+        else:\n+            assert(failure is not None)\n+            spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+# Expected error strings\n+ERR_KEYPATH_INVALID_SIG = {\"err_msg\": \"Invalid signature for Taproot key path spending\"}\n+ERR_SCRIPTPATH_INVALID_SIG = {\"err_msg\": \"Signature must be zero for failed CHECK(MULTI)SIG operation\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_TAPSCRIPT_CHECKMULTISIG = {\"err_msg\": \"OP_CHECKMULTISIG(VERIFY) is not available in tapscript\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Extra items left on stack after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 50000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    secs = [generate_privkey() for _ in range(4)]\n+    pubs = [compute_xonly_pubkey(sec)[0] for sec in secs]\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    tap = taproot_construct(pubs[0])\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=secs[0], failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=secs[0], failure={\"sighash\": bitflipper(default_sighash)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=secs[0], failure={\"flag_flip_r\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=secs[0], failure={\"flag_flip_p\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=secs[0], failure={\"signature\": bitflipper(default_signature)}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pubs[0])\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pubs[1])))]\n+            tap = taproot_construct(pubs[0], scripts)\n+            add_spender(spenders, \"sighash/keypath_hashtype_%x\" % hashtype, tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath_hashtype_%x\" % hashtype, tap=tap, leaf=\"s0\", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+        # Test OP_CODESEPARATOR impact on sighashing.\n+        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+        common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+        scripts = [\n+            (\"pk_codesep\", CScript(random_checksig_style(pubs[1]) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig\n+            (\"codesep_pk\", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pubs[1]))),  # codesep before checksig\n+            (\"branched_codesep\", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pubs[0], OP_ELSE, OP_CODESEPARATOR, pubs[1], OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"sighash/pk_codesep\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/codesep_pk\", tap=tap, leaf=\"codesep_pk\", key=secs[1], codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/left\", tap=tap, leaf=\"branched_codesep\", key=secs[0], codeseppos=3, **common, inputs=[getter(\"sign\"), b'\\x01'], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/right\", tap=tap, leaf=\"branched_codesep\", key=secs[1], codeseppos=6, **common, inputs=[getter(\"sign\"), b''], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Reusing the scripts above, test that various features affect the sighash.\n+    add_spender(spenders, \"sighash/annex\", tap=tap, leaf=\"pk_codesep\", key=secs[1], hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={\"sighash\": override(default_sighash, annex=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/script\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, script_taproot=tap.leaves[\"codesep_pk\"].script)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/leafver\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leafversion=random.choice([x & 0xFE for x in range(0x100) if x & 0xFE != 0xC0]))}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leaf=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/keypath\", tap=tap, key=secs[0], **common, failure={\"sighash\": override(default_sighash, leaf=\"pk_codesep\")}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # Test that invalid hashtypes don't work, both in key path and script path spends\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for invalid_hashtype in [x for x in range(0x100) if x not in VALID_SIGHASHES_TAPROOT]:\n+        add_spender(spenders, \"sighash/keypath_unk_hashtype_%x\" % invalid_hashtype, tap=tap, key=secs[0], hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_KEYPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/scriptpath_unk_hashtype_%x\" % invalid_hashtype, tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Test that hashtype 0 cannot have a hashtype byte, and 1 must have one.\n+    add_spender(spenders, \"sighash/hashtype0_byte_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    # Test that hashtype 0 and hashtype 1 cannot be transmuted into each other.\n+    add_spender(spenders, \"sighash/hashtype0to1_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0to1_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # == Test that BIP341 spending only applies to witness version 1, program length 32, no P2SH ==\n+\n+    for p2sh in [False, True]:\n+        for witver in range(1, 17):\n+            for witlen in [20, 31, 32, 33]:\n+                def mutate(spk):\n+                    prog = spk[2:]\n+                    assert(len(prog) == 32)\n+                    if witlen < 32:\n+                        prog = prog[0:witlen]\n+                    elif witlen > 32:\n+                        prog += bytes([0 for _ in range(witlen - 32)])\n+                    return CScript([CScriptOp.encode_op_n(witver), prog])\n+                scripts = [(\"s0\", CScript([pubs[0], OP_CHECKSIG])), (\"dummy\", CScript([OP_RETURN]))]\n+                tap = taproot_construct(pubs[1], scripts)\n+                if not p2sh and witver == 1 and witlen == 32:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, failure={\"leaf\": \"dummy\"}, **ERR_OP_RETURN)\n+                else:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], standard=False)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, standard=False)\n+\n+    # == Test various aspects of BIP341 spending paths ==\n+\n+    # A set of functions that compute the hashing partner in a Merkle tree, designed to exercise\n+    # edge cases. This relies on the taproot_construct feature that a lambda can be passed in\n+    # instead of a subtree, to compute the partner to be hashed with.\n+    PARTNER_MERKLE_FN = [\n+        # Combine with itself\n+        lambda h: h,\n+        # Combine with hash 0\n+        lambda h: bytes([0 for _ in range(32)]),\n+        # Combine with hash 2^256-1\n+        lambda h: bytes([0xff for _ in range(32)]),\n+        # Combine with itself-1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') + 1).to_bytes(32, 'big'),\n+        # Combine with itself-1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') + 1).to_bytes(32, 'little'),\n+        # Combine with random bitflipped version of self.\n+        lambda h: (int.from_bytes(h, 'little') ^ (1 << random.randrange(256))).to_bytes(32, 'little')\n+    ]\n+    # Start with a tree of that has depth 1 for \"128deep\" and depth 2 for \"129deep\".\n+    scripts = [(\"128deep\", CScript([pubs[0], OP_CHECKSIG])), [(\"129deep\", CScript([pubs[0], OP_CHECKSIG])), random.choice(PARTNER_MERKLE_FN)]]\n+    # Add 127 nodes on top of that tree, so that \"128deep\" and \"129deep\" end up at their designated depths.\n+    for _ in range(127):\n+        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+    tap = taproot_construct(pubs[0], scripts)\n+    # Test that spends with a depth of 128 work, but 129 doesn't (even with a tree with weird Merkle branches in it).\n+    add_spender(spenders, \"spendpath/merklelimit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"leaf\": \"129deep\"}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that flipping the negation bit invalidates spends.\n+    add_spender(spenders, \"spendpath/negflag\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"negflag\": lambda ctx: 1 - default_negflag(ctx)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the Merkle branch invalidate it.\n+    add_spender(spenders, \"spendpath/bitflipmerkle\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"merklebranch\": bitflipper(default_merklebranch)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the inner pubkey invalidate it.\n+    add_spender(spenders, \"spendpath/bitflippubkey\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"pubkey_inner\": bitflipper(default_pubkey_inner)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that empty witnesses are invalid.\n+    add_spender(spenders, \"spendpath/emptywit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"witness\": []}, **ERR_EMPTY_WITNESS)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padlongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/trunclongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    scripts = [(\"s\", CScript([pubs[0], OP_CHECKSIG]))]\n+    tap = taproot_construct(pubs[1], scripts)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/truncshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block to 1 byte (\"-1 Merkle length\") invalidates it\n+    add_spender(spenders, \"spendpath/trunc1shortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:1]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    # == Test BIP342 edge cases ==\n+\n+    checksigadd_val = random.randrange(17, 100) # Above OP_16 to avoid minimal encoding complaints\n+    checksigadd_arg = CScriptNum(checksigadd_val)\n+    checksigadd_result = CScriptNum(checksigadd_val+1)\n+    OVERSIZE_NUMBER = 2**31\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER))), 6)\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER-1))), 5)\n+\n+    big_choices = []\n+    big_scriptops = []\n+    for i in range(1000):\n+        r = random.randrange(4)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r479595186",
      "id" : 479595186,
      "in_reply_to_id" : 479591694,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5NTE4Ng==",
      "original_commit_id" : "619ceebd4d84e9fd9a16c5aed6c4a328da44381c",
      "original_line" : 745,
      "original_position" : 745,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 478090271,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/479595186",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r479595199"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/479595199"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-08-29T02:17:04Z",
      "diff_hunk" : "@@ -0,0 +1,1301 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2019-2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+# Test Taproot softfork (BIPs 340-342)\n+\n+from test_framework.blocktools import (\n+    create_coinbase,\n+    create_block,\n+    add_witness_commitment,\n+    MAX_BLOCK_SIGOPS_WEIGHT,\n+    WITNESS_SCALE_FACTOR,\n+)\n+from test_framework.messages import (\n+    COutPoint,\n+    CTransaction,\n+    CTxIn,\n+    CTxInWitness,\n+    CTxOut,\n+    ToHex,\n+)\n+from test_framework.script import (\n+    ANNEX_TAG,\n+    CScript,\n+    CScriptNum,\n+    CScriptOp,\n+    LEAF_VERSION_TAPSCRIPT,\n+    LegacySignatureHash,\n+    LOCKTIME_THRESHOLD,\n+    MAX_SCRIPT_ELEMENT_SIZE,\n+    OP_0,\n+    OP_1,\n+    OP_2,\n+    OP_3,\n+    OP_4,\n+    OP_5,\n+    OP_6,\n+    OP_7,\n+    OP_8,\n+    OP_9,\n+    OP_10,\n+    OP_11,\n+    OP_12,\n+    OP_16,\n+    OP_2DROP,\n+    OP_2DUP,\n+    OP_CHECKMULTISIG,\n+    OP_CHECKMULTISIGVERIFY,\n+    OP_CHECKSIG,\n+    OP_CHECKSIGADD,\n+    OP_CHECKSIGVERIFY,\n+    OP_CODESEPARATOR,\n+    OP_DROP,\n+    OP_DUP,\n+    OP_ELSE,\n+    OP_ENDIF,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n+    OP_IF,\n+    OP_NOP,\n+    OP_NOT,\n+    OP_NOTIF,\n+    OP_PUSHDATA1,\n+    OP_RETURN,\n+    OP_SWAP,\n+    OP_VERIFY,\n+    SIGHASH_DEFAULT,\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY,\n+    SegwitV0SignatureHash,\n+    TaprootSignatureHash,\n+    is_op_success,\n+    taproot_construct,\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_raises_rpc_error, assert_equal\n+from test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey\n+from test_framework.address import (\n+    hash160,\n+    sha256,\n+)\n+from collections import namedtuple\n+from io import BytesIO\n+import random\n+\n+# === Framework for building spending transactions. ===\n+#\n+# The computation is represented as a \"context\" dict, whose entries store potentially-unevaluated expressions that\n+# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing\n+# process can be overridden.\n+#\n+# Specifically, a context object is a dict that maps names to compositions of:\n+# - values\n+# - lists of values\n+# - callables which, when fed the context object as argument, produce any of these\n+#\n+# # The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.\n+#\n+# The get(ctx, name) function can evaluate a name, and cache its result in the context.\n+# getter(name) can be used to construct a callable that evaluates name. For example:\n+#\n+#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter(\"sign\"), b'\\x01']}\n+#\n+# creates a context where the script inputs are a signature plus the bytes 0x01.\n+#\n+# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively\n+# modified context. For example:\n+#\n+#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}\n+#\n+# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from\n+#\n+#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}\n+#\n+# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)\n+# while ctx2 only uses the modified hashtype inside the sighash calculation.\n+\n+def deep_eval(ctx, expr):\n+    \"\"\"Recursively replace any callables c in expr (including inside lists) with c(ctx).\"\"\"\n+    while callable(expr):\n+        expr = expr(ctx)\n+    if isinstance(expr, list):\n+        expr = [deep_eval(ctx, x) for x in expr]\n+    return expr\n+\n+# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).\n+Final = namedtuple(\"Final\", \"value\")\n+\n+def get(ctx, name):\n+    \"\"\"Evaluate name in context ctx.\"\"\"\n+    assert name in ctx, \"Missing '%s' in context\" % name\n+    expr = ctx[name]\n+    if not isinstance(expr, Final):\n+        # Evaluate and cache the result.\n+        expr = Final(deep_eval(ctx, expr))\n+        ctx[name] = expr\n+    return expr.value\n+\n+def getter(name):\n+    \"\"\"Return a callable that evaluates name in its passed context.\"\"\"\n+    return lambda ctx: get(ctx, name)\n+\n+def override(expr, **kwargs):\n+    \"\"\"Return a callable that evaluates expr in a modified context.\"\"\"\n+    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)\n+\n+# === Implementations for the various default expressions in DEFAULT_CONTEXT ===\n+\n+def default_hashtype(ctx):\n+    \"\"\"Default expression for \"hashtype\": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return SIGHASH_DEFAULT\n+    else:\n+        return SIGHASH_ALL\n+\n+def default_tapleaf(ctx):\n+    \"\"\"Default expression for \"tapleaf\": looking up leaf in tap[2].\"\"\"\n+    return get(ctx, \"tap\").leaves[get(ctx, \"leaf\")]\n+\n+def default_script_taproot(ctx):\n+    \"\"\"Default expression for \"script_taproot\": tapleaf.script.\"\"\"\n+    return get(ctx, \"tapleaf\").script\n+\n+def default_leafversion(ctx):\n+    \"\"\"Default expression for \"leafversion\": tapleaf.version\"\"\"\n+    return get(ctx, \"tapleaf\").version\n+\n+def default_negflag(ctx):\n+    \"\"\"Default expression for \"negflag\": tap.negflag.\"\"\"\n+    return get(ctx, \"tap\").negflag\n+\n+def default_pubkey_inner(ctx):\n+    \"\"\"Default expression for \"pubkey_inner\": tap.inner_pubkey.\"\"\"\n+    return get(ctx, \"tap\").inner_pubkey\n+\n+def default_merklebranch(ctx):\n+    \"\"\"Default expression for \"merklebranch\": tapleaf.merklebranch.\"\"\"\n+    return get(ctx, \"tapleaf\").merklebranch\n+\n+def default_controlblock(ctx):\n+    \"\"\"Default expression for \"controlblock\": combine leafversion, negflag, pubkey_inner, merklebranch.\"\"\"\n+    return bytes([get(ctx, \"leafversion\") + get(ctx, \"negflag\")]) + get(ctx, \"pubkey_inner\") + get(ctx, \"merklebranch\")\n+\n+def default_sighash(ctx):\n+    \"\"\"Default expression for \"sighash\": depending on mode, compute BIP341, BIP143, or legacy sighash.\"\"\"\n+    tx = get(ctx, \"tx\")\n+    idx = get(ctx, \"idx\")\n+    hashtype = get(ctx, \"hashtype_actual\")\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        # BIP341 signature hash\n+        utxos = get(ctx, \"utxos\")\n+        annex = get(ctx, \"annex\")\n+        if get(ctx, \"leaf\") is not None:\n+            codeseppos = get(ctx, \"codeseppos\")\n+            leaf_ver = get(ctx, \"leafversion\")\n+            script = get(ctx, \"script_taproot\")\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)\n+        else:\n+            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)\n+    elif mode == \"witv0\":\n+        # BIP143 signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        utxos = get(ctx, \"utxos\")\n+        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)\n+    else:\n+        # Pre-segwit signature hash\n+        scriptcode = get(ctx, \"scriptcode\")\n+        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0]\n+\n+def default_tweak(ctx):\n+    \"\"\"Default expression for \"tweak\": None if a leaf is specified, tap[0] otherwise.\"\"\"\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"tap\").tweak\n+    return None\n+\n+def default_key_tweaked(ctx):\n+    \"\"\"Default expression for \"key_tweaked\": key if tweak is None, tweaked with it otherwise.\"\"\"\n+    key = get(ctx, \"key\")\n+    tweak = get(ctx, \"tweak\")\n+    if tweak is None:\n+        return key\n+    else:\n+        _, negated = compute_xonly_pubkey(key)\n+        return tweak_add_privkey(key, tweak, negated)\n+\n+def default_signature(ctx):\n+    \"\"\"Default expression for \"signature\": BIP340 signature or ECDSA signature depending on mode.\"\"\"\n+    sighash = get(ctx, \"sighash\")\n+    if get(ctx, \"mode\") == \"taproot\":\n+        key = get(ctx, \"key_tweaked\")\n+        flip_r = get(ctx, \"flag_flip_r\")\n+        flip_p = get(ctx, \"flag_flip_p\")\n+        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)\n+    else:\n+        key = get(ctx, \"key\")\n+        return key.sign_ecdsa(sighash)\n+\n+def default_hashtype_actual(ctx):\n+    \"\"\"Default expression for \"hashtype_actual\": hashtype, unless mismatching SIGHASH_SINGLE in taproot.\"\"\"\n+    hashtype = get(ctx, \"hashtype\")\n+    mode = get(ctx, \"mode\")\n+    if mode != \"taproot\":\n+        return hashtype\n+    idx = get(ctx, \"idx\")\n+    tx = get(ctx, \"tx\")\n+    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):\n+        return (hashtype & ~3) | SIGHASH_NONE\n+    return hashtype\n+\n+def default_bytes_hashtype(ctx):\n+    \"\"\"Default expression for \"bytes_hashtype\": bytes([hashtype_actual]) if not 0, b\"\" otherwise.\"\"\"\n+    return bytes([x for x in [get(ctx, \"hashtype_actual\")] if x != 0])\n+\n+def default_sign(ctx):\n+    \"\"\"Default expression for \"sign\": concatenation of signature and bytes_hashtype.\"\"\"\n+    return get(ctx, \"signature\") + get(ctx, \"bytes_hashtype\")\n+\n+def default_inputs_keypath(ctx):\n+    \"\"\"Default expression for \"inputs_keypath\": a signature.\"\"\"\n+    return [get(ctx, \"sign\")]\n+\n+def default_witness_taproot(ctx):\n+    \"\"\"Default expression for \"witness_taproot\", consisting of inputs, script, control block, and annex as needed.\"\"\"\n+    annex = get(ctx, \"annex\")\n+    suffix_annex = []\n+    if annex is not None:\n+        suffix_annex = [annex]\n+    if get(ctx, \"leaf\") is None:\n+        return get(ctx, \"inputs_keypath\") + suffix_annex\n+    else:\n+        return get(ctx, \"inputs\") + [bytes(get(ctx, \"script_taproot\")), get(ctx, \"controlblock\")] + suffix_annex\n+\n+def default_witness_witv0(ctx):\n+    \"\"\"Default expression for \"witness_witv0\", consisting of inputs and witness script, as needed.\"\"\"\n+    script = get(ctx, \"script_witv0\")\n+    inputs = get(ctx, \"inputs\")\n+    if script is None:\n+        return inputs\n+    else:\n+        return inputs + [script]\n+\n+def default_witness(ctx):\n+    \"\"\"Default expression for \"witness\", delegating to \"witness_taproot\" or \"witness_witv0\" as needed.\"\"\"\n+    mode = get(ctx, \"mode\")\n+    if mode == \"taproot\":\n+        return get(ctx, \"witness_taproot\")\n+    elif mode == \"witv0\":\n+        return get(ctx, \"witness_witv0\")\n+    else:\n+        return []\n+\n+def default_scriptsig(ctx):\n+    \"\"\"Default expression for \"scriptsig\", consisting of inputs and redeemscript, as needed.\"\"\"\n+    scriptsig = []\n+    mode = get(ctx, \"mode\")\n+    if mode == \"legacy\":\n+        scriptsig = get(ctx, \"inputs\")\n+    redeemscript = get(ctx, \"script_p2sh\")\n+    if redeemscript is not None:\n+        scriptsig += [bytes(redeemscript)]\n+    return scriptsig\n+\n+# The default context object.\n+DEFAULT_CONTEXT = {\n+    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==\n+    # The overall witness stack, as a list of bytes objects.\n+    \"witness\": default_witness,\n+    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)\n+    \"scriptsig\": default_scriptsig,\n+\n+    # == Expressions you'll generally only override for intentionally invalid spends. ==\n+    # The witness stack for spending a taproot output.\n+    \"witness_taproot\": default_witness_taproot,\n+    # The witness stack for spending a P2WPKH/P2WSH output.\n+    \"witness_witv0\": default_witness_witv0,\n+    # The script inputs for a taproot key path spend.\n+    \"inputs_keypath\": default_inputs_keypath,\n+    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).\n+    \"hashtype_actual\": default_hashtype_actual,\n+    # The bytes object for a full signature (including hashtype byte, if needed).\n+    \"bytes_hashtype\": default_bytes_hashtype,\n+    # A full script signature (bytes including hashtype, if needed)\n+    \"sign\": default_sign,\n+    # An ECDSA or Schnorr signature (excluding hashtype byte).\n+    \"signature\": default_signature,\n+    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).\n+    \"key_tweaked\": default_key_tweaked,\n+    # The tweak to use (None for script path spends, the actual tweak for key path spends).\n+    \"tweak\": default_tweak,\n+    # The sighash value (32 bytes)\n+    \"sighash\": default_sighash,\n+    # The information about the chosen script path spend (TaprootLeafInfo object).\n+    \"tapleaf\": default_tapleaf,\n+    # The script to push, and include in the sighash, for a taproot script path spend.\n+    \"script_taproot\": default_script_taproot,\n+    # The inner pubkey for a taproot script path spend (32 bytes).\n+    \"pubkey_inner\": default_pubkey_inner,\n+    # The negation flag of the inner pubkey for a taproot script path spend.\n+    \"negflag\": default_negflag,\n+    # The leaf version to include in the sighash (this does not affect the one in the control block).\n+    \"leafversion\": default_leafversion,\n+    # The Merkle path to include in the control block for a script path spend.\n+    \"merklebranch\": default_merklebranch,\n+    # The control block to push for a taproot script path spend.\n+    \"controlblock\": default_controlblock,\n+    # Whether to produce signatures with invalid P sign (Schnorr signatures only).\n+    \"flag_flip_p\": False,\n+    # Whether to produce signatures with invalid R sign (Schnorr signatures only).\n+    \"flag_flip_r\": False,\n+\n+    # == Parameters that can be changed without invalidating, but do have a default: ==\n+    # The hashtype (as an integer).\n+    \"hashtype\": default_hashtype,\n+    # The annex (only when mode==\"taproot\").\n+    \"annex\": None,\n+    # The codeseparator position (only when mode==\"taproot\").\n+    \"codeseppos\": -1,\n+    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).\n+    \"script_p2sh\": None,\n+    # The script to add to the witness in (if P2WSH; None implies P2WPKH)\n+    \"script_witv0\": None,\n+    # The leaf to use in taproot spends (if script path spend; None implies key path spend).\n+    \"leaf\": None,\n+    # The input arguments to provide to the executed script\n+    \"inputs\": [],\n+\n+    # == Parameters to be set before evaluation: ==\n+    # - mode: what spending style to use (\"taproot\", \"witv0\", or \"legacy\").\n+    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).\n+    # - tap: the TaprootInfo object (see taproot_construct; needed in mode==\"taproot\").\n+    # - tx: the transaction to sign.\n+    # - utxos: the UTXOs being spent (needed in mode==\"witv0\" and mode==\"taproot\").\n+    # - idx: the input position being signed.\n+    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.\n+}\n+\n+def flatten(lst):\n+    ret = []\n+    for elem in lst:\n+        if isinstance(elem, list):\n+            ret += flatten(elem)\n+        else:\n+            ret.append(elem)\n+    return ret\n+\n+def spend(tx, idx, utxos, **kwargs):\n+    \"\"\"Sign transaction input idx of tx, provided utxos is the list of outputs being spent.\n+\n+    Additional arguments may be provided that override any aspect of the signing process.\n+    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.\n+    \"\"\"\n+\n+    ctx = {**DEFAULT_CONTEXT, \"tx\":tx, \"idx\":idx, \"utxos\":utxos, **kwargs}\n+\n+    def to_script(elem):\n+        \"\"\"If fed a CScript, return it; if fed bytes, return a CScript that pushes it.\"\"\"\n+        if isinstance(elem, CScript):\n+            return elem\n+        else:\n+            return CScript([elem])\n+\n+    scriptsig_list = flatten(get(ctx, \"scriptsig\"))\n+    tx.vin[idx].scriptSig = CScript(b\"\".join(bytes(to_script(elem)) for elem in scriptsig_list))\n+    tx.wit.vtxinwit[idx].scriptWitness.stack = flatten(get(ctx, \"witness\"))\n+\n+\n+# === Spender objects ===\n+#\n+# Each spender is a tuple of:\n+# - A scriptPubKey which is to be spent from (CScript)\n+# - A comment describing the test (string)\n+# - Whether the spending (on itself) is expected to be standard (bool)\n+# - A tx-signing lambda taking as inputs:\n+#   - A transaction to sign (CTransaction)\n+#   - An input position (int)\n+#   - The spent UTXOs by this transaction (list of CTxOut)\n+#   - Whether to produce a valid spend (bool)\n+# - A string with an expected error message for failure case if known\n+# - The (pre-taproot) sigops weight consumed by a successful spend\n+# - Whether this spend cannot fail\n+\n+Spender = namedtuple(\"Spender\", \"script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail\")\n+\n+def make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, **kwargs):\n+    \"\"\"Helper for constructing Spender objects using the context signing framework.\n+\n+    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)\n+    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)\n+    * script: the actual script executed (for bare/P2WSH/P2SH spending)\n+    * pkh: the public key for P2PKH or P2WPKH spending\n+    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)\n+    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)\n+    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)\n+    * standard: whether the (valid version of) spending is expected to be standard\n+    * err_msg: a string with an expected error message for failure (or None, if not cared about)\n+    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend\n+    \"\"\"\n+\n+    conf = dict()\n+\n+    # Compute scriptPubKey and set useful defaults based on the inputs.\n+    if witv0:\n+        assert(tap is None)\n+        conf[\"mode\"] = \"witv0\"\n+        if pkh is not None:\n+            # P2WPKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_0, pubkeyhash])\n+            conf[\"scriptcode\"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"script_witv0\"] = None\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # P2WSH\n+            spk = CScript([OP_0, sha256(script)])\n+            conf[\"scriptcode\"] = script\n+            conf[\"script_witv0\"] = script\n+        else:\n+            assert False\n+    elif tap is None:\n+        conf[\"mode\"] = \"legacy\"\n+        if pkh is not None:\n+            # P2PKH\n+            assert(script is None)\n+            pubkeyhash = hash160(pkh)\n+            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])\n+            conf[\"scriptcode\"] = spk\n+            conf[\"inputs\"] = [getter(\"sign\"), pkh]\n+        elif script is not None:\n+            # bare\n+            spk = script\n+            conf[\"scriptcode\"] = script\n+        else:\n+            assert False\n+    else:\n+        assert(script is None)\n+        conf[\"mode\"] = \"taproot\"\n+        conf[\"tap\"] = tap\n+        spk = tap.scriptPubKey\n+\n+    if spk_mutate_pre_p2sh is not None:\n+        spk = spk_mutate_pre_p2sh(spk)\n+\n+    if p2sh:\n+        # P2SH wrapper can be combined with anything else\n+        conf[\"script_p2sh\"] = spk\n+        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])\n+\n+    conf = {**conf, **kwargs}\n+\n+    def sat_fn(tx, idx, utxos, valid):\n+        if valid:\n+            spend(tx, idx, utxos, **conf)\n+        else:\n+            assert(failure is not None)\n+            spend(tx, idx, utxos, **{**conf, **failure})\n+\n+    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None)\n+\n+def add_spender(spenders, *args, **kwargs):\n+    \"\"\"Make a spender using make_spender, and add it to spenders.\"\"\"\n+    spenders.append(make_spender(*args, **kwargs))\n+\n+# === Helpers for the test ===\n+\n+def random_checksig_style(pubkey):\n+    \"\"\"Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack.\"\"\"\n+    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])\n+    if (opcode == OP_CHECKSIGVERIFY):\n+        ret = CScript([pubkey, opcode, OP_1])\n+    elif (opcode == OP_CHECKSIGADD):\n+        num = random.choice([0, 0x7fffffff, -0x7fffffff])\n+        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])\n+    else:\n+        ret = CScript([pubkey, opcode])\n+    return bytes(ret)\n+\n+def random_bytes(n):\n+    \"\"\"Return a random bytes object of length n.\"\"\"\n+    return bytes(random.getrandbits(8) for i in range(n))\n+\n+def bitflipper(expr):\n+    \"\"\"Return a callable that evaluates expr and returns it with a random bitflip.\"\"\"\n+    def fn(ctx):\n+        sub = deep_eval(ctx, expr)\n+        assert isinstance(sub, bytes)\n+        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')\n+    return fn\n+\n+# Expected error strings\n+ERR_KEYPATH_INVALID_SIG = {\"err_msg\": \"Invalid signature for Taproot key path spending\"}\n+ERR_SCRIPTPATH_INVALID_SIG = {\"err_msg\": \"Signature must be zero for failed CHECK(MULTI)SIG operation\"}\n+ERR_OP_RETURN = {\"err_msg\": \"OP_RETURN was encountered\"}\n+ERR_CONTROLBLOCK_SIZE = {\"err_msg\": \"Invalid Taproot control block size\"}\n+ERR_WITNESS_PROGRAM_MISMATCH = {\"err_msg\": \"Witness program hash mismatch\"}\n+ERR_PUSH_LIMIT = {\"err_msg\": \"Push value size limit exceeded\"}\n+ERR_DISABLED_OPCODE = {\"err_msg\": \"Attempted to use a disabled opcode\"}\n+ERR_TAPSCRIPT_CHECKMULTISIG = {\"err_msg\": \"OP_CHECKMULTISIG(VERIFY) is not available in tapscript\"}\n+ERR_MINIMALIF = {\"err_msg\": \"OP_IF/NOTIF argument must be minimal\"}\n+ERR_UNKNOWN_PUBKEY = {\"err_msg\": \"Public key is neither compressed or uncompressed\"}\n+ERR_STACK_SIZE = {\"err_msg\": \"Stack size limit exceeded\"}\n+ERR_CLEANSTACK = {\"err_msg\": \"Extra items left on stack after execution\"}\n+ERR_STACK_EMPTY = {\"err_msg\": \"Operation not valid with the current stack size\"}\n+ERR_SIGOPS_RATIO = {\"err_msg\": \"Too much signature validation relative to witness weight\"}\n+ERR_UNDECODABLE = {\"err_msg\": \"Opcode missing or not understood\"}\n+ERR_NO_SUCCESS = {\"err_msg\": \"Script evaluated without error but finished with a false/empty top stack element\"}\n+ERR_EMPTY_WITNESS = {\"err_msg\": \"Witness program was passed an empty witness\"}\n+\n+VALID_SIGHASHES_ECDSA = [\n+    SIGHASH_ALL,\n+    SIGHASH_NONE,\n+    SIGHASH_SINGLE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_ALL,\n+    SIGHASH_ANYONECANPAY + SIGHASH_NONE,\n+    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE\n+]\n+\n+VALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA\n+\n+SIGHASH_BITFLIP = {\"failure\": {\"sighash\": bitflipper(default_sighash)}}\n+SINGLE_SIG = {\"inputs\": [getter(\"sign\")]}\n+\n+DUST_LIMIT = 600\n+MIN_FEE = 50000\n+\n+# === Actual test cases ===\n+\n+\n+def spenders_taproot_active():\n+    \"\"\"Return a list of Spenders for testing post-Taproot activation behavior.\"\"\"\n+\n+    secs = [generate_privkey() for _ in range(4)]\n+    pubs = [compute_xonly_pubkey(sec)[0] for sec in secs]\n+\n+    spenders = []\n+\n+    # == Tests for BIP340 signature validation. ==\n+    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.\n+    # Some things are tested programmatically as well here.\n+\n+    tap = taproot_construct(pubs[0])\n+    # Test with key with bit flipped.\n+    add_spender(spenders, \"sig/key\", tap=tap, key=secs[0], failure={\"key_tweaked\": bitflipper(default_key_tweaked)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with sighash with bit flipped.\n+    add_spender(spenders, \"sig/sighash\", tap=tap, key=secs[0], failure={\"sighash\": bitflipper(default_sighash)}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid R sign.\n+    add_spender(spenders, \"sig/flip_r\", tap=tap, key=secs[0], failure={\"flag_flip_r\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with invalid P sign.\n+    add_spender(spenders, \"sig/flip_p\", tap=tap, key=secs[0], failure={\"flag_flip_p\": True}, **ERR_KEYPATH_INVALID_SIG)\n+    # Test with signature with bit flipped.\n+    add_spender(spenders, \"sig/bitflip\", tap=tap, key=secs[0], failure={\"signature\": bitflipper(default_signature)}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # == Tests for signature hashing ==\n+\n+    # Run all tests once with no annex, and once with a valid random annex.\n+    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:\n+        # Non-empty annex is non-standard\n+        no_annex = annex is None\n+\n+        # Sighash mutation tests (test all sighash combinations)\n+        for hashtype in VALID_SIGHASHES_TAPROOT:\n+            common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+\n+            # Pure pubkey\n+            tap = taproot_construct(pubs[0])\n+            add_spender(spenders, \"sighash/purepk\", tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+\n+            # Pubkey/P2PK script combination\n+            scripts = [(\"s0\", CScript(random_checksig_style(pubs[1])))]\n+            tap = taproot_construct(pubs[0], scripts)\n+            add_spender(spenders, \"sighash/keypath_hashtype_%x\" % hashtype, tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+            add_spender(spenders, \"sighash/scriptpath_hashtype_%x\" % hashtype, tap=tap, leaf=\"s0\", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+        # Test OP_CODESEPARATOR impact on sighashing.\n+        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+        common = {\"annex\": annex, \"hashtype\": hashtype, \"standard\": no_annex}\n+        scripts = [\n+            (\"pk_codesep\", CScript(random_checksig_style(pubs[1]) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig\n+            (\"codesep_pk\", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pubs[1]))),  # codesep before checksig\n+            (\"branched_codesep\", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pubs[0], OP_ELSE, OP_CODESEPARATOR, pubs[1], OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep\n+        ]\n+        random.shuffle(scripts)\n+        tap = taproot_construct(pubs[0], scripts)\n+        add_spender(spenders, \"sighash/pk_codesep\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/codesep_pk\", tap=tap, leaf=\"codesep_pk\", key=secs[1], codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/left\", tap=tap, leaf=\"branched_codesep\", key=secs[0], codeseppos=3, **common, inputs=[getter(\"sign\"), b'\\x01'], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/branched_codesep/right\", tap=tap, leaf=\"branched_codesep\", key=secs[1], codeseppos=6, **common, inputs=[getter(\"sign\"), b''], **SIGHASH_BITFLIP, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Reusing the scripts above, test that various features affect the sighash.\n+    add_spender(spenders, \"sighash/annex\", tap=tap, leaf=\"pk_codesep\", key=secs[1], hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={\"sighash\": override(default_sighash, annex=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/script\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, script_taproot=tap.leaves[\"codesep_pk\"].script)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/leafver\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leafversion=random.choice([x & 0xFE for x in range(0x100) if x & 0xFE != 0xC0]))}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **common, **SINGLE_SIG, failure={\"sighash\": override(default_sighash, leaf=None)}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/keypath\", tap=tap, key=secs[0], **common, failure={\"sighash\": override(default_sighash, leaf=\"pk_codesep\")}, **ERR_KEYPATH_INVALID_SIG)\n+\n+    # Test that invalid hashtypes don't work, both in key path and script path spends\n+    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)\n+    for invalid_hashtype in [x for x in range(0x100) if x not in VALID_SIGHASHES_TAPROOT]:\n+        add_spender(spenders, \"sighash/keypath_unk_hashtype_%x\" % invalid_hashtype, tap=tap, key=secs[0], hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_KEYPATH_INVALID_SIG)\n+        add_spender(spenders, \"sighash/scriptpath_unk_hashtype_%x\" % invalid_hashtype, tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=hashtype, failure={\"hashtype\": invalid_hashtype}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # Test that hashtype 0 cannot have a hashtype byte, and 1 must have one.\n+    add_spender(spenders, \"sighash/hashtype0_byte_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_DEFAULT])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1_byte_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    # Test that hashtype 0 and hashtype 1 cannot be transmuted into each other.\n+    add_spender(spenders, \"sighash/hashtype0to1_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype0to1_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={\"bytes_hashtype\": bytes([SIGHASH_ALL])}, **ERR_SCRIPTPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_keypath\", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_KEYPATH_INVALID_SIG)\n+    add_spender(spenders, \"sighash/hashtype1to0_scriptpath\", tap=tap, leaf=\"pk_codesep\", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={\"bytes_hashtype\": b''}, **ERR_SCRIPTPATH_INVALID_SIG)\n+\n+    # == Test that BIP341 spending only applies to witness version 1, program length 32, no P2SH ==\n+\n+    for p2sh in [False, True]:\n+        for witver in range(1, 17):\n+            for witlen in [20, 31, 32, 33]:\n+                def mutate(spk):\n+                    prog = spk[2:]\n+                    assert(len(prog) == 32)\n+                    if witlen < 32:\n+                        prog = prog[0:witlen]\n+                    elif witlen > 32:\n+                        prog += bytes([0 for _ in range(witlen - 32)])\n+                    return CScript([CScriptOp.encode_op_n(witver), prog])\n+                scripts = [(\"s0\", CScript([pubs[0], OP_CHECKSIG])), (\"dummy\", CScript([OP_RETURN]))]\n+                tap = taproot_construct(pubs[1], scripts)\n+                if not p2sh and witver == 1 and witlen == 32:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], **SIGHASH_BITFLIP, **ERR_KEYPATH_INVALID_SIG)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, failure={\"leaf\": \"dummy\"}, **ERR_OP_RETURN)\n+                else:\n+                    add_spender(spenders, \"applic/keypath\", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], standard=False)\n+                    add_spender(spenders, \"applic/scriptpath\", p2sh=p2sh, leaf=\"s0\", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, standard=False)\n+\n+    # == Test various aspects of BIP341 spending paths ==\n+\n+    # A set of functions that compute the hashing partner in a Merkle tree, designed to exercise\n+    # edge cases. This relies on the taproot_construct feature that a lambda can be passed in\n+    # instead of a subtree, to compute the partner to be hashed with.\n+    PARTNER_MERKLE_FN = [\n+        # Combine with itself\n+        lambda h: h,\n+        # Combine with hash 0\n+        lambda h: bytes([0 for _ in range(32)]),\n+        # Combine with hash 2^256-1\n+        lambda h: bytes([0xff for _ in range(32)]),\n+        # Combine with itself-1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (BE)\n+        lambda h: (int.from_bytes(h, 'big') + 1).to_bytes(32, 'big'),\n+        # Combine with itself-1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') - 1).to_bytes(32, 'big'),\n+        # Combine with itself+1 (LE)\n+        lambda h: (int.from_bytes(h, 'little') + 1).to_bytes(32, 'little'),\n+        # Combine with random bitflipped version of self.\n+        lambda h: (int.from_bytes(h, 'little') ^ (1 << random.randrange(256))).to_bytes(32, 'little')\n+    ]\n+    # Start with a tree of that has depth 1 for \"128deep\" and depth 2 for \"129deep\".\n+    scripts = [(\"128deep\", CScript([pubs[0], OP_CHECKSIG])), [(\"129deep\", CScript([pubs[0], OP_CHECKSIG])), random.choice(PARTNER_MERKLE_FN)]]\n+    # Add 127 nodes on top of that tree, so that \"128deep\" and \"129deep\" end up at their designated depths.\n+    for _ in range(127):\n+        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)]\n+    tap = taproot_construct(pubs[0], scripts)\n+    # Test that spends with a depth of 128 work, but 129 doesn't (even with a tree with weird Merkle branches in it).\n+    add_spender(spenders, \"spendpath/merklelimit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"leaf\": \"129deep\"}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that flipping the negation bit invalidates spends.\n+    add_spender(spenders, \"spendpath/negflag\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"negflag\": lambda ctx: 1 - default_negflag(ctx)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the Merkle branch invalidate it.\n+    add_spender(spenders, \"spendpath/bitflipmerkle\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"merklebranch\": bitflipper(default_merklebranch)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that bitflips in the inner pubkey invalidate it.\n+    add_spender(spenders, \"spendpath/bitflippubkey\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"pubkey_inner\": bitflipper(default_pubkey_inner)}, **ERR_WITNESS_PROGRAM_MISMATCH)\n+    # Test that empty witnesses are invalid.\n+    add_spender(spenders, \"spendpath/emptywit\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"witness\": []}, **ERR_EMPTY_WITNESS)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padlongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/trunclongcontrol\", tap=tap, leaf=\"128deep\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    scripts = [(\"s\", CScript([pubs[0], OP_CHECKSIG]))]\n+    tap = taproot_construct(pubs[1], scripts)\n+    # Test that adding garbage to the control block invalidates it.\n+    add_spender(spenders, \"spendpath/padshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block invalidates it.\n+    add_spender(spenders, \"spendpath/truncshortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)\n+    # Test that truncating the control block to 1 byte (\"-1 Merkle length\") invalidates it\n+    add_spender(spenders, \"spendpath/trunc1shortcontrol\", tap=tap, leaf=\"s\", **SINGLE_SIG, key=secs[0], failure={\"controlblock\": lambda ctx: default_merklebranch(ctx)[0:1]}, **ERR_CONTROLBLOCK_SIZE)\n+\n+    # == Test BIP342 edge cases ==\n+\n+    checksigadd_val = random.randrange(17, 100) # Above OP_16 to avoid minimal encoding complaints\n+    checksigadd_arg = CScriptNum(checksigadd_val)\n+    checksigadd_result = CScriptNum(checksigadd_val+1)\n+    OVERSIZE_NUMBER = 2**31\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER))), 6)\n+    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER-1))), 5)\n+\n+    big_choices = []\n+    big_scriptops = []\n+    for i in range(1000):\n+        r = random.randrange(4)\n+        big_choices.append(r)\n+        big_scriptops += [pubs[r], OP_CHECKSIGVERIFY]\n+\n+\n+    def big_spend_inputs(ctx):\n+        \"\"\"Helper function to construct the script input for t33/t34 below.\"\"\"\n+        # Instead of signing 999 times, precompute signatures for every (key, hashtype) combination\n+        sigs = {}\n+        for ht in VALID_SIGHASHES_TAPROOT:\n+            for k in range(4):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r479595199",
      "id" : 479595199,
      "in_reply_to_id" : 479591776,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5NTE5OQ==",
      "original_commit_id" : "619ceebd4d84e9fd9a16c5aed6c4a328da44381c",
      "original_line" : 755,
      "original_position" : 755,
      "original_start_line" : null,
      "path" : "test/functional/feature_taproot.py",
      "position" : null,
      "pull_request_review_id" : 478090284,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/479595199",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482137828"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482137828"
         }
      },
      "author_association" : "NONE",
      "body" : "Since these names look so similar (made me confused), maybe use names without numbers to distinguish them better? Or something like `uses_bip341_taproot`?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-02T14:59:33Z",
      "diff_hunk" : "@@ -1291,35 +1379,174 @@ uint256 GetOutputsSHA256(const T& txTo)\n     return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = SHA256Uint256(GetPrevoutsSHA256(txTo));\n-        hashSequence = SHA256Uint256(GetSequencesSHA256(txTo));\n-        hashOutputs = SHA256Uint256(GetOutputsSHA256(txTo));\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n     }\n \n-    m_ready = true;\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143 = false;\n+    bool uses_bip341 = false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482137828",
      "id" : 482137828,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEzNzgyOA==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1418,
      "original_position" : 250,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 480910639,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482137828",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1178779?v=4",
         "events_url" : "https://api.github.com/users/Kixunil/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Kixunil/followers",
         "following_url" : "https://api.github.com/users/Kixunil/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Kixunil/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Kixunil",
         "id" : 1178779,
         "login" : "Kixunil",
         "node_id" : "MDQ6VXNlcjExNzg3Nzk=",
         "organizations_url" : "https://api.github.com/users/Kixunil/orgs",
         "received_events_url" : "https://api.github.com/users/Kixunil/received_events",
         "repos_url" : "https://api.github.com/users/Kixunil/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Kixunil/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Kixunil/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Kixunil"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482168422"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482168422"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit if you retouch\r\n\r\n```suggestion\r\n    const int path_len = (control.size() - TAPROOT_CONTROL_BASE_SIZE) / TAPROOT_CONTROL_NODE_SIZE;\r\n    const XOnlyPubKey p{uint256(std::vector<unsigned char>(control.begin() + 1, control.begin() + TAPROOT_CONTROL_BASE_SIZE))};\r\n    const XOnlyPubKey q{uint256(program)};\r\n    uint256 k = (CHashWriter(HASHER_TAPLEAF) << uint8_t(control[0] & TAPROOT_LEAF_MASK) << script).GetSHA256();\r\n    for (int i = 0; i < path_len; ++i) {\r\n        CHashWriter ss_branch{HASHER_TAPBRANCH};\r\n```",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-02T15:36:20Z",
      "diff_hunk" : "@@ -1671,14 +1674,34 @@ static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CS\n     return true;\n }\n \n-static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, const std::vector<unsigned char>& program, const CScript& script)\n+{\n+    int path_len = (control.size() - TAPROOT_CONTROL_BASE_SIZE) / TAPROOT_CONTROL_NODE_SIZE;\n+    XOnlyPubKey p{uint256(std::vector<unsigned char>(control.begin() + 1, control.begin() + TAPROOT_CONTROL_BASE_SIZE))};\n+    XOnlyPubKey q{uint256(program)};\n+    uint256 k = (CHashWriter(HASHER_TAPLEAF) << uint8_t(control[0] & TAPROOT_LEAF_MASK) << script).GetSHA256();\n+    for (int i = 0; i < path_len; ++i) {\n+        CHashWriter ss_branch = HASHER_TAPBRANCH;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482168422",
      "id" : 482168422,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE2ODQyMg==",
      "original_commit_id" : "a6ca5080c4ac550dc74330e89c44d3eb268d4eb5",
      "original_line" : 1684,
      "original_position" : 22,
      "original_start_line" : 1679,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 480949321,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482168422",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1322187?v=4",
         "events_url" : "https://api.github.com/users/fjahr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fjahr/followers",
         "following_url" : "https://api.github.com/users/fjahr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fjahr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fjahr",
         "id" : 1322187,
         "login" : "fjahr",
         "node_id" : "MDQ6VXNlcjEzMjIxODc=",
         "organizations_url" : "https://api.github.com/users/fjahr/orgs",
         "received_events_url" : "https://api.github.com/users/fjahr/received_events",
         "repos_url" : "https://api.github.com/users/fjahr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fjahr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fjahr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fjahr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482169713"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482169713"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```suggestion\r\nbool XOnlyPubKey::CheckPayToContract(const XOnlyPubKey& base, const uint256& hash, const bool negated) const\r\n```",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-02T15:38:04Z",
      "diff_hunk" : "@@ -181,6 +181,13 @@ bool XOnlyPubKey::VerifySchnorr(const uint256& msg, Span<const unsigned char> si\n     return secp256k1_schnorrsig_verify(secp256k1_context_verify, sigbytes.data(), msg.begin(), &pubkey);\n }\n \n+bool XOnlyPubKey::CheckPayToContract(const XOnlyPubKey& base, const uint256& hash, bool negated) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482169713",
      "id" : 482169713,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE2OTcxMw==",
      "original_commit_id" : "a6ca5080c4ac550dc74330e89c44d3eb268d4eb5",
      "original_line" : 184,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/pubkey.cpp",
      "position" : null,
      "pull_request_review_id" : 480949321,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482169713",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1322187?v=4",
         "events_url" : "https://api.github.com/users/fjahr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fjahr/followers",
         "following_url" : "https://api.github.com/users/fjahr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fjahr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fjahr",
         "id" : 1322187,
         "login" : "fjahr",
         "node_id" : "MDQ6VXNlcjEzMjIxODc=",
         "organizations_url" : "https://api.github.com/users/fjahr/orgs",
         "received_events_url" : "https://api.github.com/users/fjahr/received_events",
         "repos_url" : "https://api.github.com/users/fjahr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fjahr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fjahr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fjahr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482170606"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482170606"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "(renaming suggested to be consistent with the name in the implementation)\r\n```suggestion\r\n    bool CheckPayToContract(const XOnlyPubKey& base, const uint256& hash, const bool negated) const;\r\n```",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-02T15:39:20Z",
      "diff_hunk" : "@@ -220,8 +220,10 @@ class XOnlyPubKey {\n      * If the signature is not exactly 64 bytes, false is returned.\n      */\n     bool VerifySchnorr(const uint256& msg, Span<const unsigned char> sigbytes) const;\n+    bool CheckPayToContract(const XOnlyPubKey& base, const uint256& hash, bool sign) const;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482170606",
      "id" : 482170606,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MDYwNg==",
      "original_commit_id" : "a6ca5080c4ac550dc74330e89c44d3eb268d4eb5",
      "original_line" : 223,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/pubkey.h",
      "position" : null,
      "pull_request_review_id" : 480949321,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482170606",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1322187?v=4",
         "events_url" : "https://api.github.com/users/fjahr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fjahr/followers",
         "following_url" : "https://api.github.com/users/fjahr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fjahr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fjahr",
         "id" : 1322187,
         "login" : "fjahr",
         "node_id" : "MDQ6VXNlcjEzMjIxODc=",
         "organizations_url" : "https://api.github.com/users/fjahr/orgs",
         "received_events_url" : "https://api.github.com/users/fjahr/received_events",
         "repos_url" : "https://api.github.com/users/fjahr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fjahr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fjahr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fjahr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482202942"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482202942"
         }
      },
      "author_association" : "NONE",
      "body" : "Would moving the `control.size()` check here be less of a footgun?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-02T16:27:29Z",
      "diff_hunk" : "@@ -1504,32 +1756,78 @@ bool GenericTransactionSignatureChecker<T>::CheckSequence(const CScriptNum& nSeq\n template class GenericTransactionSignatureChecker<CTransaction>;\n template class GenericTransactionSignatureChecker<CMutableTransaction>;\n \n-static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, const ScriptExecutionData& execdata, ScriptError* serror)\n {\n     std::vector<valtype> stack{stack_span.begin(), stack_span.end()};\n \n+    if (sigversion == SigVersion::TAPSCRIPT) {\n+        // OP_SUCCESSx processing overrides everything, including stack element size limits\n+        CScript::const_iterator pc = scriptPubKey.begin();\n+        while (pc < scriptPubKey.end()) {\n+            opcodetype opcode;\n+            if (!scriptPubKey.GetOp(pc, opcode)) {\n+                // Note how this condition would not be reached if an unknown OP_SUCCESSx was found\n+                return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n+            }\n+            // New opcodes will be listed here. May use a different sigversion to modify existing opcodes.\n+            if (IsOpSuccess(opcode)) {\n+                if (flags & SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS) {\n+                    return set_error(serror, SCRIPT_ERR_DISCOURAGE_OP_SUCCESS);\n+                }\n+                return set_success(serror);\n+            }\n+        }\n+\n+        // Tapscript enforces initial stack size limits (altstack is empty here)\n+        if (stack.size() > MAX_STACK_SIZE) {\n+            return set_error(serror, SCRIPT_ERR_STACK_SIZE);\n+        }\n+    }\n+\n     // Disallow stack item size > MAX_SCRIPT_ELEMENT_SIZE in witness stack\n     for (const valtype& elem : stack) {\n         if (elem.size() > MAX_SCRIPT_ELEMENT_SIZE) return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n     }\n \n     // Run the script interpreter.\n-    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, serror)) return false;\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, serror, execdata)) return false;\n \n     // Scripts inside witness implicitly require cleanstack behaviour\n     if (stack.size() != 1) return set_error(serror, SCRIPT_ERR_CLEANSTACK);\n     if (!CastToBool(stack.back())) return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n     return true;\n }\n \n-static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, const std::vector<unsigned char>& program, const CScript& script, uint256* tapleaf_hash)\n+{\n+    int path_len = (control.size() - TAPROOT_CONTROL_BASE_SIZE) / TAPROOT_CONTROL_NODE_SIZE;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482202942",
      "id" : 482202942,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIwMjk0Mg==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1803,
      "original_position" : 503,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 480910639,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482202942",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1178779?v=4",
         "events_url" : "https://api.github.com/users/Kixunil/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Kixunil/followers",
         "following_url" : "https://api.github.com/users/Kixunil/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Kixunil/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Kixunil",
         "id" : 1178779,
         "login" : "Kixunil",
         "node_id" : "MDQ6VXNlcjExNzg3Nzk=",
         "organizations_url" : "https://api.github.com/users/Kixunil/orgs",
         "received_events_url" : "https://api.github.com/users/Kixunil/received_events",
         "repos_url" : "https://api.github.com/users/Kixunil/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Kixunil/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Kixunil/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Kixunil"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482259993"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482259993"
         }
      },
      "author_association" : "NONE",
      "body" : "This is different from BIP114 which says the max size of path must be below 1024, however `32 * 128 == 4096`\r\n\r\nIs this correct?\r\n\r\nI suppose BIP114 limit is superseded by BIP341 (which I find reasonable) but asking to be sure. (Perhaps BIP114 should be updated?)",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-02T17:56:29Z",
      "diff_hunk" : "@@ -114,41 +121,111 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 19),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 20),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    // BIP341 precomputed data.\n+    // These are single-SHA256, see https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-15.\n+    uint256 m_bip341_prevouts_hash;\n+    uint256 m_bip341_sequences_hash;\n+    uint256 m_bip341_outputs_hash;\n+    uint256 m_bip341_spent_amounts_hash;\n+    uint256 m_bip341_spent_scripts_hash;\n+    //! Whether the 5 fields above are initialized.\n+    bool m_bip341_ready = false;\n+\n+    // BIP143 precomputed data (double-SHA256).\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n-    bool m_ready = false;\n+    //! Whether the 3 fields above are initialized.\n+    bool m_bip143_ready = false;\n+\n+    std::vector<CTxOut> m_spent_outputs;\n+    //! Whether m_spent_outputs is initialized.\n+    bool m_spent_outputs_ready = false;\n \n     PrecomputedTransactionData() = default;\n \n     template <class T>\n-    void Init(const T& tx);\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and BIP16 P2SH-wrapped redeemscripts\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with 32-byte program, not BIP16 P2SH-wrapped, key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with 32-byte program, not BIP16 P2SH-wrapped, script path spending, leaf version 0xc0; see BIP 342\n+};\n+\n+struct ScriptExecutionData\n+{\n+    //! Whether m_tapleaf_hash is initialized.\n+    bool m_tapleaf_hash_init = false;\n+    //! The tapleaf hash.\n+    uint256 m_tapleaf_hash;\n+\n+    //! Whether m_codeseparator_pos is initialized.\n+    bool m_codeseparator_pos_init = false;\n+    //! Opcode position of the last executed OP_CODESEPARATOR (or 0xFFFFFFFF if none executed).\n+    uint32_t m_codeseparator_pos;\n+\n+    //! Whether m_annex_present and (when needed) m_annex_hash are initialized.\n+    bool m_annex_init = false;\n+    //! Whether an annex is present.\n+    bool m_annex_present;\n+    //! Hash of the annex data.\n+    uint256 m_annex_hash;\n+\n+    /** Whether m_validation_weight_left is initialized. */\n+    bool m_validation_weight_left_init = false;\n+    /** How much validation weight is left (decremented for every successful signature check). */\n+    int64_t m_validation_weight_left;\n };\n \n /** Signature hash sizes */\n static constexpr size_t WITNESS_V0_SCRIPTHASH_SIZE = 32;\n static constexpr size_t WITNESS_V0_KEYHASH_SIZE = 20;\n+static constexpr size_t WITNESS_V1_TAPROOT_SIZE = 32;\n+\n+static constexpr uint8_t TAPROOT_LEAF_MASK = 0xfe;\n+static constexpr uint8_t TAPROOT_LEAF_TAPSCRIPT = 0xc0;\n+static constexpr size_t TAPROOT_CONTROL_BASE_SIZE = 33;\n+static constexpr size_t TAPROOT_CONTROL_NODE_SIZE = 32;\n+static constexpr size_t TAPROOT_CONTROL_MAX_NODE_COUNT = 128;\n+static constexpr size_t TAPROOT_CONTROL_MAX_SIZE = TAPROOT_CONTROL_BASE_SIZE + TAPROOT_CONTROL_NODE_SIZE * TAPROOT_CONTROL_MAX_NODE_COUNT;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482259993",
      "id" : 482259993,
      "line" : 215,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1OTk5Mw==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 215,
      "original_position" : 128,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : 128,
      "pull_request_review_id" : 480910639,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482259993",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1178779?v=4",
         "events_url" : "https://api.github.com/users/Kixunil/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Kixunil/followers",
         "following_url" : "https://api.github.com/users/Kixunil/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Kixunil/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Kixunil",
         "id" : 1178779,
         "login" : "Kixunil",
         "node_id" : "MDQ6VXNlcjExNzg3Nzk=",
         "organizations_url" : "https://api.github.com/users/Kixunil/orgs",
         "received_events_url" : "https://api.github.com/users/Kixunil/received_events",
         "repos_url" : "https://api.github.com/users/Kixunil/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Kixunil/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Kixunil/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Kixunil"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482378845"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482378845"
         }
      },
      "author_association" : "NONE",
      "body" : "Why not BIP8?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-02T19:58:16Z",
      "diff_hunk" : "@@ -146,7 +146,19 @@ def _test_getblockchaininfo(self):\n                         'possible': True,\n                     },\n                 },\n-                'active': False}\n+                'active': False\n+            },\n+            'taproot': {\n+                'type': 'bip9',",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482378845",
      "id" : 482378845,
      "line" : 152,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjM3ODg0NQ==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 152,
      "original_position" : 8,
      "original_start_line" : null,
      "path" : "test/functional/rpc_blockchain.py",
      "position" : 8,
      "pull_request_review_id" : 480910639,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482378845",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1178779?v=4",
         "events_url" : "https://api.github.com/users/Kixunil/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Kixunil/followers",
         "following_url" : "https://api.github.com/users/Kixunil/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Kixunil/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Kixunil",
         "id" : 1178779,
         "login" : "Kixunil",
         "node_id" : "MDQ6VXNlcjExNzg3Nzk=",
         "organizations_url" : "https://api.github.com/users/Kixunil/orgs",
         "received_events_url" : "https://api.github.com/users/Kixunil/received_events",
         "repos_url" : "https://api.github.com/users/Kixunil/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Kixunil/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Kixunil/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Kixunil"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482596393"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482596393"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be referenced in `CTxDestination` typedef.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-02T23:25:07Z",
      "diff_hunk" : "@@ -129,6 +129,7 @@ enum class TxoutType {\n     NULL_DATA, //!< unspendable OP_RETURN script that carries data\n     WITNESS_V0_SCRIPTHASH,\n     WITNESS_V0_KEYHASH,\n+    WITNESS_V1_TAPROOT,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482596393",
      "id" : 482596393,
      "line" : 132,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU5NjM5Mw==",
      "original_commit_id" : "8859e78b6a563fecd75aca9498c1321f583bd8d8",
      "original_line" : 132,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/script/standard.h",
      "position" : 4,
      "pull_request_review_id" : 481335549,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482596393",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482598143"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482598143"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't get a `feature_taproot.py` failure for this ?\r\n\r\n```\r\ndiff --git a/src/script/interpreter.cpp b/src/script/interpreter.cpp\r\nindex 053df47a2..02de07bc5 100644\r\n--- a/src/script/interpreter.cpp\r\n+++ b/src/script/interpreter.cpp\r\n@@ -1652,7 +1652,7 @@ bool GenericTransactionSignatureChecker<T>::CheckECDSASignature(const std::vecto\r\n template <class T>\r\n bool GenericTransactionSignatureChecker<T>::CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey_in, SigVersion sigversion, const ScriptExecutionData& execdata) const\r\n {\r\n-    if (sig.empty()) return false;\r\n+    if (sig.empty()) return true;\r\n     if (pubkey_in.size() != 32) return false;\r\n \r\n     XOnlyPubKey pubkey{pubkey_in};\r\n```",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-02T23:28:51Z",
      "diff_hunk" : "@@ -1410,12 +1643,31 @@ bool GenericTransactionSignatureChecker<T>::CheckSig(const std::vector<unsigned\n \n     uint256 sighash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion, this->txdata);\n \n-    if (!VerifySignature(vchSig, pubkey, sighash))\n+    if (!VerifyECDSASignature(vchSig, pubkey, sighash))\n         return false;\n \n     return true;\n }\n \n+template <class T>\n+bool GenericTransactionSignatureChecker<T>::CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey_in, SigVersion sigversion, const ScriptExecutionData& execdata) const\n+{\n+    if (sig.empty()) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482598143",
      "id" : 482598143,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU5ODE0Mw==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1655,
      "original_position" : 433,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 481335549,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482598143",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482599178"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482599178"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Idem, is this part of the code tested non-deterministically ?\r\n\r\n```\r\ndiff --git a/src/script/interpreter.cpp b/src/script/interpreter.cpp\r\nindex 053df47a2..fcaacc152 100644\r\n--- a/src/script/interpreter.cpp\r\n+++ b/src/script/interpreter.cpp\r\n@@ -1653,7 +1653,7 @@ template <class T>\r\n bool GenericTransactionSignatureChecker<T>::CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey_in, SigVersion sigversion, const ScriptExecutionData& execdata) const\r\n {\r\n     if (sig.empty()) return false;\r\n-    if (pubkey_in.size() != 32) return false;\r\n+    if (pubkey_in.size() != 32) return true;\r\n \r\n     XOnlyPubKey pubkey{pubkey_in};\r\n```",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-02T23:32:15Z",
      "diff_hunk" : "@@ -1410,12 +1643,31 @@ bool GenericTransactionSignatureChecker<T>::CheckSig(const std::vector<unsigned\n \n     uint256 sighash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion, this->txdata);\n \n-    if (!VerifySignature(vchSig, pubkey, sighash))\n+    if (!VerifyECDSASignature(vchSig, pubkey, sighash))\n         return false;\n \n     return true;\n }\n \n+template <class T>\n+bool GenericTransactionSignatureChecker<T>::CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey_in, SigVersion sigversion, const ScriptExecutionData& execdata) const\n+{\n+    if (sig.empty()) return false;\n+    if (pubkey_in.size() != 32) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482599178",
      "id" : 482599178,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU5OTE3OA==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1656,
      "original_position" : 434,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 481335549,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482599178",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482601984"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482601984"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Again don't get failure in `feature_taproot.py` ? What should be the prefix something like `sighash/keypath_*` ?\r\n\r\n\r\n```\r\ndiff --git a/src/script/interpreter.cpp b/src/script/interpreter.cpp\r\nindex 053df47a2..24ba2ac41 100644\r\n--- a/src/script/interpreter.cpp\r\n+++ b/src/script/interpreter.cpp\r\n@@ -1662,7 +1662,7 @@ bool GenericTransactionSignatureChecker<T>::CheckSchnorrSignature(Span<const uns\r\n         hashtype = SpanPopBack(sig);\r\n         if (hashtype == SIGHASH_DEFAULT) return false;\r\n     }\r\n-    if (sig.size() != 64) return false;\r\n+    if (sig.size() != 64) return true;\r\n     uint256 sighash;\r\n     if (!SignatureHashSchnorr(sighash, execdata, *txTo, nIn, hashtype, sigversion, this->txdata)) return false;\r\n     return VerifySchnorrSignature(sig, pubkey, sighash);\r\n```",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-02T23:41:35Z",
      "diff_hunk" : "@@ -1410,12 +1643,31 @@ bool GenericTransactionSignatureChecker<T>::CheckSig(const std::vector<unsigned\n \n     uint256 sighash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion, this->txdata);\n \n-    if (!VerifySignature(vchSig, pubkey, sighash))\n+    if (!VerifyECDSASignature(vchSig, pubkey, sighash))\n         return false;\n \n     return true;\n }\n \n+template <class T>\n+bool GenericTransactionSignatureChecker<T>::CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey_in, SigVersion sigversion, const ScriptExecutionData& execdata) const\n+{\n+    if (sig.empty()) return false;\n+    if (pubkey_in.size() != 32) return false;\n+\n+    XOnlyPubKey pubkey{pubkey_in};\n+\n+    uint8_t hashtype = SIGHASH_DEFAULT;\n+    if (sig.size() == 65) {\n+        hashtype = SpanPopBack(sig);\n+        if (hashtype == SIGHASH_DEFAULT) return false;\n+    }\n+    if (sig.size() != 64) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482601984",
      "id" : 482601984,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYwMTk4NA==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1665,
      "original_position" : 443,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 481335549,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482601984",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482603435"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482603435"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Technically this should be called `witnessScript` (BIP141) or just `script` (BIP341) ? `scriptPubKey` is a bit confusing as this is fed from the witness?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-02T23:46:17Z",
      "diff_hunk" : "@@ -1540,22 +1838,64 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n             if (memcmp(hashScriptPubKey.begin(), program.data(), 32)) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);\n             }\n-            return ExecuteWitnessScript(stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, serror);\n+            return ExecuteWitnessScript(stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, execdata, serror);\n         } else if (program.size() == WITNESS_V0_KEYHASH_SIZE) {\n-            // Special case for pay-to-pubkeyhash; signature + pubkey in witness\n+            // BIP141 P2WPKH: 20-byte witness v0 program (which encodes Hash160(pubkey))\n             if (stack.size() != 2) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH); // 2 items in witness\n             }\n             scriptPubKey << OP_DUP << OP_HASH160 << program << OP_EQUALVERIFY << OP_CHECKSIG;\n-            return ExecuteWitnessScript(stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, serror);\n+            return ExecuteWitnessScript(stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, execdata, serror);\n         } else {\n             return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH);\n         }\n+    } else if (witversion == 1 && program.size() == WITNESS_V1_TAPROOT_SIZE && !is_p2sh) {\n+        // BIP341 Taproot: 32-byte non-P2SH witness v1 program (which encodes a P2C-tweaked pubkey)\n+        if (!(flags & SCRIPT_VERIFY_TAPROOT)) return set_success(serror);\n+        if (stack.size() == 0) return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);\n+        if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {\n+            // Drop annex\n+            const valtype& annex = SpanPopBack(stack);\n+            execdata.m_annex_hash = (CHashWriter(SER_GETHASH, 0) << annex).GetSHA256();\n+            execdata.m_annex_present = true;\n+        } else {\n+            execdata.m_annex_present = false;\n+        }\n+        execdata.m_annex_init = true;\n+        if (stack.size() == 1) {\n+            // Key path spending (stack size is 1 after removing optional annex)\n+            if (!checker.CheckSchnorrSignature(stack.front(), program, SigVersion::TAPROOT, execdata)) {\n+                return set_error(serror, SCRIPT_ERR_TAPROOT_INVALID_SIG);\n+            }\n+            return set_success(serror);\n+        } else {\n+            // Script path spending (stack size is >1 after removing optional annex)\n+            const valtype& control = SpanPopBack(stack);\n+            const valtype& script_bytes = SpanPopBack(stack);\n+            scriptPubKey = CScript(script_bytes.begin(), script_bytes.end());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482603435",
      "id" : 482603435,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYwMzQzNQ==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1875,
      "original_position" : 576,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 481335549,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482603435",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482608452"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482608452"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I tried to tweak serializers to test that `compact_size(size of s)` is well-committed in tapleaf hash. Of course I got failure far earlier, so I was wondering if there is a way to test this in isolation ? I guess that's useless as our script ser is already used at anytime, so any error would be more than obvious.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-03T00:03:06Z",
      "diff_hunk" : "@@ -1504,32 +1756,78 @@ bool GenericTransactionSignatureChecker<T>::CheckSequence(const CScriptNum& nSeq\n template class GenericTransactionSignatureChecker<CTransaction>;\n template class GenericTransactionSignatureChecker<CMutableTransaction>;\n \n-static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, const ScriptExecutionData& execdata, ScriptError* serror)\n {\n     std::vector<valtype> stack{stack_span.begin(), stack_span.end()};\n \n+    if (sigversion == SigVersion::TAPSCRIPT) {\n+        // OP_SUCCESSx processing overrides everything, including stack element size limits\n+        CScript::const_iterator pc = scriptPubKey.begin();\n+        while (pc < scriptPubKey.end()) {\n+            opcodetype opcode;\n+            if (!scriptPubKey.GetOp(pc, opcode)) {\n+                // Note how this condition would not be reached if an unknown OP_SUCCESSx was found\n+                return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n+            }\n+            // New opcodes will be listed here. May use a different sigversion to modify existing opcodes.\n+            if (IsOpSuccess(opcode)) {\n+                if (flags & SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS) {\n+                    return set_error(serror, SCRIPT_ERR_DISCOURAGE_OP_SUCCESS);\n+                }\n+                return set_success(serror);\n+            }\n+        }\n+\n+        // Tapscript enforces initial stack size limits (altstack is empty here)\n+        if (stack.size() > MAX_STACK_SIZE) {\n+            return set_error(serror, SCRIPT_ERR_STACK_SIZE);\n+        }\n+    }\n+\n     // Disallow stack item size > MAX_SCRIPT_ELEMENT_SIZE in witness stack\n     for (const valtype& elem : stack) {\n         if (elem.size() > MAX_SCRIPT_ELEMENT_SIZE) return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n     }\n \n     // Run the script interpreter.\n-    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, serror)) return false;\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, serror, execdata)) return false;\n \n     // Scripts inside witness implicitly require cleanstack behaviour\n     if (stack.size() != 1) return set_error(serror, SCRIPT_ERR_CLEANSTACK);\n     if (!CastToBool(stack.back())) return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n     return true;\n }\n \n-static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, const std::vector<unsigned char>& program, const CScript& script, uint256* tapleaf_hash)\n+{\n+    int path_len = (control.size() - TAPROOT_CONTROL_BASE_SIZE) / TAPROOT_CONTROL_NODE_SIZE;\n+    XOnlyPubKey p{uint256(std::vector<unsigned char>(control.begin() + 1, control.begin() + TAPROOT_CONTROL_BASE_SIZE))};\n+    XOnlyPubKey q{uint256(program)};\n+    uint256 k = (CHashWriter(HASHER_TAPLEAF) << uint8_t(control[0] & TAPROOT_LEAF_MASK) << script).GetSHA256();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482608452",
      "id" : 482608452,
      "line" : 1817,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYwODQ1Mg==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1817,
      "original_position" : 506,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 524,
      "pull_request_review_id" : 481335549,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482608452",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482615760"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482615760"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Computation of tweaked_pubkey `Q` is guarantee to be non-malleable by a third-party such that any intentional flip of the parity bit of the control block would fail here ? Is this test somewhere, when I try to test it I got some `opsuccess/return` error ?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-03T00:28:31Z",
      "diff_hunk" : "@@ -1504,32 +1756,78 @@ bool GenericTransactionSignatureChecker<T>::CheckSequence(const CScriptNum& nSeq\n template class GenericTransactionSignatureChecker<CTransaction>;\n template class GenericTransactionSignatureChecker<CMutableTransaction>;\n \n-static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, const ScriptExecutionData& execdata, ScriptError* serror)\n {\n     std::vector<valtype> stack{stack_span.begin(), stack_span.end()};\n \n+    if (sigversion == SigVersion::TAPSCRIPT) {\n+        // OP_SUCCESSx processing overrides everything, including stack element size limits\n+        CScript::const_iterator pc = scriptPubKey.begin();\n+        while (pc < scriptPubKey.end()) {\n+            opcodetype opcode;\n+            if (!scriptPubKey.GetOp(pc, opcode)) {\n+                // Note how this condition would not be reached if an unknown OP_SUCCESSx was found\n+                return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n+            }\n+            // New opcodes will be listed here. May use a different sigversion to modify existing opcodes.\n+            if (IsOpSuccess(opcode)) {\n+                if (flags & SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS) {\n+                    return set_error(serror, SCRIPT_ERR_DISCOURAGE_OP_SUCCESS);\n+                }\n+                return set_success(serror);\n+            }\n+        }\n+\n+        // Tapscript enforces initial stack size limits (altstack is empty here)\n+        if (stack.size() > MAX_STACK_SIZE) {\n+            return set_error(serror, SCRIPT_ERR_STACK_SIZE);\n+        }\n+    }\n+\n     // Disallow stack item size > MAX_SCRIPT_ELEMENT_SIZE in witness stack\n     for (const valtype& elem : stack) {\n         if (elem.size() > MAX_SCRIPT_ELEMENT_SIZE) return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n     }\n \n     // Run the script interpreter.\n-    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, serror)) return false;\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, serror, execdata)) return false;\n \n     // Scripts inside witness implicitly require cleanstack behaviour\n     if (stack.size() != 1) return set_error(serror, SCRIPT_ERR_CLEANSTACK);\n     if (!CastToBool(stack.back())) return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n     return true;\n }\n \n-static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, const std::vector<unsigned char>& program, const CScript& script, uint256* tapleaf_hash)\n+{\n+    int path_len = (control.size() - TAPROOT_CONTROL_BASE_SIZE) / TAPROOT_CONTROL_NODE_SIZE;\n+    XOnlyPubKey p{uint256(std::vector<unsigned char>(control.begin() + 1, control.begin() + TAPROOT_CONTROL_BASE_SIZE))};\n+    XOnlyPubKey q{uint256(program)};\n+    uint256 k = (CHashWriter(HASHER_TAPLEAF) << uint8_t(control[0] & TAPROOT_LEAF_MASK) << script).GetSHA256();\n+    if (tapleaf_hash) *tapleaf_hash = k;\n+    for (int i = 0; i < path_len; ++i) {\n+        CHashWriter ss_branch = HASHER_TAPBRANCH;\n+        Span<const unsigned char> node(control.data() + TAPROOT_CONTROL_BASE_SIZE + TAPROOT_CONTROL_NODE_SIZE * i, TAPROOT_CONTROL_NODE_SIZE);\n+        if (std::lexicographical_compare(k.begin(), k.end(), node.begin(), node.end())) {\n+            ss_branch << k << node;\n+        } else {\n+            ss_branch << node << k;\n+        }\n+        k = ss_branch.GetSHA256();\n+    }\n+    k = (CHashWriter(HASHER_TAPTWEAK) << MakeSpan(p) << k).GetSHA256();\n+    return q.CheckPayToContract(p, k, control[0] & 1);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482615760",
      "id" : 482615760,
      "line" : 1830,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYxNTc2MA==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1830,
      "original_position" : 519,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 537,
      "pull_request_review_id" : 481335549,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482615760",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482623999"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482623999"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Why can't we outlaw witness-with-annex from our policy ?\r\n\r\nEDIT: This is part of it as 7548827. Maybe add a reference that's is outlawed in `IsWitnessStandard`. A side-question, why OP_SUCESSx and unknown public key types aren't rejected there too to gather all witness sanitization check in one place ?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-03T00:46:19Z",
      "diff_hunk" : "@@ -1540,22 +1838,64 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n             if (memcmp(hashScriptPubKey.begin(), program.data(), 32)) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);\n             }\n-            return ExecuteWitnessScript(stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, serror);\n+            return ExecuteWitnessScript(stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, execdata, serror);\n         } else if (program.size() == WITNESS_V0_KEYHASH_SIZE) {\n-            // Special case for pay-to-pubkeyhash; signature + pubkey in witness\n+            // BIP141 P2WPKH: 20-byte witness v0 program (which encodes Hash160(pubkey))\n             if (stack.size() != 2) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH); // 2 items in witness\n             }\n             scriptPubKey << OP_DUP << OP_HASH160 << program << OP_EQUALVERIFY << OP_CHECKSIG;\n-            return ExecuteWitnessScript(stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, serror);\n+            return ExecuteWitnessScript(stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, execdata, serror);\n         } else {\n             return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH);\n         }\n+    } else if (witversion == 1 && program.size() == WITNESS_V1_TAPROOT_SIZE && !is_p2sh) {\n+        // BIP341 Taproot: 32-byte non-P2SH witness v1 program (which encodes a P2C-tweaked pubkey)\n+        if (!(flags & SCRIPT_VERIFY_TAPROOT)) return set_success(serror);\n+        if (stack.size() == 0) return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);\n+        if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482623999",
      "id" : 482623999,
      "line" : 1867,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYyMzk5OQ==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1867,
      "original_position" : 557,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 584,
      "pull_request_review_id" : 481335549,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482623999",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482631236"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482631236"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Assert altstack empty ?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-03T00:59:32Z",
      "diff_hunk" : "@@ -1504,32 +1756,78 @@ bool GenericTransactionSignatureChecker<T>::CheckSequence(const CScriptNum& nSeq\n template class GenericTransactionSignatureChecker<CTransaction>;\n template class GenericTransactionSignatureChecker<CMutableTransaction>;\n \n-static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, const ScriptExecutionData& execdata, ScriptError* serror)\n {\n     std::vector<valtype> stack{stack_span.begin(), stack_span.end()};\n \n+    if (sigversion == SigVersion::TAPSCRIPT) {\n+        // OP_SUCCESSx processing overrides everything, including stack element size limits\n+        CScript::const_iterator pc = scriptPubKey.begin();\n+        while (pc < scriptPubKey.end()) {\n+            opcodetype opcode;\n+            if (!scriptPubKey.GetOp(pc, opcode)) {\n+                // Note how this condition would not be reached if an unknown OP_SUCCESSx was found\n+                return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n+            }\n+            // New opcodes will be listed here. May use a different sigversion to modify existing opcodes.\n+            if (IsOpSuccess(opcode)) {\n+                if (flags & SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS) {\n+                    return set_error(serror, SCRIPT_ERR_DISCOURAGE_OP_SUCCESS);\n+                }\n+                return set_success(serror);\n+            }\n+        }\n+\n+        // Tapscript enforces initial stack size limits (altstack is empty here)\n+        if (stack.size() > MAX_STACK_SIZE) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482631236",
      "id" : 482631236,
      "line" : 1793,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYzMTIzNg==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1793,
      "original_position" : 480,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 498,
      "pull_request_review_id" : 481335549,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482631236",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482644663"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482644663"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Seems like `tapscript/emptysigs/checksig` aka script `t12` should cover this case? Confirmed it somehow doesn't.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-03T01:49:34Z",
      "diff_hunk" : "@@ -1410,12 +1643,31 @@ bool GenericTransactionSignatureChecker<T>::CheckSig(const std::vector<unsigned\n \n     uint256 sighash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion, this->txdata);\n \n-    if (!VerifySignature(vchSig, pubkey, sighash))\n+    if (!VerifyECDSASignature(vchSig, pubkey, sighash))\n         return false;\n \n     return true;\n }\n \n+template <class T>\n+bool GenericTransactionSignatureChecker<T>::CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey_in, SigVersion sigversion, const ScriptExecutionData& execdata) const\n+{\n+    if (sig.empty()) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482644663",
      "id" : 482644663,
      "in_reply_to_id" : 482598143,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY0NDY2Mw==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1655,
      "original_position" : 433,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 481427997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482644663",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482990495"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482990495"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should we assert  exclusion of scriptless (?) script versions at a higher-level like `EvalScript` or `ExecuteWitnessScript` to catch witness parsing bug where such a script wouldn't call a sig operation ?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-03T13:47:08Z",
      "diff_hunk" : "@@ -363,15 +360,76 @@ static bool EvalChecksig(const valtype& vchSig, const valtype& vchPubKey, CScrip\n         //serror is set\n         return false;\n     }\n-    fSuccess = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion);\n+    fSuccess = checker.CheckECDSASignature(vchSig, vchPubKey, scriptCode, sigversion);\n \n     if (!fSuccess && (flags & SCRIPT_VERIFY_NULLFAIL) && vchSig.size())\n         return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);\n \n     return true;\n }\n \n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)\n+static bool EvalChecksigTapscript(const valtype& sig, const valtype& pubkey, ScriptExecutionData& execdata, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& success)\n+{\n+    assert(sigversion == SigVersion::TAPSCRIPT);\n+\n+    /*\n+     *  The following validation sequence is consensus critical. Please note how --\n+     *    upgradable public key versions precede other rules;\n+     *    the script execution fails when using empty signature with invalid public key;\n+     *    the script execution fails when using non-empty invalid signature.\n+     */\n+    success = !sig.empty();\n+    if (success) {\n+        // Implement the sigops/witnesssize ratio test.\n+        // Passing with an upgradable public key version is also counted.\n+        assert(execdata.m_validation_weight_left_init);\n+        execdata.m_validation_weight_left -= VALIDATION_WEIGHT_PER_SIGOP_PASSED;\n+        if (execdata.m_validation_weight_left < 0) {\n+            return set_error(serror, SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT);\n+        }\n+    }\n+    if (pubkey.size() == 0) {\n+        return set_error(serror, SCRIPT_ERR_PUBKEYTYPE);\n+    } else if (pubkey.size() == 32) {\n+        if (success && !checker.CheckSchnorrSignature(sig, pubkey, sigversion, execdata)) {\n+            return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);\n+        }\n+    } else {\n+        /*\n+         *  New public key version softforks should be defined before this `else` block.\n+         *  Generally, the new code should not do anything but failing the script execution. To avoid\n+         *  consensus bugs, it should not modify any existing values (including success).\n+         */\n+        if ((flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE) != 0) {\n+            return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE);\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+/** Helper for OP_CHECKSIG, OP_CHECKSIGVERIFY, and (in Tapscript) OP_CHECKSIGADD.\n+ *\n+ * A return value of false means the script fails entirely. When true is returned, the\n+ * fSuccess variable indicates whether the signature check itself succeeded.\n+ */\n+static bool EvalChecksig(const valtype& sig, const valtype& pubkey, CScript::const_iterator pbegincodehash, CScript::const_iterator pend, ScriptExecutionData& execdata, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& success)\n+{\n+    switch (sigversion) {\n+    case SigVersion::BASE:\n+    case SigVersion::WITNESS_V0:\n+        return EvalChecksigPreTapscript(sig, pubkey, pbegincodehash, pend, flags, checker, sigversion, serror, success);\n+    case SigVersion::TAPSCRIPT:\n+        return EvalChecksigTapscript(sig, pubkey, execdata, flags, checker, sigversion, serror, success);\n+    case SigVersion::TAPROOT:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r482990495",
      "id" : 482990495,
      "line" : 424,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk5MDQ5NQ==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 424,
      "original_position" : 84,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 84,
      "pull_request_review_id" : 481855746,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/482990495",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483027964"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483027964"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think this comment is ambiguous with regards to `EvalChecksigTapscript` and BIP342 requirement. Successful could be interpreted as :\r\n* if signature verification is successful\r\n* if signature is non-empty\r\n\r\nAFAICT, the second alternative is actually what is referred by `signature check`.  Maybe add `successful non-empty signature check`",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-03T14:35:48Z",
      "diff_hunk" : "@@ -114,41 +121,111 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 19),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 20),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    // BIP341 precomputed data.\n+    // These are single-SHA256, see https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-15.\n+    uint256 m_bip341_prevouts_hash;\n+    uint256 m_bip341_sequences_hash;\n+    uint256 m_bip341_outputs_hash;\n+    uint256 m_bip341_spent_amounts_hash;\n+    uint256 m_bip341_spent_scripts_hash;\n+    //! Whether the 5 fields above are initialized.\n+    bool m_bip341_ready = false;\n+\n+    // BIP143 precomputed data (double-SHA256).\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n-    bool m_ready = false;\n+    //! Whether the 3 fields above are initialized.\n+    bool m_bip143_ready = false;\n+\n+    std::vector<CTxOut> m_spent_outputs;\n+    //! Whether m_spent_outputs is initialized.\n+    bool m_spent_outputs_ready = false;\n \n     PrecomputedTransactionData() = default;\n \n     template <class T>\n-    void Init(const T& tx);\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and BIP16 P2SH-wrapped redeemscripts\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with 32-byte program, not BIP16 P2SH-wrapped, key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with 32-byte program, not BIP16 P2SH-wrapped, script path spending, leaf version 0xc0; see BIP 342\n+};\n+\n+struct ScriptExecutionData\n+{\n+    //! Whether m_tapleaf_hash is initialized.\n+    bool m_tapleaf_hash_init = false;\n+    //! The tapleaf hash.\n+    uint256 m_tapleaf_hash;\n+\n+    //! Whether m_codeseparator_pos is initialized.\n+    bool m_codeseparator_pos_init = false;\n+    //! Opcode position of the last executed OP_CODESEPARATOR (or 0xFFFFFFFF if none executed).\n+    uint32_t m_codeseparator_pos;\n+\n+    //! Whether m_annex_present and (when needed) m_annex_hash are initialized.\n+    bool m_annex_init = false;\n+    //! Whether an annex is present.\n+    bool m_annex_present;\n+    //! Hash of the annex data.\n+    uint256 m_annex_hash;\n+\n+    /** Whether m_validation_weight_left is initialized. */\n+    bool m_validation_weight_left_init = false;\n+    /** How much validation weight is left (decremented for every successful signature check). */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483027964",
      "id" : 483027964,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAyNzk2NA==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 201,
      "original_position" : 114,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 481855746,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483027964",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483047134"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483047134"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think melting a consensus check with a policy one in the same conditional is likely source to confusion for future reviewers. I'm quite sure that's already something done elsewhere but maybe we could do better by adding a `GetScriptVersionFlags(SigVersion)` called at the top of `EvalScript`. \r\n\r\nThis new function should set each consensus-compliant interpreter flags per-type of script evaluated thus avoiding setting flags for old scripts types if we would do this in `GetBlockScriptFlags` while easily overloading flag setting for future types.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-03T15:01:40Z",
      "diff_hunk" : "@@ -568,7 +632,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                         if (stack.size() < 1)\n                             return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);\n                         valtype& vch = stacktop(-1);\n-                        if (sigversion == SigVersion::WITNESS_V0 && (flags & SCRIPT_VERIFY_MINIMALIF)) {\n+                        if (sigversion == SigVersion::TAPSCRIPT || (sigversion == SigVersion::WITNESS_V0 && (flags & SCRIPT_VERIFY_MINIMALIF))) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483047134",
      "id" : 483047134,
      "line" : 640,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA0NzEzNA==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 640,
      "original_position" : 139,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 151,
      "pull_request_review_id" : 481855746,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483047134",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483058642"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483058642"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Is MINIMALDATA  consensus-mandatory for `OP_CHECKSIGADD` or only part of our relay-policy like for other `CScriptNum` operators ? The spec only mentions `All CScriptNum-related behaviours of `OP_ADD` are also applicable to `OP_CHECKSIGADD\", it's a bit unclear.\r\n\r\nIn either case flipping it to `true/false` doesn't give me back any test failure.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-03T15:17:55Z",
      "diff_hunk" : "@@ -1029,9 +1094,32 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                 }\n                 break;\n \n+                case OP_CHECKSIGADD:\n+                {\n+                    // OP_CHECKSIGADD is only available in Tapscript\n+                    if (sigversion == SigVersion::BASE || sigversion == SigVersion::WITNESS_V0) return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n+\n+                    // (sig num pubkey -- num)\n+                    if (stack.size() < 3) return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n+\n+                    const valtype& sig = stacktop(-3);\n+                    const CScriptNum num(stacktop(-2), fRequireMinimal);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483058642",
      "id" : 483058642,
      "line" : 1111,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA1ODY0Mg==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1111,
      "original_position" : 173,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 185,
      "pull_request_review_id" : 481855746,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483058642",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483092066"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483092066"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think BIP341 footnote mentions that TAPSCRIPT's `ext_flag=1` but I don't find where it mandates that TAPROOT's one is actually `ext_flag=0`",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-03T16:05:10Z",
      "diff_hunk" : "@@ -1291,35 +1379,174 @@ uint256 GetOutputsSHA256(const T& txTo)\n     return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = SHA256Uint256(GetPrevoutsSHA256(txTo));\n-        hashSequence = SHA256Uint256(GetSequencesSHA256(txTo));\n-        hashOutputs = SHA256Uint256(GetOutputsSHA256(txTo));\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n     }\n \n-    m_ready = true;\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143 = false;\n+    bool uses_bip341 = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every native witness v1 spend as a Taproot spend. This only works if spent_outputs was\n+                // provided as well, but if it wasn't, actual validation will fail anyway.\n+                uses_bip341 = true;\n+            } else {\n+                // Treat every spend that's not known to native witness v1 as a Witness v0 spend. This branch may\n+                // also be taken for unknown witness versions, but it is harmless, and being precise would require\n+                // P2SH evaluation to find the redeemScript.\n+                uses_bip143 = true;\n+            }\n+        }\n+    }\n+\n+    if (uses_bip143 || uses_bip341) {\n+        // Computations shared between both sighash schemes.\n+        m_bip341_prevouts_hash = GetPrevoutsSHA256(txTo);\n+        m_bip341_sequences_hash = GetSequencesSHA256(txTo);\n+        m_bip341_outputs_hash = GetOutputsSHA256(txTo);\n+    }\n+    if (uses_bip143) {\n+        hashPrevouts = SHA256Uint256(m_bip341_prevouts_hash);\n+        hashSequence = SHA256Uint256(m_bip341_sequences_hash);\n+        hashOutputs = SHA256Uint256(m_bip341_outputs_hash);\n+        m_bip143_ready = true;\n+    }\n+    if (uses_bip341) {\n+        m_bip341_spent_amounts_hash = GetSpentAmountsSHA256(m_spent_outputs);\n+        m_bip341_spent_scripts_hash = GetSpentScriptsSHA256(m_spent_outputs);\n+        m_bip341_ready = true;\n+    }\n }\n \n template <class T>\n PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n {\n-    Init(txTo);\n+    Init(txTo, {});\n }\n \n // explicit instantiation\n-template void PrecomputedTransactionData::Init(const CTransaction& txTo);\n-template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo);\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+static const CHashWriter HASHER_TAPLEAF = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HASHER_TAPBRANCH = TaggedHash(\"TapBranch\");\n+static const CHashWriter HASHER_TAPTWEAK = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData* cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483092066",
      "id" : 483092066,
      "line" : 1482,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA5MjA2Ng==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1482,
      "original_position" : 312,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 324,
      "pull_request_review_id" : 481855746,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483092066",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483102106"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483102106"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't get `feature_taproot.py` failure for this :\r\n\r\n```\r\ndiff --git a/src/script/interpreter.cpp b/src/script/interpreter.cpp\r\nindex 053df47a2..eb3847250 100644\r\n--- a/src/script/interpreter.cpp\r\n+++ b/src/script/interpreter.cpp\r\n@@ -1528,7 +1528,7 @@ bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata\r\n\r\n     // Data about the output(s)\r\n     if (output_type == SIGHASH_SINGLE) {\r\n-        if (in_pos >= tx_to.vout.size()) return false;\r\n+        if (in_pos >= tx_to.vout.size()) return true;\r\n         CHashWriter sha_single_output(SER_GETHASH, 0);\r\n         sha_single_output << tx_to.vout[in_pos];\r\n         ss << sha_single_output.GetSHA256();\r\n```\r\n\r\nAlso I think this is check can be moved above at `hash_type` validation as every predicate is already known and we would save on hashing by failing faster ?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-03T16:20:29Z",
      "diff_hunk" : "@@ -1291,35 +1379,174 @@ uint256 GetOutputsSHA256(const T& txTo)\n     return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = SHA256Uint256(GetPrevoutsSHA256(txTo));\n-        hashSequence = SHA256Uint256(GetSequencesSHA256(txTo));\n-        hashOutputs = SHA256Uint256(GetOutputsSHA256(txTo));\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n     }\n \n-    m_ready = true;\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143 = false;\n+    bool uses_bip341 = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every native witness v1 spend as a Taproot spend. This only works if spent_outputs was\n+                // provided as well, but if it wasn't, actual validation will fail anyway.\n+                uses_bip341 = true;\n+            } else {\n+                // Treat every spend that's not known to native witness v1 as a Witness v0 spend. This branch may\n+                // also be taken for unknown witness versions, but it is harmless, and being precise would require\n+                // P2SH evaluation to find the redeemScript.\n+                uses_bip143 = true;\n+            }\n+        }\n+    }\n+\n+    if (uses_bip143 || uses_bip341) {\n+        // Computations shared between both sighash schemes.\n+        m_bip341_prevouts_hash = GetPrevoutsSHA256(txTo);\n+        m_bip341_sequences_hash = GetSequencesSHA256(txTo);\n+        m_bip341_outputs_hash = GetOutputsSHA256(txTo);\n+    }\n+    if (uses_bip143) {\n+        hashPrevouts = SHA256Uint256(m_bip341_prevouts_hash);\n+        hashSequence = SHA256Uint256(m_bip341_sequences_hash);\n+        hashOutputs = SHA256Uint256(m_bip341_outputs_hash);\n+        m_bip143_ready = true;\n+    }\n+    if (uses_bip341) {\n+        m_bip341_spent_amounts_hash = GetSpentAmountsSHA256(m_spent_outputs);\n+        m_bip341_spent_scripts_hash = GetSpentScriptsSHA256(m_spent_outputs);\n+        m_bip341_ready = true;\n+    }\n }\n \n template <class T>\n PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n {\n-    Init(txTo);\n+    Init(txTo, {});\n }\n \n // explicit instantiation\n-template void PrecomputedTransactionData::Init(const CTransaction& txTo);\n-template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo);\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+static const CHashWriter HASHER_TAPLEAF = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HASHER_TAPBRANCH = TaggedHash(\"TapBranch\");\n+static const CHashWriter HASHER_TAPTWEAK = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData* cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    case SigVersion::TAPSCRIPT:\n+        ext_flag = 1;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache != nullptr && cache->m_bip341_ready && cache->m_spent_outputs_ready);\n+\n+    CHashWriter ss = HASHER_TAPSIGHASH;\n+\n+    // Epoch\n+    static constexpr uint8_t EPOCH = 0;\n+    ss << EPOCH;\n+\n+    // Hash type\n+    const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n+    const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;\n+    if (!(hash_type <= 0x03 || (hash_type >= 0x81 && hash_type <= 0x83))) return false;\n+    ss << hash_type;\n+\n+    // Transaction level data\n+    ss << tx_to.nVersion;\n+    ss << tx_to.nLockTime;\n+    if (input_type != SIGHASH_ANYONECANPAY) {\n+        ss << cache->m_bip341_prevouts_hash;\n+        ss << cache->m_bip341_spent_amounts_hash;\n+        ss << cache->m_bip341_spent_scripts_hash;\n+        ss << cache->m_bip341_sequences_hash;\n+    }\n+    if (output_type == SIGHASH_ALL) {\n+        ss << cache->m_bip341_outputs_hash;\n+    }\n+\n+    // Data about the input/prevout being spent\n+    assert(execdata.m_annex_init);\n+    const bool have_annex = execdata.m_annex_present;\n+    const uint8_t spend_type = (ext_flag << 1) + (have_annex ? 1 : 0); // The low bit indicates whether an annex is present.\n+    ss << spend_type;\n+    if (input_type == SIGHASH_ANYONECANPAY) {\n+        ss << tx_to.vin[in_pos].prevout;\n+        ss << cache->m_spent_outputs[in_pos];\n+        ss << tx_to.vin[in_pos].nSequence;\n+    } else {\n+        ss << in_pos;\n+    }\n+    if (have_annex) {\n+        ss << execdata.m_annex_hash;\n+    }\n+\n+    // Data about the output(s)\n+    if (output_type == SIGHASH_SINGLE) {\n+        if (in_pos >= tx_to.vout.size()) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483102106",
      "id" : 483102106,
      "line" : 1536,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEwMjEwNg==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1536,
      "original_position" : 366,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 378,
      "pull_request_review_id" : 481855746,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483102106",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483107386"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483107386"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Does this key version is actually the one of defined 32-byte public key or it is an independent versioning ? \r\n\r\nIf it is the first option I think we should add a `m_key_version` to `ScriptExecutionData` and ensure we set it at key type detection in `ExecuteWitnessScript` to avoid hashing and public key validation going out of sync ?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-03T16:28:56Z",
      "diff_hunk" : "@@ -1291,35 +1379,174 @@ uint256 GetOutputsSHA256(const T& txTo)\n     return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = SHA256Uint256(GetPrevoutsSHA256(txTo));\n-        hashSequence = SHA256Uint256(GetSequencesSHA256(txTo));\n-        hashOutputs = SHA256Uint256(GetOutputsSHA256(txTo));\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n     }\n \n-    m_ready = true;\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143 = false;\n+    bool uses_bip341 = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every native witness v1 spend as a Taproot spend. This only works if spent_outputs was\n+                // provided as well, but if it wasn't, actual validation will fail anyway.\n+                uses_bip341 = true;\n+            } else {\n+                // Treat every spend that's not known to native witness v1 as a Witness v0 spend. This branch may\n+                // also be taken for unknown witness versions, but it is harmless, and being precise would require\n+                // P2SH evaluation to find the redeemScript.\n+                uses_bip143 = true;\n+            }\n+        }\n+    }\n+\n+    if (uses_bip143 || uses_bip341) {\n+        // Computations shared between both sighash schemes.\n+        m_bip341_prevouts_hash = GetPrevoutsSHA256(txTo);\n+        m_bip341_sequences_hash = GetSequencesSHA256(txTo);\n+        m_bip341_outputs_hash = GetOutputsSHA256(txTo);\n+    }\n+    if (uses_bip143) {\n+        hashPrevouts = SHA256Uint256(m_bip341_prevouts_hash);\n+        hashSequence = SHA256Uint256(m_bip341_sequences_hash);\n+        hashOutputs = SHA256Uint256(m_bip341_outputs_hash);\n+        m_bip143_ready = true;\n+    }\n+    if (uses_bip341) {\n+        m_bip341_spent_amounts_hash = GetSpentAmountsSHA256(m_spent_outputs);\n+        m_bip341_spent_scripts_hash = GetSpentScriptsSHA256(m_spent_outputs);\n+        m_bip341_ready = true;\n+    }\n }\n \n template <class T>\n PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n {\n-    Init(txTo);\n+    Init(txTo, {});\n }\n \n // explicit instantiation\n-template void PrecomputedTransactionData::Init(const CTransaction& txTo);\n-template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo);\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+static const CHashWriter HASHER_TAPLEAF = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HASHER_TAPBRANCH = TaggedHash(\"TapBranch\");\n+static const CHashWriter HASHER_TAPTWEAK = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData* cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    case SigVersion::TAPSCRIPT:\n+        ext_flag = 1;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache != nullptr && cache->m_bip341_ready && cache->m_spent_outputs_ready);\n+\n+    CHashWriter ss = HASHER_TAPSIGHASH;\n+\n+    // Epoch\n+    static constexpr uint8_t EPOCH = 0;\n+    ss << EPOCH;\n+\n+    // Hash type\n+    const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n+    const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;\n+    if (!(hash_type <= 0x03 || (hash_type >= 0x81 && hash_type <= 0x83))) return false;\n+    ss << hash_type;\n+\n+    // Transaction level data\n+    ss << tx_to.nVersion;\n+    ss << tx_to.nLockTime;\n+    if (input_type != SIGHASH_ANYONECANPAY) {\n+        ss << cache->m_bip341_prevouts_hash;\n+        ss << cache->m_bip341_spent_amounts_hash;\n+        ss << cache->m_bip341_spent_scripts_hash;\n+        ss << cache->m_bip341_sequences_hash;\n+    }\n+    if (output_type == SIGHASH_ALL) {\n+        ss << cache->m_bip341_outputs_hash;\n+    }\n+\n+    // Data about the input/prevout being spent\n+    assert(execdata.m_annex_init);\n+    const bool have_annex = execdata.m_annex_present;\n+    const uint8_t spend_type = (ext_flag << 1) + (have_annex ? 1 : 0); // The low bit indicates whether an annex is present.\n+    ss << spend_type;\n+    if (input_type == SIGHASH_ANYONECANPAY) {\n+        ss << tx_to.vin[in_pos].prevout;\n+        ss << cache->m_spent_outputs[in_pos];\n+        ss << tx_to.vin[in_pos].nSequence;\n+    } else {\n+        ss << in_pos;\n+    }\n+    if (have_annex) {\n+        ss << execdata.m_annex_hash;\n+    }\n+\n+    // Data about the output(s)\n+    if (output_type == SIGHASH_SINGLE) {\n+        if (in_pos >= tx_to.vout.size()) return false;\n+        CHashWriter sha_single_output(SER_GETHASH, 0);\n+        sha_single_output << tx_to.vout[in_pos];\n+        ss << sha_single_output.GetSHA256();\n+    }\n+\n+    // Additional data for BIP 342 signatures\n+    if (sigversion == SigVersion::TAPSCRIPT) {\n+        assert(execdata.m_tapleaf_hash_init);\n+        ss << execdata.m_tapleaf_hash;\n+        ss << uint8_t(0); // key_version",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483107386",
      "id" : 483107386,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEwNzM4Ng==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1541,
      "original_position" : 376,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 481855746,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483107386",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483122518"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483122518"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't get `feature_taproot.py` failure for :\r\n\r\n```\r\ndiff --git a/src/pubkey.cpp b/src/pubkey.cpp\r\nindex 111f9c10e..0163f61a2 100644\r\n--- a/src/pubkey.cpp\r\n+++ b/src/pubkey.cpp\r\n@@ -174,7 +174,7 @@ XOnlyPubKey::XOnlyPubKey(Span<const unsigned char> in)\r\n }\r\n \r\n bool XOnlyPubKey::VerifySchnorr(const uint256& msg, Span<const unsigned char> sigbytes) const {\r\n-    if (sigbytes.size() != 64) return false;\r\n+    if (sigbytes.size() != 64) return true;\r\n     if (msg.size() != 32) return false;\r\n     secp256k1_xonly_pubkey pubkey;\r\n     if (!secp256k1_xonly_pubkey_parse(secp256k1_context_verify, &\r\n```\r\n\r\nAnd same for next check on message size.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-03T16:53:51Z",
      "diff_hunk" : "@@ -166,6 +167,27 @@ static int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1\n     return 1;\n }\n \n+XOnlyPubKey::XOnlyPubKey(Span<const unsigned char> in)\n+{\n+    assert(in.size() == 32);\n+    std::copy(in.begin(), in.end(), m_keydata.begin());\n+}\n+\n+bool XOnlyPubKey::VerifySchnorr(const uint256& msg, Span<const unsigned char> sigbytes) const {\n+    if (sigbytes.size() != 64) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483122518",
      "id" : 483122518,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEyMjUxOA==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 177,
      "original_position" : 19,
      "original_start_line" : null,
      "path" : "src/pubkey.cpp",
      "position" : null,
      "pull_request_review_id" : 481855746,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483122518",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483125017"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483125017"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Maybe precise that's invalid with regards to consensus. Or at least we enforce this as a policy rule without any tightening with regards to consensus rule.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-03T16:57:58Z",
      "diff_hunk" : "@@ -237,6 +239,36 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check policy limits for Taproot spends:\n+        // - MAX_STANDARD_TAPSCRIPT_STACK_ITEM_SIZE limit for stack item size\n+        // - No annexes\n+        if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE && !p2sh) {\n+            // Taproot spend (non-P2SH-wrapped, version 1, witness program size 32; see BIP 341)\n+            auto stack = MakeSpan(tx.vin[i].scriptWitness.stack);\n+            if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {\n+                // Annexes are nonstandard as long as no semantics are defined for them.\n+                return false;\n+            }\n+            if (stack.size() >= 2) {\n+                // Script path spend (2 or more stack elements are removing optional annex)\n+                const auto& control_block = SpanPopBack(stack);\n+                SpanPopBack(stack); // Ignore script\n+                if (control_block.empty()) return false; // Empty control block is invalid\n+                if ((control_block[0] & TAPROOT_LEAF_MASK) == TAPROOT_LEAF_TAPSCRIPT) {\n+                    // Leaf version 0xc0 (aka Tapscript, see BIP 342)\n+                    for (const auto& item : stack) {\n+                        if (item.size() > MAX_STANDARD_TAPSCRIPT_STACK_ITEM_SIZE) return false;\n+                    }\n+                }\n+            } else if (stack.size() == 1) {\n+                // Key path spend (1 stack element after removing optional annex)\n+                // (no policy rules apply)\n+            } else {\n+                // 0 stack elements remain after removing optional annex; this is invalid",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483125017",
      "id" : 483125017,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEyNTAxNw==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 268,
      "original_position" : 55,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : null,
      "pull_request_review_id" : 481855746,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483125017",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483322220"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483322220"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I kept it out so that invalid control size can be its own error code. It's sanity checked before this function is invoked.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-04T00:31:54Z",
      "diff_hunk" : "@@ -1504,32 +1756,78 @@ bool GenericTransactionSignatureChecker<T>::CheckSequence(const CScriptNum& nSeq\n template class GenericTransactionSignatureChecker<CTransaction>;\n template class GenericTransactionSignatureChecker<CMutableTransaction>;\n \n-static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, const ScriptExecutionData& execdata, ScriptError* serror)\n {\n     std::vector<valtype> stack{stack_span.begin(), stack_span.end()};\n \n+    if (sigversion == SigVersion::TAPSCRIPT) {\n+        // OP_SUCCESSx processing overrides everything, including stack element size limits\n+        CScript::const_iterator pc = scriptPubKey.begin();\n+        while (pc < scriptPubKey.end()) {\n+            opcodetype opcode;\n+            if (!scriptPubKey.GetOp(pc, opcode)) {\n+                // Note how this condition would not be reached if an unknown OP_SUCCESSx was found\n+                return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n+            }\n+            // New opcodes will be listed here. May use a different sigversion to modify existing opcodes.\n+            if (IsOpSuccess(opcode)) {\n+                if (flags & SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS) {\n+                    return set_error(serror, SCRIPT_ERR_DISCOURAGE_OP_SUCCESS);\n+                }\n+                return set_success(serror);\n+            }\n+        }\n+\n+        // Tapscript enforces initial stack size limits (altstack is empty here)\n+        if (stack.size() > MAX_STACK_SIZE) {\n+            return set_error(serror, SCRIPT_ERR_STACK_SIZE);\n+        }\n+    }\n+\n     // Disallow stack item size > MAX_SCRIPT_ELEMENT_SIZE in witness stack\n     for (const valtype& elem : stack) {\n         if (elem.size() > MAX_SCRIPT_ELEMENT_SIZE) return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n     }\n \n     // Run the script interpreter.\n-    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, serror)) return false;\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, serror, execdata)) return false;\n \n     // Scripts inside witness implicitly require cleanstack behaviour\n     if (stack.size() != 1) return set_error(serror, SCRIPT_ERR_CLEANSTACK);\n     if (!CastToBool(stack.back())) return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n     return true;\n }\n \n-static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, const std::vector<unsigned char>& program, const CScript& script, uint256* tapleaf_hash)\n+{\n+    int path_len = (control.size() - TAPROOT_CONTROL_BASE_SIZE) / TAPROOT_CONTROL_NODE_SIZE;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483322220",
      "id" : 483322220,
      "in_reply_to_id" : 482202942,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMyMjIyMA==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1803,
      "original_position" : 503,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 482284758,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483322220",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483322759"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483322759"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This is an implementation of BIP340/341/342, not BIP114. BIP341 specifies a max depth of 128 nodes, and gives a rationale why.\r\n\r\nBIP114 is a completely independent proposal, which BIP341 took some inspiration from, but it isn't compatible with in any way. You could suggest to BIP114's author that it may be retracted, but in theory, they're free to pursue activation of that as an alternative to, or in addition to, BIP341.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-04T00:34:13Z",
      "diff_hunk" : "@@ -114,41 +121,111 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 19),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 20),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    // BIP341 precomputed data.\n+    // These are single-SHA256, see https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-15.\n+    uint256 m_bip341_prevouts_hash;\n+    uint256 m_bip341_sequences_hash;\n+    uint256 m_bip341_outputs_hash;\n+    uint256 m_bip341_spent_amounts_hash;\n+    uint256 m_bip341_spent_scripts_hash;\n+    //! Whether the 5 fields above are initialized.\n+    bool m_bip341_ready = false;\n+\n+    // BIP143 precomputed data (double-SHA256).\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n-    bool m_ready = false;\n+    //! Whether the 3 fields above are initialized.\n+    bool m_bip143_ready = false;\n+\n+    std::vector<CTxOut> m_spent_outputs;\n+    //! Whether m_spent_outputs is initialized.\n+    bool m_spent_outputs_ready = false;\n \n     PrecomputedTransactionData() = default;\n \n     template <class T>\n-    void Init(const T& tx);\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and BIP16 P2SH-wrapped redeemscripts\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with 32-byte program, not BIP16 P2SH-wrapped, key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with 32-byte program, not BIP16 P2SH-wrapped, script path spending, leaf version 0xc0; see BIP 342\n+};\n+\n+struct ScriptExecutionData\n+{\n+    //! Whether m_tapleaf_hash is initialized.\n+    bool m_tapleaf_hash_init = false;\n+    //! The tapleaf hash.\n+    uint256 m_tapleaf_hash;\n+\n+    //! Whether m_codeseparator_pos is initialized.\n+    bool m_codeseparator_pos_init = false;\n+    //! Opcode position of the last executed OP_CODESEPARATOR (or 0xFFFFFFFF if none executed).\n+    uint32_t m_codeseparator_pos;\n+\n+    //! Whether m_annex_present and (when needed) m_annex_hash are initialized.\n+    bool m_annex_init = false;\n+    //! Whether an annex is present.\n+    bool m_annex_present;\n+    //! Hash of the annex data.\n+    uint256 m_annex_hash;\n+\n+    /** Whether m_validation_weight_left is initialized. */\n+    bool m_validation_weight_left_init = false;\n+    /** How much validation weight is left (decremented for every successful signature check). */\n+    int64_t m_validation_weight_left;\n };\n \n /** Signature hash sizes */\n static constexpr size_t WITNESS_V0_SCRIPTHASH_SIZE = 32;\n static constexpr size_t WITNESS_V0_KEYHASH_SIZE = 20;\n+static constexpr size_t WITNESS_V1_TAPROOT_SIZE = 32;\n+\n+static constexpr uint8_t TAPROOT_LEAF_MASK = 0xfe;\n+static constexpr uint8_t TAPROOT_LEAF_TAPSCRIPT = 0xc0;\n+static constexpr size_t TAPROOT_CONTROL_BASE_SIZE = 33;\n+static constexpr size_t TAPROOT_CONTROL_NODE_SIZE = 32;\n+static constexpr size_t TAPROOT_CONTROL_MAX_NODE_COUNT = 128;\n+static constexpr size_t TAPROOT_CONTROL_MAX_SIZE = TAPROOT_CONTROL_BASE_SIZE + TAPROOT_CONTROL_NODE_SIZE * TAPROOT_CONTROL_MAX_NODE_COUNT;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483322759",
      "id" : 483322759,
      "in_reply_to_id" : 482259993,
      "line" : 215,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMyMjc1OQ==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 215,
      "original_position" : 128,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : 128,
      "pull_request_review_id" : 482285362,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483322759",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483323690"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483323690"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think there is a bit of a misconception here: this doesn't, and doesn't intended to, implement mainchain activation. That's still up for discussion, and BIP341 states that activation is TBD.\r\n\r\nBIP9 is chosen here for regtest activation as it's easiest in the current codebase, so that the consensus changes can be tested. Mainchain activation will probably follow in a separate PR, possibly in a different version (the consensus changes usually go in a major release, with activation in a later minor release once there is community consensus on that).",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-04T00:37:53Z",
      "diff_hunk" : "@@ -146,7 +146,19 @@ def _test_getblockchaininfo(self):\n                         'possible': True,\n                     },\n                 },\n-                'active': False}\n+                'active': False\n+            },\n+            'taproot': {\n+                'type': 'bip9',",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483323690",
      "id" : 483323690,
      "in_reply_to_id" : 482378845,
      "line" : 152,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMyMzY5MA==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 152,
      "original_position" : 8,
      "original_start_line" : null,
      "path" : "test/functional/rpc_blockchain.py",
      "position" : 8,
      "pull_request_review_id" : 482286338,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483323690",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483330051"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483330051"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Given that this is covered by a hash, this is sort of implicitly tested. The functional tests reimplement the (hopefully correctly, but please review) serialization/leaf hashing scheme, and there are tests that if the wrong leaf is used, spending fails.\r\n\r\nThe fact that there is a hash around this whole computation means that it's either right or wrong, and there is little avenue for testing small tweaks to the code - any change will break the whole thing immediately.\r\n\r\nI'm happy to try adding a test that explicitly tests spending with an incorrectly hashed leaf, but I don't think it adds much.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-04T01:03:55Z",
      "diff_hunk" : "@@ -1504,32 +1756,78 @@ bool GenericTransactionSignatureChecker<T>::CheckSequence(const CScriptNum& nSeq\n template class GenericTransactionSignatureChecker<CTransaction>;\n template class GenericTransactionSignatureChecker<CMutableTransaction>;\n \n-static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, const ScriptExecutionData& execdata, ScriptError* serror)\n {\n     std::vector<valtype> stack{stack_span.begin(), stack_span.end()};\n \n+    if (sigversion == SigVersion::TAPSCRIPT) {\n+        // OP_SUCCESSx processing overrides everything, including stack element size limits\n+        CScript::const_iterator pc = scriptPubKey.begin();\n+        while (pc < scriptPubKey.end()) {\n+            opcodetype opcode;\n+            if (!scriptPubKey.GetOp(pc, opcode)) {\n+                // Note how this condition would not be reached if an unknown OP_SUCCESSx was found\n+                return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n+            }\n+            // New opcodes will be listed here. May use a different sigversion to modify existing opcodes.\n+            if (IsOpSuccess(opcode)) {\n+                if (flags & SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS) {\n+                    return set_error(serror, SCRIPT_ERR_DISCOURAGE_OP_SUCCESS);\n+                }\n+                return set_success(serror);\n+            }\n+        }\n+\n+        // Tapscript enforces initial stack size limits (altstack is empty here)\n+        if (stack.size() > MAX_STACK_SIZE) {\n+            return set_error(serror, SCRIPT_ERR_STACK_SIZE);\n+        }\n+    }\n+\n     // Disallow stack item size > MAX_SCRIPT_ELEMENT_SIZE in witness stack\n     for (const valtype& elem : stack) {\n         if (elem.size() > MAX_SCRIPT_ELEMENT_SIZE) return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n     }\n \n     // Run the script interpreter.\n-    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, serror)) return false;\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, serror, execdata)) return false;\n \n     // Scripts inside witness implicitly require cleanstack behaviour\n     if (stack.size() != 1) return set_error(serror, SCRIPT_ERR_CLEANSTACK);\n     if (!CastToBool(stack.back())) return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n     return true;\n }\n \n-static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, const std::vector<unsigned char>& program, const CScript& script, uint256* tapleaf_hash)\n+{\n+    int path_len = (control.size() - TAPROOT_CONTROL_BASE_SIZE) / TAPROOT_CONTROL_NODE_SIZE;\n+    XOnlyPubKey p{uint256(std::vector<unsigned char>(control.begin() + 1, control.begin() + TAPROOT_CONTROL_BASE_SIZE))};\n+    XOnlyPubKey q{uint256(program)};\n+    uint256 k = (CHashWriter(HASHER_TAPLEAF) << uint8_t(control[0] & TAPROOT_LEAF_MASK) << script).GetSHA256();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483330051",
      "id" : 483330051,
      "in_reply_to_id" : 482608452,
      "line" : 1817,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMzMDA1MQ==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1817,
      "original_position" : 506,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 524,
      "pull_request_review_id" : 482293339,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483330051",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483330260"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483330260"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`spendpath/negflag` should explicitly test this already.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-04T01:04:44Z",
      "diff_hunk" : "@@ -1504,32 +1756,78 @@ bool GenericTransactionSignatureChecker<T>::CheckSequence(const CScriptNum& nSeq\n template class GenericTransactionSignatureChecker<CTransaction>;\n template class GenericTransactionSignatureChecker<CMutableTransaction>;\n \n-static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, const ScriptExecutionData& execdata, ScriptError* serror)\n {\n     std::vector<valtype> stack{stack_span.begin(), stack_span.end()};\n \n+    if (sigversion == SigVersion::TAPSCRIPT) {\n+        // OP_SUCCESSx processing overrides everything, including stack element size limits\n+        CScript::const_iterator pc = scriptPubKey.begin();\n+        while (pc < scriptPubKey.end()) {\n+            opcodetype opcode;\n+            if (!scriptPubKey.GetOp(pc, opcode)) {\n+                // Note how this condition would not be reached if an unknown OP_SUCCESSx was found\n+                return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n+            }\n+            // New opcodes will be listed here. May use a different sigversion to modify existing opcodes.\n+            if (IsOpSuccess(opcode)) {\n+                if (flags & SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS) {\n+                    return set_error(serror, SCRIPT_ERR_DISCOURAGE_OP_SUCCESS);\n+                }\n+                return set_success(serror);\n+            }\n+        }\n+\n+        // Tapscript enforces initial stack size limits (altstack is empty here)\n+        if (stack.size() > MAX_STACK_SIZE) {\n+            return set_error(serror, SCRIPT_ERR_STACK_SIZE);\n+        }\n+    }\n+\n     // Disallow stack item size > MAX_SCRIPT_ELEMENT_SIZE in witness stack\n     for (const valtype& elem : stack) {\n         if (elem.size() > MAX_SCRIPT_ELEMENT_SIZE) return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n     }\n \n     // Run the script interpreter.\n-    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, serror)) return false;\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, serror, execdata)) return false;\n \n     // Scripts inside witness implicitly require cleanstack behaviour\n     if (stack.size() != 1) return set_error(serror, SCRIPT_ERR_CLEANSTACK);\n     if (!CastToBool(stack.back())) return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n     return true;\n }\n \n-static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, const std::vector<unsigned char>& program, const CScript& script, uint256* tapleaf_hash)\n+{\n+    int path_len = (control.size() - TAPROOT_CONTROL_BASE_SIZE) / TAPROOT_CONTROL_NODE_SIZE;\n+    XOnlyPubKey p{uint256(std::vector<unsigned char>(control.begin() + 1, control.begin() + TAPROOT_CONTROL_BASE_SIZE))};\n+    XOnlyPubKey q{uint256(program)};\n+    uint256 k = (CHashWriter(HASHER_TAPLEAF) << uint8_t(control[0] & TAPROOT_LEAF_MASK) << script).GetSHA256();\n+    if (tapleaf_hash) *tapleaf_hash = k;\n+    for (int i = 0; i < path_len; ++i) {\n+        CHashWriter ss_branch = HASHER_TAPBRANCH;\n+        Span<const unsigned char> node(control.data() + TAPROOT_CONTROL_BASE_SIZE + TAPROOT_CONTROL_NODE_SIZE * i, TAPROOT_CONTROL_NODE_SIZE);\n+        if (std::lexicographical_compare(k.begin(), k.end(), node.begin(), node.end())) {\n+            ss_branch << k << node;\n+        } else {\n+            ss_branch << node << k;\n+        }\n+        k = ss_branch.GetSHA256();\n+    }\n+    k = (CHashWriter(HASHER_TAPTWEAK) << MakeSpan(p) << k).GetSHA256();\n+    return q.CheckPayToContract(p, k, control[0] & 1);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483330260",
      "id" : 483330260,
      "in_reply_to_id" : 482615760,
      "line" : 1830,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMzMDI2MA==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1830,
      "original_position" : 519,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 537,
      "pull_request_review_id" : 482293558,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483330260",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483335562"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483335562"
         }
      },
      "author_association" : "MEMBER",
      "body" : "There was some earlier discussion about this (github's webinterface is starting to suffer from the obesity of the discussion here, so I can't find the link).\r\n\r\nI'm not sure what the best strategy is here:\r\n* Keeping things solely in the interpreter avoids duplicate work/complexity of detecting what type of spending is used, but means extra script validation flags.\r\n* Putting things in `IsWitnessStandard` may be more efficient, as it runs before any script validation is executed (and can be bypassed on testnet, which may or may not be desirable).\r\n\r\nI'm currrently following a \"things that don't need significant duplication of work go in `IsWitnessStandard`, the rest is done using script validation flags\" rule, but I admit it's fairly arbitrary.\r\n\r\nGoing to add a comment here to note that annexes are nonstandard through other code.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-04T01:26:27Z",
      "diff_hunk" : "@@ -1540,22 +1838,64 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n             if (memcmp(hashScriptPubKey.begin(), program.data(), 32)) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);\n             }\n-            return ExecuteWitnessScript(stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, serror);\n+            return ExecuteWitnessScript(stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, execdata, serror);\n         } else if (program.size() == WITNESS_V0_KEYHASH_SIZE) {\n-            // Special case for pay-to-pubkeyhash; signature + pubkey in witness\n+            // BIP141 P2WPKH: 20-byte witness v0 program (which encodes Hash160(pubkey))\n             if (stack.size() != 2) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH); // 2 items in witness\n             }\n             scriptPubKey << OP_DUP << OP_HASH160 << program << OP_EQUALVERIFY << OP_CHECKSIG;\n-            return ExecuteWitnessScript(stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, serror);\n+            return ExecuteWitnessScript(stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, execdata, serror);\n         } else {\n             return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH);\n         }\n+    } else if (witversion == 1 && program.size() == WITNESS_V1_TAPROOT_SIZE && !is_p2sh) {\n+        // BIP341 Taproot: 32-byte non-P2SH witness v1 program (which encodes a P2C-tweaked pubkey)\n+        if (!(flags & SCRIPT_VERIFY_TAPROOT)) return set_success(serror);\n+        if (stack.size() == 0) return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);\n+        if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483335562",
      "id" : 483335562,
      "in_reply_to_id" : 482623999,
      "line" : 1867,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMzNTU2Mg==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1867,
      "original_position" : 557,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 584,
      "pull_request_review_id" : 482299398,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483335562",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483337198"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483337198"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The variable to hold the altstack doesn't even exist at this point (it's local to `EvalScript`, which is invoked a bit further in this function).",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-04T01:33:11Z",
      "diff_hunk" : "@@ -1504,32 +1756,78 @@ bool GenericTransactionSignatureChecker<T>::CheckSequence(const CScriptNum& nSeq\n template class GenericTransactionSignatureChecker<CTransaction>;\n template class GenericTransactionSignatureChecker<CMutableTransaction>;\n \n-static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, const ScriptExecutionData& execdata, ScriptError* serror)\n {\n     std::vector<valtype> stack{stack_span.begin(), stack_span.end()};\n \n+    if (sigversion == SigVersion::TAPSCRIPT) {\n+        // OP_SUCCESSx processing overrides everything, including stack element size limits\n+        CScript::const_iterator pc = scriptPubKey.begin();\n+        while (pc < scriptPubKey.end()) {\n+            opcodetype opcode;\n+            if (!scriptPubKey.GetOp(pc, opcode)) {\n+                // Note how this condition would not be reached if an unknown OP_SUCCESSx was found\n+                return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n+            }\n+            // New opcodes will be listed here. May use a different sigversion to modify existing opcodes.\n+            if (IsOpSuccess(opcode)) {\n+                if (flags & SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS) {\n+                    return set_error(serror, SCRIPT_ERR_DISCOURAGE_OP_SUCCESS);\n+                }\n+                return set_success(serror);\n+            }\n+        }\n+\n+        // Tapscript enforces initial stack size limits (altstack is empty here)\n+        if (stack.size() > MAX_STACK_SIZE) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483337198",
      "id" : 483337198,
      "in_reply_to_id" : 482631236,
      "line" : 1793,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMzNzE5OA==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1793,
      "original_position" : 480,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 498,
      "pull_request_review_id" : 482301242,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483337198",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483349601"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483349601"
         }
      },
      "author_association" : "MEMBER",
      "body" : "BIP341 says to use `0x00 || SigMsg(0x00, 0)` as message. The `0` there is the `ext_flag` argument.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-04T02:23:46Z",
      "diff_hunk" : "@@ -1291,35 +1379,174 @@ uint256 GetOutputsSHA256(const T& txTo)\n     return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = SHA256Uint256(GetPrevoutsSHA256(txTo));\n-        hashSequence = SHA256Uint256(GetSequencesSHA256(txTo));\n-        hashOutputs = SHA256Uint256(GetOutputsSHA256(txTo));\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n     }\n \n-    m_ready = true;\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143 = false;\n+    bool uses_bip341 = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every native witness v1 spend as a Taproot spend. This only works if spent_outputs was\n+                // provided as well, but if it wasn't, actual validation will fail anyway.\n+                uses_bip341 = true;\n+            } else {\n+                // Treat every spend that's not known to native witness v1 as a Witness v0 spend. This branch may\n+                // also be taken for unknown witness versions, but it is harmless, and being precise would require\n+                // P2SH evaluation to find the redeemScript.\n+                uses_bip143 = true;\n+            }\n+        }\n+    }\n+\n+    if (uses_bip143 || uses_bip341) {\n+        // Computations shared between both sighash schemes.\n+        m_bip341_prevouts_hash = GetPrevoutsSHA256(txTo);\n+        m_bip341_sequences_hash = GetSequencesSHA256(txTo);\n+        m_bip341_outputs_hash = GetOutputsSHA256(txTo);\n+    }\n+    if (uses_bip143) {\n+        hashPrevouts = SHA256Uint256(m_bip341_prevouts_hash);\n+        hashSequence = SHA256Uint256(m_bip341_sequences_hash);\n+        hashOutputs = SHA256Uint256(m_bip341_outputs_hash);\n+        m_bip143_ready = true;\n+    }\n+    if (uses_bip341) {\n+        m_bip341_spent_amounts_hash = GetSpentAmountsSHA256(m_spent_outputs);\n+        m_bip341_spent_scripts_hash = GetSpentScriptsSHA256(m_spent_outputs);\n+        m_bip341_ready = true;\n+    }\n }\n \n template <class T>\n PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n {\n-    Init(txTo);\n+    Init(txTo, {});\n }\n \n // explicit instantiation\n-template void PrecomputedTransactionData::Init(const CTransaction& txTo);\n-template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo);\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+static const CHashWriter HASHER_TAPLEAF = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HASHER_TAPBRANCH = TaggedHash(\"TapBranch\");\n+static const CHashWriter HASHER_TAPTWEAK = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData* cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483349601",
      "id" : 483349601,
      "in_reply_to_id" : 483092066,
      "line" : 1482,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM0OTYwMQ==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1482,
      "original_position" : 312,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 324,
      "pull_request_review_id" : 482315576,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483349601",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483370057"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483370057"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Good idea, done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-04T03:52:09Z",
      "diff_hunk" : "@@ -1291,35 +1379,174 @@ uint256 GetOutputsSHA256(const T& txTo)\n     return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = SHA256Uint256(GetPrevoutsSHA256(txTo));\n-        hashSequence = SHA256Uint256(GetSequencesSHA256(txTo));\n-        hashOutputs = SHA256Uint256(GetOutputsSHA256(txTo));\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n     }\n \n-    m_ready = true;\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143 = false;\n+    bool uses_bip341 = false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483370057",
      "id" : 483370057,
      "in_reply_to_id" : 482137828,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM3MDA1Nw==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1418,
      "original_position" : 250,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 482338663,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483370057",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483370162"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483370162"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-04T03:52:37Z",
      "diff_hunk" : "@@ -129,6 +129,7 @@ enum class TxoutType {\n     NULL_DATA, //!< unspendable OP_RETURN script that carries data\n     WITNESS_V0_SCRIPTHASH,\n     WITNESS_V0_KEYHASH,\n+    WITNESS_V1_TAPROOT,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483370162",
      "id" : 483370162,
      "in_reply_to_id" : 482596393,
      "line" : 132,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM3MDE2Mg==",
      "original_commit_id" : "8859e78b6a563fecd75aca9498c1321f583bd8d8",
      "original_line" : 132,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/script/standard.h",
      "position" : 4,
      "pull_request_review_id" : 482338774,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483370162",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483370218"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483370218"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-04T03:52:52Z",
      "diff_hunk" : "@@ -1671,14 +1674,34 @@ static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CS\n     return true;\n }\n \n-static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, const std::vector<unsigned char>& program, const CScript& script)\n+{\n+    int path_len = (control.size() - TAPROOT_CONTROL_BASE_SIZE) / TAPROOT_CONTROL_NODE_SIZE;\n+    XOnlyPubKey p{uint256(std::vector<unsigned char>(control.begin() + 1, control.begin() + TAPROOT_CONTROL_BASE_SIZE))};\n+    XOnlyPubKey q{uint256(program)};\n+    uint256 k = (CHashWriter(HASHER_TAPLEAF) << uint8_t(control[0] & TAPROOT_LEAF_MASK) << script).GetSHA256();\n+    for (int i = 0; i < path_len; ++i) {\n+        CHashWriter ss_branch = HASHER_TAPBRANCH;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483370218",
      "id" : 483370218,
      "in_reply_to_id" : 482168422,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM3MDIxOA==",
      "original_commit_id" : "a6ca5080c4ac550dc74330e89c44d3eb268d4eb5",
      "original_line" : 1684,
      "original_position" : 22,
      "original_start_line" : 1679,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 482338835,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483370218",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483370332"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483370332"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Changed to `parity` in both .h and .cpp, as that's the name of the libsecp256k1 function.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-04T03:53:14Z",
      "diff_hunk" : "@@ -220,8 +220,10 @@ class XOnlyPubKey {\n      * If the signature is not exactly 64 bytes, false is returned.\n      */\n     bool VerifySchnorr(const uint256& msg, Span<const unsigned char> sigbytes) const;\n+    bool CheckPayToContract(const XOnlyPubKey& base, const uint256& hash, bool sign) const;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483370332",
      "id" : 483370332,
      "in_reply_to_id" : 482170606,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM3MDMzMg==",
      "original_commit_id" : "a6ca5080c4ac550dc74330e89c44d3eb268d4eb5",
      "original_line" : 223,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/pubkey.h",
      "position" : null,
      "pull_request_review_id" : 482338976,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483370332",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> The biggest mistake IMO is using BIP9 instead of BIP8.\r\n\r\nThis PR doesn't even have activation *at all*: it is set to always active in regtest and not at all otherwise.  The only connection to bip9 is that the code that handles BIP9 is the codebases' generic code for handling consensus rules which are active in some places and not others.\r\n\r\nThe way this works (and the way it has generally worked for prior consensus changes)-- is that the functionality is first merged disabled (except for in testing modes) and then later the activation gets done. It's difficult to test things completely without establishing them in the codebase, and people can't really decide to activate a consensus change that isn't done.\r\n\r\nSo please don't bring activation discussion to this PR, it's offtopic unless there is some specific technical property of the implementation or specification that would have some particular ramification for activation: e.g. if it was implemented in a way that prevented the new rules from being activated at a particular block but not active before then that would be worth pointing out.\r\n",
      "created_at" : "2020-09-04T04:48:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-686903679",
      "id" : 686903679,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY4NjkwMzY3OQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-04T04:48:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/686903679",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "node_id" : "MDQ6VXNlcjg1ODQ1NA==",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483394286"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483394286"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Great catch. There were no tests at all with signatures with unusual lengths, so I've added a number of them. `tapscript/emptysigs/checksig` didn't exercise this, as empty signatures are dealt with specially in script path spending. I've added comments to explain this.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-04T05:26:23Z",
      "diff_hunk" : "@@ -1410,12 +1643,31 @@ bool GenericTransactionSignatureChecker<T>::CheckSig(const std::vector<unsigned\n \n     uint256 sighash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion, this->txdata);\n \n-    if (!VerifySignature(vchSig, pubkey, sighash))\n+    if (!VerifyECDSASignature(vchSig, pubkey, sighash))\n         return false;\n \n     return true;\n }\n \n+template <class T>\n+bool GenericTransactionSignatureChecker<T>::CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey_in, SigVersion sigversion, const ScriptExecutionData& execdata) const\n+{\n+    if (sig.empty()) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483394286",
      "id" : 483394286,
      "in_reply_to_id" : 482598143,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5NDI4Ng==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1655,
      "original_position" : 433,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 482366925,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483394286",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483394932"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483394932"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've changed this to an assert. You can't do BIP340 signature verification with keys of length different than 32, and as both call sites already enforce this, it seems better to leave the responsibility for key length checking there.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-04T05:28:37Z",
      "diff_hunk" : "@@ -1410,12 +1643,31 @@ bool GenericTransactionSignatureChecker<T>::CheckSig(const std::vector<unsigned\n \n     uint256 sighash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion, this->txdata);\n \n-    if (!VerifySignature(vchSig, pubkey, sighash))\n+    if (!VerifyECDSASignature(vchSig, pubkey, sighash))\n         return false;\n \n     return true;\n }\n \n+template <class T>\n+bool GenericTransactionSignatureChecker<T>::CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey_in, SigVersion sigversion, const ScriptExecutionData& execdata) const\n+{\n+    if (sig.empty()) return false;\n+    if (pubkey_in.size() != 32) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483394932",
      "id" : 483394932,
      "in_reply_to_id" : 482599178,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5NDkzMg==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1656,
      "original_position" : 434,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 482367641,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483394932",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483395019"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483395019"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've restructed this a bit. It should be covered by new tests.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-04T05:29:02Z",
      "diff_hunk" : "@@ -1410,12 +1643,31 @@ bool GenericTransactionSignatureChecker<T>::CheckSig(const std::vector<unsigned\n \n     uint256 sighash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion, this->txdata);\n \n-    if (!VerifySignature(vchSig, pubkey, sighash))\n+    if (!VerifyECDSASignature(vchSig, pubkey, sighash))\n         return false;\n \n     return true;\n }\n \n+template <class T>\n+bool GenericTransactionSignatureChecker<T>::CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey_in, SigVersion sigversion, const ScriptExecutionData& execdata) const\n+{\n+    if (sig.empty()) return false;\n+    if (pubkey_in.size() != 32) return false;\n+\n+    XOnlyPubKey pubkey{pubkey_in};\n+\n+    uint8_t hashtype = SIGHASH_DEFAULT;\n+    if (sig.size() == 65) {\n+        hashtype = SpanPopBack(sig);\n+        if (hashtype == SIGHASH_DEFAULT) return false;\n+    }\n+    if (sig.size() != 64) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483395019",
      "id" : 483395019,
      "in_reply_to_id" : 482601984,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5NTAxOQ==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1665,
      "original_position" : 443,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 482367769,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483395019",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483395178"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483395178"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've added an extra commit that renames the variable. It was just wrong to call it `scriptPubKey`.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-04T05:29:37Z",
      "diff_hunk" : "@@ -1540,22 +1838,64 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n             if (memcmp(hashScriptPubKey.begin(), program.data(), 32)) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);\n             }\n-            return ExecuteWitnessScript(stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, serror);\n+            return ExecuteWitnessScript(stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, execdata, serror);\n         } else if (program.size() == WITNESS_V0_KEYHASH_SIZE) {\n-            // Special case for pay-to-pubkeyhash; signature + pubkey in witness\n+            // BIP141 P2WPKH: 20-byte witness v0 program (which encodes Hash160(pubkey))\n             if (stack.size() != 2) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH); // 2 items in witness\n             }\n             scriptPubKey << OP_DUP << OP_HASH160 << program << OP_EQUALVERIFY << OP_CHECKSIG;\n-            return ExecuteWitnessScript(stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, serror);\n+            return ExecuteWitnessScript(stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, execdata, serror);\n         } else {\n             return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH);\n         }\n+    } else if (witversion == 1 && program.size() == WITNESS_V1_TAPROOT_SIZE && !is_p2sh) {\n+        // BIP341 Taproot: 32-byte non-P2SH witness v1 program (which encodes a P2C-tweaked pubkey)\n+        if (!(flags & SCRIPT_VERIFY_TAPROOT)) return set_success(serror);\n+        if (stack.size() == 0) return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);\n+        if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {\n+            // Drop annex\n+            const valtype& annex = SpanPopBack(stack);\n+            execdata.m_annex_hash = (CHashWriter(SER_GETHASH, 0) << annex).GetSHA256();\n+            execdata.m_annex_present = true;\n+        } else {\n+            execdata.m_annex_present = false;\n+        }\n+        execdata.m_annex_init = true;\n+        if (stack.size() == 1) {\n+            // Key path spending (stack size is 1 after removing optional annex)\n+            if (!checker.CheckSchnorrSignature(stack.front(), program, SigVersion::TAPROOT, execdata)) {\n+                return set_error(serror, SCRIPT_ERR_TAPROOT_INVALID_SIG);\n+            }\n+            return set_success(serror);\n+        } else {\n+            // Script path spending (stack size is >1 after removing optional annex)\n+            const valtype& control = SpanPopBack(stack);\n+            const valtype& script_bytes = SpanPopBack(stack);\n+            scriptPubKey = CScript(script_bytes.begin(), script_bytes.end());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483395178",
      "id" : 483395178,
      "in_reply_to_id" : 482603435,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5NTE3OA==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1875,
      "original_position" : 576,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 482367931,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483395178",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483395546"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483395546"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've added a few more asserts (I'm using the terminology \"key path spending\", fwiw).",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-04T05:30:53Z",
      "diff_hunk" : "@@ -363,15 +360,76 @@ static bool EvalChecksig(const valtype& vchSig, const valtype& vchPubKey, CScrip\n         //serror is set\n         return false;\n     }\n-    fSuccess = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion);\n+    fSuccess = checker.CheckECDSASignature(vchSig, vchPubKey, scriptCode, sigversion);\n \n     if (!fSuccess && (flags & SCRIPT_VERIFY_NULLFAIL) && vchSig.size())\n         return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);\n \n     return true;\n }\n \n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)\n+static bool EvalChecksigTapscript(const valtype& sig, const valtype& pubkey, ScriptExecutionData& execdata, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& success)\n+{\n+    assert(sigversion == SigVersion::TAPSCRIPT);\n+\n+    /*\n+     *  The following validation sequence is consensus critical. Please note how --\n+     *    upgradable public key versions precede other rules;\n+     *    the script execution fails when using empty signature with invalid public key;\n+     *    the script execution fails when using non-empty invalid signature.\n+     */\n+    success = !sig.empty();\n+    if (success) {\n+        // Implement the sigops/witnesssize ratio test.\n+        // Passing with an upgradable public key version is also counted.\n+        assert(execdata.m_validation_weight_left_init);\n+        execdata.m_validation_weight_left -= VALIDATION_WEIGHT_PER_SIGOP_PASSED;\n+        if (execdata.m_validation_weight_left < 0) {\n+            return set_error(serror, SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT);\n+        }\n+    }\n+    if (pubkey.size() == 0) {\n+        return set_error(serror, SCRIPT_ERR_PUBKEYTYPE);\n+    } else if (pubkey.size() == 32) {\n+        if (success && !checker.CheckSchnorrSignature(sig, pubkey, sigversion, execdata)) {\n+            return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);\n+        }\n+    } else {\n+        /*\n+         *  New public key version softforks should be defined before this `else` block.\n+         *  Generally, the new code should not do anything but failing the script execution. To avoid\n+         *  consensus bugs, it should not modify any existing values (including success).\n+         */\n+        if ((flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE) != 0) {\n+            return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE);\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+/** Helper for OP_CHECKSIG, OP_CHECKSIGVERIFY, and (in Tapscript) OP_CHECKSIGADD.\n+ *\n+ * A return value of false means the script fails entirely. When true is returned, the\n+ * fSuccess variable indicates whether the signature check itself succeeded.\n+ */\n+static bool EvalChecksig(const valtype& sig, const valtype& pubkey, CScript::const_iterator pbegincodehash, CScript::const_iterator pend, ScriptExecutionData& execdata, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& success)\n+{\n+    switch (sigversion) {\n+    case SigVersion::BASE:\n+    case SigVersion::WITNESS_V0:\n+        return EvalChecksigPreTapscript(sig, pubkey, pbegincodehash, pend, flags, checker, sigversion, serror, success);\n+    case SigVersion::TAPSCRIPT:\n+        return EvalChecksigTapscript(sig, pubkey, execdata, flags, checker, sigversion, serror, success);\n+    case SigVersion::TAPROOT:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483395546",
      "id" : 483395546,
      "in_reply_to_id" : 482990495,
      "line" : 424,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5NTU0Ng==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 424,
      "original_position" : 84,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 84,
      "pull_request_review_id" : 482368308,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483395546",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483395636"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483395636"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Good point, done. That also matches the BIP.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-04T05:31:15Z",
      "diff_hunk" : "@@ -114,41 +121,111 @@ enum\n     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts\n     //\n     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),\n+\n+    // Taproot/Tapscript validation (BIPs 341 & 342)\n+    //\n+    SCRIPT_VERIFY_TAPROOT = (1U << 17),\n+\n+    // Making unknown Taproot leaf versions non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),\n+\n+    // Making unknown OP_SUCCESS non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 19),\n+\n+    // Making unknown public key versions (in BIP 342 scripts) non-standard\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 20),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n struct PrecomputedTransactionData\n {\n+    // BIP341 precomputed data.\n+    // These are single-SHA256, see https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-15.\n+    uint256 m_bip341_prevouts_hash;\n+    uint256 m_bip341_sequences_hash;\n+    uint256 m_bip341_outputs_hash;\n+    uint256 m_bip341_spent_amounts_hash;\n+    uint256 m_bip341_spent_scripts_hash;\n+    //! Whether the 5 fields above are initialized.\n+    bool m_bip341_ready = false;\n+\n+    // BIP143 precomputed data (double-SHA256).\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n-    bool m_ready = false;\n+    //! Whether the 3 fields above are initialized.\n+    bool m_bip143_ready = false;\n+\n+    std::vector<CTxOut> m_spent_outputs;\n+    //! Whether m_spent_outputs is initialized.\n+    bool m_spent_outputs_ready = false;\n \n     PrecomputedTransactionData() = default;\n \n     template <class T>\n-    void Init(const T& tx);\n+    void Init(const T& tx, std::vector<CTxOut> spent_outputs);\n \n     template <class T>\n     explicit PrecomputedTransactionData(const T& tx);\n };\n \n enum class SigVersion\n {\n-    BASE = 0,\n-    WITNESS_V0 = 1,\n+    BASE = 0,        //!< Bare scripts and BIP16 P2SH-wrapped redeemscripts\n+    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141\n+    TAPROOT = 2,     //!< Witness v1 with 32-byte program, not BIP16 P2SH-wrapped, key path spending; see BIP 341\n+    TAPSCRIPT = 3,   //!< Witness v1 with 32-byte program, not BIP16 P2SH-wrapped, script path spending, leaf version 0xc0; see BIP 342\n+};\n+\n+struct ScriptExecutionData\n+{\n+    //! Whether m_tapleaf_hash is initialized.\n+    bool m_tapleaf_hash_init = false;\n+    //! The tapleaf hash.\n+    uint256 m_tapleaf_hash;\n+\n+    //! Whether m_codeseparator_pos is initialized.\n+    bool m_codeseparator_pos_init = false;\n+    //! Opcode position of the last executed OP_CODESEPARATOR (or 0xFFFFFFFF if none executed).\n+    uint32_t m_codeseparator_pos;\n+\n+    //! Whether m_annex_present and (when needed) m_annex_hash are initialized.\n+    bool m_annex_init = false;\n+    //! Whether an annex is present.\n+    bool m_annex_present;\n+    //! Hash of the annex data.\n+    uint256 m_annex_hash;\n+\n+    /** Whether m_validation_weight_left is initialized. */\n+    bool m_validation_weight_left_init = false;\n+    /** How much validation weight is left (decremented for every successful signature check). */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483395636",
      "id" : 483395636,
      "in_reply_to_id" : 483027964,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5NTYzNg==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 201,
      "original_position" : 114,
      "original_start_line" : null,
      "path" : "src/script/interpreter.h",
      "position" : null,
      "pull_request_review_id" : 482368406,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483395636",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483395943"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483395943"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't like the idea of changing script validation flags based on context. It might be ok here, but in general that gets complex very quickly - things could even start interacting.\r\n\r\nI've just added a comment to explain this. What do you think?",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-04T05:32:27Z",
      "diff_hunk" : "@@ -568,7 +632,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                         if (stack.size() < 1)\n                             return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);\n                         valtype& vch = stacktop(-1);\n-                        if (sigversion == SigVersion::WITNESS_V0 && (flags & SCRIPT_VERIFY_MINIMALIF)) {\n+                        if (sigversion == SigVersion::TAPSCRIPT || (sigversion == SigVersion::WITNESS_V0 && (flags & SCRIPT_VERIFY_MINIMALIF))) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483395943",
      "id" : 483395943,
      "in_reply_to_id" : 483047134,
      "line" : 640,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5NTk0Mw==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 640,
      "original_position" : 139,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 151,
      "pull_request_review_id" : 482368770,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483395943",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483396437"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483396437"
         }
      },
      "author_association" : "MEMBER",
      "body" : "MINIMALDATA is purely a policy rule, and those are out of scope for BIP341/BIP342. It's not consensus, but apart from that, this behavior isn't specified by the BIPs.\r\n\r\nI've added a test that should exercise non-minimal inputs to `OP_CHECKSIGADD`.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-04T05:34:21Z",
      "diff_hunk" : "@@ -1029,9 +1094,32 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                 }\n                 break;\n \n+                case OP_CHECKSIGADD:\n+                {\n+                    // OP_CHECKSIGADD is only available in Tapscript\n+                    if (sigversion == SigVersion::BASE || sigversion == SigVersion::WITNESS_V0) return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n+\n+                    // (sig num pubkey -- num)\n+                    if (stack.size() < 3) return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n+\n+                    const valtype& sig = stacktop(-3);\n+                    const CScriptNum num(stacktop(-2), fRequireMinimal);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483396437",
      "id" : 483396437,
      "in_reply_to_id" : 483058642,
      "line" : 1111,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5NjQzNw==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1111,
      "original_position" : 173,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 185,
      "pull_request_review_id" : 482369351,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483396437",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483396890"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483396890"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nice catch, this one was harder to address. I've added support in the test framework for specifying that a particular spending test requires a mismatching output (so the number of outputs <= input position), shuffling inputs around to accomplish that.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-04T05:35:51Z",
      "diff_hunk" : "@@ -1291,35 +1379,174 @@ uint256 GetOutputsSHA256(const T& txTo)\n     return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = SHA256Uint256(GetPrevoutsSHA256(txTo));\n-        hashSequence = SHA256Uint256(GetSequencesSHA256(txTo));\n-        hashOutputs = SHA256Uint256(GetOutputsSHA256(txTo));\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n     }\n \n-    m_ready = true;\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143 = false;\n+    bool uses_bip341 = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every native witness v1 spend as a Taproot spend. This only works if spent_outputs was\n+                // provided as well, but if it wasn't, actual validation will fail anyway.\n+                uses_bip341 = true;\n+            } else {\n+                // Treat every spend that's not known to native witness v1 as a Witness v0 spend. This branch may\n+                // also be taken for unknown witness versions, but it is harmless, and being precise would require\n+                // P2SH evaluation to find the redeemScript.\n+                uses_bip143 = true;\n+            }\n+        }\n+    }\n+\n+    if (uses_bip143 || uses_bip341) {\n+        // Computations shared between both sighash schemes.\n+        m_bip341_prevouts_hash = GetPrevoutsSHA256(txTo);\n+        m_bip341_sequences_hash = GetSequencesSHA256(txTo);\n+        m_bip341_outputs_hash = GetOutputsSHA256(txTo);\n+    }\n+    if (uses_bip143) {\n+        hashPrevouts = SHA256Uint256(m_bip341_prevouts_hash);\n+        hashSequence = SHA256Uint256(m_bip341_sequences_hash);\n+        hashOutputs = SHA256Uint256(m_bip341_outputs_hash);\n+        m_bip143_ready = true;\n+    }\n+    if (uses_bip341) {\n+        m_bip341_spent_amounts_hash = GetSpentAmountsSHA256(m_spent_outputs);\n+        m_bip341_spent_scripts_hash = GetSpentScriptsSHA256(m_spent_outputs);\n+        m_bip341_ready = true;\n+    }\n }\n \n template <class T>\n PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n {\n-    Init(txTo);\n+    Init(txTo, {});\n }\n \n // explicit instantiation\n-template void PrecomputedTransactionData::Init(const CTransaction& txTo);\n-template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo);\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+static const CHashWriter HASHER_TAPLEAF = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HASHER_TAPBRANCH = TaggedHash(\"TapBranch\");\n+static const CHashWriter HASHER_TAPTWEAK = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData* cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    case SigVersion::TAPSCRIPT:\n+        ext_flag = 1;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache != nullptr && cache->m_bip341_ready && cache->m_spent_outputs_ready);\n+\n+    CHashWriter ss = HASHER_TAPSIGHASH;\n+\n+    // Epoch\n+    static constexpr uint8_t EPOCH = 0;\n+    ss << EPOCH;\n+\n+    // Hash type\n+    const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n+    const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;\n+    if (!(hash_type <= 0x03 || (hash_type >= 0x81 && hash_type <= 0x83))) return false;\n+    ss << hash_type;\n+\n+    // Transaction level data\n+    ss << tx_to.nVersion;\n+    ss << tx_to.nLockTime;\n+    if (input_type != SIGHASH_ANYONECANPAY) {\n+        ss << cache->m_bip341_prevouts_hash;\n+        ss << cache->m_bip341_spent_amounts_hash;\n+        ss << cache->m_bip341_spent_scripts_hash;\n+        ss << cache->m_bip341_sequences_hash;\n+    }\n+    if (output_type == SIGHASH_ALL) {\n+        ss << cache->m_bip341_outputs_hash;\n+    }\n+\n+    // Data about the input/prevout being spent\n+    assert(execdata.m_annex_init);\n+    const bool have_annex = execdata.m_annex_present;\n+    const uint8_t spend_type = (ext_flag << 1) + (have_annex ? 1 : 0); // The low bit indicates whether an annex is present.\n+    ss << spend_type;\n+    if (input_type == SIGHASH_ANYONECANPAY) {\n+        ss << tx_to.vin[in_pos].prevout;\n+        ss << cache->m_spent_outputs[in_pos];\n+        ss << tx_to.vin[in_pos].nSequence;\n+    } else {\n+        ss << in_pos;\n+    }\n+    if (have_annex) {\n+        ss << execdata.m_annex_hash;\n+    }\n+\n+    // Data about the output(s)\n+    if (output_type == SIGHASH_SINGLE) {\n+        if (in_pos >= tx_to.vout.size()) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483396890",
      "id" : 483396890,
      "in_reply_to_id" : 483102106,
      "line" : 1536,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5Njg5MA==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1536,
      "original_position" : 366,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 378,
      "pull_request_review_id" : 482369851,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483396890",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483397855"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483397855"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It's intended to be used for future key versions. That means it can't be in `ScriptExecutionData` which is shared for an entire script execution (and one script could contain multiple key versions).\r\n\r\nI've tried to clarify this by making `key_version` an explicit argument to `SignatureHashSchnorr` (but with an assert that it's zero). This allows passing it down from `CheckSchnorrSignature`, which is where that decision logic might go (there, or even higher in `EvalChecksigTapscript`).",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-04T05:39:16Z",
      "diff_hunk" : "@@ -1291,35 +1379,174 @@ uint256 GetOutputsSHA256(const T& txTo)\n     return ss.GetSHA256();\n }\n \n+/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */\n+uint256 GetSpentAmountsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.nValue;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */\n+uint256 GetSpentScriptsSHA256(const std::vector<CTxOut>& outputs_spent)\n+{\n+    CHashWriter ss(SER_GETHASH, 0);\n+    for (const auto& txout : outputs_spent) {\n+        ss << txout.scriptPubKey;\n+    }\n+    return ss.GetSHA256();\n+}\n+\n+\n } // namespace\n \n template <class T>\n-void PrecomputedTransactionData::Init(const T& txTo)\n+void PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut> spent_outputs)\n {\n-    assert(!m_ready);\n+    assert(!m_spent_outputs_ready);\n \n-    // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n-        hashPrevouts = SHA256Uint256(GetPrevoutsSHA256(txTo));\n-        hashSequence = SHA256Uint256(GetSequencesSHA256(txTo));\n-        hashOutputs = SHA256Uint256(GetOutputsSHA256(txTo));\n+    m_spent_outputs = std::move(spent_outputs);\n+    if (!m_spent_outputs.empty()) {\n+        assert(m_spent_outputs.size() == txTo.vin.size());\n+        m_spent_outputs_ready = true;\n     }\n \n-    m_ready = true;\n+    // Determine which precomputation-impacting features this transaction uses.\n+    bool uses_bip143 = false;\n+    bool uses_bip341 = false;\n+    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {\n+        if (!txTo.vin[inpos].scriptWitness.IsNull()) {\n+            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&\n+                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {\n+                // Treat every native witness v1 spend as a Taproot spend. This only works if spent_outputs was\n+                // provided as well, but if it wasn't, actual validation will fail anyway.\n+                uses_bip341 = true;\n+            } else {\n+                // Treat every spend that's not known to native witness v1 as a Witness v0 spend. This branch may\n+                // also be taken for unknown witness versions, but it is harmless, and being precise would require\n+                // P2SH evaluation to find the redeemScript.\n+                uses_bip143 = true;\n+            }\n+        }\n+    }\n+\n+    if (uses_bip143 || uses_bip341) {\n+        // Computations shared between both sighash schemes.\n+        m_bip341_prevouts_hash = GetPrevoutsSHA256(txTo);\n+        m_bip341_sequences_hash = GetSequencesSHA256(txTo);\n+        m_bip341_outputs_hash = GetOutputsSHA256(txTo);\n+    }\n+    if (uses_bip143) {\n+        hashPrevouts = SHA256Uint256(m_bip341_prevouts_hash);\n+        hashSequence = SHA256Uint256(m_bip341_sequences_hash);\n+        hashOutputs = SHA256Uint256(m_bip341_outputs_hash);\n+        m_bip143_ready = true;\n+    }\n+    if (uses_bip341) {\n+        m_bip341_spent_amounts_hash = GetSpentAmountsSHA256(m_spent_outputs);\n+        m_bip341_spent_scripts_hash = GetSpentScriptsSHA256(m_spent_outputs);\n+        m_bip341_ready = true;\n+    }\n }\n \n template <class T>\n PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)\n {\n-    Init(txTo);\n+    Init(txTo, {});\n }\n \n // explicit instantiation\n-template void PrecomputedTransactionData::Init(const CTransaction& txTo);\n-template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo);\n+template void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut> spent_outputs);\n+template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut> spent_outputs);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);\n template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);\n \n+static const CHashWriter HASHER_TAPSIGHASH = TaggedHash(\"TapSighash\");\n+static const CHashWriter HASHER_TAPLEAF = TaggedHash(\"TapLeaf\");\n+static const CHashWriter HASHER_TAPBRANCH = TaggedHash(\"TapBranch\");\n+static const CHashWriter HASHER_TAPTWEAK = TaggedHash(\"TapTweak\");\n+\n+template<typename T>\n+bool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, const uint32_t in_pos, const uint8_t hash_type, const SigVersion sigversion, const PrecomputedTransactionData* cache)\n+{\n+    uint8_t ext_flag;\n+    switch (sigversion) {\n+    case SigVersion::TAPROOT:\n+        ext_flag = 0;\n+        break;\n+    case SigVersion::TAPSCRIPT:\n+        ext_flag = 1;\n+        break;\n+    default:\n+        assert(false);\n+    }\n+    assert(in_pos < tx_to.vin.size());\n+    assert(cache != nullptr && cache->m_bip341_ready && cache->m_spent_outputs_ready);\n+\n+    CHashWriter ss = HASHER_TAPSIGHASH;\n+\n+    // Epoch\n+    static constexpr uint8_t EPOCH = 0;\n+    ss << EPOCH;\n+\n+    // Hash type\n+    const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL\n+    const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;\n+    if (!(hash_type <= 0x03 || (hash_type >= 0x81 && hash_type <= 0x83))) return false;\n+    ss << hash_type;\n+\n+    // Transaction level data\n+    ss << tx_to.nVersion;\n+    ss << tx_to.nLockTime;\n+    if (input_type != SIGHASH_ANYONECANPAY) {\n+        ss << cache->m_bip341_prevouts_hash;\n+        ss << cache->m_bip341_spent_amounts_hash;\n+        ss << cache->m_bip341_spent_scripts_hash;\n+        ss << cache->m_bip341_sequences_hash;\n+    }\n+    if (output_type == SIGHASH_ALL) {\n+        ss << cache->m_bip341_outputs_hash;\n+    }\n+\n+    // Data about the input/prevout being spent\n+    assert(execdata.m_annex_init);\n+    const bool have_annex = execdata.m_annex_present;\n+    const uint8_t spend_type = (ext_flag << 1) + (have_annex ? 1 : 0); // The low bit indicates whether an annex is present.\n+    ss << spend_type;\n+    if (input_type == SIGHASH_ANYONECANPAY) {\n+        ss << tx_to.vin[in_pos].prevout;\n+        ss << cache->m_spent_outputs[in_pos];\n+        ss << tx_to.vin[in_pos].nSequence;\n+    } else {\n+        ss << in_pos;\n+    }\n+    if (have_annex) {\n+        ss << execdata.m_annex_hash;\n+    }\n+\n+    // Data about the output(s)\n+    if (output_type == SIGHASH_SINGLE) {\n+        if (in_pos >= tx_to.vout.size()) return false;\n+        CHashWriter sha_single_output(SER_GETHASH, 0);\n+        sha_single_output << tx_to.vout[in_pos];\n+        ss << sha_single_output.GetSHA256();\n+    }\n+\n+    // Additional data for BIP 342 signatures\n+    if (sigversion == SigVersion::TAPSCRIPT) {\n+        assert(execdata.m_tapleaf_hash_init);\n+        ss << execdata.m_tapleaf_hash;\n+        ss << uint8_t(0); // key_version",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483397855",
      "id" : 483397855,
      "in_reply_to_id" : 483107386,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5Nzg1NQ==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1541,
      "original_position" : 376,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 482370993,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483397855",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483398114"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483398114"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've changed the `sigbytes` length check to an assert. The `msg` length check was just stupid; it's a `uint256`, its length is always 32.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-04T05:40:14Z",
      "diff_hunk" : "@@ -166,6 +167,27 @@ static int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1\n     return 1;\n }\n \n+XOnlyPubKey::XOnlyPubKey(Span<const unsigned char> in)\n+{\n+    assert(in.size() == 32);\n+    std::copy(in.begin(), in.end(), m_keydata.begin());\n+}\n+\n+bool XOnlyPubKey::VerifySchnorr(const uint256& msg, Span<const unsigned char> sigbytes) const {\n+    if (sigbytes.size() != 64) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483398114",
      "id" : 483398114,
      "in_reply_to_id" : 483122518,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5ODExNA==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 177,
      "original_position" : 19,
      "original_start_line" : null,
      "path" : "src/pubkey.cpp",
      "position" : null,
      "pull_request_review_id" : 482371277,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483398114",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483398175"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483398175"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-04T05:40:23Z",
      "diff_hunk" : "@@ -237,6 +239,36 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n                     return false;\n             }\n         }\n+\n+        // Check policy limits for Taproot spends:\n+        // - MAX_STANDARD_TAPSCRIPT_STACK_ITEM_SIZE limit for stack item size\n+        // - No annexes\n+        if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE && !p2sh) {\n+            // Taproot spend (non-P2SH-wrapped, version 1, witness program size 32; see BIP 341)\n+            auto stack = MakeSpan(tx.vin[i].scriptWitness.stack);\n+            if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {\n+                // Annexes are nonstandard as long as no semantics are defined for them.\n+                return false;\n+            }\n+            if (stack.size() >= 2) {\n+                // Script path spend (2 or more stack elements are removing optional annex)\n+                const auto& control_block = SpanPopBack(stack);\n+                SpanPopBack(stack); // Ignore script\n+                if (control_block.empty()) return false; // Empty control block is invalid\n+                if ((control_block[0] & TAPROOT_LEAF_MASK) == TAPROOT_LEAF_TAPSCRIPT) {\n+                    // Leaf version 0xc0 (aka Tapscript, see BIP 342)\n+                    for (const auto& item : stack) {\n+                        if (item.size() > MAX_STANDARD_TAPSCRIPT_STACK_ITEM_SIZE) return false;\n+                    }\n+                }\n+            } else if (stack.size() == 1) {\n+                // Key path spend (1 stack element after removing optional annex)\n+                // (no policy rules apply)\n+            } else {\n+                // 0 stack elements remain after removing optional annex; this is invalid",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483398175",
      "id" : 483398175,
      "in_reply_to_id" : 483125017,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5ODE3NQ==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 268,
      "original_position" : 55,
      "original_start_line" : null,
      "path" : "src/policy/policy.cpp",
      "position" : null,
      "pull_request_review_id" : 482371341,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483398175",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased, updated libsecp256k1 to latest https://github.com/bitcoin-core/secp256k1/pull/558, and addressed a number of comments by @fjahr, @Kixunil, and @ariard. Thanks!",
      "created_at" : "2020-09-04T05:51:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-686925487",
      "id" : 686925487,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY4NjkyNTQ4Nw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-04T05:51:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/686925487",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483804762"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483804762"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Okay, bookmarked to look on functional tests serializer correctness during next round of review.\r\n\r\n> I'm happy to try adding a test that explicitly tests spending with an incorrectly hashed leaf, but I don't think it adds much.\r\n\r\nI think we agree here. I expect serialization correctness to be already covered on its own but not that we test any new invocation of them in consensus code.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-04T19:16:21Z",
      "diff_hunk" : "@@ -1504,32 +1756,78 @@ bool GenericTransactionSignatureChecker<T>::CheckSequence(const CScriptNum& nSeq\n template class GenericTransactionSignatureChecker<CTransaction>;\n template class GenericTransactionSignatureChecker<CMutableTransaction>;\n \n-static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, const ScriptExecutionData& execdata, ScriptError* serror)\n {\n     std::vector<valtype> stack{stack_span.begin(), stack_span.end()};\n \n+    if (sigversion == SigVersion::TAPSCRIPT) {\n+        // OP_SUCCESSx processing overrides everything, including stack element size limits\n+        CScript::const_iterator pc = scriptPubKey.begin();\n+        while (pc < scriptPubKey.end()) {\n+            opcodetype opcode;\n+            if (!scriptPubKey.GetOp(pc, opcode)) {\n+                // Note how this condition would not be reached if an unknown OP_SUCCESSx was found\n+                return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n+            }\n+            // New opcodes will be listed here. May use a different sigversion to modify existing opcodes.\n+            if (IsOpSuccess(opcode)) {\n+                if (flags & SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS) {\n+                    return set_error(serror, SCRIPT_ERR_DISCOURAGE_OP_SUCCESS);\n+                }\n+                return set_success(serror);\n+            }\n+        }\n+\n+        // Tapscript enforces initial stack size limits (altstack is empty here)\n+        if (stack.size() > MAX_STACK_SIZE) {\n+            return set_error(serror, SCRIPT_ERR_STACK_SIZE);\n+        }\n+    }\n+\n     // Disallow stack item size > MAX_SCRIPT_ELEMENT_SIZE in witness stack\n     for (const valtype& elem : stack) {\n         if (elem.size() > MAX_SCRIPT_ELEMENT_SIZE) return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n     }\n \n     // Run the script interpreter.\n-    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, serror)) return false;\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, serror, execdata)) return false;\n \n     // Scripts inside witness implicitly require cleanstack behaviour\n     if (stack.size() != 1) return set_error(serror, SCRIPT_ERR_CLEANSTACK);\n     if (!CastToBool(stack.back())) return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n     return true;\n }\n \n-static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, const std::vector<unsigned char>& program, const CScript& script, uint256* tapleaf_hash)\n+{\n+    int path_len = (control.size() - TAPROOT_CONTROL_BASE_SIZE) / TAPROOT_CONTROL_NODE_SIZE;\n+    XOnlyPubKey p{uint256(std::vector<unsigned char>(control.begin() + 1, control.begin() + TAPROOT_CONTROL_BASE_SIZE))};\n+    XOnlyPubKey q{uint256(program)};\n+    uint256 k = (CHashWriter(HASHER_TAPLEAF) << uint8_t(control[0] & TAPROOT_LEAF_MASK) << script).GetSHA256();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483804762",
      "id" : 483804762,
      "in_reply_to_id" : 482608452,
      "line" : 1817,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgwNDc2Mg==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1817,
      "original_position" : 506,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 524,
      "pull_request_review_id" : 482890730,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483804762",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483813708"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483813708"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It depends on how you define context, does it include `sigversion` parameter ? BIP342 introduction presents well the script rules hierarchy and that would be better if we could encode it in clean code paths, a \"flat\" flag matrix is obviously harder to reason on.\r\n\r\nI think added comment is good enough for now, I guess this conversation belong to the previous, wider one on refactoring/duplicating interpreter before post-taproot script softforks.\r\n\r\nnit: `SCRIPT_VERIFY_MINIMALIF` you forgot the `IF` in new comment. ",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-04T19:39:26Z",
      "diff_hunk" : "@@ -568,7 +632,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                         if (stack.size() < 1)\n                             return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);\n                         valtype& vch = stacktop(-1);\n-                        if (sigversion == SigVersion::WITNESS_V0 && (flags & SCRIPT_VERIFY_MINIMALIF)) {\n+                        if (sigversion == SigVersion::TAPSCRIPT || (sigversion == SigVersion::WITNESS_V0 && (flags & SCRIPT_VERIFY_MINIMALIF))) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483813708",
      "id" : 483813708,
      "in_reply_to_id" : 483047134,
      "line" : 640,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgxMzcwOA==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 640,
      "original_position" : 139,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 151,
      "pull_request_review_id" : 482901787,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483813708",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483823251"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483823251"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I personally lean towards a clean separation between policy and consensus. You need to duplicate detection anyway both at relay and validation, what we may avoid I hope is having twice the same parsing logic. Parsing can be unique and interpretation according to consensus or policy ?\r\n\r\nAnyway, it sounds costly in refactoring, I think that's a wider discussion to have so opened https://github.com/bitcoin/bitcoin/issues/19875 (pinning previous PR discussion on this matter)",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-04T20:05:19Z",
      "diff_hunk" : "@@ -1540,22 +1838,64 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n             if (memcmp(hashScriptPubKey.begin(), program.data(), 32)) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);\n             }\n-            return ExecuteWitnessScript(stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, serror);\n+            return ExecuteWitnessScript(stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, execdata, serror);\n         } else if (program.size() == WITNESS_V0_KEYHASH_SIZE) {\n-            // Special case for pay-to-pubkeyhash; signature + pubkey in witness\n+            // BIP141 P2WPKH: 20-byte witness v0 program (which encodes Hash160(pubkey))\n             if (stack.size() != 2) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH); // 2 items in witness\n             }\n             scriptPubKey << OP_DUP << OP_HASH160 << program << OP_EQUALVERIFY << OP_CHECKSIG;\n-            return ExecuteWitnessScript(stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, serror);\n+            return ExecuteWitnessScript(stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, execdata, serror);\n         } else {\n             return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH);\n         }\n+    } else if (witversion == 1 && program.size() == WITNESS_V1_TAPROOT_SIZE && !is_p2sh) {\n+        // BIP341 Taproot: 32-byte non-P2SH witness v1 program (which encodes a P2C-tweaked pubkey)\n+        if (!(flags & SCRIPT_VERIFY_TAPROOT)) return set_success(serror);\n+        if (stack.size() == 0) return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);\n+        if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483823251",
      "id" : 483823251,
      "in_reply_to_id" : 482623999,
      "line" : 1867,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgyMzI1MQ==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1867,
      "original_position" : 557,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 584,
      "pull_request_review_id" : 482913714,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483823251",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483828455"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483828455"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@ariard Yes, I agree conceptually with better separation between consensus and policy implementation of script (I myself suggested splitting CScript in a minimal consensus implementation, and a more featureful separate one for everything else - policy and more), but I don't think that's relevant to the discussion here.\r\n\r\nEven if we have a separate script interpreter for consensus and one for policy, we'll still want a separate `IsStandard*` function, which can do policy checks _before_ any script interpreter (which may be expensive) is run.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-04T20:20:03Z",
      "diff_hunk" : "@@ -1540,22 +1838,64 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n             if (memcmp(hashScriptPubKey.begin(), program.data(), 32)) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);\n             }\n-            return ExecuteWitnessScript(stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, serror);\n+            return ExecuteWitnessScript(stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, execdata, serror);\n         } else if (program.size() == WITNESS_V0_KEYHASH_SIZE) {\n-            // Special case for pay-to-pubkeyhash; signature + pubkey in witness\n+            // BIP141 P2WPKH: 20-byte witness v0 program (which encodes Hash160(pubkey))\n             if (stack.size() != 2) {\n                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH); // 2 items in witness\n             }\n             scriptPubKey << OP_DUP << OP_HASH160 << program << OP_EQUALVERIFY << OP_CHECKSIG;\n-            return ExecuteWitnessScript(stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, serror);\n+            return ExecuteWitnessScript(stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, execdata, serror);\n         } else {\n             return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH);\n         }\n+    } else if (witversion == 1 && program.size() == WITNESS_V1_TAPROOT_SIZE && !is_p2sh) {\n+        // BIP341 Taproot: 32-byte non-P2SH witness v1 program (which encodes a P2C-tweaked pubkey)\n+        if (!(flags & SCRIPT_VERIFY_TAPROOT)) return set_success(serror);\n+        if (stack.size() == 0) return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);\n+        if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r483828455",
      "id" : 483828455,
      "in_reply_to_id" : 482623999,
      "line" : 1867,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgyODQ1NQ==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1867,
      "original_position" : 557,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 584,
      "pull_request_review_id" : 482919979,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/483828455",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r484520040"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/484520040"
         }
      },
      "author_association" : "NONE",
      "body" : "Good point.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-07T16:46:53Z",
      "diff_hunk" : "@@ -1504,32 +1756,78 @@ bool GenericTransactionSignatureChecker<T>::CheckSequence(const CScriptNum& nSeq\n template class GenericTransactionSignatureChecker<CTransaction>;\n template class GenericTransactionSignatureChecker<CMutableTransaction>;\n \n-static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, const ScriptExecutionData& execdata, ScriptError* serror)\n {\n     std::vector<valtype> stack{stack_span.begin(), stack_span.end()};\n \n+    if (sigversion == SigVersion::TAPSCRIPT) {\n+        // OP_SUCCESSx processing overrides everything, including stack element size limits\n+        CScript::const_iterator pc = scriptPubKey.begin();\n+        while (pc < scriptPubKey.end()) {\n+            opcodetype opcode;\n+            if (!scriptPubKey.GetOp(pc, opcode)) {\n+                // Note how this condition would not be reached if an unknown OP_SUCCESSx was found\n+                return set_error(serror, SCRIPT_ERR_BAD_OPCODE);\n+            }\n+            // New opcodes will be listed here. May use a different sigversion to modify existing opcodes.\n+            if (IsOpSuccess(opcode)) {\n+                if (flags & SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS) {\n+                    return set_error(serror, SCRIPT_ERR_DISCOURAGE_OP_SUCCESS);\n+                }\n+                return set_success(serror);\n+            }\n+        }\n+\n+        // Tapscript enforces initial stack size limits (altstack is empty here)\n+        if (stack.size() > MAX_STACK_SIZE) {\n+            return set_error(serror, SCRIPT_ERR_STACK_SIZE);\n+        }\n+    }\n+\n     // Disallow stack item size > MAX_SCRIPT_ELEMENT_SIZE in witness stack\n     for (const valtype& elem : stack) {\n         if (elem.size() > MAX_SCRIPT_ELEMENT_SIZE) return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n     }\n \n     // Run the script interpreter.\n-    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, serror)) return false;\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, serror, execdata)) return false;\n \n     // Scripts inside witness implicitly require cleanstack behaviour\n     if (stack.size() != 1) return set_error(serror, SCRIPT_ERR_CLEANSTACK);\n     if (!CastToBool(stack.back())) return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n     return true;\n }\n \n-static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, const std::vector<unsigned char>& program, const CScript& script, uint256* tapleaf_hash)\n+{\n+    int path_len = (control.size() - TAPROOT_CONTROL_BASE_SIZE) / TAPROOT_CONTROL_NODE_SIZE;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r484520040",
      "id" : 484520040,
      "in_reply_to_id" : 482202942,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUyMDA0MA==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 1803,
      "original_position" : 503,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : null,
      "pull_request_review_id" : 483663886,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:22:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/484520040",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1178779?v=4",
         "events_url" : "https://api.github.com/users/Kixunil/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Kixunil/followers",
         "following_url" : "https://api.github.com/users/Kixunil/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Kixunil/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Kixunil",
         "id" : 1178779,
         "login" : "Kixunil",
         "node_id" : "MDQ6VXNlcjExNzg3Nzk=",
         "organizations_url" : "https://api.github.com/users/Kixunil/orgs",
         "received_events_url" : "https://api.github.com/users/Kixunil/received_events",
         "repos_url" : "https://api.github.com/users/Kixunil/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Kixunil/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Kixunil/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Kixunil"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "@gmaxwell thanks for clarifying, will check activation discussion at whatever is the appropriate place.",
      "created_at" : "2020-09-07T16:50:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-688434311",
      "id" : 688434311,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY4ODQzNDMxMQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-07T16:50:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/688434311",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1178779?v=4",
         "events_url" : "https://api.github.com/users/Kixunil/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Kixunil/followers",
         "following_url" : "https://api.github.com/users/Kixunil/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Kixunil/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Kixunil",
         "id" : 1178779,
         "login" : "Kixunil",
         "node_id" : "MDQ6VXNlcjExNzg3Nzk=",
         "organizations_url" : "https://api.github.com/users/Kixunil/orgs",
         "received_events_url" : "https://api.github.com/users/Kixunil/received_events",
         "repos_url" : "https://api.github.com/users/Kixunil/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Kixunil/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Kixunil/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Kixunil"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased on top of #19944.",
      "created_at" : "2020-09-11T21:36:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-691322646",
      "id" : 691322646,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5MTMyMjY0Ng==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-11T21:36:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/691322646",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r487644680"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/487644680"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> nit: SCRIPT_VERIFY_MINIMALIF you forgot the IF in new comment.\r\n\r\nFixed.",
      "commit_id" : "6c1edf0d73deada863b8bf32879d70831c291633",
      "created_at" : "2020-09-14T04:26:48Z",
      "diff_hunk" : "@@ -568,7 +632,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                         if (stack.size() < 1)\n                             return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);\n                         valtype& vch = stacktop(-1);\n-                        if (sigversion == SigVersion::WITNESS_V0 && (flags & SCRIPT_VERIFY_MINIMALIF)) {\n+                        if (sigversion == SigVersion::TAPSCRIPT || (sigversion == SigVersion::WITNESS_V0 && (flags & SCRIPT_VERIFY_MINIMALIF))) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#discussion_r487644680",
      "id" : 487644680,
      "in_reply_to_id" : 483047134,
      "line" : 640,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY0NDY4MA==",
      "original_commit_id" : "84ec8708596075f4b8edbb2095bcfa64acf78bf5",
      "original_line" : 640,
      "original_position" : 139,
      "original_start_line" : null,
      "path" : "src/script/interpreter.cpp",
      "position" : 151,
      "pull_request_review_id" : 487407345,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17977",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T04:26:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/487644680",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Closing in favor of new PR(s), as discussed [here](https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-682285983).",
      "created_at" : "2020-09-14T04:34:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17977#issuecomment-691804687",
      "id" : 691804687,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17977",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5MTgwNDY4Nw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-14T04:34:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/691804687",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   }
]
