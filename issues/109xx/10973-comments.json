[
   {
      "body" : "Somewhat related (I think), having the fee rate declared as a class causes some really annoying workarounds, in particular the UniValueType wrapper in rpc/server.h\r\n\r\nIt seems to me that declaring fee rate as a type that is compatible with UniValue, like CAmount, could avoid some unnecessary cruft.\r\n\r\nAnyone have any thoughts on that?",
      "created_at" : "2017-08-02T14:40:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-319693243",
      "id" : 319693243,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10973",
      "updated_at" : "2017-08-02T14:43:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/319693243",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1276717?v=4",
         "events_url" : "https://api.github.com/users/corebob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/corebob/followers",
         "following_url" : "https://api.github.com/users/corebob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/corebob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/corebob",
         "id" : 1276717,
         "login" : "corebob",
         "organizations_url" : "https://api.github.com/users/corebob/orgs",
         "received_events_url" : "https://api.github.com/users/corebob/received_events",
         "repos_url" : "https://api.github.com/users/corebob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/corebob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/corebob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/corebob"
      }
   },
   {
      "body" : "Concept ACK",
      "created_at" : "2017-08-03T09:41:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-319920836",
      "id" : 319920836,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10973",
      "updated_at" : "2017-08-03T09:41:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/319920836",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@jnewbery, the change to stop deduping link arguments is in Makefile.am [here](https://github.com/bitcoin/bitcoin/commit/7bfb409ad9e27df07108c17d63c3efc5f4bfb6a6)\r\n",
      "created_at" : "2017-09-01T17:05:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-326633872",
      "id" : 326633872,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10973",
      "updated_at" : "2017-12-14T22:16:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/326633872",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r137120520"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137120520"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Maybe `block && !ReadBlockFromDisk`",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2017-09-05T21:32:14Z",
      "diff_hunk" : "@@ -28,6 +99,23 @@ class ChainImpl : public Chain\n         return std::move(result);\n     }\n     std::unique_ptr<Chain::LockedState> assumeLocked() override { return MakeUnique<LockedStateImpl>(); }\n+    bool findBlock(const uint256& hash, CBlock* block, int64_t* time) override\n+    {\n+        LOCK(cs_main);\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it == ::mapBlockIndex.end()) {\n+            return false;\n+        }\n+        if (block) {\n+            if (!ReadBlockFromDisk(*block, it->second, Params().GetConsensus())) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r137120520",
      "id" : 137120520,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEzNzEyMDUyMA==",
      "original_commit_id" : "c1194635c663536a5140beb4b59f634e4ca09110",
      "original_position" : 96,
      "path" : "src/ipc/local/bitcoind.cpp",
      "position" : null,
      "pull_request_review_id" : 60747312,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137120520",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r137124189"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137124189"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Maybe this would be a good place to use boost::option to simplify this API -- would be much clearer to get back `Some(Height) | Nothing` or `Some(Depth) | Nothing` than having semantics around if the invalid return is -1 or 0.\r\n",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2017-09-05T21:50:38Z",
      "diff_hunk" : "@@ -23,6 +26,68 @@ class Chain\n     {\n     public:\n         virtual ~LockedState() {}\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r137124189",
      "id" : 137124189,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEzNzEyNDE4OQ==",
      "original_commit_id" : "c1194635c663536a5140beb4b59f634e4ca09110",
      "original_position" : 15,
      "path" : "src/ipc/interfaces.h",
      "position" : null,
      "pull_request_review_id" : 60747312,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137124189",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r137136281"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137136281"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Can we have something that wraps both ipc_chain and ipc_clients for passing in? Is there a reason to have them separate? I don't want to add another useless class, it just seems they are always passed around together & are created together.",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2017-09-05T23:02:42Z",
      "diff_hunk" : "@@ -887,7 +888,7 @@ bool AppInitBasicSetup()\n     return true;\n }\n \n-bool AppInitParameterInteraction()\n+bool AppInitParameterInteraction(ipc::Chain& ipc_chain, ipc::Chain::Clients& ipc_clients)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r137136281",
      "id" : 137136281,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEzNzEzNjI4MQ==",
      "original_commit_id" : "5269b56ec4e82d765098ba88ee0e3e79f5de1941",
      "original_position" : 22,
      "path" : "src/init.cpp",
      "position" : null,
      "pull_request_review_id" : 60747312,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137136281",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r137139176"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137139176"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: semantics of name LockedState is maybe a bit clearer as ChainStateLock?",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2017-09-05T23:22:48Z",
      "diff_hunk" : "@@ -14,6 +14,26 @@ class Chain\n public:\n     virtual ~Chain() {}\n \n+    //! Interface for querying locked chain state, used by legacy code that\n+    //! assumes state won't change between calls. New code should avoid using\n+    //! the LockedState interface and instead call higher-level Chain methods\n+    //! that return more information so the chain doesn't need to stay locked\n+    //! between calls.\n+    class LockedState",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r137139176",
      "id" : 137139176,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEzNzEzOTE3Ng==",
      "original_commit_id" : "e26e00bd3f53435ecd580e3f1f56ef4fd45bcfc1",
      "original_position" : 9,
      "path" : "src/ipc/interfaces.h",
      "position" : null,
      "pull_request_review_id" : 60747312,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137139176",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r140299282"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/140299282"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> Can we have something that wraps both ipc_chain and ipc_clients for passing in? Is there a reason to have them separate? I don't want to add another useless class, it just seems they are always passed around together & are created together.\r\n\r\nGood suggestion. I wrapped these in the InitInterfaces struct which simplified some things.",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2017-09-21T16:53:36Z",
      "diff_hunk" : "@@ -887,7 +888,7 @@ bool AppInitBasicSetup()\n     return true;\n }\n \n-bool AppInitParameterInteraction()\n+bool AppInitParameterInteraction(ipc::Chain& ipc_chain, ipc::Chain::Clients& ipc_clients)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r140299282",
      "id" : 140299282,
      "in_reply_to_id" : 137136281,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE0MDI5OTI4Mg==",
      "original_commit_id" : "5269b56ec4e82d765098ba88ee0e3e79f5de1941",
      "original_position" : 22,
      "path" : "src/init.cpp",
      "position" : null,
      "pull_request_review_id" : 64351645,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/140299282",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r140299357"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/140299357"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> nit: semantics of name LockedState is maybe a bit clearer as ChainStateLock?\r\n\r\nThis is now named Chain::Lock, which hopefully is clearer. I kind of wanted to chose a shorter name because locked_chain variables so commonly used in [https://github.com/ryanofsky/bitcoin/blob/pr/wipc-sep/src/wallet/wallet.cpp](wallet.cpp) after this.",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2017-09-21T16:53:51Z",
      "diff_hunk" : "@@ -14,6 +14,26 @@ class Chain\n public:\n     virtual ~Chain() {}\n \n+    //! Interface for querying locked chain state, used by legacy code that\n+    //! assumes state won't change between calls. New code should avoid using\n+    //! the LockedState interface and instead call higher-level Chain methods\n+    //! that return more information so the chain doesn't need to stay locked\n+    //! between calls.\n+    class LockedState",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r140299357",
      "id" : 140299357,
      "in_reply_to_id" : 137139176,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE0MDI5OTM1Nw==",
      "original_commit_id" : "e26e00bd3f53435ecd580e3f1f56ef4fd45bcfc1",
      "original_position" : 9,
      "path" : "src/ipc/interfaces.h",
      "position" : null,
      "pull_request_review_id" : 64351645,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/140299357",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r140299394"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/140299394"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> Maybe block && !ReadBlockFromDisk\r\n\r\nThanks, done in f98a13387d8c409153748996a64eb6051cfecfec",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2017-09-21T16:54:02Z",
      "diff_hunk" : "@@ -28,6 +99,23 @@ class ChainImpl : public Chain\n         return std::move(result);\n     }\n     std::unique_ptr<Chain::LockedState> assumeLocked() override { return MakeUnique<LockedStateImpl>(); }\n+    bool findBlock(const uint256& hash, CBlock* block, int64_t* time) override\n+    {\n+        LOCK(cs_main);\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it == ::mapBlockIndex.end()) {\n+            return false;\n+        }\n+        if (block) {\n+            if (!ReadBlockFromDisk(*block, it->second, Params().GetConsensus())) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r140299394",
      "id" : 140299394,
      "in_reply_to_id" : 137120520,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE0MDI5OTM5NA==",
      "original_commit_id" : "c1194635c663536a5140beb4b59f634e4ca09110",
      "original_position" : 96,
      "path" : "src/ipc/local/bitcoind.cpp",
      "position" : null,
      "pull_request_review_id" : 64351645,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/140299394",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r140603814"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/140603814"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> Maybe this would be a good place to use boost::option to simplify this API -- would be much clearer to get back Some(Height) | Nothing or Some(Depth) | Nothing than having semantics around if the invalid return is -1 or 0.\r\n\r\nDone in 4b2ae4761c9e75e2d39ce46671d4562b28e54e6f. I'm not sure if it is a simplification, but it is definitely safer and probably clearer. Leaving it unsquashed for now, since there might be differing opinions.",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2017-09-22T21:47:15Z",
      "diff_hunk" : "@@ -23,6 +26,68 @@ class Chain\n     {\n     public:\n         virtual ~LockedState() {}\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r140603814",
      "id" : 140603814,
      "in_reply_to_id" : 137124189,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE0MDYwMzgxNA==",
      "original_commit_id" : "c1194635c663536a5140beb4b59f634e4ca09110",
      "original_position" : 15,
      "path" : "src/ipc/interfaces.h",
      "position" : null,
      "pull_request_review_id" : 64351645,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/140603814",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r180142594"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/180142594"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\nInclude(s) from src/interfaces/chain.h duplicated in src/interfaces/chain.cpp:\r\n#include <memory>\r\nInclude(s) from src/interfaces/wallet.h duplicated in src/interfaces/wallet.cpp:\r\n#include <memory>\r\n#include <string>\r\n#include <utility>\r\n#include <vector>\r\nInclude(s) from src/wallet/init.h duplicated in src/wallet/init.cpp:\r\n#include <walletinitinterface.h>\r\n^---- failure generated from contrib/devtools/lint-includes.sh",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-04-09T15:54:33Z",
      "diff_hunk" : "@@ -0,0 +1,438 @@\n+#include <interfaces/chain.h>\n+\n+#include <amount.h>\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <interfaces/handler.h>\n+#include <net.h>\n+#include <policy/feerate.h>\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <protocol.h>\n+#include <rpc/mining.h>\n+#include <rpc/protocol.h>\n+#include <rpc/server.h>\n+#include <sync.h>\n+#include <timedata.h>\n+#include <txmempool.h>\n+#include <ui_interface.h>\n+#include <uint256.h>\n+#include <univalue.h>\n+#include <util.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+#ifdef ENABLE_WALLET\n+#include <wallet/fees.h>\n+#include <wallet/wallet.h>\n+#define CHECK_WALLET(x) x\n+#else\n+#define CHECK_WALLET(x) throw std::logic_error(\"Wallet function called in non-wallet build.\")\n+#endif\n+\n+#include <algorithm>\n+#include <future>\n+#include <map>\n+#include <memory>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r180142594",
      "id" : 180142594,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4MDE0MjU5NA==",
      "original_commit_id" : "419308f3c8cf1b7fff0bd02de8522280ad91a93b",
      "original_position" : 41,
      "path" : "src/interfaces/chain.cpp",
      "position" : 34,
      "pull_request_review_id" : 110512280,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/180142594",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r180375204"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/180375204"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> failure generated from contrib/devtools/lint-includes.sh\r\n\r\nI'll try to submit a pr to simplify the developer guideline and this lint check. This check is incompatible with the [iwyu tool](https://github.com/include-what-you-use/include-what-you-use/blob/master/docs/WhyIWYU.md), and I think \"include what you use\" is a better and simpler policy than \"include what you use most of the time but not if the same include line appears in a different file\"",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-04-10T10:45:55Z",
      "diff_hunk" : "@@ -0,0 +1,438 @@\n+#include <interfaces/chain.h>\n+\n+#include <amount.h>\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <interfaces/handler.h>\n+#include <net.h>\n+#include <policy/feerate.h>\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <protocol.h>\n+#include <rpc/mining.h>\n+#include <rpc/protocol.h>\n+#include <rpc/server.h>\n+#include <sync.h>\n+#include <timedata.h>\n+#include <txmempool.h>\n+#include <ui_interface.h>\n+#include <uint256.h>\n+#include <univalue.h>\n+#include <util.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+#ifdef ENABLE_WALLET\n+#include <wallet/fees.h>\n+#include <wallet/wallet.h>\n+#define CHECK_WALLET(x) x\n+#else\n+#define CHECK_WALLET(x) throw std::logic_error(\"Wallet function called in non-wallet build.\")\n+#endif\n+\n+#include <algorithm>\n+#include <future>\n+#include <map>\n+#include <memory>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r180375204",
      "id" : 180375204,
      "in_reply_to_id" : 180142594,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4MDM3NTIwNA==",
      "original_commit_id" : "419308f3c8cf1b7fff0bd02de8522280ad91a93b",
      "original_position" : 41,
      "path" : "src/interfaces/chain.cpp",
      "position" : 34,
      "pull_request_review_id" : 110782252,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/180375204",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r180412881"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/180412881"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@ryanofsky Agree with you here. I merged that pull request because it had some acks and no nack, afaics. I am happy to ACK a pull that adjusts the developer guidelines and removes the lint check.",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-04-10T13:07:17Z",
      "diff_hunk" : "@@ -0,0 +1,438 @@\n+#include <interfaces/chain.h>\n+\n+#include <amount.h>\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <interfaces/handler.h>\n+#include <net.h>\n+#include <policy/feerate.h>\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <protocol.h>\n+#include <rpc/mining.h>\n+#include <rpc/protocol.h>\n+#include <rpc/server.h>\n+#include <sync.h>\n+#include <timedata.h>\n+#include <txmempool.h>\n+#include <ui_interface.h>\n+#include <uint256.h>\n+#include <univalue.h>\n+#include <util.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+#ifdef ENABLE_WALLET\n+#include <wallet/fees.h>\n+#include <wallet/wallet.h>\n+#define CHECK_WALLET(x) x\n+#else\n+#define CHECK_WALLET(x) throw std::logic_error(\"Wallet function called in non-wallet build.\")\n+#endif\n+\n+#include <algorithm>\n+#include <future>\n+#include <map>\n+#include <memory>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r180412881",
      "id" : 180412881,
      "in_reply_to_id" : 180142594,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4MDQxMjg4MQ==",
      "original_commit_id" : "419308f3c8cf1b7fff0bd02de8522280ad91a93b",
      "original_position" : 41,
      "path" : "src/interfaces/chain.cpp",
      "position" : 34,
      "pull_request_review_id" : 110826150,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/180412881",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@skeees, this PR might be relevant to the `GetDepthInMainChain` discussion from https://github.com/bitcoin/bitcoin/pull/12801#issuecomment-379930111. This PR replaces direct accesses to `chainActive` and `cs_main`  global variables in the wallet with calls to a `Chain::Lock` interface:\r\n\r\nhttps://github.com/bitcoin/bitcoin/blob/6efd1524caf008641c4ffc15e8a2b2c2586c6d0f/src/interfaces/chain.h#L42-L111\r\n\r\nIf you look at [wallet.cpp](https://github.com/ryanofsky/bitcoin/blob/pr/wipc-sep/src/wallet/wallet.cpp) and search for `locked_chain`,  you can see all the things the wallet is currently doing while assuming the chain is locked.\r\n\r\nIdeally we would like to eliminate these `locked_chain` objects, or make them very rarely used. I think the single change that would eliminate most uses of `locked_chain` would be to add an `m_last_block_processed_height` member to CWallet and an `m_block_height` member to `CMerkleTx`. These variables could get updated in `BlockConnected`, so methods like `GetDepthInMainChain`, `IsInMainChain`, and `GetBlocksToMaturity` could be implemented without external locking.\r\n\r\nThis is a change which I think could be implemented right now in a new PR that doesn't depend on anything. And there are probably other similar changes which could eliminate more locking and which your #12801 notifier might come in handy for.",
      "created_at" : "2018-04-10T13:38:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-380101269",
      "id" : 380101269,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10973",
      "updated_at" : "2018-04-10T13:38:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/380101269",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "It might also be decent to use a RW-lock -- I'd imagine *all* of the wallet code is only in read mode, and a good chunk of other code can run in read mode as well.",
      "created_at" : "2018-04-10T18:24:42Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-380200698",
      "id" : 380200698,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10973",
      "updated_at" : "2018-04-10T18:24:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/380200698",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> It might also be decent to use a RW-lock -- I'd imagine all of the wallet code is only in read mode,\r\n\r\nThis is a really interesting suggestion and observation. The benefit of using a RW lock would be that multiple wallets could hold the lock at same time, though I think we'd also need to prevent the wallets from blocking the `SingleThreadedSchedulerClient` notification thread to really take advantage of this.\r\n\r\nAnother way to take advantage of the read-only nature of the wallet client might be to change the `Chain::Lock` class to not even hold onto `cs_main` at all, but just present a locked view of the chain while still allowing updates to happen, [mvcc-like](https://en.wikipedia.org/wiki/Multiversion_concurrency_control). This would actually be pretty easy to implement by just saving the current chain tip in the constructor, and using it in all the other methods. But I imagine this could create subtle bugs and make generally things harder to reason about, so I'm still inclined to think getting rid of `Chain::Lock` is the best outcome, even though it will involve storing more state in the wallet. Getting rid of `Chain::Lock` could also be a nice way to avoid IPC overhead in addition to lock contention.\r\n\r\n---\r\n\r\nRebased 6efd1524caf008641c4ffc15e8a2b2c2586c6d0f -> 085519d9893a928c6bf60596305d6c257bf58725 ([pr/wipc-sep.41](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.41) -> [pr/wipc-sep.42](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.42)) due to conflicts with #12749, #12920, #12925\r\nRebased 085519d9893a928c6bf60596305d6c257bf58725 -> 22e6aad5b62545bf254df97f885635eb42f5abdd ([pr/wipc-sep.42](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.42) -> [pr/wipc-sep.43](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.43)) due to conflicts with #12977\r\nRebased 22e6aad5b62545bf254df97f885635eb42f5abdd -> daa337627f2181c360d775761a8d6829803ab915 ([pr/wipc-sep.43](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.43) -> [pr/wipc-sep.44](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.44)) due to conflicts with #12949\r\nUpdated daa337627f2181c360d775761a8d6829803ab915 -> 337d4535fe7a319f9628379378704e407dffa254 ([pr/wipc-sep.44](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.44) -> [pr/wipc-sep.45](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.45)) to remove orphaned wallet/init.h header file from previous rebase.\r\nRebased 337d4535fe7a319f9628379378704e407dffa254 -> d061f3511060996421bec36bc83b701fbd47bb64 ([pr/wipc-sep.45](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.45) -> [pr/wipc-sep.46](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.46)) due to conflict with #13017\r\nRebased d061f3511060996421bec36bc83b701fbd47bb64 -> 16f0e2fa5530848e48ad4d9359430f5156966da9 ([pr/wipc-sep.46](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.46) -> [pr/wipc-sep.47](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.47)) due to conflicts with #12909, #12953, #12830\r\nRebased 16f0e2fa5530848e48ad4d9359430f5156966da9 -> 60c7f5eb5af9390e16307796e05c13a24a63fdee ([pr/wipc-sep.47](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.47) -> [pr/wipc-sep.48](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.48)) due to conflict with #13033\r\nRebased 60c7f5eb5af9390e16307796e05c13a24a63fdee -> b4245a5697ed2006c3bc92a2183563264e0632ed ([pr/wipc-sep.48](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.48) -> [pr/wipc-sep.49](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.49)) due to conflict with #13090\r\nRebased b4245a5697ed2006c3bc92a2183563264e0632ed -> ce6af5dd9e70db2dfcd5d5f1ae10494b5129ff88 ([pr/wipc-sep.49](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.49) -> [pr/wipc-sep.50](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.50)) due to conflict with #13106\r\n",
      "created_at" : "2018-04-11T15:22:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-380492056",
      "id" : 380492056,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10973",
      "updated_at" : "2018-05-02T14:08:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/380492056",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r185077211"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/185077211"
         }
      },
      "author_association" : "MEMBER",
      "body" : "(in https://github.com/bitcoin/bitcoin/pull/10973/commits/a0279e40745dfb8692e92c5cac0848a25b37f930)\r\n\r\nI think we'll need to make an equivalent change in `addressbooktests.cpp` as well.",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-04-30T18:58:14Z",
      "diff_hunk" : "@@ -144,7 +144,9 @@ void TestGUI()\n     for (int i = 0; i < 5; ++i) {\n         test.CreateAndProcessBlock({}, GetScriptForRawPubKey(test.coinbaseKey.GetPubKey()));\n     }\n-    CWallet wallet(\"mock\", WalletDatabase::CreateMock());\n+    auto node = interfaces::MakeNode();\n+    node->parseParameters(0, nullptr);\n+    CWallet wallet(&node->getChain(), \"mock\", WalletDatabase::CreateMock());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r185077211",
      "id" : 185077211,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NTA3NzIxMQ==",
      "original_commit_id" : "a0279e40745dfb8692e92c5cac0848a25b37f930",
      "original_position" : 7,
      "path" : "src/qt/test/wallettests.cpp",
      "position" : null,
      "pull_request_review_id" : 116397255,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/185077211",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r185320554"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/185320554"
         }
      },
      "author_association" : "MEMBER",
      "body" : "(in https://github.com/bitcoin/bitcoin/pull/10973/commits/ba1e24b718d1db1c2ed06f88087e28994248b1c7)\r\n\r\nShould be \"1 for following block ...\"?",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-01T20:09:37Z",
      "diff_hunk" : "@@ -24,6 +30,62 @@ class Chain\n     {\n     public:\n         virtual ~Lock() {}\n+\n+        //! Get current chain height, not including genesis block (returns 0 if\n+        //! chain only contains genesis block, nothing if chain does not contain\n+        //! any blocks).\n+        virtual Optional<int> getHeight() = 0;\n+\n+        //! Get block height above genesis block. Returns 0 for genesis block,\n+        //! for following block, and so on. Returns nothing for a block not",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r185320554",
      "id" : 185320554,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NTMyMDU1NA==",
      "original_commit_id" : "ba1e24b718d1db1c2ed06f88087e28994248b1c7",
      "original_position" : 29,
      "path" : "src/interfaces/chain.h",
      "position" : null,
      "pull_request_review_id" : 116397255,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/185320554",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r185321164"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/185321164"
         }
      },
      "author_association" : "MEMBER",
      "body" : "(in https://github.com/bitcoin/bitcoin/pull/10973/commits/ba1e24b718d1db1c2ed06f88087e28994248b1c7)\r\n\r\n> optinal",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-01T20:12:15Z",
      "diff_hunk" : "@@ -24,6 +30,62 @@ class Chain\n     {\n     public:\n         virtual ~Lock() {}\n+\n+        //! Get current chain height, not including genesis block (returns 0 if\n+        //! chain only contains genesis block, nothing if chain does not contain\n+        //! any blocks).\n+        virtual Optional<int> getHeight() = 0;\n+\n+        //! Get block height above genesis block. Returns 0 for genesis block,\n+        //! for following block, and so on. Returns nothing for a block not\n+        //! included in the current chain.\n+        virtual Optional<int> getBlockHeight(const uint256& hash) = 0;\n+\n+        //! Get block depth. Returns 1 for chain tip, 2 for preceding block, and\n+        //! so on. Returns 0 for a block not included in the current chain.\n+        virtual int getBlockDepth(const uint256& hash) = 0;\n+\n+        //! Get block hash.\n+        virtual uint256 getBlockHash(int height) = 0;\n+\n+        //! Get block time.\n+        virtual int64_t getBlockTime(int height) = 0;\n+\n+        //! Get block median time past.\n+        virtual int64_t getBlockMedianTimePast(int height) = 0;\n+\n+        //! Check if block is empty.\n+        virtual bool blockHasTransactions(int height) = 0;\n+\n+        //! Return height of earliest block in chain with timestamp equal or\n+        //! greater than the given time, or nothing if there is no block with a\n+        //! high enough timestamp.\n+        virtual Optional<int> findEarliestAtLeast(int64_t time) = 0;\n+\n+        //! Return height of last block in chain with timestamp less than the\n+        //! given, and height less than or equal to the given, or nothing if\n+        //! there is no such block.\n+        virtual Optional<int> findLastBefore(int64_t time, int start_height) = 0;\n+\n+        //! Return height of last block in the specified range which is pruned, or\n+        //! nothing if no block in the range is pruned. Range is inclusive.\n+        virtual Optional<int> findPruned(int start_height = 0, Optional<int> stop_height = nullopt) = 0;\n+\n+        //! Return height of the highest block on the chain that is an ancestor\n+        //! of the specified block. Also return the height of the specified\n+        //! block as an optinal output parameter.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r185321164",
      "id" : 185321164,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NTMyMTE2NA==",
      "original_commit_id" : "ba1e24b718d1db1c2ed06f88087e28994248b1c7",
      "original_position" : 65,
      "path" : "src/interfaces/chain.h",
      "position" : null,
      "pull_request_review_id" : 116397255,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/185321164",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r185327873"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/185327873"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Are the `UniValue` calls necessary?",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-01T20:40:33Z",
      "diff_hunk" : "@@ -3725,58 +3724,53 @@ UniValue rescanblockchain(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Wallet is currently rescanning. Abort existing rescan or wait.\");\n     }\n \n-    CBlockIndex *pindexStart = nullptr;\n-    CBlockIndex *pindexStop = nullptr;\n-    CBlockIndex *pChainTip = nullptr;\n+    int start_height = 0;\n+    Optional<int> stop_height;\n+    Optional<int> tip_height;\n+    uint256 start_block, stop_block;\n     {\n         auto locked_chain = pwallet->chain().lock();\n-        pindexStart = chainActive.Genesis();\n-        pChainTip = chainActive.Tip();\n+        tip_height = locked_chain->getHeight();\n \n         if (!request.params[0].isNull()) {\n-            pindexStart = chainActive[request.params[0].get_int()];\n-            if (!pindexStart) {\n+            start_height = request.params[0].get_int();\n+            if (start_height < 0 || !tip_height || start_height > *tip_height) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid start_height\");\n             }\n         }\n \n         if (!request.params[1].isNull()) {\n-            pindexStop = chainActive[request.params[1].get_int()];\n-            if (!pindexStop) {\n+            stop_height = request.params[1].get_int();\n+            if (*stop_height < 0 || !tip_height || *stop_height > *tip_height) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid stop_height\");\n             }\n-            else if (pindexStop->nHeight < pindexStart->nHeight) {\n+            else if (*stop_height < start_height) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"stop_height must be greater than start_height\");\n             }\n         }\n-    }\n \n-    // We can't rescan beyond non-pruned blocks, stop and throw an error\n-    if (fPruneMode) {\n-        auto locked_chain = pwallet->chain().lock();\n-        CBlockIndex *block = pindexStop ? pindexStop : pChainTip;\n-        while (block && block->nHeight >= pindexStart->nHeight) {\n-            if (!(block->nStatus & BLOCK_HAVE_DATA)) {\n-                throw JSONRPCError(RPC_MISC_ERROR, \"Can't rescan beyond pruned data. Use RPC call getblockchaininfo to determine your pruned height.\");\n-            }\n-            block = block->pprev;\n+        // We can't rescan beyond non-pruned blocks, stop and throw an error\n+        if (locked_chain->findPruned(start_height, stop_height)) {\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Can't rescan beyond pruned data. Use RPC call getblockchaininfo to determine your pruned height.\");\n+        }\n+\n+        if (tip_height) {\n+            start_block = locked_chain->getBlockHash(start_height);\n+            stop_block = locked_chain->getBlockHash(stop_height ? *stop_height : *tip_height);\n         }\n     }\n \n-    CBlockIndex *stopBlock = pwallet->ScanForWalletTransactions(pindexStart, pindexStop, reserver, true);\n-    if (!stopBlock) {\n+    if (pwallet->ScanForWalletTransactions(start_block, stop_block, reserver, true).IsNull()) {\n         if (pwallet->IsAbortingRescan()) {\n             throw JSONRPCError(RPC_MISC_ERROR, \"Rescan aborted.\");\n         }\n-        // if we got a nullptr returned, ScanForWalletTransactions did rescan up to the requested stopindex\n-        stopBlock = pindexStop ? pindexStop : pChainTip;\n     }\n     else {\n         throw JSONRPCError(RPC_MISC_ERROR, \"Rescan failed. Potentially corrupted data files.\");\n     }\n     UniValue response(UniValue::VOBJ);\n-    response.pushKV(\"start_height\", pindexStart->nHeight);\n-    response.pushKV(\"stop_height\", stopBlock->nHeight);\n+    response.pushKV(\"start_height\", start_height);\n+    response.pushKV(\"stop_height\", stop_height ? UniValue(*stop_height) : tip_height ? UniValue(*tip_height): UniValue());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r185327873",
      "id" : 185327873,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NTMyNzg3Mw==",
      "original_commit_id" : "ba1e24b718d1db1c2ed06f88087e28994248b1c7",
      "original_position" : 158,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 116397255,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/185327873",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r185796547"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/185796547"
         }
      },
      "author_association" : "MEMBER",
      "body" : "(in https://github.com/bitcoin/bitcoin/pull/10973/commits/7f087936082170018b189f19adb7d789f4c2969d)\r\n> transac<tions",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-03T13:28:04Z",
      "diff_hunk" : "@@ -1699,108 +1694,126 @@ int64_t CWallet::RescanFromTime(int64_t startTime, const WalletRescanReserver& r\n     // Find starting block. May be null if nCreateTime is greater than the\n     // highest blockchain timestamp, in which case there is nothing that needs\n     // to be scanned.\n-    CBlockIndex* startBlock = nullptr;\n+    uint256 start_block;\n     {\n         auto locked_chain = m_chain->lock();\n-        startBlock = chainActive.FindEarliestAtLeast(startTime - TIMESTAMP_WINDOW);\n-        LogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, startBlock ? chainActive.Height() - startBlock->nHeight + 1 : 0);\n-    }\n-\n-    if (startBlock) {\n-        const CBlockIndex* const failedBlock = ScanForWalletTransactions(startBlock, nullptr, reserver, update);\n-        if (failedBlock) {\n-            return failedBlock->GetBlockTimeMax() + TIMESTAMP_WINDOW + 1;\n+        const Optional<int> start_height = locked_chain->findEarliestAtLeast(startTime - TIMESTAMP_WINDOW);\n+        const Optional<int> tip_height = locked_chain->getHeight();\n+        LogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, tip_height && start_height ? *tip_height - *start_height + 1 : 0);\n+        if (start_height) start_block = locked_chain->getBlockHash(*start_height);\n+    }\n+\n+    if (!start_block.IsNull()) {\n+        uint256 failed_block = ScanForWalletTransactions(start_block, {} /* stop block */, reserver, update);\n+        if (!failed_block.IsNull()) {\n+            int64_t time_max;\n+            if (!m_chain->findBlock(failed_block, nullptr /* CBlock */, nullptr /* time */, &time_max)) {\n+                throw std::logic_error(\"ScanForWalletTransactions returned invalid block hash\");\n+            }\n+            return time_max + TIMESTAMP_WINDOW + 1;\n         }\n     }\n     return startTime;\n }\n \n /**\n- * Scan the block chain (starting in pindexStart) for transactions\n+ * Scan the block chain (starting in start_block) for transactions\n  * from or to us. If fUpdate is true, found transactions that already\n  * exist in the wallet will be updated.\n  *\n  * Returns null if scan was successful. Otherwise, if a complete rescan was not\n  * possible (due to pruning or corruption), returns pointer to the most recent\n  * block that could not be scanned.\n  *\n- * If pindexStop is not a nullptr, the scan will stop at the block-index\n- * defined by pindexStop\n+ * If stop_block is not null, the scan will stop at the block-index\n+ * defined by stop_block\n  *\n- * Caller needs to make sure pindexStop (and the optional pindexStart) are on\n+ * Caller needs to make sure stop_block (and the optional start_block) are on\n  * the main chain after to the addition of any new keys you want to detect\n  * transactions for.\n  */\n-CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, CBlockIndex* pindexStop, const WalletRescanReserver &reserver, bool fUpdate)\n+uint256 CWallet::ScanForWalletTransactions(const uint256& start_block, const uint256& stop_block, const WalletRescanReserver &reserver, bool fUpdate)\n {\n     int64_t nNow = GetTime();\n     const CChainParams& chainParams = Params();\n \n     assert(reserver.isReserved());\n-    if (pindexStop) {\n-        assert(pindexStop->nHeight >= pindexStart->nHeight);\n-    }\n \n-    CBlockIndex* pindex = pindexStart;\n-    CBlockIndex* ret = nullptr;\n+    uint256 block_hash = start_block;\n+    uint256 ret;\n \n-    if (pindex) LogPrintf(\"Rescan started from block %d...\\n\", pindex->nHeight);\n+    LogPrintf(\"Rescan started from block %s...\\n\", start_block.ToString());\n \n     {\n         fAbortRescan = false;\n         ShowProgress(_(\"Rescanning...\"), 0); // show rescan progress in GUI as dialog or on splashscreen, if -rescan on startup\n-        CBlockIndex* tip = nullptr;\n+        uint256 tip_hash;\n+        Optional<int> block_height;\n         double dProgressStart;\n         double dProgressTip;\n         {\n             auto locked_chain = m_chain->lock();\n-            tip = chainActive.Tip();\n-            dProgressStart = GuessVerificationProgress(chainParams.TxData(), pindex);\n-            dProgressTip = GuessVerificationProgress(chainParams.TxData(), tip);\n+            if (Optional<int> tip_height = locked_chain->getHeight()) {\n+                tip_hash = locked_chain->getBlockHash(*tip_height);\n+            }\n+            block_height = locked_chain->getBlockHeight(block_hash);\n+            dProgressStart = m_chain->guessVerificationProgress(block_hash);\n+            dProgressTip = m_chain->guessVerificationProgress(tip_hash);\n         }\n         double gvp = dProgressStart;\n-        while (pindex && !fAbortRescan)\n+        while (block_height && !fAbortRescan)\n         {\n-            if (pindex->nHeight % 100 == 0 && dProgressTip - dProgressStart > 0.0) {\n+            if (*block_height % 100 == 0 && dProgressTip - dProgressStart > 0.0) {\n                 ShowProgress(_(\"Rescanning...\"), std::max(1, std::min(99, (int)((gvp - dProgressStart) / (dProgressTip - dProgressStart) * 100))));\n             }\n             if (GetTime() >= nNow + 60) {\n                 nNow = GetTime();\n-                LogPrintf(\"Still rescanning. At block %d. Progress=%f\\n\", pindex->nHeight, gvp);\n+                LogPrintf(\"Still rescanning. At block %d. Progress=%f\\n\", *block_height, gvp);\n             }\n \n             CBlock block;\n-            if (ReadBlockFromDisk(block, pindex, Params().GetConsensus())) {\n+            if (m_chain->findBlock(block_hash, &block) && !block.IsNull()) {\n                 auto locked_chain = m_chain->lock();\n                 LOCK(cs_wallet);\n-                if (pindex && !chainActive.Contains(pindex)) {\n+                if (!locked_chain->getBlockHeight(block_hash)) {\n                     // Abort scan if current block is no longer active, to prevent\n-                    // marking transactions as coming from the wrong block.\n-                    ret = pindex;\n+                    // marking transac<tions as coming from the wrong block.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r185796547",
      "id" : 185796547,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NTc5NjU0Nw==",
      "original_commit_id" : "7f087936082170018b189f19adb7d789f4c2969d",
      "original_position" : 227,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 116397255,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/185796547",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Needs rebase.",
      "created_at" : "2018-05-03T14:47:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-386321291",
      "id" : 386321291,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10973",
      "updated_at" : "2018-05-03T14:47:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/386321291",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> Needs rebase.\r\n\r\nRebased ce6af5dd9e70db2dfcd5d5f1ae10494b5129ff88 -> af8f8087699c30ec83995c54112955253bcaba84 ([pr/wipc-sep.50](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.50) -> [pr/wipc-sep.51](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.51)) due to conflicts with #12639 and #12507.\r\n\r\n(Reminders to rebase this are welcome, but not needed. Since this conflicts with most wallet prs, I tend to check this frequently and rebase it a few times per week).\r\n",
      "created_at" : "2018-05-03T15:13:14Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-386330307",
      "id" : 386330307,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10973",
      "updated_at" : "2018-05-03T15:13:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/386330307",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r185886977"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/185886977"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Any reason you don't just want to do \r\n```c++\r\nfor (const CRPCCommand* command : m_commands) { ... }\r\n```\r\nhere?",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-03T17:56:10Z",
      "diff_hunk" : "@@ -286,8 +301,106 @@ class ChainImpl : public Chain\n         return MakeUnique<HandlerImpl>(notifications);\n     }\n     void waitForNotifications() override { SyncWithValidationInterfaceQueue(); }\n+    std::unique_ptr<Handler> handleRpc(const CRPCCommand& command) override;\n+\n+    //! Map of RPC method name to forwarder. If multiple clients provide\n+    //! implementations of the same RPC method, the RPC forwarder can dispatch\n+    //! between them.\n+    class RpcForwarder;\n+    std::map<Ref<const std::string>, RpcForwarder> m_rpc_forwarders;\n+};\n+\n+//! Forwarder for one RPC method.\n+class ChainImpl::RpcForwarder\n+{\n+public:\n+    RpcForwarder(const CRPCCommand& command) : m_command(command)\n+    {\n+        m_command.actor = [this](const JSONRPCRequest& request) { return forwardRequest(request); };\n+    }\n+\n+    bool registerForwarder() { return ::tableRPC.appendCommand(m_command.name, &m_command); }\n+\n+    void addCommand(const CRPCCommand& command) { m_commands.emplace_back(&command); }\n+\n+    void removeCommand(const CRPCCommand& command)\n+    {\n+        m_commands.erase(std::remove(m_commands.begin(), m_commands.end(), &command));\n+    }\n+\n+    UniValue forwardRequest(const JSONRPCRequest& request) const\n+    {\n+        // Simple forwarding of RPC requests. This just sends the request to the\n+        // first client that registered a handler for the RPC method. If the\n+        // handler throws a wallet not found exception, this will retry\n+        // forwarding to the next handler (if any).\n+        //\n+        // This forwarding mechanism could be made more efficient (peeking\n+        // inside the RPC request for wallet name and sending it directly to the\n+        // right handler), but right now all wallets are in-process so there is\n+        // only ever a single handler, and in the future it isn't clear if we\n+        // will want we want to keep forwarding RPCs at all (clients could just\n+        // listen for their own RPCs).\n+        for (auto it = m_commands.begin(); it != m_commands.end();) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r185886977",
      "id" : 185886977,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NTg4Njk3Nw==",
      "original_commit_id" : "7a6069a3c51582f32fa1ce9bed6c3c905b5bfd0c",
      "original_position" : 82,
      "path" : "src/interfaces/chain.cpp",
      "position" : 388,
      "pull_request_review_id" : 116397255,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/185886977",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r185934311"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/185934311"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Seems like these instances of straight pass-through to some underlying function may be good cases for templated argument forwarding. I don't feel strongly either way, but maybe worth considering to cut down on interface duplication?\r\n\r\nI guess if the end objective is to come up with a cross-process interface, duplicating these arguments in the meantime is actually what we want to do.",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-03T20:58:18Z",
      "diff_hunk" : "@@ -296,6 +299,13 @@ class ChainImpl : public Chain\n     void initMessage(const std::string& message) override { ::uiInterface.InitMessage(message); }\n     void initWarning(const std::string& message) override { InitWarning(message); }\n     void initError(const std::string& message) override { InitError(message); }\n+    UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbase_script,\n+        int num_blocks,\n+        uint64_t max_tries,\n+        bool keep_script) override\n+    {\n+        return ::generateBlocks(coinbase_script, num_blocks, max_tries, keep_script);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r185934311",
      "id" : 185934311,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NTkzNDMxMQ==",
      "original_commit_id" : "604c567e3c39099d2dd62ead72804d6a584cf34a",
      "original_position" : 26,
      "path" : "src/interfaces/chain.cpp",
      "position" : 341,
      "pull_request_review_id" : 116397255,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/185934311",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186125434"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186125434"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't understand why this is in `parseParameters()`, rather than a constructor for `NodeImpl`",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-04T15:52:41Z",
      "diff_hunk" : "@@ -50,6 +51,7 @@ class NodeImpl : public Node\n {\n     void parseParameters(int argc, const char* const argv[]) override\n     {\n+        m_interfaces.chain = interfaces::MakeChain();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186125434",
      "id" : 186125434,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjEyNTQzNA==",
      "original_commit_id" : "af8f8087699c30ec83995c54112955253bcaba84",
      "original_position" : 12,
      "path" : "src/interfaces/node.cpp",
      "position" : null,
      "pull_request_review_id" : 117658720,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186125434",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186132129"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186132129"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think the `(Scheduler is ignored if client is out-of-process).` comment can be saved for #10102",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-04T16:15:54Z",
      "diff_hunk" : "@@ -0,0 +1,251 @@\n+#ifndef BITCOIN_INTERFACES_CHAIN_H\n+#define BITCOIN_INTERFACES_CHAIN_H\n+\n+#include <optional.h>               // For Optional and nullopt\n+#include <policy/rbf.h>             // For RBFTransactionState\n+#include <primitives/transaction.h> // For CTransactionRef\n+\n+#include <memory>\n+#include <stddef.h>\n+#include <stdint.h>\n+#include <string>\n+#include <vector>\n+\n+class CBlock;\n+class CRPCCommand;\n+class CReserveScript;\n+class CScheduler;\n+class CValidationState;\n+class UniValue;\n+class uint256;\n+struct CBlockLocator;\n+struct FeeCalculation;\n+\n+namespace interfaces {\n+\n+class Handler;\n+\n+//! Interface for giving wallet processes access to blockchain state.\n+class Chain\n+{\n+public:\n+    virtual ~Chain() {}\n+\n+    //! Interface for querying locked chain state, used by legacy code that\n+    //! assumes state won't change between calls. New code should avoid using\n+    //! the Lock interface and instead call higher-level Chain methods\n+    //! that return more information so the chain doesn't need to stay locked\n+    //! between calls.\n+    class Lock\n+    {\n+    public:\n+        virtual ~Lock() {}\n+\n+        //! Get current chain height, not including genesis block (returns 0 if\n+        //! chain only contains genesis block, nothing if chain does not contain\n+        //! any blocks).\n+        virtual Optional<int> getHeight() = 0;\n+\n+        //! Get block height above genesis block. Returns 0 for genesis block,\n+        //! for following block, and so on. Returns nothing for a block not\n+        //! included in the current chain.\n+        virtual Optional<int> getBlockHeight(const uint256& hash) = 0;\n+\n+        //! Get block depth. Returns 1 for chain tip, 2 for preceding block, and\n+        //! so on. Returns 0 for a block not included in the current chain.\n+        virtual int getBlockDepth(const uint256& hash) = 0;\n+\n+        //! Get block hash.\n+        virtual uint256 getBlockHash(int height) = 0;\n+\n+        //! Get block time.\n+        virtual int64_t getBlockTime(int height) = 0;\n+\n+        //! Get block median time past.\n+        virtual int64_t getBlockMedianTimePast(int height) = 0;\n+\n+        //! Check if block is empty.\n+        virtual bool blockHasTransactions(int height) = 0;\n+\n+        //! Return height of earliest block in chain with timestamp equal or\n+        //! greater than the given time, or nothing if there is no block with a\n+        //! high enough timestamp.\n+        virtual Optional<int> findEarliestAtLeast(int64_t time) = 0;\n+\n+        //! Return height of last block in chain with timestamp less than the\n+        //! given, and height less than or equal to the given, or nothing if\n+        //! there is no such block.\n+        virtual Optional<int> findLastBefore(int64_t time, int start_height) = 0;\n+\n+        //! Return height of last block in the specified range which is pruned, or\n+        //! nothing if no block in the range is pruned. Range is inclusive.\n+        virtual Optional<int> findPruned(int start_height = 0, Optional<int> stop_height = nullopt) = 0;\n+\n+        //! Return height of the highest block on the chain that is an ancestor\n+        //! of the specified block. Also return the height of the specified\n+        //! block as an optinal output parameter.\n+        virtual Optional<int> findFork(const uint256& hash, Optional<int>* height) = 0;\n+\n+        //! Return true if block hash points to the current chain tip, or to a\n+        //! possible descendant of the current chain tip that isn't currently\n+        //! connected.\n+        virtual bool isPotentialTip(const uint256& hash) = 0;\n+\n+        //! Get locator for the current chain tip.\n+        virtual CBlockLocator getLocator() = 0;\n+\n+        //! Return height of block on the chain using locator.\n+        virtual Optional<int> findLocatorFork(const CBlockLocator& locator) = 0;\n+\n+        //! Check if transaction will be final given chain height current time.\n+        virtual bool checkFinalTx(const CTransaction& tx) = 0;\n+\n+        //! Check whether segregated witness is enabled on the network.\n+        virtual bool isWitnessEnabled() = 0;\n+\n+        //! Add transaction to memory pool.\n+        virtual bool acceptToMemoryPool(CTransactionRef tx, CValidationState& state) = 0;\n+    };\n+\n+    //! Return Lock interface. Chain is locked when this is called, and\n+    //! unlocked when the returned interface is freed.\n+    virtual std::unique_ptr<Lock> lock(bool try_lock = false) = 0;\n+\n+    //! Return Lock interface assuming chain is already locked. This\n+    //! method is temporary and is only used in a few places to avoid changing\n+    //! behavior while code is transitioned to use the LockState interface.\n+    virtual std::unique_ptr<Lock> assumeLocked() = 0;\n+\n+    //! Return whether node has the block and optionally return block metadata or contents.\n+    virtual bool findBlock(const uint256& hash,\n+        CBlock* block = nullptr,\n+        int64_t* time = nullptr,\n+        int64_t* max_time = nullptr) = 0;\n+\n+    //! Estimate fraction of total transactions verified if blocks up to\n+    //! given height are verified.\n+    virtual double guessVerificationProgress(const uint256& block_hash) = 0;\n+\n+    //! Get virtual transaction size.\n+    virtual int64_t getVirtualTransactionSize(const CTransaction& tx) = 0;\n+\n+    //! Check if transaction is RBF opt in.\n+    virtual RBFTransactionState isRBFOptIn(const CTransaction& tx) = 0;\n+\n+    //! Check if transaction has descendants in mempool.\n+    virtual bool hasDescendantsInMempool(const uint256& txid) = 0;\n+\n+    //! Relay transaction.\n+    virtual bool relayTransaction(const uint256& txid) = 0;\n+\n+    //! Check if transaction is within chain limit.\n+    virtual bool transactionWithinChainLimit(const uint256& txid, size_t chain_limit) = 0;\n+\n+    //! Check chain limits.\n+    virtual bool checkChainLimits(CTransactionRef tx) = 0;\n+\n+    //! Estimate smart fee.\n+    virtual CFeeRate estimateSmartFee(int num_blocks, bool conservative, FeeCalculation* calc = nullptr) = 0;\n+\n+    //! Fee estimator max target.\n+    virtual int estimateMaxBlocks() = 0;\n+\n+    //! Pool min fee.\n+    virtual CFeeRate poolMinFee() = 0;\n+\n+    //! Check if pruning is enabled.\n+    virtual bool getPruneMode() = 0;\n+\n+    //! Check if p2p enabled.\n+    virtual bool p2pEnabled() = 0;\n+\n+    //! Get adjusted time.\n+    virtual int64_t getAdjustedTime() = 0;\n+\n+    //! Send init message.\n+    virtual void initMessage(const std::string& message) = 0;\n+\n+    //! Send init warning.\n+    virtual void initWarning(const std::string& message) = 0;\n+\n+    //! Send init error.\n+    virtual void initError(const std::string& message) = 0;\n+\n+    //! Generate blocks\n+    virtual UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbase_script,\n+        int num_blocks,\n+        uint64_t max_tries,\n+        bool keep_script) = 0;\n+\n+    //! Parse confirm target.\n+    virtual unsigned int parseConfirmTarget(const UniValue& value) = 0;\n+\n+    //! Chain notifications.\n+    class Notifications\n+    {\n+    public:\n+        virtual ~Notifications() {}\n+        virtual void TransactionAddedToMempool(const CTransactionRef& tx) {}\n+        virtual void TransactionRemovedFromMempool(const CTransactionRef& ptx) {}\n+        virtual void BlockConnected(const CBlock& block,\n+            const uint256& block_hash,\n+            const std::vector<CTransactionRef>& tx_conflicted)\n+        {\n+        }\n+        virtual void BlockDisconnected(const CBlock& block) {}\n+        virtual void ChainStateFlushed(const CBlockLocator& locator) {}\n+        virtual void Inventory(const uint256& hash) {}\n+        virtual void ResendWalletTransactions(int64_t best_block_time) {}\n+    };\n+\n+    //! Register handler for notifications.\n+    virtual std::unique_ptr<Handler> handleNotifications(Notifications& notifications) = 0;\n+\n+    //! Wait for pending notifications to be handled.\n+    virtual void waitForNotifications() = 0;\n+\n+    //! Interface to let node manage chain clients (wallets, or maybe tools for\n+    //! monitoring and analysis in the future).\n+    class Client\n+    {\n+    public:\n+        virtual ~Client() {}\n+\n+        //! Register rpcs.\n+        virtual void registerRpcs() = 0;\n+\n+        //! Prepare for execution, loading any needed state.\n+        virtual bool prepare() = 0;\n+\n+        //! Start client execution and provide a scheduler. (Scheduler is",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186132129",
      "id" : 186132129,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjEzMjEyOQ==",
      "original_commit_id" : "af8f8087699c30ec83995c54112955253bcaba84",
      "original_position" : 220,
      "path" : "src/interfaces/chain.h",
      "position" : null,
      "pull_request_review_id" : 117658720,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186132129",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186174271"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186174271"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I find the name of this class quite confusing, since it's not actually a lock. How about renaming this to `LockedChain` and renaming `LockingStateImpl` to `ChainLockImpl`?",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-04T18:16:35Z",
      "diff_hunk" : "@@ -0,0 +1,251 @@\n+#ifndef BITCOIN_INTERFACES_CHAIN_H\n+#define BITCOIN_INTERFACES_CHAIN_H\n+\n+#include <optional.h>               // For Optional and nullopt\n+#include <policy/rbf.h>             // For RBFTransactionState\n+#include <primitives/transaction.h> // For CTransactionRef\n+\n+#include <memory>\n+#include <stddef.h>\n+#include <stdint.h>\n+#include <string>\n+#include <vector>\n+\n+class CBlock;\n+class CRPCCommand;\n+class CReserveScript;\n+class CScheduler;\n+class CValidationState;\n+class UniValue;\n+class uint256;\n+struct CBlockLocator;\n+struct FeeCalculation;\n+\n+namespace interfaces {\n+\n+class Handler;\n+\n+//! Interface for giving wallet processes access to blockchain state.\n+class Chain\n+{\n+public:\n+    virtual ~Chain() {}\n+\n+    //! Interface for querying locked chain state, used by legacy code that\n+    //! assumes state won't change between calls. New code should avoid using\n+    //! the Lock interface and instead call higher-level Chain methods\n+    //! that return more information so the chain doesn't need to stay locked\n+    //! between calls.\n+    class Lock",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186174271",
      "id" : 186174271,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjE3NDI3MQ==",
      "original_commit_id" : "af8f8087699c30ec83995c54112955253bcaba84",
      "original_position" : 39,
      "path" : "src/interfaces/chain.h",
      "position" : 44,
      "pull_request_review_id" : 117658720,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186174271",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186174854"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186174854"
         }
      },
      "author_association" : "MEMBER",
      "body" : "There are 4 of these `Temporary. Removed in upcoming lock cleanup` comments. Sorry if I missed the answer to this, but what's the plan for removing them?",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-04T18:18:55Z",
      "diff_hunk" : "@@ -3388,7 +3417,8 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     CAmount nFeeOut;\n     std::string strFailReason;\n \n-    if (!pwallet->FundTransaction(tx, nFeeOut, changePosition, strFailReason, lockUnspents, setSubtractFeeFromOutputs, coinControl)) {\n+    auto locked_chain = pwallet->chain().assumeLocked();  // Temporary. Removed in upcoming lock cleanup",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186174854",
      "id" : 186174854,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjE3NDg1NA==",
      "original_commit_id" : "af8f8087699c30ec83995c54112955253bcaba84",
      "original_position" : 782,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 117658720,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186174854",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186179348"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186179348"
         }
      },
      "author_association" : "MEMBER",
      "body" : "s/optinal/optional",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-04T18:35:39Z",
      "diff_hunk" : "@@ -0,0 +1,251 @@\n+#ifndef BITCOIN_INTERFACES_CHAIN_H\n+#define BITCOIN_INTERFACES_CHAIN_H\n+\n+#include <optional.h>               // For Optional and nullopt\n+#include <policy/rbf.h>             // For RBFTransactionState\n+#include <primitives/transaction.h> // For CTransactionRef\n+\n+#include <memory>\n+#include <stddef.h>\n+#include <stdint.h>\n+#include <string>\n+#include <vector>\n+\n+class CBlock;\n+class CRPCCommand;\n+class CReserveScript;\n+class CScheduler;\n+class CValidationState;\n+class UniValue;\n+class uint256;\n+struct CBlockLocator;\n+struct FeeCalculation;\n+\n+namespace interfaces {\n+\n+class Handler;\n+\n+//! Interface for giving wallet processes access to blockchain state.\n+class Chain\n+{\n+public:\n+    virtual ~Chain() {}\n+\n+    //! Interface for querying locked chain state, used by legacy code that\n+    //! assumes state won't change between calls. New code should avoid using\n+    //! the Lock interface and instead call higher-level Chain methods\n+    //! that return more information so the chain doesn't need to stay locked\n+    //! between calls.\n+    class Lock\n+    {\n+    public:\n+        virtual ~Lock() {}\n+\n+        //! Get current chain height, not including genesis block (returns 0 if\n+        //! chain only contains genesis block, nothing if chain does not contain\n+        //! any blocks).\n+        virtual Optional<int> getHeight() = 0;\n+\n+        //! Get block height above genesis block. Returns 0 for genesis block,\n+        //! for following block, and so on. Returns nothing for a block not\n+        //! included in the current chain.\n+        virtual Optional<int> getBlockHeight(const uint256& hash) = 0;\n+\n+        //! Get block depth. Returns 1 for chain tip, 2 for preceding block, and\n+        //! so on. Returns 0 for a block not included in the current chain.\n+        virtual int getBlockDepth(const uint256& hash) = 0;\n+\n+        //! Get block hash.\n+        virtual uint256 getBlockHash(int height) = 0;\n+\n+        //! Get block time.\n+        virtual int64_t getBlockTime(int height) = 0;\n+\n+        //! Get block median time past.\n+        virtual int64_t getBlockMedianTimePast(int height) = 0;\n+\n+        //! Check if block is empty.\n+        virtual bool blockHasTransactions(int height) = 0;\n+\n+        //! Return height of earliest block in chain with timestamp equal or\n+        //! greater than the given time, or nothing if there is no block with a\n+        //! high enough timestamp.\n+        virtual Optional<int> findEarliestAtLeast(int64_t time) = 0;\n+\n+        //! Return height of last block in chain with timestamp less than the\n+        //! given, and height less than or equal to the given, or nothing if\n+        //! there is no such block.\n+        virtual Optional<int> findLastBefore(int64_t time, int start_height) = 0;\n+\n+        //! Return height of last block in the specified range which is pruned, or\n+        //! nothing if no block in the range is pruned. Range is inclusive.\n+        virtual Optional<int> findPruned(int start_height = 0, Optional<int> stop_height = nullopt) = 0;\n+\n+        //! Return height of the highest block on the chain that is an ancestor\n+        //! of the specified block. Also return the height of the specified\n+        //! block as an optinal output parameter.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186179348",
      "id" : 186179348,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjE3OTM0OA==",
      "original_commit_id" : "af8f8087699c30ec83995c54112955253bcaba84",
      "original_position" : 86,
      "path" : "src/interfaces/chain.h",
      "position" : null,
      "pull_request_review_id" : 117658720,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186179348",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186181022"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186181022"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Comment is wrong. Needs to be updated to `Should be called with non-zero block_hash and posInBlock...`",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-04T18:42:13Z",
      "diff_hunk" : "@@ -698,7 +697,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n \n     /* Used by TransactionAddedToMemorypool/BlockConnected/Disconnected.\n      * Should be called with pindexBlock and posInBlock if this is for a transaction that is included in a block. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186181022",
      "id" : 186181022,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjE4MTAyMg==",
      "original_commit_id" : "af8f8087699c30ec83995c54112955253bcaba84",
      "original_position" : 90,
      "path" : "src/wallet/wallet.h",
      "position" : null,
      "pull_request_review_id" : 117658720,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186181022",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186181393"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186181393"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Remove comment",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-04T18:43:37Z",
      "diff_hunk" : "@@ -744,7 +751,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n      *\n      * Protected by cs_main (see BlockUntilSyncedToCurrentChain)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186181393",
      "id" : 186181393,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjE4MTM5Mw==",
      "original_commit_id" : "af8f8087699c30ec83995c54112955253bcaba84",
      "original_position" : 120,
      "path" : "src/wallet/wallet.h",
      "position" : null,
      "pull_request_review_id" : 117658720,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186181393",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186216539"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186216539"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The \"missing block hash\" and \"missing block time\" outputs here are a change in behaviour (and could potentially break clients using the dumpwallet API)",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-04T20:46:48Z",
      "diff_hunk" : "@@ -747,8 +756,9 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     // produce output\n     file << strprintf(\"# Wallet dump created by Bitcoin %s\\n\", CLIENT_BUILD);\n     file << strprintf(\"# * Created on %s\\n\", FormatISO8601DateTime(GetTime()));\n-    file << strprintf(\"# * Best block at time of backup was %i (%s),\\n\", chainActive.Height(), chainActive.Tip()->GetBlockHash().ToString());\n-    file << strprintf(\"#   mined on %s\\n\", FormatISO8601DateTime(chainActive.Tip()->GetBlockTime()));\n+    const Optional<int> tip_height = locked_chain->getHeight();\n+    file << strprintf(\"# * Best block at time of backup was %i (%s),\\n\", tip_height ? *tip_height : -1, tip_height ? locked_chain->getBlockHash(*tip_height).ToString() : \"(missing block hash)\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186216539",
      "id" : 186216539,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjIxNjUzOQ==",
      "original_commit_id" : "af8f8087699c30ec83995c54112955253bcaba84",
      "original_position" : 158,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 117658720,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186216539",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186225645"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186225645"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Can you use `locked_chain->getDepth(blockId)` here?",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-04T21:26:29Z",
      "diff_hunk" : "@@ -2214,39 +2227,41 @@ UniValue listsinceblock(const JSONRPCRequest& request)\n \n     bool include_removed = (request.params[3].isNull() || request.params[3].get_bool());\n \n-    int depth = pindex ? (1 + chainActive.Height() - pindex->nHeight) : -1;\n+    const Optional<int> tip_height = locked_chain->getHeight();\n+    int depth = tip_height && height ? (1 + *tip_height - *height) : -1;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186225645",
      "id" : 186225645,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjIyNTY0NQ==",
      "original_commit_id" : "af8f8087699c30ec83995c54112955253bcaba84",
      "original_position" : 530,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 406,
      "pull_request_review_id" : 117658720,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186225645",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186272603"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186272603"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r185320554\r\n\r\n> Should be \"1 for following block ...\"?\r\n\r\n Thanks, fixed in 7f2f5cc41aa05e6f2ad7bfa74173c11136b67cf9",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-05T21:28:20Z",
      "diff_hunk" : "@@ -24,6 +30,62 @@ class Chain\n     {\n     public:\n         virtual ~Lock() {}\n+\n+        //! Get current chain height, not including genesis block (returns 0 if\n+        //! chain only contains genesis block, nothing if chain does not contain\n+        //! any blocks).\n+        virtual Optional<int> getHeight() = 0;\n+\n+        //! Get block height above genesis block. Returns 0 for genesis block,\n+        //! for following block, and so on. Returns nothing for a block not",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186272603",
      "id" : 186272603,
      "in_reply_to_id" : 185320554,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjI3MjYwMw==",
      "original_commit_id" : "ba1e24b718d1db1c2ed06f88087e28994248b1c7",
      "original_position" : 29,
      "path" : "src/interfaces/chain.h",
      "position" : null,
      "pull_request_review_id" : 117825376,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186272603",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186272611"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186272611"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r185321164\r\n\r\n> optinal\r\n\r\nFixed in 6bb7af9b1e41f833389f6d4d7ceb02b947dbfd07",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-05T21:28:34Z",
      "diff_hunk" : "@@ -24,6 +30,62 @@ class Chain\n     {\n     public:\n         virtual ~Lock() {}\n+\n+        //! Get current chain height, not including genesis block (returns 0 if\n+        //! chain only contains genesis block, nothing if chain does not contain\n+        //! any blocks).\n+        virtual Optional<int> getHeight() = 0;\n+\n+        //! Get block height above genesis block. Returns 0 for genesis block,\n+        //! for following block, and so on. Returns nothing for a block not\n+        //! included in the current chain.\n+        virtual Optional<int> getBlockHeight(const uint256& hash) = 0;\n+\n+        //! Get block depth. Returns 1 for chain tip, 2 for preceding block, and\n+        //! so on. Returns 0 for a block not included in the current chain.\n+        virtual int getBlockDepth(const uint256& hash) = 0;\n+\n+        //! Get block hash.\n+        virtual uint256 getBlockHash(int height) = 0;\n+\n+        //! Get block time.\n+        virtual int64_t getBlockTime(int height) = 0;\n+\n+        //! Get block median time past.\n+        virtual int64_t getBlockMedianTimePast(int height) = 0;\n+\n+        //! Check if block is empty.\n+        virtual bool blockHasTransactions(int height) = 0;\n+\n+        //! Return height of earliest block in chain with timestamp equal or\n+        //! greater than the given time, or nothing if there is no block with a\n+        //! high enough timestamp.\n+        virtual Optional<int> findEarliestAtLeast(int64_t time) = 0;\n+\n+        //! Return height of last block in chain with timestamp less than the\n+        //! given, and height less than or equal to the given, or nothing if\n+        //! there is no such block.\n+        virtual Optional<int> findLastBefore(int64_t time, int start_height) = 0;\n+\n+        //! Return height of last block in the specified range which is pruned, or\n+        //! nothing if no block in the range is pruned. Range is inclusive.\n+        virtual Optional<int> findPruned(int start_height = 0, Optional<int> stop_height = nullopt) = 0;\n+\n+        //! Return height of the highest block on the chain that is an ancestor\n+        //! of the specified block. Also return the height of the specified\n+        //! block as an optinal output parameter.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186272611",
      "id" : 186272611,
      "in_reply_to_id" : 185321164,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjI3MjYxMQ==",
      "original_commit_id" : "ba1e24b718d1db1c2ed06f88087e28994248b1c7",
      "original_position" : 65,
      "path" : "src/interfaces/chain.h",
      "position" : null,
      "pull_request_review_id" : 117825376,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186272611",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186272614"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186272614"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186179348\r\n\r\n> s/optinal/optional\r\n\r\nFixed in 6bb7af9b1e41f833389f6d4d7ceb02b947dbfd07",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-05T21:28:42Z",
      "diff_hunk" : "@@ -0,0 +1,251 @@\n+#ifndef BITCOIN_INTERFACES_CHAIN_H\n+#define BITCOIN_INTERFACES_CHAIN_H\n+\n+#include <optional.h>               // For Optional and nullopt\n+#include <policy/rbf.h>             // For RBFTransactionState\n+#include <primitives/transaction.h> // For CTransactionRef\n+\n+#include <memory>\n+#include <stddef.h>\n+#include <stdint.h>\n+#include <string>\n+#include <vector>\n+\n+class CBlock;\n+class CRPCCommand;\n+class CReserveScript;\n+class CScheduler;\n+class CValidationState;\n+class UniValue;\n+class uint256;\n+struct CBlockLocator;\n+struct FeeCalculation;\n+\n+namespace interfaces {\n+\n+class Handler;\n+\n+//! Interface for giving wallet processes access to blockchain state.\n+class Chain\n+{\n+public:\n+    virtual ~Chain() {}\n+\n+    //! Interface for querying locked chain state, used by legacy code that\n+    //! assumes state won't change between calls. New code should avoid using\n+    //! the Lock interface and instead call higher-level Chain methods\n+    //! that return more information so the chain doesn't need to stay locked\n+    //! between calls.\n+    class Lock\n+    {\n+    public:\n+        virtual ~Lock() {}\n+\n+        //! Get current chain height, not including genesis block (returns 0 if\n+        //! chain only contains genesis block, nothing if chain does not contain\n+        //! any blocks).\n+        virtual Optional<int> getHeight() = 0;\n+\n+        //! Get block height above genesis block. Returns 0 for genesis block,\n+        //! for following block, and so on. Returns nothing for a block not\n+        //! included in the current chain.\n+        virtual Optional<int> getBlockHeight(const uint256& hash) = 0;\n+\n+        //! Get block depth. Returns 1 for chain tip, 2 for preceding block, and\n+        //! so on. Returns 0 for a block not included in the current chain.\n+        virtual int getBlockDepth(const uint256& hash) = 0;\n+\n+        //! Get block hash.\n+        virtual uint256 getBlockHash(int height) = 0;\n+\n+        //! Get block time.\n+        virtual int64_t getBlockTime(int height) = 0;\n+\n+        //! Get block median time past.\n+        virtual int64_t getBlockMedianTimePast(int height) = 0;\n+\n+        //! Check if block is empty.\n+        virtual bool blockHasTransactions(int height) = 0;\n+\n+        //! Return height of earliest block in chain with timestamp equal or\n+        //! greater than the given time, or nothing if there is no block with a\n+        //! high enough timestamp.\n+        virtual Optional<int> findEarliestAtLeast(int64_t time) = 0;\n+\n+        //! Return height of last block in chain with timestamp less than the\n+        //! given, and height less than or equal to the given, or nothing if\n+        //! there is no such block.\n+        virtual Optional<int> findLastBefore(int64_t time, int start_height) = 0;\n+\n+        //! Return height of last block in the specified range which is pruned, or\n+        //! nothing if no block in the range is pruned. Range is inclusive.\n+        virtual Optional<int> findPruned(int start_height = 0, Optional<int> stop_height = nullopt) = 0;\n+\n+        //! Return height of the highest block on the chain that is an ancestor\n+        //! of the specified block. Also return the height of the specified\n+        //! block as an optinal output parameter.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186272614",
      "id" : 186272614,
      "in_reply_to_id" : 186179348,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjI3MjYxNA==",
      "original_commit_id" : "af8f8087699c30ec83995c54112955253bcaba84",
      "original_position" : 86,
      "path" : "src/interfaces/chain.h",
      "position" : null,
      "pull_request_review_id" : 117825376,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186272614",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186272619"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186272619"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r185077211\r\n\r\n> I think we'll need to make an equivalent change in addressbooktests.cpp as well.\r\n\r\nThanks, moved this change to the right commit (it was in c917d976c039c3bb79bb4a1b7aff72117b066597 instead of a0279e40745dfb8692e92c5cac0848a25b37f930)",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-05T21:28:53Z",
      "diff_hunk" : "@@ -144,7 +144,9 @@ void TestGUI()\n     for (int i = 0; i < 5; ++i) {\n         test.CreateAndProcessBlock({}, GetScriptForRawPubKey(test.coinbaseKey.GetPubKey()));\n     }\n-    CWallet wallet(\"mock\", WalletDatabase::CreateMock());\n+    auto node = interfaces::MakeNode();\n+    node->parseParameters(0, nullptr);\n+    CWallet wallet(&node->getChain(), \"mock\", WalletDatabase::CreateMock());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186272619",
      "id" : 186272619,
      "in_reply_to_id" : 185077211,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjI3MjYxOQ==",
      "original_commit_id" : "a0279e40745dfb8692e92c5cac0848a25b37f930",
      "original_position" : 7,
      "path" : "src/qt/test/wallettests.cpp",
      "position" : null,
      "pull_request_review_id" : 117825376,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186272619",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186272655"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186272655"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r185327873\r\n\r\n> Are the UniValue calls necessary?\r\n\r\nGood catch, removed in 63dd8abdf822026a4a93356546ff1220e6c00e9e",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-05T21:30:24Z",
      "diff_hunk" : "@@ -3725,58 +3724,53 @@ UniValue rescanblockchain(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Wallet is currently rescanning. Abort existing rescan or wait.\");\n     }\n \n-    CBlockIndex *pindexStart = nullptr;\n-    CBlockIndex *pindexStop = nullptr;\n-    CBlockIndex *pChainTip = nullptr;\n+    int start_height = 0;\n+    Optional<int> stop_height;\n+    Optional<int> tip_height;\n+    uint256 start_block, stop_block;\n     {\n         auto locked_chain = pwallet->chain().lock();\n-        pindexStart = chainActive.Genesis();\n-        pChainTip = chainActive.Tip();\n+        tip_height = locked_chain->getHeight();\n \n         if (!request.params[0].isNull()) {\n-            pindexStart = chainActive[request.params[0].get_int()];\n-            if (!pindexStart) {\n+            start_height = request.params[0].get_int();\n+            if (start_height < 0 || !tip_height || start_height > *tip_height) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid start_height\");\n             }\n         }\n \n         if (!request.params[1].isNull()) {\n-            pindexStop = chainActive[request.params[1].get_int()];\n-            if (!pindexStop) {\n+            stop_height = request.params[1].get_int();\n+            if (*stop_height < 0 || !tip_height || *stop_height > *tip_height) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid stop_height\");\n             }\n-            else if (pindexStop->nHeight < pindexStart->nHeight) {\n+            else if (*stop_height < start_height) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"stop_height must be greater than start_height\");\n             }\n         }\n-    }\n \n-    // We can't rescan beyond non-pruned blocks, stop and throw an error\n-    if (fPruneMode) {\n-        auto locked_chain = pwallet->chain().lock();\n-        CBlockIndex *block = pindexStop ? pindexStop : pChainTip;\n-        while (block && block->nHeight >= pindexStart->nHeight) {\n-            if (!(block->nStatus & BLOCK_HAVE_DATA)) {\n-                throw JSONRPCError(RPC_MISC_ERROR, \"Can't rescan beyond pruned data. Use RPC call getblockchaininfo to determine your pruned height.\");\n-            }\n-            block = block->pprev;\n+        // We can't rescan beyond non-pruned blocks, stop and throw an error\n+        if (locked_chain->findPruned(start_height, stop_height)) {\n+            throw JSONRPCError(RPC_MISC_ERROR, \"Can't rescan beyond pruned data. Use RPC call getblockchaininfo to determine your pruned height.\");\n+        }\n+\n+        if (tip_height) {\n+            start_block = locked_chain->getBlockHash(start_height);\n+            stop_block = locked_chain->getBlockHash(stop_height ? *stop_height : *tip_height);\n         }\n     }\n \n-    CBlockIndex *stopBlock = pwallet->ScanForWalletTransactions(pindexStart, pindexStop, reserver, true);\n-    if (!stopBlock) {\n+    if (pwallet->ScanForWalletTransactions(start_block, stop_block, reserver, true).IsNull()) {\n         if (pwallet->IsAbortingRescan()) {\n             throw JSONRPCError(RPC_MISC_ERROR, \"Rescan aborted.\");\n         }\n-        // if we got a nullptr returned, ScanForWalletTransactions did rescan up to the requested stopindex\n-        stopBlock = pindexStop ? pindexStop : pChainTip;\n     }\n     else {\n         throw JSONRPCError(RPC_MISC_ERROR, \"Rescan failed. Potentially corrupted data files.\");\n     }\n     UniValue response(UniValue::VOBJ);\n-    response.pushKV(\"start_height\", pindexStart->nHeight);\n-    response.pushKV(\"stop_height\", stopBlock->nHeight);\n+    response.pushKV(\"start_height\", start_height);\n+    response.pushKV(\"stop_height\", stop_height ? UniValue(*stop_height) : tip_height ? UniValue(*tip_height): UniValue());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186272655",
      "id" : 186272655,
      "in_reply_to_id" : 185327873,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjI3MjY1NQ==",
      "original_commit_id" : "ba1e24b718d1db1c2ed06f88087e28994248b1c7",
      "original_position" : 158,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 117825376,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186272655",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186272662"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186272662"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r185796547\r\n\r\n> transac<tions\r\n\r\nFixed in 62f15da95f7abb4ae0a02517885d7fb69097f698",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-05T21:30:40Z",
      "diff_hunk" : "@@ -1699,108 +1694,126 @@ int64_t CWallet::RescanFromTime(int64_t startTime, const WalletRescanReserver& r\n     // Find starting block. May be null if nCreateTime is greater than the\n     // highest blockchain timestamp, in which case there is nothing that needs\n     // to be scanned.\n-    CBlockIndex* startBlock = nullptr;\n+    uint256 start_block;\n     {\n         auto locked_chain = m_chain->lock();\n-        startBlock = chainActive.FindEarliestAtLeast(startTime - TIMESTAMP_WINDOW);\n-        LogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, startBlock ? chainActive.Height() - startBlock->nHeight + 1 : 0);\n-    }\n-\n-    if (startBlock) {\n-        const CBlockIndex* const failedBlock = ScanForWalletTransactions(startBlock, nullptr, reserver, update);\n-        if (failedBlock) {\n-            return failedBlock->GetBlockTimeMax() + TIMESTAMP_WINDOW + 1;\n+        const Optional<int> start_height = locked_chain->findEarliestAtLeast(startTime - TIMESTAMP_WINDOW);\n+        const Optional<int> tip_height = locked_chain->getHeight();\n+        LogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, tip_height && start_height ? *tip_height - *start_height + 1 : 0);\n+        if (start_height) start_block = locked_chain->getBlockHash(*start_height);\n+    }\n+\n+    if (!start_block.IsNull()) {\n+        uint256 failed_block = ScanForWalletTransactions(start_block, {} /* stop block */, reserver, update);\n+        if (!failed_block.IsNull()) {\n+            int64_t time_max;\n+            if (!m_chain->findBlock(failed_block, nullptr /* CBlock */, nullptr /* time */, &time_max)) {\n+                throw std::logic_error(\"ScanForWalletTransactions returned invalid block hash\");\n+            }\n+            return time_max + TIMESTAMP_WINDOW + 1;\n         }\n     }\n     return startTime;\n }\n \n /**\n- * Scan the block chain (starting in pindexStart) for transactions\n+ * Scan the block chain (starting in start_block) for transactions\n  * from or to us. If fUpdate is true, found transactions that already\n  * exist in the wallet will be updated.\n  *\n  * Returns null if scan was successful. Otherwise, if a complete rescan was not\n  * possible (due to pruning or corruption), returns pointer to the most recent\n  * block that could not be scanned.\n  *\n- * If pindexStop is not a nullptr, the scan will stop at the block-index\n- * defined by pindexStop\n+ * If stop_block is not null, the scan will stop at the block-index\n+ * defined by stop_block\n  *\n- * Caller needs to make sure pindexStop (and the optional pindexStart) are on\n+ * Caller needs to make sure stop_block (and the optional start_block) are on\n  * the main chain after to the addition of any new keys you want to detect\n  * transactions for.\n  */\n-CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, CBlockIndex* pindexStop, const WalletRescanReserver &reserver, bool fUpdate)\n+uint256 CWallet::ScanForWalletTransactions(const uint256& start_block, const uint256& stop_block, const WalletRescanReserver &reserver, bool fUpdate)\n {\n     int64_t nNow = GetTime();\n     const CChainParams& chainParams = Params();\n \n     assert(reserver.isReserved());\n-    if (pindexStop) {\n-        assert(pindexStop->nHeight >= pindexStart->nHeight);\n-    }\n \n-    CBlockIndex* pindex = pindexStart;\n-    CBlockIndex* ret = nullptr;\n+    uint256 block_hash = start_block;\n+    uint256 ret;\n \n-    if (pindex) LogPrintf(\"Rescan started from block %d...\\n\", pindex->nHeight);\n+    LogPrintf(\"Rescan started from block %s...\\n\", start_block.ToString());\n \n     {\n         fAbortRescan = false;\n         ShowProgress(_(\"Rescanning...\"), 0); // show rescan progress in GUI as dialog or on splashscreen, if -rescan on startup\n-        CBlockIndex* tip = nullptr;\n+        uint256 tip_hash;\n+        Optional<int> block_height;\n         double dProgressStart;\n         double dProgressTip;\n         {\n             auto locked_chain = m_chain->lock();\n-            tip = chainActive.Tip();\n-            dProgressStart = GuessVerificationProgress(chainParams.TxData(), pindex);\n-            dProgressTip = GuessVerificationProgress(chainParams.TxData(), tip);\n+            if (Optional<int> tip_height = locked_chain->getHeight()) {\n+                tip_hash = locked_chain->getBlockHash(*tip_height);\n+            }\n+            block_height = locked_chain->getBlockHeight(block_hash);\n+            dProgressStart = m_chain->guessVerificationProgress(block_hash);\n+            dProgressTip = m_chain->guessVerificationProgress(tip_hash);\n         }\n         double gvp = dProgressStart;\n-        while (pindex && !fAbortRescan)\n+        while (block_height && !fAbortRescan)\n         {\n-            if (pindex->nHeight % 100 == 0 && dProgressTip - dProgressStart > 0.0) {\n+            if (*block_height % 100 == 0 && dProgressTip - dProgressStart > 0.0) {\n                 ShowProgress(_(\"Rescanning...\"), std::max(1, std::min(99, (int)((gvp - dProgressStart) / (dProgressTip - dProgressStart) * 100))));\n             }\n             if (GetTime() >= nNow + 60) {\n                 nNow = GetTime();\n-                LogPrintf(\"Still rescanning. At block %d. Progress=%f\\n\", pindex->nHeight, gvp);\n+                LogPrintf(\"Still rescanning. At block %d. Progress=%f\\n\", *block_height, gvp);\n             }\n \n             CBlock block;\n-            if (ReadBlockFromDisk(block, pindex, Params().GetConsensus())) {\n+            if (m_chain->findBlock(block_hash, &block) && !block.IsNull()) {\n                 auto locked_chain = m_chain->lock();\n                 LOCK(cs_wallet);\n-                if (pindex && !chainActive.Contains(pindex)) {\n+                if (!locked_chain->getBlockHeight(block_hash)) {\n                     // Abort scan if current block is no longer active, to prevent\n-                    // marking transactions as coming from the wrong block.\n-                    ret = pindex;\n+                    // marking transac<tions as coming from the wrong block.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186272662",
      "id" : 186272662,
      "in_reply_to_id" : 185796547,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjI3MjY2Mg==",
      "original_commit_id" : "7f087936082170018b189f19adb7d789f4c2969d",
      "original_position" : 227,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 117825376,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186272662",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186272672"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186272672"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r185886977\r\n\r\n> Any reason you don't just want to do for (const CRPCCommand* command : m_commands) { ... }\r\n\r\nHaving access to the iterator makes it possible to detect the last loop iteration and let `RPC_WALLET_NOT_FOUND` exceptions from the last wallet process get reraised instead of being suppressed.",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-05T21:31:02Z",
      "diff_hunk" : "@@ -286,8 +301,106 @@ class ChainImpl : public Chain\n         return MakeUnique<HandlerImpl>(notifications);\n     }\n     void waitForNotifications() override { SyncWithValidationInterfaceQueue(); }\n+    std::unique_ptr<Handler> handleRpc(const CRPCCommand& command) override;\n+\n+    //! Map of RPC method name to forwarder. If multiple clients provide\n+    //! implementations of the same RPC method, the RPC forwarder can dispatch\n+    //! between them.\n+    class RpcForwarder;\n+    std::map<Ref<const std::string>, RpcForwarder> m_rpc_forwarders;\n+};\n+\n+//! Forwarder for one RPC method.\n+class ChainImpl::RpcForwarder\n+{\n+public:\n+    RpcForwarder(const CRPCCommand& command) : m_command(command)\n+    {\n+        m_command.actor = [this](const JSONRPCRequest& request) { return forwardRequest(request); };\n+    }\n+\n+    bool registerForwarder() { return ::tableRPC.appendCommand(m_command.name, &m_command); }\n+\n+    void addCommand(const CRPCCommand& command) { m_commands.emplace_back(&command); }\n+\n+    void removeCommand(const CRPCCommand& command)\n+    {\n+        m_commands.erase(std::remove(m_commands.begin(), m_commands.end(), &command));\n+    }\n+\n+    UniValue forwardRequest(const JSONRPCRequest& request) const\n+    {\n+        // Simple forwarding of RPC requests. This just sends the request to the\n+        // first client that registered a handler for the RPC method. If the\n+        // handler throws a wallet not found exception, this will retry\n+        // forwarding to the next handler (if any).\n+        //\n+        // This forwarding mechanism could be made more efficient (peeking\n+        // inside the RPC request for wallet name and sending it directly to the\n+        // right handler), but right now all wallets are in-process so there is\n+        // only ever a single handler, and in the future it isn't clear if we\n+        // will want we want to keep forwarding RPCs at all (clients could just\n+        // listen for their own RPCs).\n+        for (auto it = m_commands.begin(); it != m_commands.end();) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186272672",
      "id" : 186272672,
      "in_reply_to_id" : 185886977,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjI3MjY3Mg==",
      "original_commit_id" : "7a6069a3c51582f32fa1ce9bed6c3c905b5bfd0c",
      "original_position" : 82,
      "path" : "src/interfaces/chain.cpp",
      "position" : 388,
      "pull_request_review_id" : 117825376,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186272672",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186272697"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186272697"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186174271\r\n\r\n> I find the name of this class quite confusing, since it's not actually a lock. How about renaming this to LockedChain and renaming LockingStateImpl to ChainLockImpl?\r\n\r\nIt is really a lock, analogous to `std::unique_lock` (and the implementation will even inherit from a class called `UniqueLock` after #11599 renames `CCriticalBlock` to `UniqueLock`).\r\n\r\nI think `LockedChain` would be a good name if this were not an inner class, but `Chain::Lock` is less redundant than `Chain::LockedChain` (or `Chain::LockedState`, which was what this was called before https://github.com/bitcoin/bitcoin/pull/10973#discussion_r137139176).\r\n\r\n`LockingStateImpl` is temporary (it will go away when `assumeLocked` is removed), and it's also internal to chain.cpp, so I can rename it, but I don't think should be too much concern about it.",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-05T21:31:40Z",
      "diff_hunk" : "@@ -0,0 +1,251 @@\n+#ifndef BITCOIN_INTERFACES_CHAIN_H\n+#define BITCOIN_INTERFACES_CHAIN_H\n+\n+#include <optional.h>               // For Optional and nullopt\n+#include <policy/rbf.h>             // For RBFTransactionState\n+#include <primitives/transaction.h> // For CTransactionRef\n+\n+#include <memory>\n+#include <stddef.h>\n+#include <stdint.h>\n+#include <string>\n+#include <vector>\n+\n+class CBlock;\n+class CRPCCommand;\n+class CReserveScript;\n+class CScheduler;\n+class CValidationState;\n+class UniValue;\n+class uint256;\n+struct CBlockLocator;\n+struct FeeCalculation;\n+\n+namespace interfaces {\n+\n+class Handler;\n+\n+//! Interface for giving wallet processes access to blockchain state.\n+class Chain\n+{\n+public:\n+    virtual ~Chain() {}\n+\n+    //! Interface for querying locked chain state, used by legacy code that\n+    //! assumes state won't change between calls. New code should avoid using\n+    //! the Lock interface and instead call higher-level Chain methods\n+    //! that return more information so the chain doesn't need to stay locked\n+    //! between calls.\n+    class Lock",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186272697",
      "id" : 186272697,
      "in_reply_to_id" : 186174271,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjI3MjY5Nw==",
      "original_commit_id" : "af8f8087699c30ec83995c54112955253bcaba84",
      "original_position" : 39,
      "path" : "src/interfaces/chain.h",
      "position" : 44,
      "pull_request_review_id" : 117825376,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186272697",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186272710"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186272710"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186132129\r\n\r\n> I think the (Scheduler is ignored if client is out-of-process). comment can be saved for #10102\r\n\r\nSure, removed in 0d9ba1a093e30d77348efc55f0ff6599cef76621.",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-05T21:32:05Z",
      "diff_hunk" : "@@ -0,0 +1,251 @@\n+#ifndef BITCOIN_INTERFACES_CHAIN_H\n+#define BITCOIN_INTERFACES_CHAIN_H\n+\n+#include <optional.h>               // For Optional and nullopt\n+#include <policy/rbf.h>             // For RBFTransactionState\n+#include <primitives/transaction.h> // For CTransactionRef\n+\n+#include <memory>\n+#include <stddef.h>\n+#include <stdint.h>\n+#include <string>\n+#include <vector>\n+\n+class CBlock;\n+class CRPCCommand;\n+class CReserveScript;\n+class CScheduler;\n+class CValidationState;\n+class UniValue;\n+class uint256;\n+struct CBlockLocator;\n+struct FeeCalculation;\n+\n+namespace interfaces {\n+\n+class Handler;\n+\n+//! Interface for giving wallet processes access to blockchain state.\n+class Chain\n+{\n+public:\n+    virtual ~Chain() {}\n+\n+    //! Interface for querying locked chain state, used by legacy code that\n+    //! assumes state won't change between calls. New code should avoid using\n+    //! the Lock interface and instead call higher-level Chain methods\n+    //! that return more information so the chain doesn't need to stay locked\n+    //! between calls.\n+    class Lock\n+    {\n+    public:\n+        virtual ~Lock() {}\n+\n+        //! Get current chain height, not including genesis block (returns 0 if\n+        //! chain only contains genesis block, nothing if chain does not contain\n+        //! any blocks).\n+        virtual Optional<int> getHeight() = 0;\n+\n+        //! Get block height above genesis block. Returns 0 for genesis block,\n+        //! for following block, and so on. Returns nothing for a block not\n+        //! included in the current chain.\n+        virtual Optional<int> getBlockHeight(const uint256& hash) = 0;\n+\n+        //! Get block depth. Returns 1 for chain tip, 2 for preceding block, and\n+        //! so on. Returns 0 for a block not included in the current chain.\n+        virtual int getBlockDepth(const uint256& hash) = 0;\n+\n+        //! Get block hash.\n+        virtual uint256 getBlockHash(int height) = 0;\n+\n+        //! Get block time.\n+        virtual int64_t getBlockTime(int height) = 0;\n+\n+        //! Get block median time past.\n+        virtual int64_t getBlockMedianTimePast(int height) = 0;\n+\n+        //! Check if block is empty.\n+        virtual bool blockHasTransactions(int height) = 0;\n+\n+        //! Return height of earliest block in chain with timestamp equal or\n+        //! greater than the given time, or nothing if there is no block with a\n+        //! high enough timestamp.\n+        virtual Optional<int> findEarliestAtLeast(int64_t time) = 0;\n+\n+        //! Return height of last block in chain with timestamp less than the\n+        //! given, and height less than or equal to the given, or nothing if\n+        //! there is no such block.\n+        virtual Optional<int> findLastBefore(int64_t time, int start_height) = 0;\n+\n+        //! Return height of last block in the specified range which is pruned, or\n+        //! nothing if no block in the range is pruned. Range is inclusive.\n+        virtual Optional<int> findPruned(int start_height = 0, Optional<int> stop_height = nullopt) = 0;\n+\n+        //! Return height of the highest block on the chain that is an ancestor\n+        //! of the specified block. Also return the height of the specified\n+        //! block as an optinal output parameter.\n+        virtual Optional<int> findFork(const uint256& hash, Optional<int>* height) = 0;\n+\n+        //! Return true if block hash points to the current chain tip, or to a\n+        //! possible descendant of the current chain tip that isn't currently\n+        //! connected.\n+        virtual bool isPotentialTip(const uint256& hash) = 0;\n+\n+        //! Get locator for the current chain tip.\n+        virtual CBlockLocator getLocator() = 0;\n+\n+        //! Return height of block on the chain using locator.\n+        virtual Optional<int> findLocatorFork(const CBlockLocator& locator) = 0;\n+\n+        //! Check if transaction will be final given chain height current time.\n+        virtual bool checkFinalTx(const CTransaction& tx) = 0;\n+\n+        //! Check whether segregated witness is enabled on the network.\n+        virtual bool isWitnessEnabled() = 0;\n+\n+        //! Add transaction to memory pool.\n+        virtual bool acceptToMemoryPool(CTransactionRef tx, CValidationState& state) = 0;\n+    };\n+\n+    //! Return Lock interface. Chain is locked when this is called, and\n+    //! unlocked when the returned interface is freed.\n+    virtual std::unique_ptr<Lock> lock(bool try_lock = false) = 0;\n+\n+    //! Return Lock interface assuming chain is already locked. This\n+    //! method is temporary and is only used in a few places to avoid changing\n+    //! behavior while code is transitioned to use the LockState interface.\n+    virtual std::unique_ptr<Lock> assumeLocked() = 0;\n+\n+    //! Return whether node has the block and optionally return block metadata or contents.\n+    virtual bool findBlock(const uint256& hash,\n+        CBlock* block = nullptr,\n+        int64_t* time = nullptr,\n+        int64_t* max_time = nullptr) = 0;\n+\n+    //! Estimate fraction of total transactions verified if blocks up to\n+    //! given height are verified.\n+    virtual double guessVerificationProgress(const uint256& block_hash) = 0;\n+\n+    //! Get virtual transaction size.\n+    virtual int64_t getVirtualTransactionSize(const CTransaction& tx) = 0;\n+\n+    //! Check if transaction is RBF opt in.\n+    virtual RBFTransactionState isRBFOptIn(const CTransaction& tx) = 0;\n+\n+    //! Check if transaction has descendants in mempool.\n+    virtual bool hasDescendantsInMempool(const uint256& txid) = 0;\n+\n+    //! Relay transaction.\n+    virtual bool relayTransaction(const uint256& txid) = 0;\n+\n+    //! Check if transaction is within chain limit.\n+    virtual bool transactionWithinChainLimit(const uint256& txid, size_t chain_limit) = 0;\n+\n+    //! Check chain limits.\n+    virtual bool checkChainLimits(CTransactionRef tx) = 0;\n+\n+    //! Estimate smart fee.\n+    virtual CFeeRate estimateSmartFee(int num_blocks, bool conservative, FeeCalculation* calc = nullptr) = 0;\n+\n+    //! Fee estimator max target.\n+    virtual int estimateMaxBlocks() = 0;\n+\n+    //! Pool min fee.\n+    virtual CFeeRate poolMinFee() = 0;\n+\n+    //! Check if pruning is enabled.\n+    virtual bool getPruneMode() = 0;\n+\n+    //! Check if p2p enabled.\n+    virtual bool p2pEnabled() = 0;\n+\n+    //! Get adjusted time.\n+    virtual int64_t getAdjustedTime() = 0;\n+\n+    //! Send init message.\n+    virtual void initMessage(const std::string& message) = 0;\n+\n+    //! Send init warning.\n+    virtual void initWarning(const std::string& message) = 0;\n+\n+    //! Send init error.\n+    virtual void initError(const std::string& message) = 0;\n+\n+    //! Generate blocks\n+    virtual UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbase_script,\n+        int num_blocks,\n+        uint64_t max_tries,\n+        bool keep_script) = 0;\n+\n+    //! Parse confirm target.\n+    virtual unsigned int parseConfirmTarget(const UniValue& value) = 0;\n+\n+    //! Chain notifications.\n+    class Notifications\n+    {\n+    public:\n+        virtual ~Notifications() {}\n+        virtual void TransactionAddedToMempool(const CTransactionRef& tx) {}\n+        virtual void TransactionRemovedFromMempool(const CTransactionRef& ptx) {}\n+        virtual void BlockConnected(const CBlock& block,\n+            const uint256& block_hash,\n+            const std::vector<CTransactionRef>& tx_conflicted)\n+        {\n+        }\n+        virtual void BlockDisconnected(const CBlock& block) {}\n+        virtual void ChainStateFlushed(const CBlockLocator& locator) {}\n+        virtual void Inventory(const uint256& hash) {}\n+        virtual void ResendWalletTransactions(int64_t best_block_time) {}\n+    };\n+\n+    //! Register handler for notifications.\n+    virtual std::unique_ptr<Handler> handleNotifications(Notifications& notifications) = 0;\n+\n+    //! Wait for pending notifications to be handled.\n+    virtual void waitForNotifications() = 0;\n+\n+    //! Interface to let node manage chain clients (wallets, or maybe tools for\n+    //! monitoring and analysis in the future).\n+    class Client\n+    {\n+    public:\n+        virtual ~Client() {}\n+\n+        //! Register rpcs.\n+        virtual void registerRpcs() = 0;\n+\n+        //! Prepare for execution, loading any needed state.\n+        virtual bool prepare() = 0;\n+\n+        //! Start client execution and provide a scheduler. (Scheduler is",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186272710",
      "id" : 186272710,
      "in_reply_to_id" : 186132129,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjI3MjcxMA==",
      "original_commit_id" : "af8f8087699c30ec83995c54112955253bcaba84",
      "original_position" : 220,
      "path" : "src/interfaces/chain.h",
      "position" : null,
      "pull_request_review_id" : 117825376,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186272710",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186272718"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186272718"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186125434\r\n\r\n> I don't understand why this is in parseParameters(), rather than a constructor for NodeImpl\r\n\r\nGood suggestion. Moved to constructor in 53a5d3e48093b366e4a227fc9c3e50d7729ba461. An earlier version of #10102 initialized `m_interfaces` here in order to be able to use the `argv[0]` directory from the `bitcoin-gui` process to spawn `bitcoin-wallet` processes from the `bitcoin-node` process. But the current version uses `bitcoin-node`'s `argv[0]`, which is simpler and doesn't require access to the GUI's `argv`.",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-05T21:32:26Z",
      "diff_hunk" : "@@ -50,6 +51,7 @@ class NodeImpl : public Node\n {\n     void parseParameters(int argc, const char* const argv[]) override\n     {\n+        m_interfaces.chain = interfaces::MakeChain();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186272718",
      "id" : 186272718,
      "in_reply_to_id" : 186125434,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjI3MjcxOA==",
      "original_commit_id" : "af8f8087699c30ec83995c54112955253bcaba84",
      "original_position" : 12,
      "path" : "src/interfaces/node.cpp",
      "position" : null,
      "pull_request_review_id" : 117825376,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186272718",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186272735"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186272735"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186216539\r\n\r\n> The \"missing block hash\" and \"missing block time\" outputs here are a change in behaviour (and could potentially break clients using the dumpwallet API)\r\n\r\nI don't think there is a risk of clients breaking, since the change in behavior is outputting \"(missing block hash)\" and \"(missing block time)\" where previously the code would segfault.",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-05T21:32:43Z",
      "diff_hunk" : "@@ -747,8 +756,9 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     // produce output\n     file << strprintf(\"# Wallet dump created by Bitcoin %s\\n\", CLIENT_BUILD);\n     file << strprintf(\"# * Created on %s\\n\", FormatISO8601DateTime(GetTime()));\n-    file << strprintf(\"# * Best block at time of backup was %i (%s),\\n\", chainActive.Height(), chainActive.Tip()->GetBlockHash().ToString());\n-    file << strprintf(\"#   mined on %s\\n\", FormatISO8601DateTime(chainActive.Tip()->GetBlockTime()));\n+    const Optional<int> tip_height = locked_chain->getHeight();\n+    file << strprintf(\"# * Best block at time of backup was %i (%s),\\n\", tip_height ? *tip_height : -1, tip_height ? locked_chain->getBlockHash(*tip_height).ToString() : \"(missing block hash)\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186272735",
      "id" : 186272735,
      "in_reply_to_id" : 186216539,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjI3MjczNQ==",
      "original_commit_id" : "af8f8087699c30ec83995c54112955253bcaba84",
      "original_position" : 158,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 117825376,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186272735",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186272743"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186272743"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186225645\r\n\r\n> Can you use locked_chain->getDepth(blockId) here?\r\n\r\nI think so, but it seems like it would be deviating unnecessarily from current code and also obscuring relationship between height and depth which is currently explicit here.\r\n",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-05T21:33:00Z",
      "diff_hunk" : "@@ -2214,39 +2227,41 @@ UniValue listsinceblock(const JSONRPCRequest& request)\n \n     bool include_removed = (request.params[3].isNull() || request.params[3].get_bool());\n \n-    int depth = pindex ? (1 + chainActive.Height() - pindex->nHeight) : -1;\n+    const Optional<int> tip_height = locked_chain->getHeight();\n+    int depth = tip_height && height ? (1 + *tip_height - *height) : -1;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186272743",
      "id" : 186272743,
      "in_reply_to_id" : 186225645,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjI3Mjc0Mw==",
      "original_commit_id" : "af8f8087699c30ec83995c54112955253bcaba84",
      "original_position" : 530,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 406,
      "pull_request_review_id" : 117825376,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186272743",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186272746"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186272746"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186174854\r\n\r\n> There are 4 of these Temporary. Removed in upcoming lock cleanup comments. Sorry if I missed the answer to this, but what's the plan for removing them?\r\n\r\nThese are introduced in commit 4d11732cc453b8ad5db571491909259fbacd1f51 (Remove uses of cs_main in wallet code), which like other commits in this PR, is just supposed to be mechanical change that doesn't change behavior.\r\n\r\nThe fixes for these comments will depend on the individual situation but will just mean adding required locks that are missing or removing recursive locks that are redundant. As an example, if #10605 is merged, the temporary comment in ListLocked can go away.\r\n",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-05T21:33:18Z",
      "diff_hunk" : "@@ -3388,7 +3417,8 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     CAmount nFeeOut;\n     std::string strFailReason;\n \n-    if (!pwallet->FundTransaction(tx, nFeeOut, changePosition, strFailReason, lockUnspents, setSubtractFeeFromOutputs, coinControl)) {\n+    auto locked_chain = pwallet->chain().assumeLocked();  // Temporary. Removed in upcoming lock cleanup",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186272746",
      "id" : 186272746,
      "in_reply_to_id" : 186174854,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjI3Mjc0Ng==",
      "original_commit_id" : "af8f8087699c30ec83995c54112955253bcaba84",
      "original_position" : 782,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 117825376,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186272746",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186272748"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186272748"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186181022\r\n\r\n> Comment is wrong. Needs to be updated to Should be called with non-zero block_hash and posInBlock...\r\n\r\nThanks, fixed in 77cd28c7f5043ff82500fe59936d7a6abc8d0bf6",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-05T21:33:33Z",
      "diff_hunk" : "@@ -698,7 +697,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n \n     /* Used by TransactionAddedToMemorypool/BlockConnected/Disconnected.\n      * Should be called with pindexBlock and posInBlock if this is for a transaction that is included in a block. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186272748",
      "id" : 186272748,
      "in_reply_to_id" : 186181022,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjI3Mjc0OA==",
      "original_commit_id" : "af8f8087699c30ec83995c54112955253bcaba84",
      "original_position" : 90,
      "path" : "src/wallet/wallet.h",
      "position" : null,
      "pull_request_review_id" : 117825376,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186272748",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186272752"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186272752"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186181393\r\n\r\n> Remove comment\r\n\r\nRemoved in cc2290887af57d60640e7ec90afe2a87dcee3ed7",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-05T21:33:48Z",
      "diff_hunk" : "@@ -744,7 +751,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n      *\n      * Protected by cs_main (see BlockUntilSyncedToCurrentChain)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186272752",
      "id" : 186272752,
      "in_reply_to_id" : 186181393,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjI3Mjc1Mg==",
      "original_commit_id" : "af8f8087699c30ec83995c54112955253bcaba84",
      "original_position" : 120,
      "path" : "src/wallet/wallet.h",
      "position" : null,
      "pull_request_review_id" : 117825376,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186272752",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186444555"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186444555"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Would it make sense to have a `Chain::Lock.getTip()` to just return the tip hash?",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-07T14:42:19Z",
      "diff_hunk" : "@@ -1694,109 +1695,128 @@ int64_t CWallet::RescanFromTime(int64_t startTime, const WalletRescanReserver& r\n     // Find starting block. May be null if nCreateTime is greater than the\n     // highest blockchain timestamp, in which case there is nothing that needs\n     // to be scanned.\n-    CBlockIndex* startBlock = nullptr;\n+    uint256 start_block;\n     {\n-        LOCK(cs_main);\n-        startBlock = chainActive.FindEarliestAtLeast(startTime - TIMESTAMP_WINDOW);\n-        LogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, startBlock ? chainActive.Height() - startBlock->nHeight + 1 : 0);\n-    }\n-\n-    if (startBlock) {\n-        const CBlockIndex* const failedBlock = ScanForWalletTransactions(startBlock, nullptr, reserver, update);\n-        if (failedBlock) {\n-            return failedBlock->GetBlockTimeMax() + TIMESTAMP_WINDOW + 1;\n+        auto locked_chain = m_chain->lock();\n+        const Optional<int> start_height = locked_chain->findEarliestAtLeast(startTime - TIMESTAMP_WINDOW);\n+        const Optional<int> tip_height = locked_chain->getHeight();\n+        LogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, tip_height && start_height ? *tip_height - *start_height + 1 : 0);\n+        if (start_height) start_block = locked_chain->getBlockHash(*start_height);\n+    }\n+\n+    if (!start_block.IsNull()) {\n+        uint256 failed_block = ScanForWalletTransactions(start_block, {} /* stop block */, reserver, update);\n+        if (!failed_block.IsNull()) {\n+            int64_t time_max;\n+            if (!m_chain->findBlock(failed_block, nullptr /* CBlock */, nullptr /* time */, &time_max)) {\n+                throw std::logic_error(\"ScanForWalletTransactions returned invalid block hash\");\n+            }\n+            return time_max + TIMESTAMP_WINDOW + 1;\n         }\n     }\n     return startTime;\n }\n \n /**\n- * Scan the block chain (starting in pindexStart) for transactions\n+ * Scan the block chain (starting in start_block) for transactions\n  * from or to us. If fUpdate is true, found transactions that already\n  * exist in the wallet will be updated.\n  *\n  * Returns null if scan was successful. Otherwise, if a complete rescan was not\n  * possible (due to pruning or corruption), returns pointer to the most recent\n  * block that could not be scanned.\n  *\n- * If pindexStop is not a nullptr, the scan will stop at the block-index\n- * defined by pindexStop\n+ * If stop_block is not null, the scan will stop at the block-index\n+ * defined by stop_block\n  *\n- * Caller needs to make sure pindexStop (and the optional pindexStart) are on\n+ * Caller needs to make sure stop_block (and the optional start_block) are on\n  * the main chain after to the addition of any new keys you want to detect\n  * transactions for.\n  */\n-CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, CBlockIndex* pindexStop, const WalletRescanReserver &reserver, bool fUpdate)\n+uint256 CWallet::ScanForWalletTransactions(const uint256& start_block, const uint256& stop_block, const WalletRescanReserver &reserver, bool fUpdate)\n {\n     int64_t nNow = GetTime();\n     const CChainParams& chainParams = Params();\n \n     assert(reserver.isReserved());\n-    if (pindexStop) {\n-        assert(pindexStop->nHeight >= pindexStart->nHeight);\n-    }\n \n-    CBlockIndex* pindex = pindexStart;\n-    CBlockIndex* ret = nullptr;\n+    uint256 block_hash = start_block;\n+    uint256 ret;\n \n-    if (pindex) LogPrintf(\"Rescan started from block %d...\\n\", pindex->nHeight);\n+    LogPrintf(\"Rescan started from block %s...\\n\", start_block.ToString());\n \n     {\n         fAbortRescan = false;\n         ShowProgress(_(\"Rescanning...\"), 0); // show rescan progress in GUI as dialog or on splashscreen, if -rescan on startup\n-        CBlockIndex* tip = nullptr;\n+        uint256 tip_hash;\n+        Optional<int> block_height;\n         double dProgressStart;\n         double dProgressTip;\n         {\n-            LOCK(cs_main);\n-            tip = chainActive.Tip();\n-            dProgressStart = GuessVerificationProgress(chainParams.TxData(), pindex);\n-            dProgressTip = GuessVerificationProgress(chainParams.TxData(), tip);\n+            auto locked_chain = m_chain->lock();\n+            if (Optional<int> tip_height = locked_chain->getHeight()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186444555",
      "id" : 186444555,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjQ0NDU1NQ==",
      "original_commit_id" : "af8f8087699c30ec83995c54112955253bcaba84",
      "original_position" : 326,
      "path" : "src/wallet/wallet.cpp",
      "position" : 330,
      "pull_request_review_id" : 118022524,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186444555",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186462615"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186462615"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This variable isn't a pointer to a CBlockIndex, and should be named `max_height` or similar.",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-07T15:42:19Z",
      "diff_hunk" : "@@ -3795,8 +3818,9 @@ void CWallet::GetKeyBirthTimes(std::map<CTxDestination, int64_t> &mapKeyBirth) c\n     }\n \n     // map in which we'll infer heights of other keys\n-    CBlockIndex *pindexMax = chainActive[std::max(0, chainActive.Height() - 144)]; // the tip can be reorganized; use a 144-block safety margin\n-    std::map<CKeyID, CBlockIndex*> mapKeyFirstBlock;\n+    const Optional<int> tip_height = locked_chain.getHeight();\n+    const int pindexMax = tip_height && *tip_height > 144 ? *tip_height - 144 : 0; // the tip can be reorganized; use a 144-block safety margin",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186462615",
      "id" : 186462615,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjQ2MjYxNQ==",
      "original_commit_id" : "af8f8087699c30ec83995c54112955253bcaba84",
      "original_position" : 1026,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 118022524,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186462615",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186496577"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186496577"
         }
      },
      "author_association" : "MEMBER",
      "body" : "would `block_height` or `block_index` be a better variable name here?",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-07T17:49:23Z",
      "diff_hunk" : "@@ -4129,44 +4152,56 @@ CWallet* CWallet::CreateWalletFromFile(const std::string& name, const fs::path&\n     // Try to top up keypool. No-op if the wallet is locked.\n     walletInstance->TopUpKeyPool();\n \n-    LOCK(cs_main);\n+    auto locked_chain = chain.lock();\n \n-    CBlockIndex *pindexRescan = chainActive.Genesis();\n+    int index_rescan = 0;\n     if (!gArgs.GetBoolArg(\"-rescan\", false))\n     {\n         WalletBatch batch(*walletInstance->database);\n         CBlockLocator locator;\n-        if (batch.ReadBestBlock(locator))\n-            pindexRescan = FindForkInGlobalIndex(chainActive, locator);\n+        if (batch.ReadBestBlock(locator)) {\n+            if (const Optional<int> fork_height = locked_chain->findLocatorFork(locator)) {\n+                index_rescan = *fork_height;\n+            }\n+        }\n+    }\n+\n+    const Optional<int> tip_height = locked_chain->getHeight();\n+    if (tip_height) {\n+        walletInstance->m_last_block_processed = locked_chain->getBlockHash(index_rescan);\n+    } else {\n+        walletInstance->m_last_block_processed.SetNull();\n     }\n \n-    walletInstance->m_last_block_processed = chainActive.Tip();\n-    RegisterValidationInterface(walletInstance);\n+    walletInstance->m_handler = chain.handleNotifications(*walletInstance);\n \n-    if (chainActive.Tip() && chainActive.Tip() != pindexRescan)\n+    if (tip_height && *tip_height != index_rescan)\n     {\n         //We can't rescan beyond non-pruned blocks, stop and throw an error\n         //this might happen if a user uses an old wallet within a pruned node\n         // or if he ran -disablewallet for a longer time, then decided to re-enable\n-        if (fPruneMode)\n+        if (chain.getPruneMode())\n         {\n-            CBlockIndex *block = chainActive.Tip();\n-            while (block && block->pprev && (block->pprev->nStatus & BLOCK_HAVE_DATA) && block->pprev->nTx > 0 && pindexRescan != block)\n-                block = block->pprev;\n+            int block = *tip_height;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186496577",
      "id" : 186496577,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjQ5NjU3Nw==",
      "original_commit_id" : "af8f8087699c30ec83995c54112955253bcaba84",
      "original_position" : 1225,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 118022524,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186496577",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186497214"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186497214"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think this comment should make clear that the block must be available on disk:\r\n\r\n`Check that the full block is available on disk (ie has not been pruned), and contains transactions.`",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-07T17:51:27Z",
      "diff_hunk" : "@@ -0,0 +1,251 @@\n+#ifndef BITCOIN_INTERFACES_CHAIN_H\n+#define BITCOIN_INTERFACES_CHAIN_H\n+\n+#include <optional.h>               // For Optional and nullopt\n+#include <policy/rbf.h>             // For RBFTransactionState\n+#include <primitives/transaction.h> // For CTransactionRef\n+\n+#include <memory>\n+#include <stddef.h>\n+#include <stdint.h>\n+#include <string>\n+#include <vector>\n+\n+class CBlock;\n+class CRPCCommand;\n+class CReserveScript;\n+class CScheduler;\n+class CValidationState;\n+class UniValue;\n+class uint256;\n+struct CBlockLocator;\n+struct FeeCalculation;\n+\n+namespace interfaces {\n+\n+class Handler;\n+\n+//! Interface for giving wallet processes access to blockchain state.\n+class Chain\n+{\n+public:\n+    virtual ~Chain() {}\n+\n+    //! Interface for querying locked chain state, used by legacy code that\n+    //! assumes state won't change between calls. New code should avoid using\n+    //! the Lock interface and instead call higher-level Chain methods\n+    //! that return more information so the chain doesn't need to stay locked\n+    //! between calls.\n+    class Lock\n+    {\n+    public:\n+        virtual ~Lock() {}\n+\n+        //! Get current chain height, not including genesis block (returns 0 if\n+        //! chain only contains genesis block, nothing if chain does not contain\n+        //! any blocks).\n+        virtual Optional<int> getHeight() = 0;\n+\n+        //! Get block height above genesis block. Returns 0 for genesis block,\n+        //! for following block, and so on. Returns nothing for a block not\n+        //! included in the current chain.\n+        virtual Optional<int> getBlockHeight(const uint256& hash) = 0;\n+\n+        //! Get block depth. Returns 1 for chain tip, 2 for preceding block, and\n+        //! so on. Returns 0 for a block not included in the current chain.\n+        virtual int getBlockDepth(const uint256& hash) = 0;\n+\n+        //! Get block hash.\n+        virtual uint256 getBlockHash(int height) = 0;\n+\n+        //! Get block time.\n+        virtual int64_t getBlockTime(int height) = 0;\n+\n+        //! Get block median time past.\n+        virtual int64_t getBlockMedianTimePast(int height) = 0;\n+\n+        //! Check if block is empty.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186497214",
      "id" : 186497214,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjQ5NzIxNA==",
      "original_commit_id" : "af8f8087699c30ec83995c54112955253bcaba84",
      "original_position" : 67,
      "path" : "src/interfaces/chain.h",
      "position" : null,
      "pull_request_review_id" : 118022524,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186497214",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186499592"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186499592"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In fact, I think this function is misnamed. What we're interested in is whether the block is available on disk or not. The 'block contains transactions' conditional test was added here: https://github.com/bitcoin/bitcoin/commit/7e6569ea5be8cb26454ede3efb6a50b393aaa9be (comment here: https://github.com/bitcoin/bitcoin/pull/6057#issuecomment-97393680). I suggest renaming the function to `haveBlockOnDisk()` or similar.",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-07T17:59:43Z",
      "diff_hunk" : "@@ -0,0 +1,251 @@\n+#ifndef BITCOIN_INTERFACES_CHAIN_H\n+#define BITCOIN_INTERFACES_CHAIN_H\n+\n+#include <optional.h>               // For Optional and nullopt\n+#include <policy/rbf.h>             // For RBFTransactionState\n+#include <primitives/transaction.h> // For CTransactionRef\n+\n+#include <memory>\n+#include <stddef.h>\n+#include <stdint.h>\n+#include <string>\n+#include <vector>\n+\n+class CBlock;\n+class CRPCCommand;\n+class CReserveScript;\n+class CScheduler;\n+class CValidationState;\n+class UniValue;\n+class uint256;\n+struct CBlockLocator;\n+struct FeeCalculation;\n+\n+namespace interfaces {\n+\n+class Handler;\n+\n+//! Interface for giving wallet processes access to blockchain state.\n+class Chain\n+{\n+public:\n+    virtual ~Chain() {}\n+\n+    //! Interface for querying locked chain state, used by legacy code that\n+    //! assumes state won't change between calls. New code should avoid using\n+    //! the Lock interface and instead call higher-level Chain methods\n+    //! that return more information so the chain doesn't need to stay locked\n+    //! between calls.\n+    class Lock\n+    {\n+    public:\n+        virtual ~Lock() {}\n+\n+        //! Get current chain height, not including genesis block (returns 0 if\n+        //! chain only contains genesis block, nothing if chain does not contain\n+        //! any blocks).\n+        virtual Optional<int> getHeight() = 0;\n+\n+        //! Get block height above genesis block. Returns 0 for genesis block,\n+        //! for following block, and so on. Returns nothing for a block not\n+        //! included in the current chain.\n+        virtual Optional<int> getBlockHeight(const uint256& hash) = 0;\n+\n+        //! Get block depth. Returns 1 for chain tip, 2 for preceding block, and\n+        //! so on. Returns 0 for a block not included in the current chain.\n+        virtual int getBlockDepth(const uint256& hash) = 0;\n+\n+        //! Get block hash.\n+        virtual uint256 getBlockHash(int height) = 0;\n+\n+        //! Get block time.\n+        virtual int64_t getBlockTime(int height) = 0;\n+\n+        //! Get block median time past.\n+        virtual int64_t getBlockMedianTimePast(int height) = 0;\n+\n+        //! Check if block is empty.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186499592",
      "id" : 186499592,
      "in_reply_to_id" : 186497214,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjQ5OTU5Mg==",
      "original_commit_id" : "af8f8087699c30ec83995c54112955253bcaba84",
      "original_position" : 67,
      "path" : "src/interfaces/chain.h",
      "position" : null,
      "pull_request_review_id" : 118022524,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186499592",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186501200"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186501200"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Shouldn't this be \"height greater than or equal to the given\"? The implementation starts at `start_height` and moves forwards along the chain.",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-07T18:05:22Z",
      "diff_hunk" : "@@ -0,0 +1,251 @@\n+#ifndef BITCOIN_INTERFACES_CHAIN_H\n+#define BITCOIN_INTERFACES_CHAIN_H\n+\n+#include <optional.h>               // For Optional and nullopt\n+#include <policy/rbf.h>             // For RBFTransactionState\n+#include <primitives/transaction.h> // For CTransactionRef\n+\n+#include <memory>\n+#include <stddef.h>\n+#include <stdint.h>\n+#include <string>\n+#include <vector>\n+\n+class CBlock;\n+class CRPCCommand;\n+class CReserveScript;\n+class CScheduler;\n+class CValidationState;\n+class UniValue;\n+class uint256;\n+struct CBlockLocator;\n+struct FeeCalculation;\n+\n+namespace interfaces {\n+\n+class Handler;\n+\n+//! Interface for giving wallet processes access to blockchain state.\n+class Chain\n+{\n+public:\n+    virtual ~Chain() {}\n+\n+    //! Interface for querying locked chain state, used by legacy code that\n+    //! assumes state won't change between calls. New code should avoid using\n+    //! the Lock interface and instead call higher-level Chain methods\n+    //! that return more information so the chain doesn't need to stay locked\n+    //! between calls.\n+    class Lock\n+    {\n+    public:\n+        virtual ~Lock() {}\n+\n+        //! Get current chain height, not including genesis block (returns 0 if\n+        //! chain only contains genesis block, nothing if chain does not contain\n+        //! any blocks).\n+        virtual Optional<int> getHeight() = 0;\n+\n+        //! Get block height above genesis block. Returns 0 for genesis block,\n+        //! for following block, and so on. Returns nothing for a block not\n+        //! included in the current chain.\n+        virtual Optional<int> getBlockHeight(const uint256& hash) = 0;\n+\n+        //! Get block depth. Returns 1 for chain tip, 2 for preceding block, and\n+        //! so on. Returns 0 for a block not included in the current chain.\n+        virtual int getBlockDepth(const uint256& hash) = 0;\n+\n+        //! Get block hash.\n+        virtual uint256 getBlockHash(int height) = 0;\n+\n+        //! Get block time.\n+        virtual int64_t getBlockTime(int height) = 0;\n+\n+        //! Get block median time past.\n+        virtual int64_t getBlockMedianTimePast(int height) = 0;\n+\n+        //! Check if block is empty.\n+        virtual bool blockHasTransactions(int height) = 0;\n+\n+        //! Return height of earliest block in chain with timestamp equal or\n+        //! greater than the given time, or nothing if there is no block with a\n+        //! high enough timestamp.\n+        virtual Optional<int> findEarliestAtLeast(int64_t time) = 0;\n+\n+        //! Return height of last block in chain with timestamp less than the\n+        //! given, and height less than or equal to the given, or nothing if",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186501200",
      "id" : 186501200,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjUwMTIwMA==",
      "original_commit_id" : "af8f8087699c30ec83995c54112955253bcaba84",
      "original_position" : 76,
      "path" : "src/interfaces/chain.h",
      "position" : null,
      "pull_request_review_id" : 118022524,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186501200",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186538449"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186538449"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Supporting multiple clients makes this more complex than it needs to be.\r\n\r\nThis PR would be easier to review if it initially supported just a single client (as we do today). A future PR could extend the RPC forwarding to support multiple clients.",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-07T20:23:47Z",
      "diff_hunk" : "@@ -0,0 +1,419 @@\n+#include <interfaces/chain.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <interfaces/handler.h>\n+#include <net.h>\n+#include <policy/fees.h>\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <protocol.h>\n+#include <rpc/mining.h>\n+#include <rpc/protocol.h>\n+#include <rpc/server.h>\n+#include <sync.h>\n+#include <timedata.h>\n+#include <txmempool.h>\n+#include <ui_interface.h>\n+#include <uint256.h>\n+#include <univalue.h>\n+#include <util.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <tuple>\n+#include <unordered_map>\n+#include <utility>\n+\n+class CReserveScript;\n+\n+namespace interfaces {\n+namespace {\n+\n+//! Extension of std::reference_wrapper with operator< for use as map key.\n+template <typename T>\n+class Ref : public std::reference_wrapper<T>\n+{\n+public:\n+    using std::reference_wrapper<T>::reference_wrapper;\n+    bool operator<(const Ref<T>& other) const { return this->get() < other.get(); }\n+};\n+\n+class LockImpl : public Chain::Lock\n+{\n+    Optional<int> getHeight() override\n+    {\n+        int height = ::chainActive.Height();\n+        if (height >= 0) {\n+            return height;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> getBlockHeight(const uint256& hash) override\n+    {\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end() && it->second) {\n+            if (::chainActive.Contains(it->second)) {\n+                return it->second->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    int getBlockDepth(const uint256& hash) override\n+    {\n+        const Optional<int> tip_height = getHeight();\n+        const Optional<int> height = getBlockHeight(hash);\n+        return tip_height && height ? *tip_height - *height + 1 : 0;\n+    }\n+    uint256 getBlockHash(int height) override { return ::chainActive[height]->GetBlockHash(); }\n+    int64_t getBlockTime(int height) override { return ::chainActive[height]->GetBlockTime(); }\n+    int64_t getBlockMedianTimePast(int height) override { return ::chainActive[height]->GetMedianTimePast(); }\n+    bool blockHasTransactions(int height) override\n+    {\n+        CBlockIndex* block = ::chainActive[height];\n+        return block && (block->nStatus & BLOCK_HAVE_DATA) && block->nTx > 0;\n+    }\n+    Optional<int> findEarliestAtLeast(int64_t time) override\n+    {\n+        CBlockIndex* block = ::chainActive.FindEarliestAtLeast(time);\n+        if (block) {\n+            return block->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findLastBefore(int64_t time, int start_height) override\n+    {\n+        CBlockIndex* block = ::chainActive[start_height];\n+        while (block && block->GetBlockTime() < time) {\n+            block = ::chainActive.Next(block);\n+        }\n+        if (block) {\n+            return block->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findPruned(int start_height, Optional<int> stop_height) override\n+    {\n+        if (::fPruneMode) {\n+            CBlockIndex* block = stop_height ? ::chainActive[*stop_height] : ::chainActive.Tip();\n+            while (block && block->nHeight >= start_height) {\n+                if (!(block->nStatus & BLOCK_HAVE_DATA)) {\n+                    return block->nHeight;\n+                }\n+                block = block->pprev;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFork(const uint256& hash, Optional<int>* height) override\n+    {\n+        const CBlockIndex *block{nullptr}, *fork{nullptr};\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end()) {\n+            block = it->second;\n+            fork = ::chainActive.FindFork(block);\n+        }\n+        if (height) {\n+            if (block) {\n+                *height = block->nHeight;\n+            } else {\n+                height->reset();\n+            }\n+        }\n+        if (fork) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool isPotentialTip(const uint256& hash) override\n+    {\n+        if (::chainActive.Tip()->GetBlockHash() == hash) return true;\n+        auto it = ::mapBlockIndex.find(hash);\n+        return it != ::mapBlockIndex.end() && it->second->GetAncestor(::chainActive.Height()) == ::chainActive.Tip();\n+    }\n+    CBlockLocator getLocator() override { return ::chainActive.GetLocator(); }\n+    Optional<int> findLocatorFork(const CBlockLocator& locator) override\n+    {\n+        if (CBlockIndex* fork = FindForkInGlobalIndex(::chainActive, locator)) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool checkFinalTx(const CTransaction& tx) override { return CheckFinalTx(tx); }\n+    bool isWitnessEnabled() override { return ::IsWitnessEnabled(::chainActive.Tip(), Params().GetConsensus()); }\n+    bool acceptToMemoryPool(CTransactionRef tx, CValidationState& state) override\n+    {\n+        return AcceptToMemoryPool(::mempool, state, tx, nullptr /* missing inputs */, nullptr /* txn replaced */,\n+            false /* bypass limits */, ::maxTxFee /* absurd fee */);\n+    }\n+};\n+\n+class LockingStateImpl : public LockImpl, public CCriticalBlock\n+{\n+    using CCriticalBlock::CCriticalBlock;\n+};\n+\n+class HandlerImpl : public Handler, private CValidationInterface\n+{\n+public:\n+    HandlerImpl(Chain::Notifications& notifications) : m_notifications(notifications)\n+    {\n+        RegisterValidationInterface(this);\n+    }\n+    ~HandlerImpl() override\n+    {\n+        // Don't call UnregisterValidationInterface here because it would try to\n+        // access virtual methods on this object which can't be accessed during\n+        // destruction. Also UnregisterAllValidationInterfaces is already called\n+        // at this point, so unregistering this object would be redundant.\n+    }\n+    void disconnect() override { UnregisterValidationInterface(this); }\n+    void TransactionAddedToMempool(const CTransactionRef& tx) override\n+    {\n+        m_notifications.TransactionAddedToMempool(tx);\n+    }\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx) override\n+    {\n+        m_notifications.TransactionRemovedFromMempool(tx);\n+    }\n+    void BlockConnected(const std::shared_ptr<const CBlock>& block,\n+        const CBlockIndex* index,\n+        const std::vector<CTransactionRef>& tx_conflicted) override\n+    {\n+        m_notifications.BlockConnected(*block, index->GetBlockHash(), tx_conflicted);\n+    }\n+    void BlockDisconnected(const std::shared_ptr<const CBlock>& block) override\n+    {\n+        m_notifications.BlockDisconnected(*block);\n+    }\n+    void ChainStateFlushed(const CBlockLocator& locator) override { m_notifications.ChainStateFlushed(locator); }\n+    void Inventory(const uint256& hash) override { m_notifications.Inventory(hash); }\n+    void ResendWalletTransactions(int64_t best_block_time, CConnman* connman) override\n+    {\n+        m_notifications.ResendWalletTransactions(best_block_time);\n+    }\n+    Chain::Notifications& m_notifications;\n+};\n+\n+class ChainImpl : public Chain\n+{\n+public:\n+    std::unique_ptr<Chain::Lock> lock(bool try_lock) override\n+    {\n+        auto result = MakeUnique<LockingStateImpl>(::cs_main, \"cs_main\", __FILE__, __LINE__, try_lock);\n+        if (try_lock && result && !*result) return {};\n+        // std::move necessary on some compilers due to conversion from\n+        // LockingStateImpl to Lock pointer\n+        return std::move(result);\n+    }\n+    std::unique_ptr<Chain::Lock> assumeLocked() override { return MakeUnique<LockImpl>(); }\n+    bool findBlock(const uint256& hash, CBlock* block, int64_t* time, int64_t* time_max) override\n+    {\n+        CBlockIndex* index;\n+        {\n+            LOCK(cs_main);\n+            auto it = ::mapBlockIndex.find(hash);\n+            if (it == ::mapBlockIndex.end()) {\n+                return false;\n+            }\n+            index = it->second;\n+            if (time) {\n+                *time = index->GetBlockTime();\n+            }\n+            if (time_max) {\n+                *time_max = index->GetBlockTimeMax();\n+            }\n+        }\n+        if (block && !ReadBlockFromDisk(*block, index, Params().GetConsensus())) {\n+            block->SetNull();\n+        }\n+        return true;\n+    }\n+    double guessVerificationProgress(const uint256& block_hash) override\n+    {\n+        LOCK(cs_main);\n+        auto it = ::mapBlockIndex.find(block_hash);\n+        return GuessVerificationProgress(Params().TxData(), it != ::mapBlockIndex.end() ? it->second : nullptr);\n+    }\n+    int64_t getVirtualTransactionSize(const CTransaction& tx) override { return GetVirtualTransactionSize(tx); }\n+    RBFTransactionState isRBFOptIn(const CTransaction& tx) override\n+    {\n+        LOCK(::mempool.cs);\n+        return IsRBFOptIn(tx, ::mempool);\n+    }\n+    bool hasDescendantsInMempool(const uint256& txid) override\n+    {\n+        LOCK(::mempool.cs);\n+        auto it_mp = ::mempool.mapTx.find(txid);\n+        return it_mp != ::mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1;\n+    }\n+    bool relayTransaction(const uint256& txid) override\n+    {\n+        if (g_connman) {\n+            CInv inv(MSG_TX, txid);\n+            g_connman->ForEachNode([&inv](CNode* node) { node->PushInventory(inv); });\n+            return true;\n+        }\n+        return false;\n+    }\n+    bool transactionWithinChainLimit(const uint256& txid, size_t chain_limit) override\n+    {\n+        return ::mempool.TransactionWithinChainLimit(txid, chain_limit);\n+    }\n+    bool checkChainLimits(CTransactionRef tx) override\n+    {\n+        LockPoints lp;\n+        CTxMemPoolEntry entry(tx, 0, 0, 0, false, 0, lp);\n+        CTxMemPool::setEntries setAncestors;\n+        size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n+        size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT) * 1000;\n+        size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n+        size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT) * 1000;\n+        std::string errString;\n+        if (!::mempool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize,\n+                nLimitDescendants, nLimitDescendantSize, errString)) {\n+            return false;\n+        }\n+        return true;\n+    }\n+    CFeeRate estimateSmartFee(int num_blocks, bool conservative, FeeCalculation* calc) override\n+    {\n+        return ::feeEstimator.estimateSmartFee(num_blocks, calc, conservative);\n+    }\n+    int estimateMaxBlocks() override\n+    {\n+        return ::feeEstimator.HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE);\n+    }\n+    CFeeRate poolMinFee() override\n+    {\n+        return ::mempool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    }\n+    bool getPruneMode() override { return ::fPruneMode; }\n+    bool p2pEnabled() override { return g_connman != nullptr; }\n+    int64_t getAdjustedTime() override { return GetAdjustedTime(); }\n+    void initMessage(const std::string& message) override { ::uiInterface.InitMessage(message); }\n+    void initWarning(const std::string& message) override { InitWarning(message); }\n+    void initError(const std::string& message) override { InitError(message); }\n+    UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbase_script,\n+        int num_blocks,\n+        uint64_t max_tries,\n+        bool keep_script) override\n+    {\n+        return ::generateBlocks(coinbase_script, num_blocks, max_tries, keep_script);\n+    }\n+    unsigned int parseConfirmTarget(const UniValue& value) override { return ParseConfirmTarget(value); }\n+    std::unique_ptr<Handler> handleNotifications(Notifications& notifications) override\n+    {\n+        return MakeUnique<HandlerImpl>(notifications);\n+    }\n+    void waitForNotifications() override { SyncWithValidationInterfaceQueue(); }\n+    std::unique_ptr<Handler> handleRpc(const CRPCCommand& command) override;\n+\n+    //! Map of RPC method name to forwarder. If multiple clients provide\n+    //! implementations of the same RPC method, the RPC forwarder can dispatch\n+    //! between them.\n+    class RpcForwarder;\n+    std::map<Ref<const std::string>, RpcForwarder> m_rpc_forwarders;\n+};\n+\n+//! Forwarder for one RPC method.\n+class ChainImpl::RpcForwarder\n+{\n+public:\n+    RpcForwarder(const CRPCCommand& command) : m_command(command)\n+    {\n+        m_command.actor = [this](const JSONRPCRequest& request) { return forwardRequest(request); };\n+    }\n+\n+    bool registerForwarder() { return ::tableRPC.appendCommand(m_command.name, &m_command); }\n+\n+    void addCommand(const CRPCCommand& command) { m_commands.emplace_back(&command); }\n+\n+    void removeCommand(const CRPCCommand& command)\n+    {\n+        m_commands.erase(std::remove(m_commands.begin(), m_commands.end(), &command));\n+    }\n+\n+    UniValue forwardRequest(const JSONRPCRequest& request) const\n+    {\n+        // Simple forwarding of RPC requests. This just sends the request to the",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186538449",
      "id" : 186538449,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjUzODQ0OQ==",
      "original_commit_id" : "af8f8087699c30ec83995c54112955253bcaba84",
      "original_position" : 344,
      "path" : "src/interfaces/chain.cpp",
      "position" : 377,
      "pull_request_review_id" : 118137361,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186538449",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Overall, I think this is a huge improvement. It gives us a well-defined interface between the wallet and node and is a huge step towards separating out the different subsystems. Whether or not we decide to go ahead with process separation, this is very useful work.\r\n\r\nThe wallet<->node interface could certainly be tidied up in future PRs. Since this is an internal interface, that shouldn't stop this PR from being merged as the first step.",
      "created_at" : "2018-05-07T20:33:54Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-387196649",
      "id" : 387196649,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10973",
      "updated_at" : "2018-05-07T20:33:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/387196649",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186791509"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186791509"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186497214\r\n\r\n> I think this comment should make clear that the block must be available on disk:\r\n\r\nRenamed as suggested and added your comment in 731b02dd1885e5d7242c894d14054ead91044550.\r\n",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-08T16:39:31Z",
      "diff_hunk" : "@@ -0,0 +1,251 @@\n+#ifndef BITCOIN_INTERFACES_CHAIN_H\n+#define BITCOIN_INTERFACES_CHAIN_H\n+\n+#include <optional.h>               // For Optional and nullopt\n+#include <policy/rbf.h>             // For RBFTransactionState\n+#include <primitives/transaction.h> // For CTransactionRef\n+\n+#include <memory>\n+#include <stddef.h>\n+#include <stdint.h>\n+#include <string>\n+#include <vector>\n+\n+class CBlock;\n+class CRPCCommand;\n+class CReserveScript;\n+class CScheduler;\n+class CValidationState;\n+class UniValue;\n+class uint256;\n+struct CBlockLocator;\n+struct FeeCalculation;\n+\n+namespace interfaces {\n+\n+class Handler;\n+\n+//! Interface for giving wallet processes access to blockchain state.\n+class Chain\n+{\n+public:\n+    virtual ~Chain() {}\n+\n+    //! Interface for querying locked chain state, used by legacy code that\n+    //! assumes state won't change between calls. New code should avoid using\n+    //! the Lock interface and instead call higher-level Chain methods\n+    //! that return more information so the chain doesn't need to stay locked\n+    //! between calls.\n+    class Lock\n+    {\n+    public:\n+        virtual ~Lock() {}\n+\n+        //! Get current chain height, not including genesis block (returns 0 if\n+        //! chain only contains genesis block, nothing if chain does not contain\n+        //! any blocks).\n+        virtual Optional<int> getHeight() = 0;\n+\n+        //! Get block height above genesis block. Returns 0 for genesis block,\n+        //! for following block, and so on. Returns nothing for a block not\n+        //! included in the current chain.\n+        virtual Optional<int> getBlockHeight(const uint256& hash) = 0;\n+\n+        //! Get block depth. Returns 1 for chain tip, 2 for preceding block, and\n+        //! so on. Returns 0 for a block not included in the current chain.\n+        virtual int getBlockDepth(const uint256& hash) = 0;\n+\n+        //! Get block hash.\n+        virtual uint256 getBlockHash(int height) = 0;\n+\n+        //! Get block time.\n+        virtual int64_t getBlockTime(int height) = 0;\n+\n+        //! Get block median time past.\n+        virtual int64_t getBlockMedianTimePast(int height) = 0;\n+\n+        //! Check if block is empty.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186791509",
      "id" : 186791509,
      "in_reply_to_id" : 186497214,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4Njc5MTUwOQ==",
      "original_commit_id" : "af8f8087699c30ec83995c54112955253bcaba84",
      "original_position" : 67,
      "path" : "src/interfaces/chain.h",
      "position" : null,
      "pull_request_review_id" : 117825376,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186791509",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186791578"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186791578"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186501200\r\n\r\n> Shouldn't this be \"height greater than or equal to the given\"?\r\n\r\nYes you're right. Updated comment and renamed method to reflect this in d1ea68d7aa0e8a5b7389a38c4176b38bff5e94b4.",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-08T16:39:47Z",
      "diff_hunk" : "@@ -0,0 +1,251 @@\n+#ifndef BITCOIN_INTERFACES_CHAIN_H\n+#define BITCOIN_INTERFACES_CHAIN_H\n+\n+#include <optional.h>               // For Optional and nullopt\n+#include <policy/rbf.h>             // For RBFTransactionState\n+#include <primitives/transaction.h> // For CTransactionRef\n+\n+#include <memory>\n+#include <stddef.h>\n+#include <stdint.h>\n+#include <string>\n+#include <vector>\n+\n+class CBlock;\n+class CRPCCommand;\n+class CReserveScript;\n+class CScheduler;\n+class CValidationState;\n+class UniValue;\n+class uint256;\n+struct CBlockLocator;\n+struct FeeCalculation;\n+\n+namespace interfaces {\n+\n+class Handler;\n+\n+//! Interface for giving wallet processes access to blockchain state.\n+class Chain\n+{\n+public:\n+    virtual ~Chain() {}\n+\n+    //! Interface for querying locked chain state, used by legacy code that\n+    //! assumes state won't change between calls. New code should avoid using\n+    //! the Lock interface and instead call higher-level Chain methods\n+    //! that return more information so the chain doesn't need to stay locked\n+    //! between calls.\n+    class Lock\n+    {\n+    public:\n+        virtual ~Lock() {}\n+\n+        //! Get current chain height, not including genesis block (returns 0 if\n+        //! chain only contains genesis block, nothing if chain does not contain\n+        //! any blocks).\n+        virtual Optional<int> getHeight() = 0;\n+\n+        //! Get block height above genesis block. Returns 0 for genesis block,\n+        //! for following block, and so on. Returns nothing for a block not\n+        //! included in the current chain.\n+        virtual Optional<int> getBlockHeight(const uint256& hash) = 0;\n+\n+        //! Get block depth. Returns 1 for chain tip, 2 for preceding block, and\n+        //! so on. Returns 0 for a block not included in the current chain.\n+        virtual int getBlockDepth(const uint256& hash) = 0;\n+\n+        //! Get block hash.\n+        virtual uint256 getBlockHash(int height) = 0;\n+\n+        //! Get block time.\n+        virtual int64_t getBlockTime(int height) = 0;\n+\n+        //! Get block median time past.\n+        virtual int64_t getBlockMedianTimePast(int height) = 0;\n+\n+        //! Check if block is empty.\n+        virtual bool blockHasTransactions(int height) = 0;\n+\n+        //! Return height of earliest block in chain with timestamp equal or\n+        //! greater than the given time, or nothing if there is no block with a\n+        //! high enough timestamp.\n+        virtual Optional<int> findEarliestAtLeast(int64_t time) = 0;\n+\n+        //! Return height of last block in chain with timestamp less than the\n+        //! given, and height less than or equal to the given, or nothing if",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186791578",
      "id" : 186791578,
      "in_reply_to_id" : 186501200,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4Njc5MTU3OA==",
      "original_commit_id" : "af8f8087699c30ec83995c54112955253bcaba84",
      "original_position" : 76,
      "path" : "src/interfaces/chain.h",
      "position" : null,
      "pull_request_review_id" : 117825376,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186791578",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186791740"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186791740"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186538449\r\n\r\n> Supporting multiple clients makes this more complex than it needs to be.\r\n>\r\n> This PR would be easier to review if it initially supported just a single client (as we do today). A future PR could extend the RPC forwarding to support multiple clients.\r\n\r\nRPC forwarding is complex I think mostly because I tried to make few changes to `src/rpc/` and instead do forwarding to wallet clients in a new layer. Making the `src/rpc/` code aware of clients and able to disconnect handlers might be a way to make dispatching simpler overall, but would require a larger diff. I'm also not sure it would be useful in the longer run, because it's probably better for wallet processes to just listen for RPC requests directly instead of having the node process listen and forward requests to them.\r\n\r\nSupporting only one client per RPC method instead of multiple seems like it would be sacrificing correctness and only providing a minor simplification. It would allow getting rid of the try/catch in `RpcForwarder::forwardRequest` and replacing `std::vector<const CRPCCommand*> m_commands;` with `const CRPCCommand* m_command;` but I think that's it.",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-08T16:40:21Z",
      "diff_hunk" : "@@ -0,0 +1,419 @@\n+#include <interfaces/chain.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <interfaces/handler.h>\n+#include <net.h>\n+#include <policy/fees.h>\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <protocol.h>\n+#include <rpc/mining.h>\n+#include <rpc/protocol.h>\n+#include <rpc/server.h>\n+#include <sync.h>\n+#include <timedata.h>\n+#include <txmempool.h>\n+#include <ui_interface.h>\n+#include <uint256.h>\n+#include <univalue.h>\n+#include <util.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <tuple>\n+#include <unordered_map>\n+#include <utility>\n+\n+class CReserveScript;\n+\n+namespace interfaces {\n+namespace {\n+\n+//! Extension of std::reference_wrapper with operator< for use as map key.\n+template <typename T>\n+class Ref : public std::reference_wrapper<T>\n+{\n+public:\n+    using std::reference_wrapper<T>::reference_wrapper;\n+    bool operator<(const Ref<T>& other) const { return this->get() < other.get(); }\n+};\n+\n+class LockImpl : public Chain::Lock\n+{\n+    Optional<int> getHeight() override\n+    {\n+        int height = ::chainActive.Height();\n+        if (height >= 0) {\n+            return height;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> getBlockHeight(const uint256& hash) override\n+    {\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end() && it->second) {\n+            if (::chainActive.Contains(it->second)) {\n+                return it->second->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    int getBlockDepth(const uint256& hash) override\n+    {\n+        const Optional<int> tip_height = getHeight();\n+        const Optional<int> height = getBlockHeight(hash);\n+        return tip_height && height ? *tip_height - *height + 1 : 0;\n+    }\n+    uint256 getBlockHash(int height) override { return ::chainActive[height]->GetBlockHash(); }\n+    int64_t getBlockTime(int height) override { return ::chainActive[height]->GetBlockTime(); }\n+    int64_t getBlockMedianTimePast(int height) override { return ::chainActive[height]->GetMedianTimePast(); }\n+    bool blockHasTransactions(int height) override\n+    {\n+        CBlockIndex* block = ::chainActive[height];\n+        return block && (block->nStatus & BLOCK_HAVE_DATA) && block->nTx > 0;\n+    }\n+    Optional<int> findEarliestAtLeast(int64_t time) override\n+    {\n+        CBlockIndex* block = ::chainActive.FindEarliestAtLeast(time);\n+        if (block) {\n+            return block->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findLastBefore(int64_t time, int start_height) override\n+    {\n+        CBlockIndex* block = ::chainActive[start_height];\n+        while (block && block->GetBlockTime() < time) {\n+            block = ::chainActive.Next(block);\n+        }\n+        if (block) {\n+            return block->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findPruned(int start_height, Optional<int> stop_height) override\n+    {\n+        if (::fPruneMode) {\n+            CBlockIndex* block = stop_height ? ::chainActive[*stop_height] : ::chainActive.Tip();\n+            while (block && block->nHeight >= start_height) {\n+                if (!(block->nStatus & BLOCK_HAVE_DATA)) {\n+                    return block->nHeight;\n+                }\n+                block = block->pprev;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFork(const uint256& hash, Optional<int>* height) override\n+    {\n+        const CBlockIndex *block{nullptr}, *fork{nullptr};\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end()) {\n+            block = it->second;\n+            fork = ::chainActive.FindFork(block);\n+        }\n+        if (height) {\n+            if (block) {\n+                *height = block->nHeight;\n+            } else {\n+                height->reset();\n+            }\n+        }\n+        if (fork) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool isPotentialTip(const uint256& hash) override\n+    {\n+        if (::chainActive.Tip()->GetBlockHash() == hash) return true;\n+        auto it = ::mapBlockIndex.find(hash);\n+        return it != ::mapBlockIndex.end() && it->second->GetAncestor(::chainActive.Height()) == ::chainActive.Tip();\n+    }\n+    CBlockLocator getLocator() override { return ::chainActive.GetLocator(); }\n+    Optional<int> findLocatorFork(const CBlockLocator& locator) override\n+    {\n+        if (CBlockIndex* fork = FindForkInGlobalIndex(::chainActive, locator)) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool checkFinalTx(const CTransaction& tx) override { return CheckFinalTx(tx); }\n+    bool isWitnessEnabled() override { return ::IsWitnessEnabled(::chainActive.Tip(), Params().GetConsensus()); }\n+    bool acceptToMemoryPool(CTransactionRef tx, CValidationState& state) override\n+    {\n+        return AcceptToMemoryPool(::mempool, state, tx, nullptr /* missing inputs */, nullptr /* txn replaced */,\n+            false /* bypass limits */, ::maxTxFee /* absurd fee */);\n+    }\n+};\n+\n+class LockingStateImpl : public LockImpl, public CCriticalBlock\n+{\n+    using CCriticalBlock::CCriticalBlock;\n+};\n+\n+class HandlerImpl : public Handler, private CValidationInterface\n+{\n+public:\n+    HandlerImpl(Chain::Notifications& notifications) : m_notifications(notifications)\n+    {\n+        RegisterValidationInterface(this);\n+    }\n+    ~HandlerImpl() override\n+    {\n+        // Don't call UnregisterValidationInterface here because it would try to\n+        // access virtual methods on this object which can't be accessed during\n+        // destruction. Also UnregisterAllValidationInterfaces is already called\n+        // at this point, so unregistering this object would be redundant.\n+    }\n+    void disconnect() override { UnregisterValidationInterface(this); }\n+    void TransactionAddedToMempool(const CTransactionRef& tx) override\n+    {\n+        m_notifications.TransactionAddedToMempool(tx);\n+    }\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx) override\n+    {\n+        m_notifications.TransactionRemovedFromMempool(tx);\n+    }\n+    void BlockConnected(const std::shared_ptr<const CBlock>& block,\n+        const CBlockIndex* index,\n+        const std::vector<CTransactionRef>& tx_conflicted) override\n+    {\n+        m_notifications.BlockConnected(*block, index->GetBlockHash(), tx_conflicted);\n+    }\n+    void BlockDisconnected(const std::shared_ptr<const CBlock>& block) override\n+    {\n+        m_notifications.BlockDisconnected(*block);\n+    }\n+    void ChainStateFlushed(const CBlockLocator& locator) override { m_notifications.ChainStateFlushed(locator); }\n+    void Inventory(const uint256& hash) override { m_notifications.Inventory(hash); }\n+    void ResendWalletTransactions(int64_t best_block_time, CConnman* connman) override\n+    {\n+        m_notifications.ResendWalletTransactions(best_block_time);\n+    }\n+    Chain::Notifications& m_notifications;\n+};\n+\n+class ChainImpl : public Chain\n+{\n+public:\n+    std::unique_ptr<Chain::Lock> lock(bool try_lock) override\n+    {\n+        auto result = MakeUnique<LockingStateImpl>(::cs_main, \"cs_main\", __FILE__, __LINE__, try_lock);\n+        if (try_lock && result && !*result) return {};\n+        // std::move necessary on some compilers due to conversion from\n+        // LockingStateImpl to Lock pointer\n+        return std::move(result);\n+    }\n+    std::unique_ptr<Chain::Lock> assumeLocked() override { return MakeUnique<LockImpl>(); }\n+    bool findBlock(const uint256& hash, CBlock* block, int64_t* time, int64_t* time_max) override\n+    {\n+        CBlockIndex* index;\n+        {\n+            LOCK(cs_main);\n+            auto it = ::mapBlockIndex.find(hash);\n+            if (it == ::mapBlockIndex.end()) {\n+                return false;\n+            }\n+            index = it->second;\n+            if (time) {\n+                *time = index->GetBlockTime();\n+            }\n+            if (time_max) {\n+                *time_max = index->GetBlockTimeMax();\n+            }\n+        }\n+        if (block && !ReadBlockFromDisk(*block, index, Params().GetConsensus())) {\n+            block->SetNull();\n+        }\n+        return true;\n+    }\n+    double guessVerificationProgress(const uint256& block_hash) override\n+    {\n+        LOCK(cs_main);\n+        auto it = ::mapBlockIndex.find(block_hash);\n+        return GuessVerificationProgress(Params().TxData(), it != ::mapBlockIndex.end() ? it->second : nullptr);\n+    }\n+    int64_t getVirtualTransactionSize(const CTransaction& tx) override { return GetVirtualTransactionSize(tx); }\n+    RBFTransactionState isRBFOptIn(const CTransaction& tx) override\n+    {\n+        LOCK(::mempool.cs);\n+        return IsRBFOptIn(tx, ::mempool);\n+    }\n+    bool hasDescendantsInMempool(const uint256& txid) override\n+    {\n+        LOCK(::mempool.cs);\n+        auto it_mp = ::mempool.mapTx.find(txid);\n+        return it_mp != ::mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1;\n+    }\n+    bool relayTransaction(const uint256& txid) override\n+    {\n+        if (g_connman) {\n+            CInv inv(MSG_TX, txid);\n+            g_connman->ForEachNode([&inv](CNode* node) { node->PushInventory(inv); });\n+            return true;\n+        }\n+        return false;\n+    }\n+    bool transactionWithinChainLimit(const uint256& txid, size_t chain_limit) override\n+    {\n+        return ::mempool.TransactionWithinChainLimit(txid, chain_limit);\n+    }\n+    bool checkChainLimits(CTransactionRef tx) override\n+    {\n+        LockPoints lp;\n+        CTxMemPoolEntry entry(tx, 0, 0, 0, false, 0, lp);\n+        CTxMemPool::setEntries setAncestors;\n+        size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n+        size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT) * 1000;\n+        size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n+        size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT) * 1000;\n+        std::string errString;\n+        if (!::mempool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize,\n+                nLimitDescendants, nLimitDescendantSize, errString)) {\n+            return false;\n+        }\n+        return true;\n+    }\n+    CFeeRate estimateSmartFee(int num_blocks, bool conservative, FeeCalculation* calc) override\n+    {\n+        return ::feeEstimator.estimateSmartFee(num_blocks, calc, conservative);\n+    }\n+    int estimateMaxBlocks() override\n+    {\n+        return ::feeEstimator.HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE);\n+    }\n+    CFeeRate poolMinFee() override\n+    {\n+        return ::mempool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    }\n+    bool getPruneMode() override { return ::fPruneMode; }\n+    bool p2pEnabled() override { return g_connman != nullptr; }\n+    int64_t getAdjustedTime() override { return GetAdjustedTime(); }\n+    void initMessage(const std::string& message) override { ::uiInterface.InitMessage(message); }\n+    void initWarning(const std::string& message) override { InitWarning(message); }\n+    void initError(const std::string& message) override { InitError(message); }\n+    UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbase_script,\n+        int num_blocks,\n+        uint64_t max_tries,\n+        bool keep_script) override\n+    {\n+        return ::generateBlocks(coinbase_script, num_blocks, max_tries, keep_script);\n+    }\n+    unsigned int parseConfirmTarget(const UniValue& value) override { return ParseConfirmTarget(value); }\n+    std::unique_ptr<Handler> handleNotifications(Notifications& notifications) override\n+    {\n+        return MakeUnique<HandlerImpl>(notifications);\n+    }\n+    void waitForNotifications() override { SyncWithValidationInterfaceQueue(); }\n+    std::unique_ptr<Handler> handleRpc(const CRPCCommand& command) override;\n+\n+    //! Map of RPC method name to forwarder. If multiple clients provide\n+    //! implementations of the same RPC method, the RPC forwarder can dispatch\n+    //! between them.\n+    class RpcForwarder;\n+    std::map<Ref<const std::string>, RpcForwarder> m_rpc_forwarders;\n+};\n+\n+//! Forwarder for one RPC method.\n+class ChainImpl::RpcForwarder\n+{\n+public:\n+    RpcForwarder(const CRPCCommand& command) : m_command(command)\n+    {\n+        m_command.actor = [this](const JSONRPCRequest& request) { return forwardRequest(request); };\n+    }\n+\n+    bool registerForwarder() { return ::tableRPC.appendCommand(m_command.name, &m_command); }\n+\n+    void addCommand(const CRPCCommand& command) { m_commands.emplace_back(&command); }\n+\n+    void removeCommand(const CRPCCommand& command)\n+    {\n+        m_commands.erase(std::remove(m_commands.begin(), m_commands.end(), &command));\n+    }\n+\n+    UniValue forwardRequest(const JSONRPCRequest& request) const\n+    {\n+        // Simple forwarding of RPC requests. This just sends the request to the",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186791740",
      "id" : 186791740,
      "in_reply_to_id" : 186538449,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4Njc5MTc0MA==",
      "original_commit_id" : "af8f8087699c30ec83995c54112955253bcaba84",
      "original_position" : 344,
      "path" : "src/interfaces/chain.cpp",
      "position" : 377,
      "pull_request_review_id" : 117825376,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186791740",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186791830"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186791830"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186444555\r\n\r\n> Would it make sense to have a Chain::Lock.getTip() to just return the tip hash?\r\n\r\n I started to implement this and look for different places where `getTip` could be used, and found that this was actually the only place it would remove any code. So I think it doesn't make sense to add for now.",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-08T16:40:41Z",
      "diff_hunk" : "@@ -1694,109 +1695,128 @@ int64_t CWallet::RescanFromTime(int64_t startTime, const WalletRescanReserver& r\n     // Find starting block. May be null if nCreateTime is greater than the\n     // highest blockchain timestamp, in which case there is nothing that needs\n     // to be scanned.\n-    CBlockIndex* startBlock = nullptr;\n+    uint256 start_block;\n     {\n-        LOCK(cs_main);\n-        startBlock = chainActive.FindEarliestAtLeast(startTime - TIMESTAMP_WINDOW);\n-        LogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, startBlock ? chainActive.Height() - startBlock->nHeight + 1 : 0);\n-    }\n-\n-    if (startBlock) {\n-        const CBlockIndex* const failedBlock = ScanForWalletTransactions(startBlock, nullptr, reserver, update);\n-        if (failedBlock) {\n-            return failedBlock->GetBlockTimeMax() + TIMESTAMP_WINDOW + 1;\n+        auto locked_chain = m_chain->lock();\n+        const Optional<int> start_height = locked_chain->findEarliestAtLeast(startTime - TIMESTAMP_WINDOW);\n+        const Optional<int> tip_height = locked_chain->getHeight();\n+        LogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, tip_height && start_height ? *tip_height - *start_height + 1 : 0);\n+        if (start_height) start_block = locked_chain->getBlockHash(*start_height);\n+    }\n+\n+    if (!start_block.IsNull()) {\n+        uint256 failed_block = ScanForWalletTransactions(start_block, {} /* stop block */, reserver, update);\n+        if (!failed_block.IsNull()) {\n+            int64_t time_max;\n+            if (!m_chain->findBlock(failed_block, nullptr /* CBlock */, nullptr /* time */, &time_max)) {\n+                throw std::logic_error(\"ScanForWalletTransactions returned invalid block hash\");\n+            }\n+            return time_max + TIMESTAMP_WINDOW + 1;\n         }\n     }\n     return startTime;\n }\n \n /**\n- * Scan the block chain (starting in pindexStart) for transactions\n+ * Scan the block chain (starting in start_block) for transactions\n  * from or to us. If fUpdate is true, found transactions that already\n  * exist in the wallet will be updated.\n  *\n  * Returns null if scan was successful. Otherwise, if a complete rescan was not\n  * possible (due to pruning or corruption), returns pointer to the most recent\n  * block that could not be scanned.\n  *\n- * If pindexStop is not a nullptr, the scan will stop at the block-index\n- * defined by pindexStop\n+ * If stop_block is not null, the scan will stop at the block-index\n+ * defined by stop_block\n  *\n- * Caller needs to make sure pindexStop (and the optional pindexStart) are on\n+ * Caller needs to make sure stop_block (and the optional start_block) are on\n  * the main chain after to the addition of any new keys you want to detect\n  * transactions for.\n  */\n-CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, CBlockIndex* pindexStop, const WalletRescanReserver &reserver, bool fUpdate)\n+uint256 CWallet::ScanForWalletTransactions(const uint256& start_block, const uint256& stop_block, const WalletRescanReserver &reserver, bool fUpdate)\n {\n     int64_t nNow = GetTime();\n     const CChainParams& chainParams = Params();\n \n     assert(reserver.isReserved());\n-    if (pindexStop) {\n-        assert(pindexStop->nHeight >= pindexStart->nHeight);\n-    }\n \n-    CBlockIndex* pindex = pindexStart;\n-    CBlockIndex* ret = nullptr;\n+    uint256 block_hash = start_block;\n+    uint256 ret;\n \n-    if (pindex) LogPrintf(\"Rescan started from block %d...\\n\", pindex->nHeight);\n+    LogPrintf(\"Rescan started from block %s...\\n\", start_block.ToString());\n \n     {\n         fAbortRescan = false;\n         ShowProgress(_(\"Rescanning...\"), 0); // show rescan progress in GUI as dialog or on splashscreen, if -rescan on startup\n-        CBlockIndex* tip = nullptr;\n+        uint256 tip_hash;\n+        Optional<int> block_height;\n         double dProgressStart;\n         double dProgressTip;\n         {\n-            LOCK(cs_main);\n-            tip = chainActive.Tip();\n-            dProgressStart = GuessVerificationProgress(chainParams.TxData(), pindex);\n-            dProgressTip = GuessVerificationProgress(chainParams.TxData(), tip);\n+            auto locked_chain = m_chain->lock();\n+            if (Optional<int> tip_height = locked_chain->getHeight()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186791830",
      "id" : 186791830,
      "in_reply_to_id" : 186444555,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4Njc5MTgzMA==",
      "original_commit_id" : "af8f8087699c30ec83995c54112955253bcaba84",
      "original_position" : 326,
      "path" : "src/wallet/wallet.cpp",
      "position" : 330,
      "pull_request_review_id" : 117825376,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186791830",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186791900"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186791900"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186462615\r\n\r\n> This variable isn't a pointer to a CBlockIndex, and should be named max_height or similar.\r\n\r\nRenamed as suggested in 63158224c69bd3d3621569a42132012ad186eb76.\r\n\r\n",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-08T16:40:58Z",
      "diff_hunk" : "@@ -3795,8 +3818,9 @@ void CWallet::GetKeyBirthTimes(std::map<CTxDestination, int64_t> &mapKeyBirth) c\n     }\n \n     // map in which we'll infer heights of other keys\n-    CBlockIndex *pindexMax = chainActive[std::max(0, chainActive.Height() - 144)]; // the tip can be reorganized; use a 144-block safety margin\n-    std::map<CKeyID, CBlockIndex*> mapKeyFirstBlock;\n+    const Optional<int> tip_height = locked_chain.getHeight();\n+    const int pindexMax = tip_height && *tip_height > 144 ? *tip_height - 144 : 0; // the tip can be reorganized; use a 144-block safety margin",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186791900",
      "id" : 186791900,
      "in_reply_to_id" : 186462615,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4Njc5MTkwMA==",
      "original_commit_id" : "af8f8087699c30ec83995c54112955253bcaba84",
      "original_position" : 1026,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 117825376,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186791900",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186791980"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186791980"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186496577\r\n\r\n> would block_height or block_index be a better variable name here?\r\n\r\nYes, I think so and went with block_height in b2224a586fd6d9f186f9b45a778f70b7294bb83c.",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-08T16:41:16Z",
      "diff_hunk" : "@@ -4129,44 +4152,56 @@ CWallet* CWallet::CreateWalletFromFile(const std::string& name, const fs::path&\n     // Try to top up keypool. No-op if the wallet is locked.\n     walletInstance->TopUpKeyPool();\n \n-    LOCK(cs_main);\n+    auto locked_chain = chain.lock();\n \n-    CBlockIndex *pindexRescan = chainActive.Genesis();\n+    int index_rescan = 0;\n     if (!gArgs.GetBoolArg(\"-rescan\", false))\n     {\n         WalletBatch batch(*walletInstance->database);\n         CBlockLocator locator;\n-        if (batch.ReadBestBlock(locator))\n-            pindexRescan = FindForkInGlobalIndex(chainActive, locator);\n+        if (batch.ReadBestBlock(locator)) {\n+            if (const Optional<int> fork_height = locked_chain->findLocatorFork(locator)) {\n+                index_rescan = *fork_height;\n+            }\n+        }\n+    }\n+\n+    const Optional<int> tip_height = locked_chain->getHeight();\n+    if (tip_height) {\n+        walletInstance->m_last_block_processed = locked_chain->getBlockHash(index_rescan);\n+    } else {\n+        walletInstance->m_last_block_processed.SetNull();\n     }\n \n-    walletInstance->m_last_block_processed = chainActive.Tip();\n-    RegisterValidationInterface(walletInstance);\n+    walletInstance->m_handler = chain.handleNotifications(*walletInstance);\n \n-    if (chainActive.Tip() && chainActive.Tip() != pindexRescan)\n+    if (tip_height && *tip_height != index_rescan)\n     {\n         //We can't rescan beyond non-pruned blocks, stop and throw an error\n         //this might happen if a user uses an old wallet within a pruned node\n         // or if he ran -disablewallet for a longer time, then decided to re-enable\n-        if (fPruneMode)\n+        if (chain.getPruneMode())\n         {\n-            CBlockIndex *block = chainActive.Tip();\n-            while (block && block->pprev && (block->pprev->nStatus & BLOCK_HAVE_DATA) && block->pprev->nTx > 0 && pindexRescan != block)\n-                block = block->pprev;\n+            int block = *tip_height;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186791980",
      "id" : 186791980,
      "in_reply_to_id" : 186496577,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4Njc5MTk4MA==",
      "original_commit_id" : "af8f8087699c30ec83995c54112955253bcaba84",
      "original_position" : 1225,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 117825376,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186791980",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186847373"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186847373"
         }
      },
      "author_association" : "MEMBER",
      "body" : "We need `tip_height` for later and so using `getDepth()` would do an extra `getHeight()` call. But agree that it's a shame to see the depth arithmetic repeated...",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-08T19:53:25Z",
      "diff_hunk" : "@@ -2214,39 +2227,41 @@ UniValue listsinceblock(const JSONRPCRequest& request)\n \n     bool include_removed = (request.params[3].isNull() || request.params[3].get_bool());\n \n-    int depth = pindex ? (1 + chainActive.Height() - pindex->nHeight) : -1;\n+    const Optional<int> tip_height = locked_chain->getHeight();\n+    int depth = tip_height && height ? (1 + *tip_height - *height) : -1;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r186847373",
      "id" : 186847373,
      "in_reply_to_id" : 186225645,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4Njg0NzM3Mw==",
      "original_commit_id" : "af8f8087699c30ec83995c54112955253bcaba84",
      "original_position" : 530,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 406,
      "pull_request_review_id" : 118508941,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186847373",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK on a better defined interface between wallet and node.",
      "created_at" : "2018-05-17T19:40:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-389985196",
      "id" : 389985196,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10973",
      "updated_at" : "2018-05-17T19:40:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/389985196",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK, makes sense!",
      "created_at" : "2018-05-17T19:45:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-389986573",
      "id" : 389986573,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10973",
      "updated_at" : "2018-05-17T19:45:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/389986573",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK",
      "created_at" : "2018-05-17T19:48:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-389987377",
      "id" : 389987377,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10973",
      "updated_at" : "2018-05-17T19:48:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/389987377",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "In case there is agreement to do this change, there should be a plan on how to review and merge without wasting a lot of (re)review and rebase resources. Even though the commits make little sense on their own without the large picture, I assume it would help to split out the mechanical-diff part from the actual code-review part?\r\nAlso, it should probably wait for the current conflicting high-priority pulls to go in.",
      "created_at" : "2018-05-17T20:02:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-389991468",
      "id" : 389991468,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10973",
      "updated_at" : "2018-05-17T20:02:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/389991468",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Great. 3 concept ACKs!\r\n\r\nSplitting first 6 commits into their own PR could make this easier to review: https://botbot.me/freenode/bitcoin-core-dev/2018-05-17/?msg=100176268&page=4\r\n\r\n@ryanofsky - let me know if I can help with that.",
      "created_at" : "2018-05-17T20:02:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-389991584",
      "id" : 389991584,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10973",
      "updated_at" : "2018-05-17T20:02:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/389991584",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Rebased b13720a225f50f9fa96b7e10fda181b1d2770cb8 -> a71c5b8e73d991f28945280c8812fa0c2898a710 ([pr/wipc-sep.55](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.55) -> [pr/wipc-sep.56](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.56)) due to conflict with #10740",
      "created_at" : "2018-05-18T20:10:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-390318779",
      "id" : 390318779,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10973",
      "updated_at" : "2018-05-18T20:10:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/390318779",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r189395768"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189395768"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This feels like a weird method to put in the chain interface because it's just an RPC helper function. I'd actually rather it be duplicated (though that might still require a `maxConfirmTarget` method on the interface).",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-18T21:19:06Z",
      "diff_hunk" : "@@ -182,6 +182,9 @@ class Chain\n         uint64_t max_tries,\n         bool keep_script) = 0;\n \n+    //! Parse confirm target.\n+    virtual unsigned int parseConfirmTarget(const UniValue& value) = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r189395768",
      "id" : 189395768,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4OTM5NTc2OA==",
      "original_commit_id" : "a71c5b8e73d991f28945280c8812fa0c2898a710",
      "original_position" : 5,
      "path" : "src/interfaces/chain.h",
      "position" : null,
      "pull_request_review_id" : 121575825,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/189395768",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "node_id" : "MDQ6VXNlcjg4MTI1Mw==",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Wow, this is heroic. Big Concept ACK. But I would like to see it split into multiple PRs.\r\n\r\nAlso, I'll note that the lowercasing of method names on the interfaces conflicts with the [Coding Style](https://github.com/bitcoin/bitcoin/blob/master/doc/developer-notes.md#coding-style).",
      "created_at" : "2018-05-18T21:22:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-390335988",
      "id" : 390335988,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10973",
      "updated_at" : "2018-05-18T21:22:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/390335988",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "utACK f06a3cc9190bcac4f6109bf9a9f03f92edf1d1fd (not the head commit)\r\n\r\nWill leave <strike>two</strike> one questions for clarification.",
      "created_at" : "2018-05-22T19:50:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-391118517",
      "id" : 391118517,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10973",
      "updated_at" : "2018-05-22T20:14:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/391118517",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r190031428"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/190031428"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Mind to explain why this is removed? I believe `Construct` will still return without creating a chain client and thus `RegisterWalletRPCCommands` is never called.",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-05-22T19:51:52Z",
      "diff_hunk" : "@@ -66,11 +66,6 @@ bool EnsureWalletIsAvailable(CWallet * const pwallet, bool avoidException)\n     if (pwallet) return true;\n     if (avoidException) return false;\n     if (!HasWallets()) {\n-        // Note: It isn't currently possible to trigger this error because\n-        // wallet RPC methods aren't registered unless a wallet is loaded. But\n-        // this error is being kept as a precaution, because it's possible in\n-        // the future that wallet RPC methods might get or remain registered\n-        // when no wallets are loaded.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r190031428",
      "id" : 190031428,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MDAzMTQyOA==",
      "original_commit_id" : "a71c5b8e73d991f28945280c8812fa0c2898a710",
      "original_position" : 8,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 122326231,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/190031428",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2018-06-11T15:04:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-396276168",
      "id" : 396276168,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10973",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5NjI3NjE2OA==",
      "updated_at" : "2018-06-11T15:04:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/396276168",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r196881338"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/196881338"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Maybe replace these two lines as `#include <boost/optional.hpp>` to pass travis tests.\r\n\r\nIn commit 'Remove uses of chainActive and mapBlockIndex in wallet code '",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-06-20T17:39:35Z",
      "diff_hunk" : "@@ -0,0 +1,18 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_OPTIONAL_H\n+#define BITCOIN_OPTIONAL_H\n+\n+#include <boost/none.hpp>\n+#include <boost/optional/optional.hpp>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r196881338",
      "id" : 196881338,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5Njg4MTMzOA==",
      "original_commit_id" : "4a1c901c7e4bd9e2e5545d1a1ab155e86d72faea",
      "original_position" : 9,
      "path" : "src/optional.h",
      "position" : null,
      "pull_request_review_id" : 130515100,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/196881338",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/11154118?v=4",
         "events_url" : "https://api.github.com/users/ken2812221/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ken2812221/followers",
         "following_url" : "https://api.github.com/users/ken2812221/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ken2812221/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ken2812221",
         "id" : 11154118,
         "login" : "ken2812221",
         "node_id" : "MDQ6VXNlcjExMTU0MTE4",
         "organizations_url" : "https://api.github.com/users/ken2812221/orgs",
         "received_events_url" : "https://api.github.com/users/ken2812221/received_events",
         "repos_url" : "https://api.github.com/users/ken2812221/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ken2812221/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ken2812221/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ken2812221"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@ryanofsky - are you still maintaining this? What are your thoughts about splitting the first 6 commits into a separate PR (https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-389991584)?",
      "created_at" : "2018-06-20T18:16:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-398847006",
      "id" : 398847006,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10973",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5ODg0NzAwNg==",
      "updated_at" : "2018-06-20T18:16:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/398847006",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2018-06-24T14:22:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-399760298",
      "id" : 399760298,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10973",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5OTc2MDI5OA==",
      "updated_at" : "2018-06-24T14:22:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/399760298",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Rebased a71c5b8e73d991f28945280c8812fa0c2898a710 -> 7e906d547788bddb9a7993d98e310c65cf6b6604 ([pr/wipc-sep.56](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.56\r\n) -> [pr/wipc-sep.57](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.57)) due to conflict with #13063\r\nRebased 7e906d547788bddb9a7993d98e310c65cf6b6604 -> f8bdedf99707d9317cb600a99ccdece63bea33f8 ([pr/wipc-sep.57](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.57\r\n) -> [pr/wipc-sep.58](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.58)) due to conflict with #13112\r\nRebased f8bdedf99707d9317cb600a99ccdece63bea33f8 -> 79b723888a0ea349fb25ffdeb2ca015f85120e96 ([pr/wipc-sep.58](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.58\r\n) -> [pr/wipc-sep.59](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.59)) due to conflicts with #12634 and #13120\r\nRebased 79b723888a0ea349fb25ffdeb2ca015f85120e96 -> 4a1c901c7e4bd9e2e5545d1a1ab155e86d72faea ([pr/wipc-sep.59](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.59\r\n) -> [pr/wipc-sep.60](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.60)) due to conflict with #13437\r\nRebased 4a1c901c7e4bd9e2e5545d1a1ab155e86d72faea -> 6ee6221aa5adaf643c0d856e9b8a0480f5d6e150 ([pr/wipc-sep.60](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.60) -> [pr/wipc-sep.61](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.61)) due to conflict with #13111\r\n Updated 6ee6221aa5adaf643c0d856e9b8a0480f5d6e150 -> 7e59fa372968009d8b4df29ce9893b4038f9c2cd ([pr/wipc-sep.61](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.61) -> [pr/wipc-sep.62](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.62)) to fix lint errors\r\nRebased 7e59fa372968009d8b4df29ce9893b4038f9c2cd -> 7f9fabce8fa33aae220f9cdeb40c540ef0ef849d ([pr/wipc-sep.62](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.62) -> [pr/wipc-sep.63](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.63)) due to conflict with #13235\r\nRebased 7f9fabce8fa33aae220f9cdeb40c540ef0ef849d -> 56e391398edc617042d910a2433ccd08c6a05d44 ([pr/wipc-sep.63](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.63) -> [pr/wipc-sep.64](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.64)) due to conflict with #13570\r\nRebased 56e391398edc617042d910a2433ccd08c6a05d44 -> d8abd3c2a9378968d258b8beb33b6516eb2257fa ([pr/wipc-sep.64](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.64) -> [pr/wipc-sep.65](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.65)) due to conflict with #13622\r\nRebased d8abd3c2a9378968d258b8beb33b6516eb2257fa -> 635bc2d32ea2a5e67bef8669cc4b4466489d72d1 ([pr/wipc-sep.65](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.65) -> [pr/wipc-sep.66](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.66)) due to conflicts with #13630, #13566, #13651, #13072, and #12944. Also added `g_interfaces` global variable to be able to access chain and chain interface pointers from RPC handlers like `setmocktime` and `loadwallet` that need access to the interfaces but don't have any other way of getting access to bitcoin state.\r\nRebased 635bc2d32ea2a5e67bef8669cc4b4466489d72d1 -> 3344aa65fc6179dabc6fa736fe6c81043466f221 ([pr/wipc-sep.66](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.66) -> [pr/wipc-sep.67](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.67)) due to conflicts with #13822, #9662, #13786. Also replaced ` g_interfaces` with `g_rpc_interfaces`.\r\nUpdated 3344aa65fc6179dabc6fa736fe6c81043466f221 -> fb60d4fbbe5f5e588618a41b858e376f938a02a5 ([pr/wipc-sep.67](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.67) -> [pr/wipc-sep.68](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.68)) to work around circular dependency lint error\r\nRebased fb60d4fbbe5f5e588618a41b858e376f938a02a5 -> 1528b74cdc7425d84911b748e32daaf1d9ce3be6 ([pr/wipc-sep.68](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.68) -> [pr/wipc-sep.69](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.69)) due to conflict with #12992\r\nRebased 1528b74cdc7425d84911b748e32daaf1d9ce3be6 -> 78250d158075f0a71dfef64cfdecc6ef042caf03 ([pr/wipc-sep.69](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.69) -> [pr/wipc-sep.70](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.70)) due to conflict with #13657\r\nRebased 78250d158075f0a71dfef64cfdecc6ef042caf03 -> abe06d8140ec74e3ad0736a3721a97b4a08f6919 ([pr/wipc-sep.70](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.70) -> [pr/wipc-sep.71](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.71)) due to conflict with #13911\r\nRebased abe06d8140ec74e3ad0736a3721a97b4a08f6919 -> 2789833b2114af13881e3949e9c0211ff80a0ec1 ([pr/wipc-sep.71](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.71) -> [pr/wipc-sep.72](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.72)) due to conflict with #13634 \r\nRebased 2789833b2114af13881e3949e9c0211ff80a0ec1 -> 4910f87ee994741004a50e9394dd321771fbbff2 ([pr/wipc-sep.72](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.72) -> [pr/wipc-sep.73](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.73)) due to conflict with #12559\r\nUpdated 4910f87ee994741004a50e9394dd321771fbbff2 -> 49214aa0a0a20676fa1d9ff0324912374058adfc ([pr/wipc-sep.73](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.73) -> [pr/wipc-sep.74](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.74)) to fix msvc / appveyor link errors\r\nUpdated 49214aa0a0a20676fa1d9ff0324912374058adfc -> 3ce12080c3a7413f03df2212f1d58f405489e894 ([pr/wipc-sep.74](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.74) -> [pr/wipc-sep.75](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.75)) to fix msvc / appveyor compile error\r\nRebased 3ce12080c3a7413f03df2212f1d58f405489e894 -> 2f6bf5cd2b6dd4c8a148887afd0aa51237f79a4c ([pr/wipc-sep.75](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.75) -> [pr/wipc-sep.76](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.76)) due to conflicts with #13631, #13083, #14062, and #14023\r\nUpdated 2f6bf5cd2b6dd4c8a148887afd0aa51237f79a4c -> b344a2e3d1b16f08c97edb96fc64b6b6b65c310e ([pr/wipc-sep.76](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.76) -> [pr/wipc-sep.77](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.77)) to fix appveyor error\r\nRebased b344a2e3d1b16f08c97edb96fc64b6b6b65c310e -> bea29712919f5216ffc6096ef715db4d82594032 ([pr/wipc-sep.77](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.77) -> [pr/wipc-sep.78](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.78)) due to conflict with #13825\r\nRebased bea29712919f5216ffc6096ef715db4d82594032 -> 249bf5006184f81d77d40ee0ede0924c628bf33e ([pr/wipc-sep.78](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.78) -> [pr/wipc-sep.79](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.79)) due to conflicts with #10605 and #11599\r\nRebased 249bf5006184f81d77d40ee0ede0924c628bf33e -> 0219d88970afa3dd39501fe5fb9eb1266a0a4830 ([pr/wipc-sep.79](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.79) -> [pr/wipc-sep.80](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.80)) due to conflicts with #14204 and #14168 Rebased 0219d88970afa3dd39501fe5fb9eb1266a0a4830 -> 2da040ee454e1393050607921d625a9d60a0f960 ([pr/wipc-sep.80](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.80) -> [pr/wipc-sep.81](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.81)) due to conflict with #14208 \r\nRebased 2da040ee454e1393050607921d625a9d60a0f960 -> e44e639558b1084f14a97847592616c3df9fff38 ([pr/wipc-sep.81](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.81) -> [pr/wipc-sep.82](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.82)) due to conflict with #12493\r\nRebased e44e639558b1084f14a97847592616c3df9fff38 -> 18c5bba238abc5dbca900eb792b8239bc40f505f ([pr/wipc-sep.82](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.82) -> [pr/wipc-sep.83](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.83)) due to conflicts with #13424 and #14310\r\nRebased 18c5bba238abc5dbca900eb792b8239bc40f505f -> 45b23efaada081a7be9e255df59670f4704c45d1 ([pr/wipc-sep.83](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.83) -> [pr/wipc-sep.84](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.84)) due to conflict with #14282",
      "created_at" : "2018-06-26T17:24:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-400396804",
      "id" : 400396804,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10973",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwMDM5NjgwNA==",
      "updated_at" : "2018-09-27T18:04:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/400396804",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2018-07-07T09:00:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-403200598",
      "id" : 403200598,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10973",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwMzIwMDU5OA==",
      "updated_at" : "2018-07-07T09:00:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/403200598",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2018-07-11T15:07:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-404204168",
      "id" : 404204168,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10973",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwNDIwNDE2OA==",
      "updated_at" : "2018-07-11T15:07:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/404204168",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2018-07-13T19:44:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-404934610",
      "id" : 404934610,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10973",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwNDkzNDYxMA==",
      "updated_at" : "2018-07-13T19:44:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/404934610",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r213473620"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/213473620"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Probably out-of-scope nit: I wish the uint32_t max was instead a named constant that had meaning relative to use with nLockTime (e.g. `IGNORE_NLOCKTIME`).",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-08-28T21:10:55Z",
      "diff_hunk" : "@@ -2726,7 +2741,8 @@ bool CWallet::CreateTransaction(interfaces::Chain::Lock& locked_chain, const std\n     // enough, that fee sniping isn't a problem yet, but by implementing a fix\n     // now we ensure code won't be written that makes assumptions about\n     // nLockTime that preclude a fix later.\n-    txNew.nLockTime = chainActive.Height();\n+    const Optional<int> tip_height = locked_chain.getHeight();\n+    txNew.nLockTime = tip_height ? *tip_height : std::numeric_limits<uint32_t>::max();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r213473620",
      "id" : 213473620,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzQ3MzYyMA==",
      "original_commit_id" : "2aa964dc531464c47c7236ec7b288e3b9c403a1e",
      "original_position" : 292,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 150318841,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/213473620",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "- [x] [`d487d953c9` Add skeleton chain and client classes](https://github.com/bitcoin/bitcoin/pull/10973/commits/d487d953c9a10b11693ba8af62f5b54a77ec7686)\r\n- [x] [`6f47f5be74` Pass chain and client variables where needed](https://github.com/bitcoin/bitcoin/pull/10973/commits/6f47f5be74453f3e4bbf91f57d6ac1925db68e46)\r\n- [x] [`dff1e12e92` Remove direct node->wallet calls in init.cpp](https://github.com/bitcoin/bitcoin/pull/10973/commits/dff1e12e92573ba0e58644f5ea1be2126093625f)\r\n- [x] [`8ea7dd1909` Remove uses of cs_main in wallet code](https://github.com/bitcoin/bitcoin/pull/10973/commits/8ea7dd19093d9c76f4ac908034702e0de886ef6d)\r\n- [x] [`d67069bf83` Pass chain locked variables where needed](https://github.com/bitcoin/bitcoin/pull/10973/commits/d67069bf8334aa88f8272f7a217415dafbc14618)\r\n- [x] [`1b07623a61` Remove uses of chainActive and mapBlockIndex in wallet code](https://github.com/bitcoin/bitcoin/pull/10973/commits/1b07623a61286b0ae7ce3b943255c27ae9716438)\r\n- [x] [`14d21eb05a` Remove uses of CheckFinalTx in wallet code](https://github.com/bitcoin/bitcoin/pull/10973/commits/14d21eb05a1e3de3fea9f32d14814b047b052349)\r\n- [x] [`7bd157aa83` Remove use of AcceptToMemoryPool in wallet code](https://github.com/bitcoin/bitcoin/pull/10973/commits/7bd157aa83c0ebce2ef76520f26f618943b2279d)\r\n- [x] [`e810c853e0` Remove uses of GetVirtualTransactionSize in wallet code](https://github.com/bitcoin/bitcoin/pull/10973/commits/e810c853e0f7b487ad39e2d53e7b680a71d82868)\r\n- [x] [`c71e4f423b` Remove use of IsRBFOptIn in wallet code](https://github.com/bitcoin/bitcoin/pull/10973/commits/c71e4f423ba4833537b54eb5a8d74030090a5c27)\r\n- [x] [`3246d3d2f1` Remove use of GetCountWithDescendants in wallet code](https://github.com/bitcoin/bitcoin/pull/10973/commits/3246d3d2f17d2c4efb7104f78bf6f708c508e2da)\r\n- [x] [`e0854fc5ba` Remove use of g_connman / PushInventory in wallet code](https://github.com/bitcoin/bitcoin/pull/10973/commits/e0854fc5baa7f0212cd9c2ae4d1e3cec682dca08)\r\n- [x] [`e5a71a8e0f` Remove use of GetTransactionAncestry in wallet code](https://github.com/bitcoin/bitcoin/pull/10973/commits/e5a71a8e0fe9c9161b081c328a1034d8c5195336)\r\n- [x] [`473126929a` Remove use of CalculateMemPoolAncestors in wallet code](https://github.com/bitcoin/bitcoin/pull/10973/commits/473126929adb91d4ea28a19056060162cc3c6e9a)\r\n- [x] [`af57d274b1` Remove uses of fee globals in wallet code](https://github.com/bitcoin/bitcoin/pull/10973/commits/af57d274b1d2a490c8e511d5891dbbac8be88a71)\r\n- [x] [`1c50403a84` Remove uses of fPruneMode in wallet code](https://github.com/bitcoin/bitcoin/pull/10973/commits/1c50403a8438556d99be95a904dc7b65ec2e8129)\r\n- [x] [`677dc5e926` Remove uses of g_connman in wallet code](https://github.com/bitcoin/bitcoin/pull/10973/commits/677dc5e9264ff6704ddf783f47c5c20580ae72cb)\r\n- [x] [`87dda2fd14` Remove uses of GetAdjustedTime in wallet code](https://github.com/bitcoin/bitcoin/pull/10973/commits/87dda2fd142175d12f3980fd7f9296d389bcbf87)\r\n- [x] [`360ba70e0d` Remove uses of InitMessage/Warning/Error in wallet code](https://github.com/bitcoin/bitcoin/pull/10973/commits/360ba70e0d9132e673dfb5717290a4747f2eeb29)\r\n- [x] [`e5eb1bf14d` Remove use CValidationInterface in wallet code](https://github.com/bitcoin/bitcoin/pull/10973/commits/e5eb1bf14d9616bcc02852eed9c4c8ddc7d11b0f)\r\n- [x] [`11add99d5d` Remove use of CRPCTable::appendCommand in wallet code](https://github.com/bitcoin/bitcoin/pull/10973/commits/11add99d5de23ac52d1f1cf1ee7685975b685189)\r\n- [x] [`844df0d18f` Remove use of generateBlocks in wallet code](https://github.com/bitcoin/bitcoin/pull/10973/commits/844df0d18f8c0e119ea68462371c4f130d65d639)\r\n- [x] [`6fe04c2cee` Remove uses of ParseConfirmTarget in wallet code](https://github.com/bitcoin/bitcoin/pull/10973/commits/6fe04c2cee500d571d1966f136dc3915ae56a4ba)\r\n- [x] [`53bc670ee9` Remove use of uiInterface.LoadWallet in wallet code](https://github.com/bitcoin/bitcoin/pull/10973/commits/53bc670ee9c3b01fe3d37e228eeb1f2e6694575b)\r\n- [x] [`53d0d39026` Remove use of IsInitialBlockDownload in wallet code](https://github.com/bitcoin/bitcoin/pull/10973/commits/53d0d39026fafdebfb216e44973fa24470fe72e3)\r\n- [x] [`e44e639558` Remove use of CCoinsViewMemPool::GetCoin in wallet code](https://github.com/bitcoin/bitcoin/pull/10973/commits/e44e639558b1084f14a97847592616c3df9fff38)",
      "created_at" : "2018-09-05T07:14:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-418624533",
      "id" : 418624533,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10973",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxODYyNDUzMw==",
      "updated_at" : "2018-09-15T09:05:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/418624533",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/11154118?v=4",
         "events_url" : "https://api.github.com/users/ken2812221/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ken2812221/followers",
         "following_url" : "https://api.github.com/users/ken2812221/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ken2812221/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ken2812221",
         "id" : 11154118,
         "login" : "ken2812221",
         "node_id" : "MDQ6VXNlcjExMTU0MTE4",
         "organizations_url" : "https://api.github.com/users/ken2812221/orgs",
         "received_events_url" : "https://api.github.com/users/ken2812221/received_events",
         "repos_url" : "https://api.github.com/users/ken2812221/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ken2812221/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ken2812221/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ken2812221"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK",
      "created_at" : "2018-09-13T15:37:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-421051664",
      "id" : 421051664,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10973",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyMTA1MTY2NA==",
      "updated_at" : "2018-09-13T15:37:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/421051664",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r217879497"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/217879497"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In commit \"Remove use of g_connman / PushInventory in wallet code\": unnecessary changes",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-09-15T08:29:29Z",
      "diff_hunk" : "@@ -41,6 +41,11 @@ bench_bench_bitcoin_LDADD = \\\n   $(LIBBITCOIN_COMMON) \\\n   $(LIBBITCOIN_UTIL) \\\n   $(LIBBITCOIN_SERVER) \\\n+  $(LIBBITCOIN_COMMON) \\\n+  $(LIBBITCOIN_UTIL) \\\n+  $(LIBBITCOIN_WALLET) \\\n+  $(LIBBITCOIN_SERVER) \\\n+  $(LIBBITCOIN_UTIL) \\",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r217879497",
      "id" : 217879497,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNzg3OTQ5Nw==",
      "original_commit_id" : "e0854fc5baa7f0212cd9c2ae4d1e3cec682dca08",
      "original_position" : 8,
      "path" : "src/Makefile.bench.include",
      "position" : null,
      "pull_request_review_id" : 155707668,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/217879497",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/11154118?v=4",
         "events_url" : "https://api.github.com/users/ken2812221/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ken2812221/followers",
         "following_url" : "https://api.github.com/users/ken2812221/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ken2812221/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ken2812221",
         "id" : 11154118,
         "login" : "ken2812221",
         "node_id" : "MDQ6VXNlcjExMTU0MTE4",
         "organizations_url" : "https://api.github.com/users/ken2812221/orgs",
         "received_events_url" : "https://api.github.com/users/ken2812221/received_events",
         "repos_url" : "https://api.github.com/users/ken2812221/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ken2812221/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ken2812221/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ken2812221"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "This PR does not seem to compile when rebased on `master` :-)",
      "created_at" : "2018-09-21T07:53:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-423447036",
      "id" : 423447036,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10973",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyMzQ0NzAzNg==",
      "updated_at" : "2018-09-21T07:53:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/423447036",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219411542"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219411542"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-19 14:39:06 clang-tidy(pr=10973): src/wallet/test/wallet_test_fixture.cpp:20:21: warning: use '= default' to define a trivial destructor [hicpp-use-equals-default]\r\n```",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-09-21T07:54:18Z",
      "diff_hunk" : "@@ -8,16 +8,15 @@\n #include <wallet/db.h>\n \n WalletTestingSetup::WalletTestingSetup(const std::string& chainName):\n-    TestingSetup(chainName), m_wallet(\"mock\", WalletDatabase::CreateMock())\n+    TestingSetup(chainName), m_wallet(*m_chain, \"mock\", WalletDatabase::CreateMock())\n {\n     bool fFirstRun;\n     m_wallet.LoadWallet(fFirstRun);\n-    RegisterValidationInterface(&m_wallet);\n+    m_wallet.m_handler = m_chain->handleNotifications(m_wallet);\n \n-    RegisterWalletRPCCommands(tableRPC);\n+    m_chain_client->registerRpcs();\n }\n \n WalletTestingSetup::~WalletTestingSetup()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219411542",
      "id" : 219411542,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQxMTU0Mg==",
      "original_commit_id" : "e44e639558b1084f14a97847592616c3df9fff38",
      "original_position" : 16,
      "path" : "src/wallet/test/wallet_test_fixture.cpp",
      "position" : null,
      "pull_request_review_id" : 157580590,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219411542",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219412134"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219412134"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-19 14:39:06 clang-tidy(pr=10973): src/interfaces/chain.cpp:81:25: warning: implicit conversion 'unsigned int' -> bool [readability-implicit-bool-conversion]\r\n```",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-09-21T07:56:18Z",
      "diff_hunk" : "@@ -0,0 +1,453 @@\n+#include <interfaces/chain.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <interfaces/handler.h>\n+#include <interfaces/wallet.h>\n+#include <net.h>\n+#include <policy/fees.h>\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <protocol.h>\n+#include <rpc/mining.h>\n+#include <rpc/protocol.h>\n+#include <rpc/server.h>\n+#include <sync.h>\n+#include <threadsafety.h>\n+#include <timedata.h>\n+#include <txmempool.h>\n+#include <ui_interface.h>\n+#include <uint256.h>\n+#include <univalue.h>\n+#include <util.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <tuple>\n+#include <unordered_map>\n+#include <utility>\n+\n+class CReserveScript;\n+\n+namespace interfaces {\n+namespace {\n+\n+//! Extension of std::reference_wrapper with operator< for use as map key.\n+template <typename T>\n+class Ref : public std::reference_wrapper<T>\n+{\n+public:\n+    using std::reference_wrapper<T>::reference_wrapper;\n+    bool operator<(const Ref<T>& other) const { return this->get() < other.get(); }\n+};\n+\n+class LockImpl : public Chain::Lock\n+{\n+    Optional<int> getHeight() override\n+    {\n+        int height = ::chainActive.Height();\n+        if (height >= 0) {\n+            return height;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> getBlockHeight(const uint256& hash) override\n+    {\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end() && it->second) {\n+            if (::chainActive.Contains(it->second)) {\n+                return it->second->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    int getBlockDepth(const uint256& hash) override\n+    {\n+        const Optional<int> tip_height = getHeight();\n+        const Optional<int> height = getBlockHeight(hash);\n+        return tip_height && height ? *tip_height - *height + 1 : 0;\n+    }\n+    uint256 getBlockHash(int height) override { return ::chainActive[height]->GetBlockHash(); }\n+    int64_t getBlockTime(int height) override { return ::chainActive[height]->GetBlockTime(); }\n+    int64_t getBlockMedianTimePast(int height) override { return ::chainActive[height]->GetMedianTimePast(); }\n+    bool haveBlockOnDisk(int height) override\n+    {\n+        CBlockIndex* block = ::chainActive[height];\n+        return block && (block->nStatus & BLOCK_HAVE_DATA) && block->nTx > 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219412134",
      "id" : 219412134,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQxMjEzNA==",
      "original_commit_id" : "e44e639558b1084f14a97847592616c3df9fff38",
      "original_position" : 81,
      "path" : "src/interfaces/chain.cpp",
      "position" : null,
      "pull_request_review_id" : 157581192,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219412134",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219412177"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219412177"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-19 14:39:06 clang-tidy(pr=10973): src/interfaces/chain.cpp:105:22: warning: implicit conversion 'unsigned int' -> bool [readability-implicit-bool-conversion]\r\n```",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-09-21T07:56:31Z",
      "diff_hunk" : "@@ -0,0 +1,453 @@\n+#include <interfaces/chain.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <interfaces/handler.h>\n+#include <interfaces/wallet.h>\n+#include <net.h>\n+#include <policy/fees.h>\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <protocol.h>\n+#include <rpc/mining.h>\n+#include <rpc/protocol.h>\n+#include <rpc/server.h>\n+#include <sync.h>\n+#include <threadsafety.h>\n+#include <timedata.h>\n+#include <txmempool.h>\n+#include <ui_interface.h>\n+#include <uint256.h>\n+#include <univalue.h>\n+#include <util.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <tuple>\n+#include <unordered_map>\n+#include <utility>\n+\n+class CReserveScript;\n+\n+namespace interfaces {\n+namespace {\n+\n+//! Extension of std::reference_wrapper with operator< for use as map key.\n+template <typename T>\n+class Ref : public std::reference_wrapper<T>\n+{\n+public:\n+    using std::reference_wrapper<T>::reference_wrapper;\n+    bool operator<(const Ref<T>& other) const { return this->get() < other.get(); }\n+};\n+\n+class LockImpl : public Chain::Lock\n+{\n+    Optional<int> getHeight() override\n+    {\n+        int height = ::chainActive.Height();\n+        if (height >= 0) {\n+            return height;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> getBlockHeight(const uint256& hash) override\n+    {\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end() && it->second) {\n+            if (::chainActive.Contains(it->second)) {\n+                return it->second->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    int getBlockDepth(const uint256& hash) override\n+    {\n+        const Optional<int> tip_height = getHeight();\n+        const Optional<int> height = getBlockHeight(hash);\n+        return tip_height && height ? *tip_height - *height + 1 : 0;\n+    }\n+    uint256 getBlockHash(int height) override { return ::chainActive[height]->GetBlockHash(); }\n+    int64_t getBlockTime(int height) override { return ::chainActive[height]->GetBlockTime(); }\n+    int64_t getBlockMedianTimePast(int height) override { return ::chainActive[height]->GetMedianTimePast(); }\n+    bool haveBlockOnDisk(int height) override\n+    {\n+        CBlockIndex* block = ::chainActive[height];\n+        return block && (block->nStatus & BLOCK_HAVE_DATA) && block->nTx > 0;\n+    }\n+    Optional<int> findFirstBlockWithTime(int64_t time) override\n+    {\n+        CBlockIndex* block = ::chainActive.FindEarliestAtLeast(time);\n+        if (block) {\n+            return block->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFirstBlockWithTimeAndHeight(int64_t time, int height) override\n+    {\n+        for (CBlockIndex* block = ::chainActive[height]; block; block = ::chainActive.Next(block)) {\n+            if (block->GetBlockTime() >= time) {\n+                return block->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findPruned(int start_height, Optional<int> stop_height) override\n+    {\n+        if (::fPruneMode) {\n+            CBlockIndex* block = stop_height ? ::chainActive[*stop_height] : ::chainActive.Tip();\n+            while (block && block->nHeight >= start_height) {\n+                if (!(block->nStatus & BLOCK_HAVE_DATA)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219412177",
      "id" : 219412177,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQxMjE3Nw==",
      "original_commit_id" : "e44e639558b1084f14a97847592616c3df9fff38",
      "original_position" : 105,
      "path" : "src/interfaces/chain.cpp",
      "position" : null,
      "pull_request_review_id" : 157581246,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219412177",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219412247"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219412247"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-19 14:39:06 clang-tidy(pr=10973): src/interfaces/chain.cpp:121:13: warning: implicit conversion 'Optional<int> *' (aka 'boost::optional<int> *') -> bool [readability-implicit-bool-conversion]\r\n```",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-09-21T07:56:49Z",
      "diff_hunk" : "@@ -0,0 +1,453 @@\n+#include <interfaces/chain.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <interfaces/handler.h>\n+#include <interfaces/wallet.h>\n+#include <net.h>\n+#include <policy/fees.h>\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <protocol.h>\n+#include <rpc/mining.h>\n+#include <rpc/protocol.h>\n+#include <rpc/server.h>\n+#include <sync.h>\n+#include <threadsafety.h>\n+#include <timedata.h>\n+#include <txmempool.h>\n+#include <ui_interface.h>\n+#include <uint256.h>\n+#include <univalue.h>\n+#include <util.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <tuple>\n+#include <unordered_map>\n+#include <utility>\n+\n+class CReserveScript;\n+\n+namespace interfaces {\n+namespace {\n+\n+//! Extension of std::reference_wrapper with operator< for use as map key.\n+template <typename T>\n+class Ref : public std::reference_wrapper<T>\n+{\n+public:\n+    using std::reference_wrapper<T>::reference_wrapper;\n+    bool operator<(const Ref<T>& other) const { return this->get() < other.get(); }\n+};\n+\n+class LockImpl : public Chain::Lock\n+{\n+    Optional<int> getHeight() override\n+    {\n+        int height = ::chainActive.Height();\n+        if (height >= 0) {\n+            return height;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> getBlockHeight(const uint256& hash) override\n+    {\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end() && it->second) {\n+            if (::chainActive.Contains(it->second)) {\n+                return it->second->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    int getBlockDepth(const uint256& hash) override\n+    {\n+        const Optional<int> tip_height = getHeight();\n+        const Optional<int> height = getBlockHeight(hash);\n+        return tip_height && height ? *tip_height - *height + 1 : 0;\n+    }\n+    uint256 getBlockHash(int height) override { return ::chainActive[height]->GetBlockHash(); }\n+    int64_t getBlockTime(int height) override { return ::chainActive[height]->GetBlockTime(); }\n+    int64_t getBlockMedianTimePast(int height) override { return ::chainActive[height]->GetMedianTimePast(); }\n+    bool haveBlockOnDisk(int height) override\n+    {\n+        CBlockIndex* block = ::chainActive[height];\n+        return block && (block->nStatus & BLOCK_HAVE_DATA) && block->nTx > 0;\n+    }\n+    Optional<int> findFirstBlockWithTime(int64_t time) override\n+    {\n+        CBlockIndex* block = ::chainActive.FindEarliestAtLeast(time);\n+        if (block) {\n+            return block->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFirstBlockWithTimeAndHeight(int64_t time, int height) override\n+    {\n+        for (CBlockIndex* block = ::chainActive[height]; block; block = ::chainActive.Next(block)) {\n+            if (block->GetBlockTime() >= time) {\n+                return block->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findPruned(int start_height, Optional<int> stop_height) override\n+    {\n+        if (::fPruneMode) {\n+            CBlockIndex* block = stop_height ? ::chainActive[*stop_height] : ::chainActive.Tip();\n+            while (block && block->nHeight >= start_height) {\n+                if (!(block->nStatus & BLOCK_HAVE_DATA)) {\n+                    return block->nHeight;\n+                }\n+                block = block->pprev;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFork(const uint256& hash, Optional<int>* height) override\n+    {\n+        const CBlockIndex *block{nullptr}, *fork{nullptr};\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end()) {\n+            block = it->second;\n+            fork = ::chainActive.FindFork(block);\n+        }\n+        if (height) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219412247",
      "id" : 219412247,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQxMjI0Nw==",
      "original_commit_id" : "e44e639558b1084f14a97847592616c3df9fff38",
      "original_position" : 121,
      "path" : "src/interfaces/chain.cpp",
      "position" : null,
      "pull_request_review_id" : 157581340,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219412247",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219412334"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219412334"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-19 14:39:06 clang-tidy(pr=10973): src/interfaces/chain.cpp:168:5: warning: single-argument constructors must be marked explicit to avoid unintentional implicit conversions [hicpp-explicit-conversions]\r\n```",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-09-21T07:57:11Z",
      "diff_hunk" : "@@ -0,0 +1,453 @@\n+#include <interfaces/chain.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <interfaces/handler.h>\n+#include <interfaces/wallet.h>\n+#include <net.h>\n+#include <policy/fees.h>\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <protocol.h>\n+#include <rpc/mining.h>\n+#include <rpc/protocol.h>\n+#include <rpc/server.h>\n+#include <sync.h>\n+#include <threadsafety.h>\n+#include <timedata.h>\n+#include <txmempool.h>\n+#include <ui_interface.h>\n+#include <uint256.h>\n+#include <univalue.h>\n+#include <util.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <tuple>\n+#include <unordered_map>\n+#include <utility>\n+\n+class CReserveScript;\n+\n+namespace interfaces {\n+namespace {\n+\n+//! Extension of std::reference_wrapper with operator< for use as map key.\n+template <typename T>\n+class Ref : public std::reference_wrapper<T>\n+{\n+public:\n+    using std::reference_wrapper<T>::reference_wrapper;\n+    bool operator<(const Ref<T>& other) const { return this->get() < other.get(); }\n+};\n+\n+class LockImpl : public Chain::Lock\n+{\n+    Optional<int> getHeight() override\n+    {\n+        int height = ::chainActive.Height();\n+        if (height >= 0) {\n+            return height;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> getBlockHeight(const uint256& hash) override\n+    {\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end() && it->second) {\n+            if (::chainActive.Contains(it->second)) {\n+                return it->second->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    int getBlockDepth(const uint256& hash) override\n+    {\n+        const Optional<int> tip_height = getHeight();\n+        const Optional<int> height = getBlockHeight(hash);\n+        return tip_height && height ? *tip_height - *height + 1 : 0;\n+    }\n+    uint256 getBlockHash(int height) override { return ::chainActive[height]->GetBlockHash(); }\n+    int64_t getBlockTime(int height) override { return ::chainActive[height]->GetBlockTime(); }\n+    int64_t getBlockMedianTimePast(int height) override { return ::chainActive[height]->GetMedianTimePast(); }\n+    bool haveBlockOnDisk(int height) override\n+    {\n+        CBlockIndex* block = ::chainActive[height];\n+        return block && (block->nStatus & BLOCK_HAVE_DATA) && block->nTx > 0;\n+    }\n+    Optional<int> findFirstBlockWithTime(int64_t time) override\n+    {\n+        CBlockIndex* block = ::chainActive.FindEarliestAtLeast(time);\n+        if (block) {\n+            return block->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFirstBlockWithTimeAndHeight(int64_t time, int height) override\n+    {\n+        for (CBlockIndex* block = ::chainActive[height]; block; block = ::chainActive.Next(block)) {\n+            if (block->GetBlockTime() >= time) {\n+                return block->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findPruned(int start_height, Optional<int> stop_height) override\n+    {\n+        if (::fPruneMode) {\n+            CBlockIndex* block = stop_height ? ::chainActive[*stop_height] : ::chainActive.Tip();\n+            while (block && block->nHeight >= start_height) {\n+                if (!(block->nStatus & BLOCK_HAVE_DATA)) {\n+                    return block->nHeight;\n+                }\n+                block = block->pprev;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFork(const uint256& hash, Optional<int>* height) override\n+    {\n+        const CBlockIndex *block{nullptr}, *fork{nullptr};\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end()) {\n+            block = it->second;\n+            fork = ::chainActive.FindFork(block);\n+        }\n+        if (height) {\n+            if (block) {\n+                *height = block->nHeight;\n+            } else {\n+                height->reset();\n+            }\n+        }\n+        if (fork) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool isPotentialTip(const uint256& hash) override\n+    {\n+        if (::chainActive.Tip()->GetBlockHash() == hash) return true;\n+        auto it = ::mapBlockIndex.find(hash);\n+        return it != ::mapBlockIndex.end() && it->second->GetAncestor(::chainActive.Height()) == ::chainActive.Tip();\n+    }\n+    CBlockLocator getLocator() override { return ::chainActive.GetLocator(); }\n+    Optional<int> findLocatorFork(const CBlockLocator& locator) override\n+    {\n+        if (CBlockIndex* fork = FindForkInGlobalIndex(::chainActive, locator)) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool checkFinalTx(const CTransaction& tx) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return CheckFinalTx(tx);\n+    }\n+    bool acceptToMemoryPool(CTransactionRef tx, CValidationState& state) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return AcceptToMemoryPool(::mempool, state, tx, nullptr /* missing inputs */, nullptr /* txn replaced */,\n+            false /* bypass limits */, ::maxTxFee /* absurd fee */);\n+    }\n+};\n+\n+class LockingStateImpl : public LockImpl, public UniqueLock<CCriticalSection>\n+{\n+    using UniqueLock::UniqueLock;\n+};\n+\n+class HandlerImpl : public Handler\n+{\n+public:\n+    HandlerImpl(Chain::Notifications& notifications) : m_forwarder(notifications) {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219412334",
      "id" : 219412334,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQxMjMzNA==",
      "original_commit_id" : "e44e639558b1084f14a97847592616c3df9fff38",
      "original_position" : 168,
      "path" : "src/interfaces/chain.cpp",
      "position" : null,
      "pull_request_review_id" : 157581455,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219412334",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219412384"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219412384"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-19 14:39:06 clang-tidy(pr=10973): src/interfaces/chain.cpp:182:9: warning: single-argument constructors must be marked explicit to avoid unintentional implicit conversions [google-explicit-constructor]\r\n```",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-09-21T07:57:23Z",
      "diff_hunk" : "@@ -0,0 +1,453 @@\n+#include <interfaces/chain.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <interfaces/handler.h>\n+#include <interfaces/wallet.h>\n+#include <net.h>\n+#include <policy/fees.h>\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <protocol.h>\n+#include <rpc/mining.h>\n+#include <rpc/protocol.h>\n+#include <rpc/server.h>\n+#include <sync.h>\n+#include <threadsafety.h>\n+#include <timedata.h>\n+#include <txmempool.h>\n+#include <ui_interface.h>\n+#include <uint256.h>\n+#include <univalue.h>\n+#include <util.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <tuple>\n+#include <unordered_map>\n+#include <utility>\n+\n+class CReserveScript;\n+\n+namespace interfaces {\n+namespace {\n+\n+//! Extension of std::reference_wrapper with operator< for use as map key.\n+template <typename T>\n+class Ref : public std::reference_wrapper<T>\n+{\n+public:\n+    using std::reference_wrapper<T>::reference_wrapper;\n+    bool operator<(const Ref<T>& other) const { return this->get() < other.get(); }\n+};\n+\n+class LockImpl : public Chain::Lock\n+{\n+    Optional<int> getHeight() override\n+    {\n+        int height = ::chainActive.Height();\n+        if (height >= 0) {\n+            return height;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> getBlockHeight(const uint256& hash) override\n+    {\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end() && it->second) {\n+            if (::chainActive.Contains(it->second)) {\n+                return it->second->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    int getBlockDepth(const uint256& hash) override\n+    {\n+        const Optional<int> tip_height = getHeight();\n+        const Optional<int> height = getBlockHeight(hash);\n+        return tip_height && height ? *tip_height - *height + 1 : 0;\n+    }\n+    uint256 getBlockHash(int height) override { return ::chainActive[height]->GetBlockHash(); }\n+    int64_t getBlockTime(int height) override { return ::chainActive[height]->GetBlockTime(); }\n+    int64_t getBlockMedianTimePast(int height) override { return ::chainActive[height]->GetMedianTimePast(); }\n+    bool haveBlockOnDisk(int height) override\n+    {\n+        CBlockIndex* block = ::chainActive[height];\n+        return block && (block->nStatus & BLOCK_HAVE_DATA) && block->nTx > 0;\n+    }\n+    Optional<int> findFirstBlockWithTime(int64_t time) override\n+    {\n+        CBlockIndex* block = ::chainActive.FindEarliestAtLeast(time);\n+        if (block) {\n+            return block->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFirstBlockWithTimeAndHeight(int64_t time, int height) override\n+    {\n+        for (CBlockIndex* block = ::chainActive[height]; block; block = ::chainActive.Next(block)) {\n+            if (block->GetBlockTime() >= time) {\n+                return block->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findPruned(int start_height, Optional<int> stop_height) override\n+    {\n+        if (::fPruneMode) {\n+            CBlockIndex* block = stop_height ? ::chainActive[*stop_height] : ::chainActive.Tip();\n+            while (block && block->nHeight >= start_height) {\n+                if (!(block->nStatus & BLOCK_HAVE_DATA)) {\n+                    return block->nHeight;\n+                }\n+                block = block->pprev;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFork(const uint256& hash, Optional<int>* height) override\n+    {\n+        const CBlockIndex *block{nullptr}, *fork{nullptr};\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end()) {\n+            block = it->second;\n+            fork = ::chainActive.FindFork(block);\n+        }\n+        if (height) {\n+            if (block) {\n+                *height = block->nHeight;\n+            } else {\n+                height->reset();\n+            }\n+        }\n+        if (fork) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool isPotentialTip(const uint256& hash) override\n+    {\n+        if (::chainActive.Tip()->GetBlockHash() == hash) return true;\n+        auto it = ::mapBlockIndex.find(hash);\n+        return it != ::mapBlockIndex.end() && it->second->GetAncestor(::chainActive.Height()) == ::chainActive.Tip();\n+    }\n+    CBlockLocator getLocator() override { return ::chainActive.GetLocator(); }\n+    Optional<int> findLocatorFork(const CBlockLocator& locator) override\n+    {\n+        if (CBlockIndex* fork = FindForkInGlobalIndex(::chainActive, locator)) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool checkFinalTx(const CTransaction& tx) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return CheckFinalTx(tx);\n+    }\n+    bool acceptToMemoryPool(CTransactionRef tx, CValidationState& state) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return AcceptToMemoryPool(::mempool, state, tx, nullptr /* missing inputs */, nullptr /* txn replaced */,\n+            false /* bypass limits */, ::maxTxFee /* absurd fee */);\n+    }\n+};\n+\n+class LockingStateImpl : public LockImpl, public UniqueLock<CCriticalSection>\n+{\n+    using UniqueLock::UniqueLock;\n+};\n+\n+class HandlerImpl : public Handler\n+{\n+public:\n+    HandlerImpl(Chain::Notifications& notifications) : m_forwarder(notifications) {}\n+    ~HandlerImpl() override\n+    {\n+        // It is important to disconnect here in the HandlerImpl destructor,\n+        // instead of in the HandleImpl::Forwarder destructor, because\n+        // UnregisterAllValidationInterfaces() internally accesses Forwarder\n+        // virtual methods which are no longer available after Forwarder object\n+        // has begun to be being destroyed.\n+        m_forwarder.disconnect();\n+    }\n+    void disconnect() override { m_forwarder.disconnect(); }\n+\n+    struct Forwarder : CValidationInterface\n+    {\n+        Forwarder(Chain::Notifications& notifications) : m_notifications(&notifications)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219412384",
      "id" : 219412384,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQxMjM4NA==",
      "original_commit_id" : "e44e639558b1084f14a97847592616c3df9fff38",
      "original_position" : 182,
      "path" : "src/interfaces/chain.cpp",
      "position" : null,
      "pull_request_review_id" : 157581521,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219412384",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219412493"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219412493"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-19 14:39:06 clang-tidy(pr=10973): src/interfaces/chain.cpp:212:74: warning: parameter 'connman' is unused [misc-unused-parameters]\r\n```",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-09-21T07:57:48Z",
      "diff_hunk" : "@@ -0,0 +1,453 @@\n+#include <interfaces/chain.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <interfaces/handler.h>\n+#include <interfaces/wallet.h>\n+#include <net.h>\n+#include <policy/fees.h>\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <protocol.h>\n+#include <rpc/mining.h>\n+#include <rpc/protocol.h>\n+#include <rpc/server.h>\n+#include <sync.h>\n+#include <threadsafety.h>\n+#include <timedata.h>\n+#include <txmempool.h>\n+#include <ui_interface.h>\n+#include <uint256.h>\n+#include <univalue.h>\n+#include <util.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <tuple>\n+#include <unordered_map>\n+#include <utility>\n+\n+class CReserveScript;\n+\n+namespace interfaces {\n+namespace {\n+\n+//! Extension of std::reference_wrapper with operator< for use as map key.\n+template <typename T>\n+class Ref : public std::reference_wrapper<T>\n+{\n+public:\n+    using std::reference_wrapper<T>::reference_wrapper;\n+    bool operator<(const Ref<T>& other) const { return this->get() < other.get(); }\n+};\n+\n+class LockImpl : public Chain::Lock\n+{\n+    Optional<int> getHeight() override\n+    {\n+        int height = ::chainActive.Height();\n+        if (height >= 0) {\n+            return height;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> getBlockHeight(const uint256& hash) override\n+    {\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end() && it->second) {\n+            if (::chainActive.Contains(it->second)) {\n+                return it->second->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    int getBlockDepth(const uint256& hash) override\n+    {\n+        const Optional<int> tip_height = getHeight();\n+        const Optional<int> height = getBlockHeight(hash);\n+        return tip_height && height ? *tip_height - *height + 1 : 0;\n+    }\n+    uint256 getBlockHash(int height) override { return ::chainActive[height]->GetBlockHash(); }\n+    int64_t getBlockTime(int height) override { return ::chainActive[height]->GetBlockTime(); }\n+    int64_t getBlockMedianTimePast(int height) override { return ::chainActive[height]->GetMedianTimePast(); }\n+    bool haveBlockOnDisk(int height) override\n+    {\n+        CBlockIndex* block = ::chainActive[height];\n+        return block && (block->nStatus & BLOCK_HAVE_DATA) && block->nTx > 0;\n+    }\n+    Optional<int> findFirstBlockWithTime(int64_t time) override\n+    {\n+        CBlockIndex* block = ::chainActive.FindEarliestAtLeast(time);\n+        if (block) {\n+            return block->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFirstBlockWithTimeAndHeight(int64_t time, int height) override\n+    {\n+        for (CBlockIndex* block = ::chainActive[height]; block; block = ::chainActive.Next(block)) {\n+            if (block->GetBlockTime() >= time) {\n+                return block->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findPruned(int start_height, Optional<int> stop_height) override\n+    {\n+        if (::fPruneMode) {\n+            CBlockIndex* block = stop_height ? ::chainActive[*stop_height] : ::chainActive.Tip();\n+            while (block && block->nHeight >= start_height) {\n+                if (!(block->nStatus & BLOCK_HAVE_DATA)) {\n+                    return block->nHeight;\n+                }\n+                block = block->pprev;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFork(const uint256& hash, Optional<int>* height) override\n+    {\n+        const CBlockIndex *block{nullptr}, *fork{nullptr};\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end()) {\n+            block = it->second;\n+            fork = ::chainActive.FindFork(block);\n+        }\n+        if (height) {\n+            if (block) {\n+                *height = block->nHeight;\n+            } else {\n+                height->reset();\n+            }\n+        }\n+        if (fork) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool isPotentialTip(const uint256& hash) override\n+    {\n+        if (::chainActive.Tip()->GetBlockHash() == hash) return true;\n+        auto it = ::mapBlockIndex.find(hash);\n+        return it != ::mapBlockIndex.end() && it->second->GetAncestor(::chainActive.Height()) == ::chainActive.Tip();\n+    }\n+    CBlockLocator getLocator() override { return ::chainActive.GetLocator(); }\n+    Optional<int> findLocatorFork(const CBlockLocator& locator) override\n+    {\n+        if (CBlockIndex* fork = FindForkInGlobalIndex(::chainActive, locator)) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool checkFinalTx(const CTransaction& tx) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return CheckFinalTx(tx);\n+    }\n+    bool acceptToMemoryPool(CTransactionRef tx, CValidationState& state) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return AcceptToMemoryPool(::mempool, state, tx, nullptr /* missing inputs */, nullptr /* txn replaced */,\n+            false /* bypass limits */, ::maxTxFee /* absurd fee */);\n+    }\n+};\n+\n+class LockingStateImpl : public LockImpl, public UniqueLock<CCriticalSection>\n+{\n+    using UniqueLock::UniqueLock;\n+};\n+\n+class HandlerImpl : public Handler\n+{\n+public:\n+    HandlerImpl(Chain::Notifications& notifications) : m_forwarder(notifications) {}\n+    ~HandlerImpl() override\n+    {\n+        // It is important to disconnect here in the HandlerImpl destructor,\n+        // instead of in the HandleImpl::Forwarder destructor, because\n+        // UnregisterAllValidationInterfaces() internally accesses Forwarder\n+        // virtual methods which are no longer available after Forwarder object\n+        // has begun to be being destroyed.\n+        m_forwarder.disconnect();\n+    }\n+    void disconnect() override { m_forwarder.disconnect(); }\n+\n+    struct Forwarder : CValidationInterface\n+    {\n+        Forwarder(Chain::Notifications& notifications) : m_notifications(&notifications)\n+        {\n+            RegisterValidationInterface(this);\n+        }\n+        void disconnect()\n+        {\n+            if (m_notifications) {\n+                m_notifications = nullptr;\n+                UnregisterValidationInterface(this);\n+            }\n+        }\n+        void TransactionAddedToMempool(const CTransactionRef& tx) override\n+        {\n+            m_notifications->TransactionAddedToMempool(tx);\n+        }\n+        void TransactionRemovedFromMempool(const CTransactionRef& tx) override\n+        {\n+            m_notifications->TransactionRemovedFromMempool(tx);\n+        }\n+        void BlockConnected(const std::shared_ptr<const CBlock>& block,\n+            const CBlockIndex* index,\n+            const std::vector<CTransactionRef>& tx_conflicted) override\n+        {\n+            m_notifications->BlockConnected(*block, index->GetBlockHash(), tx_conflicted);\n+        }\n+        void BlockDisconnected(const std::shared_ptr<const CBlock>& block) override\n+        {\n+            m_notifications->BlockDisconnected(*block);\n+        }\n+        void ChainStateFlushed(const CBlockLocator& locator) override { m_notifications->ChainStateFlushed(locator); }\n+        void ResendWalletTransactions(int64_t best_block_time, CConnman* connman) override",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219412493",
      "id" : 219412493,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQxMjQ5Mw==",
      "original_commit_id" : "e44e639558b1084f14a97847592616c3df9fff38",
      "original_position" : 212,
      "path" : "src/interfaces/chain.cpp",
      "position" : null,
      "pull_request_review_id" : 157581640,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219412493",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219415575"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219415575"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-19 14:39:06 clang-tidy(pr=10973): src/interfaces/chain.cpp:315:20: warning: redundant boolean literal in conditional return statement [readability-simplify-boolean-expr]\r\n```",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-09-21T08:11:03Z",
      "diff_hunk" : "@@ -0,0 +1,453 @@\n+#include <interfaces/chain.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <interfaces/handler.h>\n+#include <interfaces/wallet.h>\n+#include <net.h>\n+#include <policy/fees.h>\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <protocol.h>\n+#include <rpc/mining.h>\n+#include <rpc/protocol.h>\n+#include <rpc/server.h>\n+#include <sync.h>\n+#include <threadsafety.h>\n+#include <timedata.h>\n+#include <txmempool.h>\n+#include <ui_interface.h>\n+#include <uint256.h>\n+#include <univalue.h>\n+#include <util.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <tuple>\n+#include <unordered_map>\n+#include <utility>\n+\n+class CReserveScript;\n+\n+namespace interfaces {\n+namespace {\n+\n+//! Extension of std::reference_wrapper with operator< for use as map key.\n+template <typename T>\n+class Ref : public std::reference_wrapper<T>\n+{\n+public:\n+    using std::reference_wrapper<T>::reference_wrapper;\n+    bool operator<(const Ref<T>& other) const { return this->get() < other.get(); }\n+};\n+\n+class LockImpl : public Chain::Lock\n+{\n+    Optional<int> getHeight() override\n+    {\n+        int height = ::chainActive.Height();\n+        if (height >= 0) {\n+            return height;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> getBlockHeight(const uint256& hash) override\n+    {\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end() && it->second) {\n+            if (::chainActive.Contains(it->second)) {\n+                return it->second->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    int getBlockDepth(const uint256& hash) override\n+    {\n+        const Optional<int> tip_height = getHeight();\n+        const Optional<int> height = getBlockHeight(hash);\n+        return tip_height && height ? *tip_height - *height + 1 : 0;\n+    }\n+    uint256 getBlockHash(int height) override { return ::chainActive[height]->GetBlockHash(); }\n+    int64_t getBlockTime(int height) override { return ::chainActive[height]->GetBlockTime(); }\n+    int64_t getBlockMedianTimePast(int height) override { return ::chainActive[height]->GetMedianTimePast(); }\n+    bool haveBlockOnDisk(int height) override\n+    {\n+        CBlockIndex* block = ::chainActive[height];\n+        return block && (block->nStatus & BLOCK_HAVE_DATA) && block->nTx > 0;\n+    }\n+    Optional<int> findFirstBlockWithTime(int64_t time) override\n+    {\n+        CBlockIndex* block = ::chainActive.FindEarliestAtLeast(time);\n+        if (block) {\n+            return block->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFirstBlockWithTimeAndHeight(int64_t time, int height) override\n+    {\n+        for (CBlockIndex* block = ::chainActive[height]; block; block = ::chainActive.Next(block)) {\n+            if (block->GetBlockTime() >= time) {\n+                return block->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findPruned(int start_height, Optional<int> stop_height) override\n+    {\n+        if (::fPruneMode) {\n+            CBlockIndex* block = stop_height ? ::chainActive[*stop_height] : ::chainActive.Tip();\n+            while (block && block->nHeight >= start_height) {\n+                if (!(block->nStatus & BLOCK_HAVE_DATA)) {\n+                    return block->nHeight;\n+                }\n+                block = block->pprev;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFork(const uint256& hash, Optional<int>* height) override\n+    {\n+        const CBlockIndex *block{nullptr}, *fork{nullptr};\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end()) {\n+            block = it->second;\n+            fork = ::chainActive.FindFork(block);\n+        }\n+        if (height) {\n+            if (block) {\n+                *height = block->nHeight;\n+            } else {\n+                height->reset();\n+            }\n+        }\n+        if (fork) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool isPotentialTip(const uint256& hash) override\n+    {\n+        if (::chainActive.Tip()->GetBlockHash() == hash) return true;\n+        auto it = ::mapBlockIndex.find(hash);\n+        return it != ::mapBlockIndex.end() && it->second->GetAncestor(::chainActive.Height()) == ::chainActive.Tip();\n+    }\n+    CBlockLocator getLocator() override { return ::chainActive.GetLocator(); }\n+    Optional<int> findLocatorFork(const CBlockLocator& locator) override\n+    {\n+        if (CBlockIndex* fork = FindForkInGlobalIndex(::chainActive, locator)) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool checkFinalTx(const CTransaction& tx) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return CheckFinalTx(tx);\n+    }\n+    bool acceptToMemoryPool(CTransactionRef tx, CValidationState& state) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return AcceptToMemoryPool(::mempool, state, tx, nullptr /* missing inputs */, nullptr /* txn replaced */,\n+            false /* bypass limits */, ::maxTxFee /* absurd fee */);\n+    }\n+};\n+\n+class LockingStateImpl : public LockImpl, public UniqueLock<CCriticalSection>\n+{\n+    using UniqueLock::UniqueLock;\n+};\n+\n+class HandlerImpl : public Handler\n+{\n+public:\n+    HandlerImpl(Chain::Notifications& notifications) : m_forwarder(notifications) {}\n+    ~HandlerImpl() override\n+    {\n+        // It is important to disconnect here in the HandlerImpl destructor,\n+        // instead of in the HandleImpl::Forwarder destructor, because\n+        // UnregisterAllValidationInterfaces() internally accesses Forwarder\n+        // virtual methods which are no longer available after Forwarder object\n+        // has begun to be being destroyed.\n+        m_forwarder.disconnect();\n+    }\n+    void disconnect() override { m_forwarder.disconnect(); }\n+\n+    struct Forwarder : CValidationInterface\n+    {\n+        Forwarder(Chain::Notifications& notifications) : m_notifications(&notifications)\n+        {\n+            RegisterValidationInterface(this);\n+        }\n+        void disconnect()\n+        {\n+            if (m_notifications) {\n+                m_notifications = nullptr;\n+                UnregisterValidationInterface(this);\n+            }\n+        }\n+        void TransactionAddedToMempool(const CTransactionRef& tx) override\n+        {\n+            m_notifications->TransactionAddedToMempool(tx);\n+        }\n+        void TransactionRemovedFromMempool(const CTransactionRef& tx) override\n+        {\n+            m_notifications->TransactionRemovedFromMempool(tx);\n+        }\n+        void BlockConnected(const std::shared_ptr<const CBlock>& block,\n+            const CBlockIndex* index,\n+            const std::vector<CTransactionRef>& tx_conflicted) override\n+        {\n+            m_notifications->BlockConnected(*block, index->GetBlockHash(), tx_conflicted);\n+        }\n+        void BlockDisconnected(const std::shared_ptr<const CBlock>& block) override\n+        {\n+            m_notifications->BlockDisconnected(*block);\n+        }\n+        void ChainStateFlushed(const CBlockLocator& locator) override { m_notifications->ChainStateFlushed(locator); }\n+        void ResendWalletTransactions(int64_t best_block_time, CConnman* connman) override\n+        {\n+            m_notifications->ResendWalletTransactions(best_block_time);\n+        }\n+\n+        Chain::Notifications* m_notifications;\n+    };\n+\n+    Forwarder m_forwarder;\n+};\n+\n+class ChainImpl : public Chain\n+{\n+public:\n+    std::unique_ptr<Chain::Lock> lock(bool try_lock) override\n+    {\n+        auto result = MakeUnique<LockingStateImpl>(::cs_main, \"cs_main\", __FILE__, __LINE__, try_lock);\n+        if (try_lock && result && !*result) return {};\n+        // std::move necessary on some compilers due to conversion from\n+        // LockingStateImpl to Lock pointer\n+        return std::move(result);\n+    }\n+    std::unique_ptr<Chain::Lock> assumeLocked() override { return MakeUnique<LockImpl>(); }\n+    bool findBlock(const uint256& hash, CBlock* block, int64_t* time, int64_t* time_max) override\n+    {\n+        CBlockIndex* index;\n+        {\n+            LOCK(cs_main);\n+            auto it = ::mapBlockIndex.find(hash);\n+            if (it == ::mapBlockIndex.end()) {\n+                return false;\n+            }\n+            index = it->second;\n+            if (time) {\n+                *time = index->GetBlockTime();\n+            }\n+            if (time_max) {\n+                *time_max = index->GetBlockTimeMax();\n+            }\n+        }\n+        if (block && !ReadBlockFromDisk(*block, index, Params().GetConsensus())) {\n+            block->SetNull();\n+        }\n+        return true;\n+    }\n+    std::vector<Coin> findCoins(const std::vector<COutPoint>& outputs) override\n+    {\n+        std::vector<Coin> coins;\n+        LOCK2(cs_main, ::mempool.cs);\n+        assert(pcoinsTip);\n+        CCoinsViewCache& chain_view = *::pcoinsTip;\n+        CCoinsViewMemPool mempool_view(&chain_view, ::mempool);\n+        for (const auto& output : outputs) {\n+            Coin coin;\n+            mempool_view.GetCoin(output, coin);\n+            coins.emplace_back(std::move(coin));\n+        }\n+        return coins;\n+    }\n+    double guessVerificationProgress(const uint256& block_hash) override\n+    {\n+        LOCK(cs_main);\n+        auto it = ::mapBlockIndex.find(block_hash);\n+        return GuessVerificationProgress(Params().TxData(), it != ::mapBlockIndex.end() ? it->second : nullptr);\n+    }\n+    int64_t getVirtualTransactionSize(const CTransaction& tx) override { return GetVirtualTransactionSize(tx); }\n+    RBFTransactionState isRBFOptIn(const CTransaction& tx) override\n+    {\n+        LOCK(::mempool.cs);\n+        return IsRBFOptIn(tx, ::mempool);\n+    }\n+    bool hasDescendantsInMempool(const uint256& txid) override\n+    {\n+        LOCK(::mempool.cs);\n+        auto it_mp = ::mempool.mapTx.find(txid);\n+        return it_mp != ::mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1;\n+    }\n+    bool relayTransaction(const uint256& txid) override\n+    {\n+        if (g_connman) {\n+            CInv inv(MSG_TX, txid);\n+            g_connman->ForEachNode([&inv](CNode* node) { node->PushInventory(inv); });\n+            return true;\n+        }\n+        return false;\n+    }\n+    void getTransactionAncestry(const uint256& txid, size_t& ancestors, size_t& descendants) override\n+    {\n+        ::mempool.GetTransactionAncestry(txid, ancestors, descendants);\n+    }\n+    bool checkChainLimits(CTransactionRef tx) override\n+    {\n+        LockPoints lp;\n+        CTxMemPoolEntry entry(tx, 0, 0, 0, false, 0, lp);\n+        CTxMemPool::setEntries setAncestors;\n+        size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n+        size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT) * 1000;\n+        size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n+        size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT) * 1000;\n+        std::string errString;\n+        LOCK(::mempool.cs);\n+        if (!::mempool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize,\n+                nLimitDescendants, nLimitDescendantSize, errString)) {\n+            return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219415575",
      "id" : 219415575,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQxNTU3NQ==",
      "original_commit_id" : "e44e639558b1084f14a97847592616c3df9fff38",
      "original_position" : 315,
      "path" : "src/interfaces/chain.cpp",
      "position" : null,
      "pull_request_review_id" : 157585498,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219415575",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219415650"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219415650"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-19 14:39:06 clang-tidy(pr=10973): src/interfaces/chain.cpp:362:5: warning: single-argument constructors must be marked explicit to avoid unintentional implicit conversions [google-explicit-constructor]\r\n```",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-09-21T08:11:24Z",
      "diff_hunk" : "@@ -0,0 +1,453 @@\n+#include <interfaces/chain.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <interfaces/handler.h>\n+#include <interfaces/wallet.h>\n+#include <net.h>\n+#include <policy/fees.h>\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <protocol.h>\n+#include <rpc/mining.h>\n+#include <rpc/protocol.h>\n+#include <rpc/server.h>\n+#include <sync.h>\n+#include <threadsafety.h>\n+#include <timedata.h>\n+#include <txmempool.h>\n+#include <ui_interface.h>\n+#include <uint256.h>\n+#include <univalue.h>\n+#include <util.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <tuple>\n+#include <unordered_map>\n+#include <utility>\n+\n+class CReserveScript;\n+\n+namespace interfaces {\n+namespace {\n+\n+//! Extension of std::reference_wrapper with operator< for use as map key.\n+template <typename T>\n+class Ref : public std::reference_wrapper<T>\n+{\n+public:\n+    using std::reference_wrapper<T>::reference_wrapper;\n+    bool operator<(const Ref<T>& other) const { return this->get() < other.get(); }\n+};\n+\n+class LockImpl : public Chain::Lock\n+{\n+    Optional<int> getHeight() override\n+    {\n+        int height = ::chainActive.Height();\n+        if (height >= 0) {\n+            return height;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> getBlockHeight(const uint256& hash) override\n+    {\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end() && it->second) {\n+            if (::chainActive.Contains(it->second)) {\n+                return it->second->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    int getBlockDepth(const uint256& hash) override\n+    {\n+        const Optional<int> tip_height = getHeight();\n+        const Optional<int> height = getBlockHeight(hash);\n+        return tip_height && height ? *tip_height - *height + 1 : 0;\n+    }\n+    uint256 getBlockHash(int height) override { return ::chainActive[height]->GetBlockHash(); }\n+    int64_t getBlockTime(int height) override { return ::chainActive[height]->GetBlockTime(); }\n+    int64_t getBlockMedianTimePast(int height) override { return ::chainActive[height]->GetMedianTimePast(); }\n+    bool haveBlockOnDisk(int height) override\n+    {\n+        CBlockIndex* block = ::chainActive[height];\n+        return block && (block->nStatus & BLOCK_HAVE_DATA) && block->nTx > 0;\n+    }\n+    Optional<int> findFirstBlockWithTime(int64_t time) override\n+    {\n+        CBlockIndex* block = ::chainActive.FindEarliestAtLeast(time);\n+        if (block) {\n+            return block->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFirstBlockWithTimeAndHeight(int64_t time, int height) override\n+    {\n+        for (CBlockIndex* block = ::chainActive[height]; block; block = ::chainActive.Next(block)) {\n+            if (block->GetBlockTime() >= time) {\n+                return block->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findPruned(int start_height, Optional<int> stop_height) override\n+    {\n+        if (::fPruneMode) {\n+            CBlockIndex* block = stop_height ? ::chainActive[*stop_height] : ::chainActive.Tip();\n+            while (block && block->nHeight >= start_height) {\n+                if (!(block->nStatus & BLOCK_HAVE_DATA)) {\n+                    return block->nHeight;\n+                }\n+                block = block->pprev;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFork(const uint256& hash, Optional<int>* height) override\n+    {\n+        const CBlockIndex *block{nullptr}, *fork{nullptr};\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end()) {\n+            block = it->second;\n+            fork = ::chainActive.FindFork(block);\n+        }\n+        if (height) {\n+            if (block) {\n+                *height = block->nHeight;\n+            } else {\n+                height->reset();\n+            }\n+        }\n+        if (fork) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool isPotentialTip(const uint256& hash) override\n+    {\n+        if (::chainActive.Tip()->GetBlockHash() == hash) return true;\n+        auto it = ::mapBlockIndex.find(hash);\n+        return it != ::mapBlockIndex.end() && it->second->GetAncestor(::chainActive.Height()) == ::chainActive.Tip();\n+    }\n+    CBlockLocator getLocator() override { return ::chainActive.GetLocator(); }\n+    Optional<int> findLocatorFork(const CBlockLocator& locator) override\n+    {\n+        if (CBlockIndex* fork = FindForkInGlobalIndex(::chainActive, locator)) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool checkFinalTx(const CTransaction& tx) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return CheckFinalTx(tx);\n+    }\n+    bool acceptToMemoryPool(CTransactionRef tx, CValidationState& state) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return AcceptToMemoryPool(::mempool, state, tx, nullptr /* missing inputs */, nullptr /* txn replaced */,\n+            false /* bypass limits */, ::maxTxFee /* absurd fee */);\n+    }\n+};\n+\n+class LockingStateImpl : public LockImpl, public UniqueLock<CCriticalSection>\n+{\n+    using UniqueLock::UniqueLock;\n+};\n+\n+class HandlerImpl : public Handler\n+{\n+public:\n+    HandlerImpl(Chain::Notifications& notifications) : m_forwarder(notifications) {}\n+    ~HandlerImpl() override\n+    {\n+        // It is important to disconnect here in the HandlerImpl destructor,\n+        // instead of in the HandleImpl::Forwarder destructor, because\n+        // UnregisterAllValidationInterfaces() internally accesses Forwarder\n+        // virtual methods which are no longer available after Forwarder object\n+        // has begun to be being destroyed.\n+        m_forwarder.disconnect();\n+    }\n+    void disconnect() override { m_forwarder.disconnect(); }\n+\n+    struct Forwarder : CValidationInterface\n+    {\n+        Forwarder(Chain::Notifications& notifications) : m_notifications(&notifications)\n+        {\n+            RegisterValidationInterface(this);\n+        }\n+        void disconnect()\n+        {\n+            if (m_notifications) {\n+                m_notifications = nullptr;\n+                UnregisterValidationInterface(this);\n+            }\n+        }\n+        void TransactionAddedToMempool(const CTransactionRef& tx) override\n+        {\n+            m_notifications->TransactionAddedToMempool(tx);\n+        }\n+        void TransactionRemovedFromMempool(const CTransactionRef& tx) override\n+        {\n+            m_notifications->TransactionRemovedFromMempool(tx);\n+        }\n+        void BlockConnected(const std::shared_ptr<const CBlock>& block,\n+            const CBlockIndex* index,\n+            const std::vector<CTransactionRef>& tx_conflicted) override\n+        {\n+            m_notifications->BlockConnected(*block, index->GetBlockHash(), tx_conflicted);\n+        }\n+        void BlockDisconnected(const std::shared_ptr<const CBlock>& block) override\n+        {\n+            m_notifications->BlockDisconnected(*block);\n+        }\n+        void ChainStateFlushed(const CBlockLocator& locator) override { m_notifications->ChainStateFlushed(locator); }\n+        void ResendWalletTransactions(int64_t best_block_time, CConnman* connman) override\n+        {\n+            m_notifications->ResendWalletTransactions(best_block_time);\n+        }\n+\n+        Chain::Notifications* m_notifications;\n+    };\n+\n+    Forwarder m_forwarder;\n+};\n+\n+class ChainImpl : public Chain\n+{\n+public:\n+    std::unique_ptr<Chain::Lock> lock(bool try_lock) override\n+    {\n+        auto result = MakeUnique<LockingStateImpl>(::cs_main, \"cs_main\", __FILE__, __LINE__, try_lock);\n+        if (try_lock && result && !*result) return {};\n+        // std::move necessary on some compilers due to conversion from\n+        // LockingStateImpl to Lock pointer\n+        return std::move(result);\n+    }\n+    std::unique_ptr<Chain::Lock> assumeLocked() override { return MakeUnique<LockImpl>(); }\n+    bool findBlock(const uint256& hash, CBlock* block, int64_t* time, int64_t* time_max) override\n+    {\n+        CBlockIndex* index;\n+        {\n+            LOCK(cs_main);\n+            auto it = ::mapBlockIndex.find(hash);\n+            if (it == ::mapBlockIndex.end()) {\n+                return false;\n+            }\n+            index = it->second;\n+            if (time) {\n+                *time = index->GetBlockTime();\n+            }\n+            if (time_max) {\n+                *time_max = index->GetBlockTimeMax();\n+            }\n+        }\n+        if (block && !ReadBlockFromDisk(*block, index, Params().GetConsensus())) {\n+            block->SetNull();\n+        }\n+        return true;\n+    }\n+    std::vector<Coin> findCoins(const std::vector<COutPoint>& outputs) override\n+    {\n+        std::vector<Coin> coins;\n+        LOCK2(cs_main, ::mempool.cs);\n+        assert(pcoinsTip);\n+        CCoinsViewCache& chain_view = *::pcoinsTip;\n+        CCoinsViewMemPool mempool_view(&chain_view, ::mempool);\n+        for (const auto& output : outputs) {\n+            Coin coin;\n+            mempool_view.GetCoin(output, coin);\n+            coins.emplace_back(std::move(coin));\n+        }\n+        return coins;\n+    }\n+    double guessVerificationProgress(const uint256& block_hash) override\n+    {\n+        LOCK(cs_main);\n+        auto it = ::mapBlockIndex.find(block_hash);\n+        return GuessVerificationProgress(Params().TxData(), it != ::mapBlockIndex.end() ? it->second : nullptr);\n+    }\n+    int64_t getVirtualTransactionSize(const CTransaction& tx) override { return GetVirtualTransactionSize(tx); }\n+    RBFTransactionState isRBFOptIn(const CTransaction& tx) override\n+    {\n+        LOCK(::mempool.cs);\n+        return IsRBFOptIn(tx, ::mempool);\n+    }\n+    bool hasDescendantsInMempool(const uint256& txid) override\n+    {\n+        LOCK(::mempool.cs);\n+        auto it_mp = ::mempool.mapTx.find(txid);\n+        return it_mp != ::mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1;\n+    }\n+    bool relayTransaction(const uint256& txid) override\n+    {\n+        if (g_connman) {\n+            CInv inv(MSG_TX, txid);\n+            g_connman->ForEachNode([&inv](CNode* node) { node->PushInventory(inv); });\n+            return true;\n+        }\n+        return false;\n+    }\n+    void getTransactionAncestry(const uint256& txid, size_t& ancestors, size_t& descendants) override\n+    {\n+        ::mempool.GetTransactionAncestry(txid, ancestors, descendants);\n+    }\n+    bool checkChainLimits(CTransactionRef tx) override\n+    {\n+        LockPoints lp;\n+        CTxMemPoolEntry entry(tx, 0, 0, 0, false, 0, lp);\n+        CTxMemPool::setEntries setAncestors;\n+        size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n+        size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT) * 1000;\n+        size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n+        size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT) * 1000;\n+        std::string errString;\n+        LOCK(::mempool.cs);\n+        if (!::mempool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize,\n+                nLimitDescendants, nLimitDescendantSize, errString)) {\n+            return false;\n+        }\n+        return true;\n+    }\n+    CFeeRate estimateSmartFee(int num_blocks, bool conservative, FeeCalculation* calc) override\n+    {\n+        return ::feeEstimator.estimateSmartFee(num_blocks, calc, conservative);\n+    }\n+    int estimateMaxBlocks() override { return ::feeEstimator.HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE); }\n+    CFeeRate poolMinFee() override\n+    {\n+        return ::mempool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    }\n+    bool getPruneMode() override { return ::fPruneMode; }\n+    bool p2pEnabled() override { return g_connman != nullptr; }\n+    bool isInitialBlockDownload() override { return IsInitialBlockDownload(); }\n+    int64_t getAdjustedTime() override { return GetAdjustedTime(); }\n+    void initMessage(const std::string& message) override { ::uiInterface.InitMessage(message); }\n+    void initWarning(const std::string& message) override { InitWarning(message); }\n+    void initError(const std::string& message) override { InitError(message); }\n+    void loadWallet(std::unique_ptr<Wallet> wallet) override { ::uiInterface.LoadWallet(wallet); }\n+    UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbase_script,\n+        int num_blocks,\n+        uint64_t max_tries,\n+        bool keep_script) override\n+    {\n+        return ::generateBlocks(coinbase_script, num_blocks, max_tries, keep_script);\n+    }\n+    unsigned int parseConfirmTarget(const UniValue& value) override { return ParseConfirmTarget(value); }\n+    std::unique_ptr<Handler> handleNotifications(Notifications& notifications) override\n+    {\n+        return MakeUnique<HandlerImpl>(notifications);\n+    }\n+    void waitForNotifications() override { SyncWithValidationInterfaceQueue(); }\n+    std::unique_ptr<Handler> handleRpc(const CRPCCommand& command) override;\n+\n+    //! Map of RPC method name to forwarder. If multiple clients provide\n+    //! implementations of the same RPC method, the RPC forwarder can dispatch\n+    //! between them.\n+    class RpcForwarder;\n+    std::map<Ref<const std::string>, RpcForwarder> m_rpc_forwarders;\n+};\n+\n+//! Forwarder for one RPC method.\n+class ChainImpl::RpcForwarder\n+{\n+public:\n+    RpcForwarder(const CRPCCommand& command) : m_command(command)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219415650",
      "id" : 219415650,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQxNTY1MA==",
      "original_commit_id" : "e44e639558b1084f14a97847592616c3df9fff38",
      "original_position" : 362,
      "path" : "src/interfaces/chain.cpp",
      "position" : null,
      "pull_request_review_id" : 157585601,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219415650",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219415928"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219415928"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-19 14:39:06 clang-tidy(pr=10973): src/interfaces/chain.cpp:373:9: warning: this call will remove at most one item even when multiple items should be removed [bugprone-inaccurate-erase]\r\n```",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-09-21T08:12:32Z",
      "diff_hunk" : "@@ -0,0 +1,453 @@\n+#include <interfaces/chain.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <interfaces/handler.h>\n+#include <interfaces/wallet.h>\n+#include <net.h>\n+#include <policy/fees.h>\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <protocol.h>\n+#include <rpc/mining.h>\n+#include <rpc/protocol.h>\n+#include <rpc/server.h>\n+#include <sync.h>\n+#include <threadsafety.h>\n+#include <timedata.h>\n+#include <txmempool.h>\n+#include <ui_interface.h>\n+#include <uint256.h>\n+#include <univalue.h>\n+#include <util.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <tuple>\n+#include <unordered_map>\n+#include <utility>\n+\n+class CReserveScript;\n+\n+namespace interfaces {\n+namespace {\n+\n+//! Extension of std::reference_wrapper with operator< for use as map key.\n+template <typename T>\n+class Ref : public std::reference_wrapper<T>\n+{\n+public:\n+    using std::reference_wrapper<T>::reference_wrapper;\n+    bool operator<(const Ref<T>& other) const { return this->get() < other.get(); }\n+};\n+\n+class LockImpl : public Chain::Lock\n+{\n+    Optional<int> getHeight() override\n+    {\n+        int height = ::chainActive.Height();\n+        if (height >= 0) {\n+            return height;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> getBlockHeight(const uint256& hash) override\n+    {\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end() && it->second) {\n+            if (::chainActive.Contains(it->second)) {\n+                return it->second->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    int getBlockDepth(const uint256& hash) override\n+    {\n+        const Optional<int> tip_height = getHeight();\n+        const Optional<int> height = getBlockHeight(hash);\n+        return tip_height && height ? *tip_height - *height + 1 : 0;\n+    }\n+    uint256 getBlockHash(int height) override { return ::chainActive[height]->GetBlockHash(); }\n+    int64_t getBlockTime(int height) override { return ::chainActive[height]->GetBlockTime(); }\n+    int64_t getBlockMedianTimePast(int height) override { return ::chainActive[height]->GetMedianTimePast(); }\n+    bool haveBlockOnDisk(int height) override\n+    {\n+        CBlockIndex* block = ::chainActive[height];\n+        return block && (block->nStatus & BLOCK_HAVE_DATA) && block->nTx > 0;\n+    }\n+    Optional<int> findFirstBlockWithTime(int64_t time) override\n+    {\n+        CBlockIndex* block = ::chainActive.FindEarliestAtLeast(time);\n+        if (block) {\n+            return block->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFirstBlockWithTimeAndHeight(int64_t time, int height) override\n+    {\n+        for (CBlockIndex* block = ::chainActive[height]; block; block = ::chainActive.Next(block)) {\n+            if (block->GetBlockTime() >= time) {\n+                return block->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findPruned(int start_height, Optional<int> stop_height) override\n+    {\n+        if (::fPruneMode) {\n+            CBlockIndex* block = stop_height ? ::chainActive[*stop_height] : ::chainActive.Tip();\n+            while (block && block->nHeight >= start_height) {\n+                if (!(block->nStatus & BLOCK_HAVE_DATA)) {\n+                    return block->nHeight;\n+                }\n+                block = block->pprev;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFork(const uint256& hash, Optional<int>* height) override\n+    {\n+        const CBlockIndex *block{nullptr}, *fork{nullptr};\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end()) {\n+            block = it->second;\n+            fork = ::chainActive.FindFork(block);\n+        }\n+        if (height) {\n+            if (block) {\n+                *height = block->nHeight;\n+            } else {\n+                height->reset();\n+            }\n+        }\n+        if (fork) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool isPotentialTip(const uint256& hash) override\n+    {\n+        if (::chainActive.Tip()->GetBlockHash() == hash) return true;\n+        auto it = ::mapBlockIndex.find(hash);\n+        return it != ::mapBlockIndex.end() && it->second->GetAncestor(::chainActive.Height()) == ::chainActive.Tip();\n+    }\n+    CBlockLocator getLocator() override { return ::chainActive.GetLocator(); }\n+    Optional<int> findLocatorFork(const CBlockLocator& locator) override\n+    {\n+        if (CBlockIndex* fork = FindForkInGlobalIndex(::chainActive, locator)) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool checkFinalTx(const CTransaction& tx) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return CheckFinalTx(tx);\n+    }\n+    bool acceptToMemoryPool(CTransactionRef tx, CValidationState& state) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return AcceptToMemoryPool(::mempool, state, tx, nullptr /* missing inputs */, nullptr /* txn replaced */,\n+            false /* bypass limits */, ::maxTxFee /* absurd fee */);\n+    }\n+};\n+\n+class LockingStateImpl : public LockImpl, public UniqueLock<CCriticalSection>\n+{\n+    using UniqueLock::UniqueLock;\n+};\n+\n+class HandlerImpl : public Handler\n+{\n+public:\n+    HandlerImpl(Chain::Notifications& notifications) : m_forwarder(notifications) {}\n+    ~HandlerImpl() override\n+    {\n+        // It is important to disconnect here in the HandlerImpl destructor,\n+        // instead of in the HandleImpl::Forwarder destructor, because\n+        // UnregisterAllValidationInterfaces() internally accesses Forwarder\n+        // virtual methods which are no longer available after Forwarder object\n+        // has begun to be being destroyed.\n+        m_forwarder.disconnect();\n+    }\n+    void disconnect() override { m_forwarder.disconnect(); }\n+\n+    struct Forwarder : CValidationInterface\n+    {\n+        Forwarder(Chain::Notifications& notifications) : m_notifications(&notifications)\n+        {\n+            RegisterValidationInterface(this);\n+        }\n+        void disconnect()\n+        {\n+            if (m_notifications) {\n+                m_notifications = nullptr;\n+                UnregisterValidationInterface(this);\n+            }\n+        }\n+        void TransactionAddedToMempool(const CTransactionRef& tx) override\n+        {\n+            m_notifications->TransactionAddedToMempool(tx);\n+        }\n+        void TransactionRemovedFromMempool(const CTransactionRef& tx) override\n+        {\n+            m_notifications->TransactionRemovedFromMempool(tx);\n+        }\n+        void BlockConnected(const std::shared_ptr<const CBlock>& block,\n+            const CBlockIndex* index,\n+            const std::vector<CTransactionRef>& tx_conflicted) override\n+        {\n+            m_notifications->BlockConnected(*block, index->GetBlockHash(), tx_conflicted);\n+        }\n+        void BlockDisconnected(const std::shared_ptr<const CBlock>& block) override\n+        {\n+            m_notifications->BlockDisconnected(*block);\n+        }\n+        void ChainStateFlushed(const CBlockLocator& locator) override { m_notifications->ChainStateFlushed(locator); }\n+        void ResendWalletTransactions(int64_t best_block_time, CConnman* connman) override\n+        {\n+            m_notifications->ResendWalletTransactions(best_block_time);\n+        }\n+\n+        Chain::Notifications* m_notifications;\n+    };\n+\n+    Forwarder m_forwarder;\n+};\n+\n+class ChainImpl : public Chain\n+{\n+public:\n+    std::unique_ptr<Chain::Lock> lock(bool try_lock) override\n+    {\n+        auto result = MakeUnique<LockingStateImpl>(::cs_main, \"cs_main\", __FILE__, __LINE__, try_lock);\n+        if (try_lock && result && !*result) return {};\n+        // std::move necessary on some compilers due to conversion from\n+        // LockingStateImpl to Lock pointer\n+        return std::move(result);\n+    }\n+    std::unique_ptr<Chain::Lock> assumeLocked() override { return MakeUnique<LockImpl>(); }\n+    bool findBlock(const uint256& hash, CBlock* block, int64_t* time, int64_t* time_max) override\n+    {\n+        CBlockIndex* index;\n+        {\n+            LOCK(cs_main);\n+            auto it = ::mapBlockIndex.find(hash);\n+            if (it == ::mapBlockIndex.end()) {\n+                return false;\n+            }\n+            index = it->second;\n+            if (time) {\n+                *time = index->GetBlockTime();\n+            }\n+            if (time_max) {\n+                *time_max = index->GetBlockTimeMax();\n+            }\n+        }\n+        if (block && !ReadBlockFromDisk(*block, index, Params().GetConsensus())) {\n+            block->SetNull();\n+        }\n+        return true;\n+    }\n+    std::vector<Coin> findCoins(const std::vector<COutPoint>& outputs) override\n+    {\n+        std::vector<Coin> coins;\n+        LOCK2(cs_main, ::mempool.cs);\n+        assert(pcoinsTip);\n+        CCoinsViewCache& chain_view = *::pcoinsTip;\n+        CCoinsViewMemPool mempool_view(&chain_view, ::mempool);\n+        for (const auto& output : outputs) {\n+            Coin coin;\n+            mempool_view.GetCoin(output, coin);\n+            coins.emplace_back(std::move(coin));\n+        }\n+        return coins;\n+    }\n+    double guessVerificationProgress(const uint256& block_hash) override\n+    {\n+        LOCK(cs_main);\n+        auto it = ::mapBlockIndex.find(block_hash);\n+        return GuessVerificationProgress(Params().TxData(), it != ::mapBlockIndex.end() ? it->second : nullptr);\n+    }\n+    int64_t getVirtualTransactionSize(const CTransaction& tx) override { return GetVirtualTransactionSize(tx); }\n+    RBFTransactionState isRBFOptIn(const CTransaction& tx) override\n+    {\n+        LOCK(::mempool.cs);\n+        return IsRBFOptIn(tx, ::mempool);\n+    }\n+    bool hasDescendantsInMempool(const uint256& txid) override\n+    {\n+        LOCK(::mempool.cs);\n+        auto it_mp = ::mempool.mapTx.find(txid);\n+        return it_mp != ::mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1;\n+    }\n+    bool relayTransaction(const uint256& txid) override\n+    {\n+        if (g_connman) {\n+            CInv inv(MSG_TX, txid);\n+            g_connman->ForEachNode([&inv](CNode* node) { node->PushInventory(inv); });\n+            return true;\n+        }\n+        return false;\n+    }\n+    void getTransactionAncestry(const uint256& txid, size_t& ancestors, size_t& descendants) override\n+    {\n+        ::mempool.GetTransactionAncestry(txid, ancestors, descendants);\n+    }\n+    bool checkChainLimits(CTransactionRef tx) override\n+    {\n+        LockPoints lp;\n+        CTxMemPoolEntry entry(tx, 0, 0, 0, false, 0, lp);\n+        CTxMemPool::setEntries setAncestors;\n+        size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n+        size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT) * 1000;\n+        size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n+        size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT) * 1000;\n+        std::string errString;\n+        LOCK(::mempool.cs);\n+        if (!::mempool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize,\n+                nLimitDescendants, nLimitDescendantSize, errString)) {\n+            return false;\n+        }\n+        return true;\n+    }\n+    CFeeRate estimateSmartFee(int num_blocks, bool conservative, FeeCalculation* calc) override\n+    {\n+        return ::feeEstimator.estimateSmartFee(num_blocks, calc, conservative);\n+    }\n+    int estimateMaxBlocks() override { return ::feeEstimator.HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE); }\n+    CFeeRate poolMinFee() override\n+    {\n+        return ::mempool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    }\n+    bool getPruneMode() override { return ::fPruneMode; }\n+    bool p2pEnabled() override { return g_connman != nullptr; }\n+    bool isInitialBlockDownload() override { return IsInitialBlockDownload(); }\n+    int64_t getAdjustedTime() override { return GetAdjustedTime(); }\n+    void initMessage(const std::string& message) override { ::uiInterface.InitMessage(message); }\n+    void initWarning(const std::string& message) override { InitWarning(message); }\n+    void initError(const std::string& message) override { InitError(message); }\n+    void loadWallet(std::unique_ptr<Wallet> wallet) override { ::uiInterface.LoadWallet(wallet); }\n+    UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbase_script,\n+        int num_blocks,\n+        uint64_t max_tries,\n+        bool keep_script) override\n+    {\n+        return ::generateBlocks(coinbase_script, num_blocks, max_tries, keep_script);\n+    }\n+    unsigned int parseConfirmTarget(const UniValue& value) override { return ParseConfirmTarget(value); }\n+    std::unique_ptr<Handler> handleNotifications(Notifications& notifications) override\n+    {\n+        return MakeUnique<HandlerImpl>(notifications);\n+    }\n+    void waitForNotifications() override { SyncWithValidationInterfaceQueue(); }\n+    std::unique_ptr<Handler> handleRpc(const CRPCCommand& command) override;\n+\n+    //! Map of RPC method name to forwarder. If multiple clients provide\n+    //! implementations of the same RPC method, the RPC forwarder can dispatch\n+    //! between them.\n+    class RpcForwarder;\n+    std::map<Ref<const std::string>, RpcForwarder> m_rpc_forwarders;\n+};\n+\n+//! Forwarder for one RPC method.\n+class ChainImpl::RpcForwarder\n+{\n+public:\n+    RpcForwarder(const CRPCCommand& command) : m_command(command)\n+    {\n+        m_command.actor = [this](const JSONRPCRequest& request) { return forwardRequest(request); };\n+    }\n+\n+    bool registerForwarder() { return ::tableRPC.appendCommand(m_command.name, &m_command); }\n+\n+    void addCommand(const CRPCCommand& command) { m_commands.emplace_back(&command); }\n+\n+    void removeCommand(const CRPCCommand& command)\n+    {\n+        m_commands.erase(std::remove(m_commands.begin(), m_commands.end(), &command));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219415928",
      "id" : 219415928,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQxNTkyOA==",
      "original_commit_id" : "e44e639558b1084f14a97847592616c3df9fff38",
      "original_position" : 373,
      "path" : "src/interfaces/chain.cpp",
      "position" : null,
      "pull_request_review_id" : 157585959,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219415928",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219416164"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219416164"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-19 14:39:06 clang-tidy(pr=10973): src/interfaces/chain.cpp:432:5: warning: annotate this function with 'override' or (rarely) 'final' [hicpp-use-override]\r\n```",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-09-21T08:13:37Z",
      "diff_hunk" : "@@ -0,0 +1,453 @@\n+#include <interfaces/chain.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <interfaces/handler.h>\n+#include <interfaces/wallet.h>\n+#include <net.h>\n+#include <policy/fees.h>\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <protocol.h>\n+#include <rpc/mining.h>\n+#include <rpc/protocol.h>\n+#include <rpc/server.h>\n+#include <sync.h>\n+#include <threadsafety.h>\n+#include <timedata.h>\n+#include <txmempool.h>\n+#include <ui_interface.h>\n+#include <uint256.h>\n+#include <univalue.h>\n+#include <util.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <tuple>\n+#include <unordered_map>\n+#include <utility>\n+\n+class CReserveScript;\n+\n+namespace interfaces {\n+namespace {\n+\n+//! Extension of std::reference_wrapper with operator< for use as map key.\n+template <typename T>\n+class Ref : public std::reference_wrapper<T>\n+{\n+public:\n+    using std::reference_wrapper<T>::reference_wrapper;\n+    bool operator<(const Ref<T>& other) const { return this->get() < other.get(); }\n+};\n+\n+class LockImpl : public Chain::Lock\n+{\n+    Optional<int> getHeight() override\n+    {\n+        int height = ::chainActive.Height();\n+        if (height >= 0) {\n+            return height;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> getBlockHeight(const uint256& hash) override\n+    {\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end() && it->second) {\n+            if (::chainActive.Contains(it->second)) {\n+                return it->second->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    int getBlockDepth(const uint256& hash) override\n+    {\n+        const Optional<int> tip_height = getHeight();\n+        const Optional<int> height = getBlockHeight(hash);\n+        return tip_height && height ? *tip_height - *height + 1 : 0;\n+    }\n+    uint256 getBlockHash(int height) override { return ::chainActive[height]->GetBlockHash(); }\n+    int64_t getBlockTime(int height) override { return ::chainActive[height]->GetBlockTime(); }\n+    int64_t getBlockMedianTimePast(int height) override { return ::chainActive[height]->GetMedianTimePast(); }\n+    bool haveBlockOnDisk(int height) override\n+    {\n+        CBlockIndex* block = ::chainActive[height];\n+        return block && (block->nStatus & BLOCK_HAVE_DATA) && block->nTx > 0;\n+    }\n+    Optional<int> findFirstBlockWithTime(int64_t time) override\n+    {\n+        CBlockIndex* block = ::chainActive.FindEarliestAtLeast(time);\n+        if (block) {\n+            return block->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFirstBlockWithTimeAndHeight(int64_t time, int height) override\n+    {\n+        for (CBlockIndex* block = ::chainActive[height]; block; block = ::chainActive.Next(block)) {\n+            if (block->GetBlockTime() >= time) {\n+                return block->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findPruned(int start_height, Optional<int> stop_height) override\n+    {\n+        if (::fPruneMode) {\n+            CBlockIndex* block = stop_height ? ::chainActive[*stop_height] : ::chainActive.Tip();\n+            while (block && block->nHeight >= start_height) {\n+                if (!(block->nStatus & BLOCK_HAVE_DATA)) {\n+                    return block->nHeight;\n+                }\n+                block = block->pprev;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFork(const uint256& hash, Optional<int>* height) override\n+    {\n+        const CBlockIndex *block{nullptr}, *fork{nullptr};\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end()) {\n+            block = it->second;\n+            fork = ::chainActive.FindFork(block);\n+        }\n+        if (height) {\n+            if (block) {\n+                *height = block->nHeight;\n+            } else {\n+                height->reset();\n+            }\n+        }\n+        if (fork) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool isPotentialTip(const uint256& hash) override\n+    {\n+        if (::chainActive.Tip()->GetBlockHash() == hash) return true;\n+        auto it = ::mapBlockIndex.find(hash);\n+        return it != ::mapBlockIndex.end() && it->second->GetAncestor(::chainActive.Height()) == ::chainActive.Tip();\n+    }\n+    CBlockLocator getLocator() override { return ::chainActive.GetLocator(); }\n+    Optional<int> findLocatorFork(const CBlockLocator& locator) override\n+    {\n+        if (CBlockIndex* fork = FindForkInGlobalIndex(::chainActive, locator)) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool checkFinalTx(const CTransaction& tx) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return CheckFinalTx(tx);\n+    }\n+    bool acceptToMemoryPool(CTransactionRef tx, CValidationState& state) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return AcceptToMemoryPool(::mempool, state, tx, nullptr /* missing inputs */, nullptr /* txn replaced */,\n+            false /* bypass limits */, ::maxTxFee /* absurd fee */);\n+    }\n+};\n+\n+class LockingStateImpl : public LockImpl, public UniqueLock<CCriticalSection>\n+{\n+    using UniqueLock::UniqueLock;\n+};\n+\n+class HandlerImpl : public Handler\n+{\n+public:\n+    HandlerImpl(Chain::Notifications& notifications) : m_forwarder(notifications) {}\n+    ~HandlerImpl() override\n+    {\n+        // It is important to disconnect here in the HandlerImpl destructor,\n+        // instead of in the HandleImpl::Forwarder destructor, because\n+        // UnregisterAllValidationInterfaces() internally accesses Forwarder\n+        // virtual methods which are no longer available after Forwarder object\n+        // has begun to be being destroyed.\n+        m_forwarder.disconnect();\n+    }\n+    void disconnect() override { m_forwarder.disconnect(); }\n+\n+    struct Forwarder : CValidationInterface\n+    {\n+        Forwarder(Chain::Notifications& notifications) : m_notifications(&notifications)\n+        {\n+            RegisterValidationInterface(this);\n+        }\n+        void disconnect()\n+        {\n+            if (m_notifications) {\n+                m_notifications = nullptr;\n+                UnregisterValidationInterface(this);\n+            }\n+        }\n+        void TransactionAddedToMempool(const CTransactionRef& tx) override\n+        {\n+            m_notifications->TransactionAddedToMempool(tx);\n+        }\n+        void TransactionRemovedFromMempool(const CTransactionRef& tx) override\n+        {\n+            m_notifications->TransactionRemovedFromMempool(tx);\n+        }\n+        void BlockConnected(const std::shared_ptr<const CBlock>& block,\n+            const CBlockIndex* index,\n+            const std::vector<CTransactionRef>& tx_conflicted) override\n+        {\n+            m_notifications->BlockConnected(*block, index->GetBlockHash(), tx_conflicted);\n+        }\n+        void BlockDisconnected(const std::shared_ptr<const CBlock>& block) override\n+        {\n+            m_notifications->BlockDisconnected(*block);\n+        }\n+        void ChainStateFlushed(const CBlockLocator& locator) override { m_notifications->ChainStateFlushed(locator); }\n+        void ResendWalletTransactions(int64_t best_block_time, CConnman* connman) override\n+        {\n+            m_notifications->ResendWalletTransactions(best_block_time);\n+        }\n+\n+        Chain::Notifications* m_notifications;\n+    };\n+\n+    Forwarder m_forwarder;\n+};\n+\n+class ChainImpl : public Chain\n+{\n+public:\n+    std::unique_ptr<Chain::Lock> lock(bool try_lock) override\n+    {\n+        auto result = MakeUnique<LockingStateImpl>(::cs_main, \"cs_main\", __FILE__, __LINE__, try_lock);\n+        if (try_lock && result && !*result) return {};\n+        // std::move necessary on some compilers due to conversion from\n+        // LockingStateImpl to Lock pointer\n+        return std::move(result);\n+    }\n+    std::unique_ptr<Chain::Lock> assumeLocked() override { return MakeUnique<LockImpl>(); }\n+    bool findBlock(const uint256& hash, CBlock* block, int64_t* time, int64_t* time_max) override\n+    {\n+        CBlockIndex* index;\n+        {\n+            LOCK(cs_main);\n+            auto it = ::mapBlockIndex.find(hash);\n+            if (it == ::mapBlockIndex.end()) {\n+                return false;\n+            }\n+            index = it->second;\n+            if (time) {\n+                *time = index->GetBlockTime();\n+            }\n+            if (time_max) {\n+                *time_max = index->GetBlockTimeMax();\n+            }\n+        }\n+        if (block && !ReadBlockFromDisk(*block, index, Params().GetConsensus())) {\n+            block->SetNull();\n+        }\n+        return true;\n+    }\n+    std::vector<Coin> findCoins(const std::vector<COutPoint>& outputs) override\n+    {\n+        std::vector<Coin> coins;\n+        LOCK2(cs_main, ::mempool.cs);\n+        assert(pcoinsTip);\n+        CCoinsViewCache& chain_view = *::pcoinsTip;\n+        CCoinsViewMemPool mempool_view(&chain_view, ::mempool);\n+        for (const auto& output : outputs) {\n+            Coin coin;\n+            mempool_view.GetCoin(output, coin);\n+            coins.emplace_back(std::move(coin));\n+        }\n+        return coins;\n+    }\n+    double guessVerificationProgress(const uint256& block_hash) override\n+    {\n+        LOCK(cs_main);\n+        auto it = ::mapBlockIndex.find(block_hash);\n+        return GuessVerificationProgress(Params().TxData(), it != ::mapBlockIndex.end() ? it->second : nullptr);\n+    }\n+    int64_t getVirtualTransactionSize(const CTransaction& tx) override { return GetVirtualTransactionSize(tx); }\n+    RBFTransactionState isRBFOptIn(const CTransaction& tx) override\n+    {\n+        LOCK(::mempool.cs);\n+        return IsRBFOptIn(tx, ::mempool);\n+    }\n+    bool hasDescendantsInMempool(const uint256& txid) override\n+    {\n+        LOCK(::mempool.cs);\n+        auto it_mp = ::mempool.mapTx.find(txid);\n+        return it_mp != ::mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1;\n+    }\n+    bool relayTransaction(const uint256& txid) override\n+    {\n+        if (g_connman) {\n+            CInv inv(MSG_TX, txid);\n+            g_connman->ForEachNode([&inv](CNode* node) { node->PushInventory(inv); });\n+            return true;\n+        }\n+        return false;\n+    }\n+    void getTransactionAncestry(const uint256& txid, size_t& ancestors, size_t& descendants) override\n+    {\n+        ::mempool.GetTransactionAncestry(txid, ancestors, descendants);\n+    }\n+    bool checkChainLimits(CTransactionRef tx) override\n+    {\n+        LockPoints lp;\n+        CTxMemPoolEntry entry(tx, 0, 0, 0, false, 0, lp);\n+        CTxMemPool::setEntries setAncestors;\n+        size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n+        size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT) * 1000;\n+        size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n+        size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT) * 1000;\n+        std::string errString;\n+        LOCK(::mempool.cs);\n+        if (!::mempool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize,\n+                nLimitDescendants, nLimitDescendantSize, errString)) {\n+            return false;\n+        }\n+        return true;\n+    }\n+    CFeeRate estimateSmartFee(int num_blocks, bool conservative, FeeCalculation* calc) override\n+    {\n+        return ::feeEstimator.estimateSmartFee(num_blocks, calc, conservative);\n+    }\n+    int estimateMaxBlocks() override { return ::feeEstimator.HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE); }\n+    CFeeRate poolMinFee() override\n+    {\n+        return ::mempool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    }\n+    bool getPruneMode() override { return ::fPruneMode; }\n+    bool p2pEnabled() override { return g_connman != nullptr; }\n+    bool isInitialBlockDownload() override { return IsInitialBlockDownload(); }\n+    int64_t getAdjustedTime() override { return GetAdjustedTime(); }\n+    void initMessage(const std::string& message) override { ::uiInterface.InitMessage(message); }\n+    void initWarning(const std::string& message) override { InitWarning(message); }\n+    void initError(const std::string& message) override { InitError(message); }\n+    void loadWallet(std::unique_ptr<Wallet> wallet) override { ::uiInterface.LoadWallet(wallet); }\n+    UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbase_script,\n+        int num_blocks,\n+        uint64_t max_tries,\n+        bool keep_script) override\n+    {\n+        return ::generateBlocks(coinbase_script, num_blocks, max_tries, keep_script);\n+    }\n+    unsigned int parseConfirmTarget(const UniValue& value) override { return ParseConfirmTarget(value); }\n+    std::unique_ptr<Handler> handleNotifications(Notifications& notifications) override\n+    {\n+        return MakeUnique<HandlerImpl>(notifications);\n+    }\n+    void waitForNotifications() override { SyncWithValidationInterfaceQueue(); }\n+    std::unique_ptr<Handler> handleRpc(const CRPCCommand& command) override;\n+\n+    //! Map of RPC method name to forwarder. If multiple clients provide\n+    //! implementations of the same RPC method, the RPC forwarder can dispatch\n+    //! between them.\n+    class RpcForwarder;\n+    std::map<Ref<const std::string>, RpcForwarder> m_rpc_forwarders;\n+};\n+\n+//! Forwarder for one RPC method.\n+class ChainImpl::RpcForwarder\n+{\n+public:\n+    RpcForwarder(const CRPCCommand& command) : m_command(command)\n+    {\n+        m_command.actor = [this](const JSONRPCRequest& request) { return forwardRequest(request); };\n+    }\n+\n+    bool registerForwarder() { return ::tableRPC.appendCommand(m_command.name, &m_command); }\n+\n+    void addCommand(const CRPCCommand& command) { m_commands.emplace_back(&command); }\n+\n+    void removeCommand(const CRPCCommand& command)\n+    {\n+        m_commands.erase(std::remove(m_commands.begin(), m_commands.end(), &command));\n+    }\n+\n+    UniValue forwardRequest(const JSONRPCRequest& request) const\n+    {\n+        // Simple forwarding of RPC requests. This just sends the request to the\n+        // first client that registered a handler for the RPC method. If the\n+        // handler throws a wallet not found exception, this will retry\n+        // forwarding to the next handler (if any).\n+        //\n+        // This forwarding mechanism could be made more efficient (peeking\n+        // inside the RPC request for wallet name and sending it directly to the\n+        // right handler), but right now all wallets are in-process so there is\n+        // only ever a single handler, and in the future it isn't clear if we\n+        // will want we want to keep forwarding RPCs at all (clients could just\n+        // listen for their own RPCs).\n+        for (auto it = m_commands.begin(); it != m_commands.end();) {\n+            const CRPCCommand& command = **it++;\n+            try {\n+                return command.actor(request);\n+            } catch (const UniValue& e) {\n+                if (it != m_commands.end()) {\n+                    const UniValue& code = e[\"code\"];\n+                    if (code.isNum() && code.get_int() == RPC_WALLET_NOT_FOUND) {\n+                        continue;\n+                    }\n+                }\n+                throw;\n+            }\n+        }\n+\n+        // This will only be reached if m_commands is empty. (Because the RPC\n+        // server provides an appendCommand, but no removeCommand method, it\n+        // will keep sending requests here even if there are no clients left to\n+        // forward to.)\n+        throw JSONRPCError(RPC_METHOD_NOT_FOUND, \"Method not found\");\n+    };\n+\n+    CRPCCommand m_command;\n+    std::vector<const CRPCCommand*> m_commands;\n+};\n+\n+class RpcHandler : public Handler\n+{\n+public:\n+    RpcHandler(ChainImpl::RpcForwarder& forwarder, const CRPCCommand& command)\n+        : m_forwarder(&forwarder), m_command(command)\n+    {\n+        m_forwarder->addCommand(m_command);\n+    }\n+\n+    void disconnect() override\n+    {\n+        if (m_forwarder) {\n+            m_forwarder->removeCommand(m_command);\n+            m_forwarder = nullptr;\n+        }\n+    }\n+\n+    ~RpcHandler() { disconnect(); }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219416164",
      "id" : 219416164,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQxNjE2NA==",
      "original_commit_id" : "e44e639558b1084f14a97847592616c3df9fff38",
      "original_position" : 432,
      "path" : "src/interfaces/chain.cpp",
      "position" : null,
      "pull_request_review_id" : 157586253,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219416164",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219416254"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219416254"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-19 14:39:06 clang-tidy(pr=10973): src/interfaces/chain.cpp:432:21: warning: Call to virtual function during destruction [clang-analyzer-optin.cplusplus.VirtualCall]\r\n```",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-09-21T08:14:02Z",
      "diff_hunk" : "@@ -0,0 +1,453 @@\n+#include <interfaces/chain.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <interfaces/handler.h>\n+#include <interfaces/wallet.h>\n+#include <net.h>\n+#include <policy/fees.h>\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <protocol.h>\n+#include <rpc/mining.h>\n+#include <rpc/protocol.h>\n+#include <rpc/server.h>\n+#include <sync.h>\n+#include <threadsafety.h>\n+#include <timedata.h>\n+#include <txmempool.h>\n+#include <ui_interface.h>\n+#include <uint256.h>\n+#include <univalue.h>\n+#include <util.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <tuple>\n+#include <unordered_map>\n+#include <utility>\n+\n+class CReserveScript;\n+\n+namespace interfaces {\n+namespace {\n+\n+//! Extension of std::reference_wrapper with operator< for use as map key.\n+template <typename T>\n+class Ref : public std::reference_wrapper<T>\n+{\n+public:\n+    using std::reference_wrapper<T>::reference_wrapper;\n+    bool operator<(const Ref<T>& other) const { return this->get() < other.get(); }\n+};\n+\n+class LockImpl : public Chain::Lock\n+{\n+    Optional<int> getHeight() override\n+    {\n+        int height = ::chainActive.Height();\n+        if (height >= 0) {\n+            return height;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> getBlockHeight(const uint256& hash) override\n+    {\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end() && it->second) {\n+            if (::chainActive.Contains(it->second)) {\n+                return it->second->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    int getBlockDepth(const uint256& hash) override\n+    {\n+        const Optional<int> tip_height = getHeight();\n+        const Optional<int> height = getBlockHeight(hash);\n+        return tip_height && height ? *tip_height - *height + 1 : 0;\n+    }\n+    uint256 getBlockHash(int height) override { return ::chainActive[height]->GetBlockHash(); }\n+    int64_t getBlockTime(int height) override { return ::chainActive[height]->GetBlockTime(); }\n+    int64_t getBlockMedianTimePast(int height) override { return ::chainActive[height]->GetMedianTimePast(); }\n+    bool haveBlockOnDisk(int height) override\n+    {\n+        CBlockIndex* block = ::chainActive[height];\n+        return block && (block->nStatus & BLOCK_HAVE_DATA) && block->nTx > 0;\n+    }\n+    Optional<int> findFirstBlockWithTime(int64_t time) override\n+    {\n+        CBlockIndex* block = ::chainActive.FindEarliestAtLeast(time);\n+        if (block) {\n+            return block->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFirstBlockWithTimeAndHeight(int64_t time, int height) override\n+    {\n+        for (CBlockIndex* block = ::chainActive[height]; block; block = ::chainActive.Next(block)) {\n+            if (block->GetBlockTime() >= time) {\n+                return block->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findPruned(int start_height, Optional<int> stop_height) override\n+    {\n+        if (::fPruneMode) {\n+            CBlockIndex* block = stop_height ? ::chainActive[*stop_height] : ::chainActive.Tip();\n+            while (block && block->nHeight >= start_height) {\n+                if (!(block->nStatus & BLOCK_HAVE_DATA)) {\n+                    return block->nHeight;\n+                }\n+                block = block->pprev;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFork(const uint256& hash, Optional<int>* height) override\n+    {\n+        const CBlockIndex *block{nullptr}, *fork{nullptr};\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end()) {\n+            block = it->second;\n+            fork = ::chainActive.FindFork(block);\n+        }\n+        if (height) {\n+            if (block) {\n+                *height = block->nHeight;\n+            } else {\n+                height->reset();\n+            }\n+        }\n+        if (fork) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool isPotentialTip(const uint256& hash) override\n+    {\n+        if (::chainActive.Tip()->GetBlockHash() == hash) return true;\n+        auto it = ::mapBlockIndex.find(hash);\n+        return it != ::mapBlockIndex.end() && it->second->GetAncestor(::chainActive.Height()) == ::chainActive.Tip();\n+    }\n+    CBlockLocator getLocator() override { return ::chainActive.GetLocator(); }\n+    Optional<int> findLocatorFork(const CBlockLocator& locator) override\n+    {\n+        if (CBlockIndex* fork = FindForkInGlobalIndex(::chainActive, locator)) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool checkFinalTx(const CTransaction& tx) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return CheckFinalTx(tx);\n+    }\n+    bool acceptToMemoryPool(CTransactionRef tx, CValidationState& state) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return AcceptToMemoryPool(::mempool, state, tx, nullptr /* missing inputs */, nullptr /* txn replaced */,\n+            false /* bypass limits */, ::maxTxFee /* absurd fee */);\n+    }\n+};\n+\n+class LockingStateImpl : public LockImpl, public UniqueLock<CCriticalSection>\n+{\n+    using UniqueLock::UniqueLock;\n+};\n+\n+class HandlerImpl : public Handler\n+{\n+public:\n+    HandlerImpl(Chain::Notifications& notifications) : m_forwarder(notifications) {}\n+    ~HandlerImpl() override\n+    {\n+        // It is important to disconnect here in the HandlerImpl destructor,\n+        // instead of in the HandleImpl::Forwarder destructor, because\n+        // UnregisterAllValidationInterfaces() internally accesses Forwarder\n+        // virtual methods which are no longer available after Forwarder object\n+        // has begun to be being destroyed.\n+        m_forwarder.disconnect();\n+    }\n+    void disconnect() override { m_forwarder.disconnect(); }\n+\n+    struct Forwarder : CValidationInterface\n+    {\n+        Forwarder(Chain::Notifications& notifications) : m_notifications(&notifications)\n+        {\n+            RegisterValidationInterface(this);\n+        }\n+        void disconnect()\n+        {\n+            if (m_notifications) {\n+                m_notifications = nullptr;\n+                UnregisterValidationInterface(this);\n+            }\n+        }\n+        void TransactionAddedToMempool(const CTransactionRef& tx) override\n+        {\n+            m_notifications->TransactionAddedToMempool(tx);\n+        }\n+        void TransactionRemovedFromMempool(const CTransactionRef& tx) override\n+        {\n+            m_notifications->TransactionRemovedFromMempool(tx);\n+        }\n+        void BlockConnected(const std::shared_ptr<const CBlock>& block,\n+            const CBlockIndex* index,\n+            const std::vector<CTransactionRef>& tx_conflicted) override\n+        {\n+            m_notifications->BlockConnected(*block, index->GetBlockHash(), tx_conflicted);\n+        }\n+        void BlockDisconnected(const std::shared_ptr<const CBlock>& block) override\n+        {\n+            m_notifications->BlockDisconnected(*block);\n+        }\n+        void ChainStateFlushed(const CBlockLocator& locator) override { m_notifications->ChainStateFlushed(locator); }\n+        void ResendWalletTransactions(int64_t best_block_time, CConnman* connman) override\n+        {\n+            m_notifications->ResendWalletTransactions(best_block_time);\n+        }\n+\n+        Chain::Notifications* m_notifications;\n+    };\n+\n+    Forwarder m_forwarder;\n+};\n+\n+class ChainImpl : public Chain\n+{\n+public:\n+    std::unique_ptr<Chain::Lock> lock(bool try_lock) override\n+    {\n+        auto result = MakeUnique<LockingStateImpl>(::cs_main, \"cs_main\", __FILE__, __LINE__, try_lock);\n+        if (try_lock && result && !*result) return {};\n+        // std::move necessary on some compilers due to conversion from\n+        // LockingStateImpl to Lock pointer\n+        return std::move(result);\n+    }\n+    std::unique_ptr<Chain::Lock> assumeLocked() override { return MakeUnique<LockImpl>(); }\n+    bool findBlock(const uint256& hash, CBlock* block, int64_t* time, int64_t* time_max) override\n+    {\n+        CBlockIndex* index;\n+        {\n+            LOCK(cs_main);\n+            auto it = ::mapBlockIndex.find(hash);\n+            if (it == ::mapBlockIndex.end()) {\n+                return false;\n+            }\n+            index = it->second;\n+            if (time) {\n+                *time = index->GetBlockTime();\n+            }\n+            if (time_max) {\n+                *time_max = index->GetBlockTimeMax();\n+            }\n+        }\n+        if (block && !ReadBlockFromDisk(*block, index, Params().GetConsensus())) {\n+            block->SetNull();\n+        }\n+        return true;\n+    }\n+    std::vector<Coin> findCoins(const std::vector<COutPoint>& outputs) override\n+    {\n+        std::vector<Coin> coins;\n+        LOCK2(cs_main, ::mempool.cs);\n+        assert(pcoinsTip);\n+        CCoinsViewCache& chain_view = *::pcoinsTip;\n+        CCoinsViewMemPool mempool_view(&chain_view, ::mempool);\n+        for (const auto& output : outputs) {\n+            Coin coin;\n+            mempool_view.GetCoin(output, coin);\n+            coins.emplace_back(std::move(coin));\n+        }\n+        return coins;\n+    }\n+    double guessVerificationProgress(const uint256& block_hash) override\n+    {\n+        LOCK(cs_main);\n+        auto it = ::mapBlockIndex.find(block_hash);\n+        return GuessVerificationProgress(Params().TxData(), it != ::mapBlockIndex.end() ? it->second : nullptr);\n+    }\n+    int64_t getVirtualTransactionSize(const CTransaction& tx) override { return GetVirtualTransactionSize(tx); }\n+    RBFTransactionState isRBFOptIn(const CTransaction& tx) override\n+    {\n+        LOCK(::mempool.cs);\n+        return IsRBFOptIn(tx, ::mempool);\n+    }\n+    bool hasDescendantsInMempool(const uint256& txid) override\n+    {\n+        LOCK(::mempool.cs);\n+        auto it_mp = ::mempool.mapTx.find(txid);\n+        return it_mp != ::mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1;\n+    }\n+    bool relayTransaction(const uint256& txid) override\n+    {\n+        if (g_connman) {\n+            CInv inv(MSG_TX, txid);\n+            g_connman->ForEachNode([&inv](CNode* node) { node->PushInventory(inv); });\n+            return true;\n+        }\n+        return false;\n+    }\n+    void getTransactionAncestry(const uint256& txid, size_t& ancestors, size_t& descendants) override\n+    {\n+        ::mempool.GetTransactionAncestry(txid, ancestors, descendants);\n+    }\n+    bool checkChainLimits(CTransactionRef tx) override\n+    {\n+        LockPoints lp;\n+        CTxMemPoolEntry entry(tx, 0, 0, 0, false, 0, lp);\n+        CTxMemPool::setEntries setAncestors;\n+        size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n+        size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT) * 1000;\n+        size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n+        size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT) * 1000;\n+        std::string errString;\n+        LOCK(::mempool.cs);\n+        if (!::mempool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize,\n+                nLimitDescendants, nLimitDescendantSize, errString)) {\n+            return false;\n+        }\n+        return true;\n+    }\n+    CFeeRate estimateSmartFee(int num_blocks, bool conservative, FeeCalculation* calc) override\n+    {\n+        return ::feeEstimator.estimateSmartFee(num_blocks, calc, conservative);\n+    }\n+    int estimateMaxBlocks() override { return ::feeEstimator.HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE); }\n+    CFeeRate poolMinFee() override\n+    {\n+        return ::mempool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    }\n+    bool getPruneMode() override { return ::fPruneMode; }\n+    bool p2pEnabled() override { return g_connman != nullptr; }\n+    bool isInitialBlockDownload() override { return IsInitialBlockDownload(); }\n+    int64_t getAdjustedTime() override { return GetAdjustedTime(); }\n+    void initMessage(const std::string& message) override { ::uiInterface.InitMessage(message); }\n+    void initWarning(const std::string& message) override { InitWarning(message); }\n+    void initError(const std::string& message) override { InitError(message); }\n+    void loadWallet(std::unique_ptr<Wallet> wallet) override { ::uiInterface.LoadWallet(wallet); }\n+    UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbase_script,\n+        int num_blocks,\n+        uint64_t max_tries,\n+        bool keep_script) override\n+    {\n+        return ::generateBlocks(coinbase_script, num_blocks, max_tries, keep_script);\n+    }\n+    unsigned int parseConfirmTarget(const UniValue& value) override { return ParseConfirmTarget(value); }\n+    std::unique_ptr<Handler> handleNotifications(Notifications& notifications) override\n+    {\n+        return MakeUnique<HandlerImpl>(notifications);\n+    }\n+    void waitForNotifications() override { SyncWithValidationInterfaceQueue(); }\n+    std::unique_ptr<Handler> handleRpc(const CRPCCommand& command) override;\n+\n+    //! Map of RPC method name to forwarder. If multiple clients provide\n+    //! implementations of the same RPC method, the RPC forwarder can dispatch\n+    //! between them.\n+    class RpcForwarder;\n+    std::map<Ref<const std::string>, RpcForwarder> m_rpc_forwarders;\n+};\n+\n+//! Forwarder for one RPC method.\n+class ChainImpl::RpcForwarder\n+{\n+public:\n+    RpcForwarder(const CRPCCommand& command) : m_command(command)\n+    {\n+        m_command.actor = [this](const JSONRPCRequest& request) { return forwardRequest(request); };\n+    }\n+\n+    bool registerForwarder() { return ::tableRPC.appendCommand(m_command.name, &m_command); }\n+\n+    void addCommand(const CRPCCommand& command) { m_commands.emplace_back(&command); }\n+\n+    void removeCommand(const CRPCCommand& command)\n+    {\n+        m_commands.erase(std::remove(m_commands.begin(), m_commands.end(), &command));\n+    }\n+\n+    UniValue forwardRequest(const JSONRPCRequest& request) const\n+    {\n+        // Simple forwarding of RPC requests. This just sends the request to the\n+        // first client that registered a handler for the RPC method. If the\n+        // handler throws a wallet not found exception, this will retry\n+        // forwarding to the next handler (if any).\n+        //\n+        // This forwarding mechanism could be made more efficient (peeking\n+        // inside the RPC request for wallet name and sending it directly to the\n+        // right handler), but right now all wallets are in-process so there is\n+        // only ever a single handler, and in the future it isn't clear if we\n+        // will want we want to keep forwarding RPCs at all (clients could just\n+        // listen for their own RPCs).\n+        for (auto it = m_commands.begin(); it != m_commands.end();) {\n+            const CRPCCommand& command = **it++;\n+            try {\n+                return command.actor(request);\n+            } catch (const UniValue& e) {\n+                if (it != m_commands.end()) {\n+                    const UniValue& code = e[\"code\"];\n+                    if (code.isNum() && code.get_int() == RPC_WALLET_NOT_FOUND) {\n+                        continue;\n+                    }\n+                }\n+                throw;\n+            }\n+        }\n+\n+        // This will only be reached if m_commands is empty. (Because the RPC\n+        // server provides an appendCommand, but no removeCommand method, it\n+        // will keep sending requests here even if there are no clients left to\n+        // forward to.)\n+        throw JSONRPCError(RPC_METHOD_NOT_FOUND, \"Method not found\");\n+    };\n+\n+    CRPCCommand m_command;\n+    std::vector<const CRPCCommand*> m_commands;\n+};\n+\n+class RpcHandler : public Handler\n+{\n+public:\n+    RpcHandler(ChainImpl::RpcForwarder& forwarder, const CRPCCommand& command)\n+        : m_forwarder(&forwarder), m_command(command)\n+    {\n+        m_forwarder->addCommand(m_command);\n+    }\n+\n+    void disconnect() override\n+    {\n+        if (m_forwarder) {\n+            m_forwarder->removeCommand(m_command);\n+            m_forwarder = nullptr;\n+        }\n+    }\n+\n+    ~RpcHandler() { disconnect(); }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219416254",
      "id" : 219416254,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQxNjI1NA==",
      "original_commit_id" : "e44e639558b1084f14a97847592616c3df9fff38",
      "original_position" : 432,
      "path" : "src/interfaces/chain.cpp",
      "position" : null,
      "pull_request_review_id" : 157586382,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219416254",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219416534"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219416534"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-19 14:39:06 clang-tidy(pr=10973): src/wallet/wallet.cpp:950:65: warning: parameter 'locked_chain' is unused [misc-unused-parameters]\r\n```",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-09-21T08:15:15Z",
      "diff_hunk" : "@@ -945,19 +947,19 @@ void CWallet::LoadToWallet(const CWalletTx& wtxIn)\n     }\n }\n \n-bool CWallet::AddToWalletIfInvolvingMe(const CTransactionRef& ptx, const CBlockIndex* pIndex, int posInBlock, bool fUpdate)\n+bool CWallet::AddToWalletIfInvolvingMe(interfaces::Chain::Lock& locked_chain, const CTransactionRef& ptx, const uint256& block_hash, int posInBlock, bool fUpdate)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219416534",
      "id" : 219416534,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQxNjUzNA==",
      "original_commit_id" : "e44e639558b1084f14a97847592616c3df9fff38",
      "original_position" : 41,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 157586754,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219416534",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219420130"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219420130"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:12:32 cppcheck(pr=10973): [src/threadsafety.h:62]: (style) Struct 'LockAnnotation' has a constructor with 1 argument that is not explicit.\r\n```",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-09-21T08:29:41Z",
      "diff_hunk" : "@@ -54,4 +54,15 @@\n #define ASSERT_EXCLUSIVE_LOCK(...)\n #endif // __GNUC__\n \n+// Utility class to indicate mutex is locked for thread analysis when it can't\n+// be determined otherwise.\n+struct SCOPED_LOCKABLE LockAnnotation\n+{\n+    template <typename Mutex>\n+    LockAnnotation(Mutex& mutex) EXCLUSIVE_LOCK_FUNCTION(mutex)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219420130",
      "id" : 219420130,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQyMDEzMA==",
      "original_commit_id" : "e44e639558b1084f14a97847592616c3df9fff38",
      "original_position" : 9,
      "path" : "src/threadsafety.h",
      "position" : null,
      "pull_request_review_id" : 157591392,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219420130",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219420288"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219420288"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:12:32 cppcheck(pr=10973): [src/interfaces/chain.cpp:168]: (style) Class 'HandlerImpl' has a constructor with 1 argument that is not explicit.\r\n```",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-09-21T08:30:14Z",
      "diff_hunk" : "@@ -0,0 +1,453 @@\n+#include <interfaces/chain.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <interfaces/handler.h>\n+#include <interfaces/wallet.h>\n+#include <net.h>\n+#include <policy/fees.h>\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <protocol.h>\n+#include <rpc/mining.h>\n+#include <rpc/protocol.h>\n+#include <rpc/server.h>\n+#include <sync.h>\n+#include <threadsafety.h>\n+#include <timedata.h>\n+#include <txmempool.h>\n+#include <ui_interface.h>\n+#include <uint256.h>\n+#include <univalue.h>\n+#include <util.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <tuple>\n+#include <unordered_map>\n+#include <utility>\n+\n+class CReserveScript;\n+\n+namespace interfaces {\n+namespace {\n+\n+//! Extension of std::reference_wrapper with operator< for use as map key.\n+template <typename T>\n+class Ref : public std::reference_wrapper<T>\n+{\n+public:\n+    using std::reference_wrapper<T>::reference_wrapper;\n+    bool operator<(const Ref<T>& other) const { return this->get() < other.get(); }\n+};\n+\n+class LockImpl : public Chain::Lock\n+{\n+    Optional<int> getHeight() override\n+    {\n+        int height = ::chainActive.Height();\n+        if (height >= 0) {\n+            return height;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> getBlockHeight(const uint256& hash) override\n+    {\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end() && it->second) {\n+            if (::chainActive.Contains(it->second)) {\n+                return it->second->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    int getBlockDepth(const uint256& hash) override\n+    {\n+        const Optional<int> tip_height = getHeight();\n+        const Optional<int> height = getBlockHeight(hash);\n+        return tip_height && height ? *tip_height - *height + 1 : 0;\n+    }\n+    uint256 getBlockHash(int height) override { return ::chainActive[height]->GetBlockHash(); }\n+    int64_t getBlockTime(int height) override { return ::chainActive[height]->GetBlockTime(); }\n+    int64_t getBlockMedianTimePast(int height) override { return ::chainActive[height]->GetMedianTimePast(); }\n+    bool haveBlockOnDisk(int height) override\n+    {\n+        CBlockIndex* block = ::chainActive[height];\n+        return block && (block->nStatus & BLOCK_HAVE_DATA) && block->nTx > 0;\n+    }\n+    Optional<int> findFirstBlockWithTime(int64_t time) override\n+    {\n+        CBlockIndex* block = ::chainActive.FindEarliestAtLeast(time);\n+        if (block) {\n+            return block->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFirstBlockWithTimeAndHeight(int64_t time, int height) override\n+    {\n+        for (CBlockIndex* block = ::chainActive[height]; block; block = ::chainActive.Next(block)) {\n+            if (block->GetBlockTime() >= time) {\n+                return block->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findPruned(int start_height, Optional<int> stop_height) override\n+    {\n+        if (::fPruneMode) {\n+            CBlockIndex* block = stop_height ? ::chainActive[*stop_height] : ::chainActive.Tip();\n+            while (block && block->nHeight >= start_height) {\n+                if (!(block->nStatus & BLOCK_HAVE_DATA)) {\n+                    return block->nHeight;\n+                }\n+                block = block->pprev;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFork(const uint256& hash, Optional<int>* height) override\n+    {\n+        const CBlockIndex *block{nullptr}, *fork{nullptr};\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end()) {\n+            block = it->second;\n+            fork = ::chainActive.FindFork(block);\n+        }\n+        if (height) {\n+            if (block) {\n+                *height = block->nHeight;\n+            } else {\n+                height->reset();\n+            }\n+        }\n+        if (fork) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool isPotentialTip(const uint256& hash) override\n+    {\n+        if (::chainActive.Tip()->GetBlockHash() == hash) return true;\n+        auto it = ::mapBlockIndex.find(hash);\n+        return it != ::mapBlockIndex.end() && it->second->GetAncestor(::chainActive.Height()) == ::chainActive.Tip();\n+    }\n+    CBlockLocator getLocator() override { return ::chainActive.GetLocator(); }\n+    Optional<int> findLocatorFork(const CBlockLocator& locator) override\n+    {\n+        if (CBlockIndex* fork = FindForkInGlobalIndex(::chainActive, locator)) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool checkFinalTx(const CTransaction& tx) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return CheckFinalTx(tx);\n+    }\n+    bool acceptToMemoryPool(CTransactionRef tx, CValidationState& state) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return AcceptToMemoryPool(::mempool, state, tx, nullptr /* missing inputs */, nullptr /* txn replaced */,\n+            false /* bypass limits */, ::maxTxFee /* absurd fee */);\n+    }\n+};\n+\n+class LockingStateImpl : public LockImpl, public UniqueLock<CCriticalSection>\n+{\n+    using UniqueLock::UniqueLock;\n+};\n+\n+class HandlerImpl : public Handler\n+{\n+public:\n+    HandlerImpl(Chain::Notifications& notifications) : m_forwarder(notifications) {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219420288",
      "id" : 219420288,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQyMDI4OA==",
      "original_commit_id" : "e44e639558b1084f14a97847592616c3df9fff38",
      "original_position" : 168,
      "path" : "src/interfaces/chain.cpp",
      "position" : null,
      "pull_request_review_id" : 157591599,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219420288",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219420364"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219420364"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:12:32 cppcheck(pr=10973): [src/interfaces/chain.cpp:182]: (style) Struct 'Forwarder' has a constructor with 1 argument that is not explicit.\r\n```",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-09-21T08:30:27Z",
      "diff_hunk" : "@@ -0,0 +1,453 @@\n+#include <interfaces/chain.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <interfaces/handler.h>\n+#include <interfaces/wallet.h>\n+#include <net.h>\n+#include <policy/fees.h>\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <protocol.h>\n+#include <rpc/mining.h>\n+#include <rpc/protocol.h>\n+#include <rpc/server.h>\n+#include <sync.h>\n+#include <threadsafety.h>\n+#include <timedata.h>\n+#include <txmempool.h>\n+#include <ui_interface.h>\n+#include <uint256.h>\n+#include <univalue.h>\n+#include <util.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <tuple>\n+#include <unordered_map>\n+#include <utility>\n+\n+class CReserveScript;\n+\n+namespace interfaces {\n+namespace {\n+\n+//! Extension of std::reference_wrapper with operator< for use as map key.\n+template <typename T>\n+class Ref : public std::reference_wrapper<T>\n+{\n+public:\n+    using std::reference_wrapper<T>::reference_wrapper;\n+    bool operator<(const Ref<T>& other) const { return this->get() < other.get(); }\n+};\n+\n+class LockImpl : public Chain::Lock\n+{\n+    Optional<int> getHeight() override\n+    {\n+        int height = ::chainActive.Height();\n+        if (height >= 0) {\n+            return height;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> getBlockHeight(const uint256& hash) override\n+    {\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end() && it->second) {\n+            if (::chainActive.Contains(it->second)) {\n+                return it->second->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    int getBlockDepth(const uint256& hash) override\n+    {\n+        const Optional<int> tip_height = getHeight();\n+        const Optional<int> height = getBlockHeight(hash);\n+        return tip_height && height ? *tip_height - *height + 1 : 0;\n+    }\n+    uint256 getBlockHash(int height) override { return ::chainActive[height]->GetBlockHash(); }\n+    int64_t getBlockTime(int height) override { return ::chainActive[height]->GetBlockTime(); }\n+    int64_t getBlockMedianTimePast(int height) override { return ::chainActive[height]->GetMedianTimePast(); }\n+    bool haveBlockOnDisk(int height) override\n+    {\n+        CBlockIndex* block = ::chainActive[height];\n+        return block && (block->nStatus & BLOCK_HAVE_DATA) && block->nTx > 0;\n+    }\n+    Optional<int> findFirstBlockWithTime(int64_t time) override\n+    {\n+        CBlockIndex* block = ::chainActive.FindEarliestAtLeast(time);\n+        if (block) {\n+            return block->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFirstBlockWithTimeAndHeight(int64_t time, int height) override\n+    {\n+        for (CBlockIndex* block = ::chainActive[height]; block; block = ::chainActive.Next(block)) {\n+            if (block->GetBlockTime() >= time) {\n+                return block->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findPruned(int start_height, Optional<int> stop_height) override\n+    {\n+        if (::fPruneMode) {\n+            CBlockIndex* block = stop_height ? ::chainActive[*stop_height] : ::chainActive.Tip();\n+            while (block && block->nHeight >= start_height) {\n+                if (!(block->nStatus & BLOCK_HAVE_DATA)) {\n+                    return block->nHeight;\n+                }\n+                block = block->pprev;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFork(const uint256& hash, Optional<int>* height) override\n+    {\n+        const CBlockIndex *block{nullptr}, *fork{nullptr};\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end()) {\n+            block = it->second;\n+            fork = ::chainActive.FindFork(block);\n+        }\n+        if (height) {\n+            if (block) {\n+                *height = block->nHeight;\n+            } else {\n+                height->reset();\n+            }\n+        }\n+        if (fork) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool isPotentialTip(const uint256& hash) override\n+    {\n+        if (::chainActive.Tip()->GetBlockHash() == hash) return true;\n+        auto it = ::mapBlockIndex.find(hash);\n+        return it != ::mapBlockIndex.end() && it->second->GetAncestor(::chainActive.Height()) == ::chainActive.Tip();\n+    }\n+    CBlockLocator getLocator() override { return ::chainActive.GetLocator(); }\n+    Optional<int> findLocatorFork(const CBlockLocator& locator) override\n+    {\n+        if (CBlockIndex* fork = FindForkInGlobalIndex(::chainActive, locator)) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool checkFinalTx(const CTransaction& tx) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return CheckFinalTx(tx);\n+    }\n+    bool acceptToMemoryPool(CTransactionRef tx, CValidationState& state) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return AcceptToMemoryPool(::mempool, state, tx, nullptr /* missing inputs */, nullptr /* txn replaced */,\n+            false /* bypass limits */, ::maxTxFee /* absurd fee */);\n+    }\n+};\n+\n+class LockingStateImpl : public LockImpl, public UniqueLock<CCriticalSection>\n+{\n+    using UniqueLock::UniqueLock;\n+};\n+\n+class HandlerImpl : public Handler\n+{\n+public:\n+    HandlerImpl(Chain::Notifications& notifications) : m_forwarder(notifications) {}\n+    ~HandlerImpl() override\n+    {\n+        // It is important to disconnect here in the HandlerImpl destructor,\n+        // instead of in the HandleImpl::Forwarder destructor, because\n+        // UnregisterAllValidationInterfaces() internally accesses Forwarder\n+        // virtual methods which are no longer available after Forwarder object\n+        // has begun to be being destroyed.\n+        m_forwarder.disconnect();\n+    }\n+    void disconnect() override { m_forwarder.disconnect(); }\n+\n+    struct Forwarder : CValidationInterface\n+    {\n+        Forwarder(Chain::Notifications& notifications) : m_notifications(&notifications)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219420364",
      "id" : 219420364,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQyMDM2NA==",
      "original_commit_id" : "e44e639558b1084f14a97847592616c3df9fff38",
      "original_position" : 182,
      "path" : "src/interfaces/chain.cpp",
      "position" : null,
      "pull_request_review_id" : 157591688,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219420364",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219420448"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219420448"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:12:32 cppcheck(pr=10973): [src/interfaces/chain.cpp:362]: (style) Class 'RpcForwarder' has a constructor with 1 argument that is not explicit.\r\n```",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-09-21T08:30:43Z",
      "diff_hunk" : "@@ -0,0 +1,453 @@\n+#include <interfaces/chain.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <interfaces/handler.h>\n+#include <interfaces/wallet.h>\n+#include <net.h>\n+#include <policy/fees.h>\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <protocol.h>\n+#include <rpc/mining.h>\n+#include <rpc/protocol.h>\n+#include <rpc/server.h>\n+#include <sync.h>\n+#include <threadsafety.h>\n+#include <timedata.h>\n+#include <txmempool.h>\n+#include <ui_interface.h>\n+#include <uint256.h>\n+#include <univalue.h>\n+#include <util.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <tuple>\n+#include <unordered_map>\n+#include <utility>\n+\n+class CReserveScript;\n+\n+namespace interfaces {\n+namespace {\n+\n+//! Extension of std::reference_wrapper with operator< for use as map key.\n+template <typename T>\n+class Ref : public std::reference_wrapper<T>\n+{\n+public:\n+    using std::reference_wrapper<T>::reference_wrapper;\n+    bool operator<(const Ref<T>& other) const { return this->get() < other.get(); }\n+};\n+\n+class LockImpl : public Chain::Lock\n+{\n+    Optional<int> getHeight() override\n+    {\n+        int height = ::chainActive.Height();\n+        if (height >= 0) {\n+            return height;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> getBlockHeight(const uint256& hash) override\n+    {\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end() && it->second) {\n+            if (::chainActive.Contains(it->second)) {\n+                return it->second->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    int getBlockDepth(const uint256& hash) override\n+    {\n+        const Optional<int> tip_height = getHeight();\n+        const Optional<int> height = getBlockHeight(hash);\n+        return tip_height && height ? *tip_height - *height + 1 : 0;\n+    }\n+    uint256 getBlockHash(int height) override { return ::chainActive[height]->GetBlockHash(); }\n+    int64_t getBlockTime(int height) override { return ::chainActive[height]->GetBlockTime(); }\n+    int64_t getBlockMedianTimePast(int height) override { return ::chainActive[height]->GetMedianTimePast(); }\n+    bool haveBlockOnDisk(int height) override\n+    {\n+        CBlockIndex* block = ::chainActive[height];\n+        return block && (block->nStatus & BLOCK_HAVE_DATA) && block->nTx > 0;\n+    }\n+    Optional<int> findFirstBlockWithTime(int64_t time) override\n+    {\n+        CBlockIndex* block = ::chainActive.FindEarliestAtLeast(time);\n+        if (block) {\n+            return block->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFirstBlockWithTimeAndHeight(int64_t time, int height) override\n+    {\n+        for (CBlockIndex* block = ::chainActive[height]; block; block = ::chainActive.Next(block)) {\n+            if (block->GetBlockTime() >= time) {\n+                return block->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findPruned(int start_height, Optional<int> stop_height) override\n+    {\n+        if (::fPruneMode) {\n+            CBlockIndex* block = stop_height ? ::chainActive[*stop_height] : ::chainActive.Tip();\n+            while (block && block->nHeight >= start_height) {\n+                if (!(block->nStatus & BLOCK_HAVE_DATA)) {\n+                    return block->nHeight;\n+                }\n+                block = block->pprev;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFork(const uint256& hash, Optional<int>* height) override\n+    {\n+        const CBlockIndex *block{nullptr}, *fork{nullptr};\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end()) {\n+            block = it->second;\n+            fork = ::chainActive.FindFork(block);\n+        }\n+        if (height) {\n+            if (block) {\n+                *height = block->nHeight;\n+            } else {\n+                height->reset();\n+            }\n+        }\n+        if (fork) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool isPotentialTip(const uint256& hash) override\n+    {\n+        if (::chainActive.Tip()->GetBlockHash() == hash) return true;\n+        auto it = ::mapBlockIndex.find(hash);\n+        return it != ::mapBlockIndex.end() && it->second->GetAncestor(::chainActive.Height()) == ::chainActive.Tip();\n+    }\n+    CBlockLocator getLocator() override { return ::chainActive.GetLocator(); }\n+    Optional<int> findLocatorFork(const CBlockLocator& locator) override\n+    {\n+        if (CBlockIndex* fork = FindForkInGlobalIndex(::chainActive, locator)) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool checkFinalTx(const CTransaction& tx) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return CheckFinalTx(tx);\n+    }\n+    bool acceptToMemoryPool(CTransactionRef tx, CValidationState& state) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return AcceptToMemoryPool(::mempool, state, tx, nullptr /* missing inputs */, nullptr /* txn replaced */,\n+            false /* bypass limits */, ::maxTxFee /* absurd fee */);\n+    }\n+};\n+\n+class LockingStateImpl : public LockImpl, public UniqueLock<CCriticalSection>\n+{\n+    using UniqueLock::UniqueLock;\n+};\n+\n+class HandlerImpl : public Handler\n+{\n+public:\n+    HandlerImpl(Chain::Notifications& notifications) : m_forwarder(notifications) {}\n+    ~HandlerImpl() override\n+    {\n+        // It is important to disconnect here in the HandlerImpl destructor,\n+        // instead of in the HandleImpl::Forwarder destructor, because\n+        // UnregisterAllValidationInterfaces() internally accesses Forwarder\n+        // virtual methods which are no longer available after Forwarder object\n+        // has begun to be being destroyed.\n+        m_forwarder.disconnect();\n+    }\n+    void disconnect() override { m_forwarder.disconnect(); }\n+\n+    struct Forwarder : CValidationInterface\n+    {\n+        Forwarder(Chain::Notifications& notifications) : m_notifications(&notifications)\n+        {\n+            RegisterValidationInterface(this);\n+        }\n+        void disconnect()\n+        {\n+            if (m_notifications) {\n+                m_notifications = nullptr;\n+                UnregisterValidationInterface(this);\n+            }\n+        }\n+        void TransactionAddedToMempool(const CTransactionRef& tx) override\n+        {\n+            m_notifications->TransactionAddedToMempool(tx);\n+        }\n+        void TransactionRemovedFromMempool(const CTransactionRef& tx) override\n+        {\n+            m_notifications->TransactionRemovedFromMempool(tx);\n+        }\n+        void BlockConnected(const std::shared_ptr<const CBlock>& block,\n+            const CBlockIndex* index,\n+            const std::vector<CTransactionRef>& tx_conflicted) override\n+        {\n+            m_notifications->BlockConnected(*block, index->GetBlockHash(), tx_conflicted);\n+        }\n+        void BlockDisconnected(const std::shared_ptr<const CBlock>& block) override\n+        {\n+            m_notifications->BlockDisconnected(*block);\n+        }\n+        void ChainStateFlushed(const CBlockLocator& locator) override { m_notifications->ChainStateFlushed(locator); }\n+        void ResendWalletTransactions(int64_t best_block_time, CConnman* connman) override\n+        {\n+            m_notifications->ResendWalletTransactions(best_block_time);\n+        }\n+\n+        Chain::Notifications* m_notifications;\n+    };\n+\n+    Forwarder m_forwarder;\n+};\n+\n+class ChainImpl : public Chain\n+{\n+public:\n+    std::unique_ptr<Chain::Lock> lock(bool try_lock) override\n+    {\n+        auto result = MakeUnique<LockingStateImpl>(::cs_main, \"cs_main\", __FILE__, __LINE__, try_lock);\n+        if (try_lock && result && !*result) return {};\n+        // std::move necessary on some compilers due to conversion from\n+        // LockingStateImpl to Lock pointer\n+        return std::move(result);\n+    }\n+    std::unique_ptr<Chain::Lock> assumeLocked() override { return MakeUnique<LockImpl>(); }\n+    bool findBlock(const uint256& hash, CBlock* block, int64_t* time, int64_t* time_max) override\n+    {\n+        CBlockIndex* index;\n+        {\n+            LOCK(cs_main);\n+            auto it = ::mapBlockIndex.find(hash);\n+            if (it == ::mapBlockIndex.end()) {\n+                return false;\n+            }\n+            index = it->second;\n+            if (time) {\n+                *time = index->GetBlockTime();\n+            }\n+            if (time_max) {\n+                *time_max = index->GetBlockTimeMax();\n+            }\n+        }\n+        if (block && !ReadBlockFromDisk(*block, index, Params().GetConsensus())) {\n+            block->SetNull();\n+        }\n+        return true;\n+    }\n+    std::vector<Coin> findCoins(const std::vector<COutPoint>& outputs) override\n+    {\n+        std::vector<Coin> coins;\n+        LOCK2(cs_main, ::mempool.cs);\n+        assert(pcoinsTip);\n+        CCoinsViewCache& chain_view = *::pcoinsTip;\n+        CCoinsViewMemPool mempool_view(&chain_view, ::mempool);\n+        for (const auto& output : outputs) {\n+            Coin coin;\n+            mempool_view.GetCoin(output, coin);\n+            coins.emplace_back(std::move(coin));\n+        }\n+        return coins;\n+    }\n+    double guessVerificationProgress(const uint256& block_hash) override\n+    {\n+        LOCK(cs_main);\n+        auto it = ::mapBlockIndex.find(block_hash);\n+        return GuessVerificationProgress(Params().TxData(), it != ::mapBlockIndex.end() ? it->second : nullptr);\n+    }\n+    int64_t getVirtualTransactionSize(const CTransaction& tx) override { return GetVirtualTransactionSize(tx); }\n+    RBFTransactionState isRBFOptIn(const CTransaction& tx) override\n+    {\n+        LOCK(::mempool.cs);\n+        return IsRBFOptIn(tx, ::mempool);\n+    }\n+    bool hasDescendantsInMempool(const uint256& txid) override\n+    {\n+        LOCK(::mempool.cs);\n+        auto it_mp = ::mempool.mapTx.find(txid);\n+        return it_mp != ::mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1;\n+    }\n+    bool relayTransaction(const uint256& txid) override\n+    {\n+        if (g_connman) {\n+            CInv inv(MSG_TX, txid);\n+            g_connman->ForEachNode([&inv](CNode* node) { node->PushInventory(inv); });\n+            return true;\n+        }\n+        return false;\n+    }\n+    void getTransactionAncestry(const uint256& txid, size_t& ancestors, size_t& descendants) override\n+    {\n+        ::mempool.GetTransactionAncestry(txid, ancestors, descendants);\n+    }\n+    bool checkChainLimits(CTransactionRef tx) override\n+    {\n+        LockPoints lp;\n+        CTxMemPoolEntry entry(tx, 0, 0, 0, false, 0, lp);\n+        CTxMemPool::setEntries setAncestors;\n+        size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n+        size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT) * 1000;\n+        size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n+        size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT) * 1000;\n+        std::string errString;\n+        LOCK(::mempool.cs);\n+        if (!::mempool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize,\n+                nLimitDescendants, nLimitDescendantSize, errString)) {\n+            return false;\n+        }\n+        return true;\n+    }\n+    CFeeRate estimateSmartFee(int num_blocks, bool conservative, FeeCalculation* calc) override\n+    {\n+        return ::feeEstimator.estimateSmartFee(num_blocks, calc, conservative);\n+    }\n+    int estimateMaxBlocks() override { return ::feeEstimator.HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE); }\n+    CFeeRate poolMinFee() override\n+    {\n+        return ::mempool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    }\n+    bool getPruneMode() override { return ::fPruneMode; }\n+    bool p2pEnabled() override { return g_connman != nullptr; }\n+    bool isInitialBlockDownload() override { return IsInitialBlockDownload(); }\n+    int64_t getAdjustedTime() override { return GetAdjustedTime(); }\n+    void initMessage(const std::string& message) override { ::uiInterface.InitMessage(message); }\n+    void initWarning(const std::string& message) override { InitWarning(message); }\n+    void initError(const std::string& message) override { InitError(message); }\n+    void loadWallet(std::unique_ptr<Wallet> wallet) override { ::uiInterface.LoadWallet(wallet); }\n+    UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbase_script,\n+        int num_blocks,\n+        uint64_t max_tries,\n+        bool keep_script) override\n+    {\n+        return ::generateBlocks(coinbase_script, num_blocks, max_tries, keep_script);\n+    }\n+    unsigned int parseConfirmTarget(const UniValue& value) override { return ParseConfirmTarget(value); }\n+    std::unique_ptr<Handler> handleNotifications(Notifications& notifications) override\n+    {\n+        return MakeUnique<HandlerImpl>(notifications);\n+    }\n+    void waitForNotifications() override { SyncWithValidationInterfaceQueue(); }\n+    std::unique_ptr<Handler> handleRpc(const CRPCCommand& command) override;\n+\n+    //! Map of RPC method name to forwarder. If multiple clients provide\n+    //! implementations of the same RPC method, the RPC forwarder can dispatch\n+    //! between them.\n+    class RpcForwarder;\n+    std::map<Ref<const std::string>, RpcForwarder> m_rpc_forwarders;\n+};\n+\n+//! Forwarder for one RPC method.\n+class ChainImpl::RpcForwarder\n+{\n+public:\n+    RpcForwarder(const CRPCCommand& command) : m_command(command)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219420448",
      "id" : 219420448,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQyMDQ0OA==",
      "original_commit_id" : "e44e639558b1084f14a97847592616c3df9fff38",
      "original_position" : 362,
      "path" : "src/interfaces/chain.cpp",
      "position" : null,
      "pull_request_review_id" : 157591801,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219420448",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219420677"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219420677"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:12:32 cppcheck(pr=10973): [src/interfaces/chain.h:209]: (style) The function 'Inventory' is never used.\r\n```",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-09-21T08:31:01Z",
      "diff_hunk" : "@@ -0,0 +1,265 @@\n+#ifndef BITCOIN_INTERFACES_CHAIN_H\n+#define BITCOIN_INTERFACES_CHAIN_H\n+\n+#include <optional.h>               // For Optional and nullopt\n+#include <policy/rbf.h>             // For RBFTransactionState\n+#include <primitives/transaction.h> // For CTransactionRef\n+\n+#include <memory>\n+#include <stddef.h>\n+#include <stdint.h>\n+#include <string>\n+#include <vector>\n+\n+class CBlock;\n+class CRPCCommand;\n+class CReserveScript;\n+class CScheduler;\n+class CValidationState;\n+class UniValue;\n+class uint256;\n+struct CBlockLocator;\n+struct FeeCalculation;\n+\n+namespace interfaces {\n+\n+class Handler;\n+class Wallet;\n+\n+//! Interface for giving wallet processes access to blockchain state.\n+class Chain\n+{\n+public:\n+    virtual ~Chain() {}\n+\n+    //! Interface for querying locked chain state, used by legacy code that\n+    //! assumes state won't change between calls. New code should avoid using\n+    //! the Lock interface and instead call higher-level Chain methods\n+    //! that return more information so the chain doesn't need to stay locked\n+    //! between calls.\n+    class Lock\n+    {\n+    public:\n+        virtual ~Lock() {}\n+\n+        //! Get current chain height, not including genesis block (returns 0 if\n+        //! chain only contains genesis block, nothing if chain does not contain\n+        //! any blocks).\n+        virtual Optional<int> getHeight() = 0;\n+\n+        //! Get block height above genesis block. Returns 0 for genesis block,\n+        //! 1 for following block, and so on. Returns nothing for a block not\n+        //! included in the current chain.\n+        virtual Optional<int> getBlockHeight(const uint256& hash) = 0;\n+\n+        //! Get block depth. Returns 1 for chain tip, 2 for preceding block, and\n+        //! so on. Returns 0 for a block not included in the current chain.\n+        virtual int getBlockDepth(const uint256& hash) = 0;\n+\n+        //! Get block hash.\n+        virtual uint256 getBlockHash(int height) = 0;\n+\n+        //! Get block time.\n+        virtual int64_t getBlockTime(int height) = 0;\n+\n+        //! Get block median time past.\n+        virtual int64_t getBlockMedianTimePast(int height) = 0;\n+\n+        //! Check that the full block is available on disk (ie has not been\n+        //! pruned), and contains transactions.\n+        virtual bool haveBlockOnDisk(int height) = 0;\n+\n+        //! Return height of the first block in the chain with timestamp equal\n+        //! or greater than the given time, or nothing if there is no block with\n+        //! a high enough timestamp.\n+        virtual Optional<int> findFirstBlockWithTime(int64_t time) = 0;\n+\n+        //! Return height of the first block in the chain with timestamp equal\n+        //! or greater than the given time and height equal or greater than the\n+        //! given height, or nothing if there is no such block.\n+        //!\n+        //! Calling this with height 0 is equivalent to calling\n+        //! findFirstBlockWithTime, but less efficient because it requires a\n+        //! linear instead of a binary search.\n+        virtual Optional<int> findFirstBlockWithTimeAndHeight(int64_t time, int height) = 0;\n+\n+        //! Return height of last block in the specified range which is pruned, or\n+        //! nothing if no block in the range is pruned. Range is inclusive.\n+        virtual Optional<int> findPruned(int start_height = 0, Optional<int> stop_height = nullopt) = 0;\n+\n+        //! Return height of the highest block on the chain that is an ancestor\n+        //! of the specified block. Also return the height of the specified\n+        //! block as an optional output parameter.\n+        virtual Optional<int> findFork(const uint256& hash, Optional<int>* height) = 0;\n+\n+        //! Return true if block hash points to the current chain tip, or to a\n+        //! possible descendant of the current chain tip that isn't currently\n+        //! connected.\n+        virtual bool isPotentialTip(const uint256& hash) = 0;\n+\n+        //! Get locator for the current chain tip.\n+        virtual CBlockLocator getLocator() = 0;\n+\n+        //! Return height of block on the chain using locator.\n+        virtual Optional<int> findLocatorFork(const CBlockLocator& locator) = 0;\n+\n+        //! Check if transaction will be final given chain height current time.\n+        virtual bool checkFinalTx(const CTransaction& tx) = 0;\n+\n+        //! Add transaction to memory pool.\n+        virtual bool acceptToMemoryPool(CTransactionRef tx, CValidationState& state) = 0;\n+    };\n+\n+    //! Return Lock interface. Chain is locked when this is called, and\n+    //! unlocked when the returned interface is freed.\n+    virtual std::unique_ptr<Lock> lock(bool try_lock = false) = 0;\n+\n+    //! Return Lock interface assuming chain is already locked. This\n+    //! method is temporary and is only used in a few places to avoid changing\n+    //! behavior while code is transitioned to use the Chain::Lock interface.\n+    virtual std::unique_ptr<Lock> assumeLocked() = 0;\n+\n+    //! Return whether node has the block and optionally return block metadata or contents.\n+    virtual bool findBlock(const uint256& hash,\n+        CBlock* block = nullptr,\n+        int64_t* time = nullptr,\n+        int64_t* max_time = nullptr) = 0;\n+\n+    //! Get unspent outputs associated with a transaction.\n+    virtual std::vector<Coin> findCoins(const std::vector<COutPoint>& outputs) = 0;\n+\n+    //! Estimate fraction of total transactions verified if blocks up to\n+    //! given height are verified.\n+    virtual double guessVerificationProgress(const uint256& block_hash) = 0;\n+\n+    //! Get virtual transaction size.\n+    virtual int64_t getVirtualTransactionSize(const CTransaction& tx) = 0;\n+\n+    //! Check if transaction is RBF opt in.\n+    virtual RBFTransactionState isRBFOptIn(const CTransaction& tx) = 0;\n+\n+    //! Check if transaction has descendants in mempool.\n+    virtual bool hasDescendantsInMempool(const uint256& txid) = 0;\n+\n+    //! Relay transaction.\n+    virtual bool relayTransaction(const uint256& txid) = 0;\n+\n+    //! Calculate mempool ancestor and descendant counts for the given transaction.\n+    virtual void getTransactionAncestry(const uint256& txid, size_t& ancestors, size_t& descendants) = 0;\n+\n+    //! Check chain limits.\n+    virtual bool checkChainLimits(CTransactionRef tx) = 0;\n+\n+    //! Estimate smart fee.\n+    virtual CFeeRate estimateSmartFee(int num_blocks, bool conservative, FeeCalculation* calc = nullptr) = 0;\n+\n+    //! Fee estimator max target.\n+    virtual int estimateMaxBlocks() = 0;\n+\n+    //! Pool min fee.\n+    virtual CFeeRate poolMinFee() = 0;\n+\n+    //! Check if pruning is enabled.\n+    virtual bool getPruneMode() = 0;\n+\n+    //! Check if p2p enabled.\n+    virtual bool p2pEnabled() = 0;\n+\n+    // Check if in IBD.\n+    virtual bool isInitialBlockDownload() = 0;\n+\n+    //! Get adjusted time.\n+    virtual int64_t getAdjustedTime() = 0;\n+\n+    //! Send init message.\n+    virtual void initMessage(const std::string& message) = 0;\n+\n+    //! Send init warning.\n+    virtual void initWarning(const std::string& message) = 0;\n+\n+    //! Send init error.\n+    virtual void initError(const std::string& message) = 0;\n+\n+    //! Send wallet load notification.\n+    virtual void loadWallet(std::unique_ptr<Wallet> wallet) = 0;\n+\n+    //! Generate blocks\n+    virtual UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbase_script,\n+        int num_blocks,\n+        uint64_t max_tries,\n+        bool keep_script) = 0;\n+\n+    //! Parse confirm target.\n+    virtual unsigned int parseConfirmTarget(const UniValue& value) = 0;\n+\n+    //! Chain notifications.\n+    class Notifications\n+    {\n+    public:\n+        virtual ~Notifications() {}\n+        virtual void TransactionAddedToMempool(const CTransactionRef& tx) {}\n+        virtual void TransactionRemovedFromMempool(const CTransactionRef& ptx) {}\n+        virtual void BlockConnected(const CBlock& block,\n+            const uint256& block_hash,\n+            const std::vector<CTransactionRef>& tx_conflicted)\n+        {\n+        }\n+        virtual void BlockDisconnected(const CBlock& block) {}\n+        virtual void ChainStateFlushed(const CBlockLocator& locator) {}\n+        virtual void Inventory(const uint256& hash) {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219420677",
      "id" : 219420677,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQyMDY3Nw==",
      "original_commit_id" : "e44e639558b1084f14a97847592616c3df9fff38",
      "original_position" : 209,
      "path" : "src/interfaces/chain.h",
      "position" : null,
      "pull_request_review_id" : 157591941,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219420677",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->Reviewers, this pull request conflicts with the following ones:\n\n* #14411 ([wallet] Restore ability to list incoming transactions by label by ryanofsky)\n* #14384 (Resolve validationinterface circular dependencies by 251Labs)\n* #14358 ([logs] Fix a few log messages related to duration measurement by romanz)\n* #14350 (Add WalletInfo class by promag)\n* #14309 (Use non-throwing type-safe ChainType where possible by MarcoFalke)\n* #14146 (wallet: Remove trailing separators from -walletdir arg by PierreRochard)\n* #14121 (Index for BIP 157 block filters by jimpo)\n* #14035 (Utxoscriptindex by mgrychow)\n* #13969 (Make sure all callers of LookupBlockIndex(...) check for nullptr before dereferencing (CBlockIndex*) by practicalswift)\n* #13804 (Transaction Pool Layer by MarcoFalke)\n* #13756 (wallet: -avoidreuse feature for improved privacy by kallewoof)\n* #13612 (Qt: Only call tryGetBalances in pollBalanceChanged if the result will be used. by tecnovert)\n* #13582 (Extract AppInitLoadBlockIndex from AppInitMain by Empact)\n* #13430 (use IsBlockPruned() where appropriate by kallewoof)\n* #13100 (gui: Add dynamic wallets support by promag)\n* #12508 (IsAllFromMe by kallewoof)\n* #11652 (Add missing locks: validation.cpp + related by practicalswift)\n* #11634 (wallet: Add missing cs_wallet/cs_KeyStore locks to wallet by practicalswift)\n* #11413 ([wallet] [rpc] sendtoaddress/sendmany: Add explicit feerate option by kallewoof)\n* #9381 (Remove CWalletTx merging logic from AddToWallet by ryanofsky)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2018-09-21T13:32:42Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-423532180",
      "id" : 423532180,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10973",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyMzUzMjE4MA==",
      "updated_at" : "2018-10-10T07:14:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/423532180",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219691759"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219691759"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n\r\n2018-09-22 22:50:20 cpplint(pr=10973): src/interfaces/chain.cpp:0:  No copyright message found.\r\n```",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-09-23T08:23:05Z",
      "diff_hunk" : "@@ -0,0 +1,453 @@\n+#include <interfaces/chain.h>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219691759",
      "id" : 219691759,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTY5MTc1OQ==",
      "original_commit_id" : "e44e639558b1084f14a97847592616c3df9fff38",
      "original_position" : 1,
      "path" : "src/interfaces/chain.cpp",
      "position" : 5,
      "pull_request_review_id" : 157932364,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219691759",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219691763"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219691763"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-22 22:50:20 cpplint(pr=10973): src/interfaces/chain.cpp:168:  Single-parameter constructors should be marked explicit.\r\n```",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-09-23T08:23:28Z",
      "diff_hunk" : "@@ -0,0 +1,453 @@\n+#include <interfaces/chain.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <interfaces/handler.h>\n+#include <interfaces/wallet.h>\n+#include <net.h>\n+#include <policy/fees.h>\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <protocol.h>\n+#include <rpc/mining.h>\n+#include <rpc/protocol.h>\n+#include <rpc/server.h>\n+#include <sync.h>\n+#include <threadsafety.h>\n+#include <timedata.h>\n+#include <txmempool.h>\n+#include <ui_interface.h>\n+#include <uint256.h>\n+#include <univalue.h>\n+#include <util.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <tuple>\n+#include <unordered_map>\n+#include <utility>\n+\n+class CReserveScript;\n+\n+namespace interfaces {\n+namespace {\n+\n+//! Extension of std::reference_wrapper with operator< for use as map key.\n+template <typename T>\n+class Ref : public std::reference_wrapper<T>\n+{\n+public:\n+    using std::reference_wrapper<T>::reference_wrapper;\n+    bool operator<(const Ref<T>& other) const { return this->get() < other.get(); }\n+};\n+\n+class LockImpl : public Chain::Lock\n+{\n+    Optional<int> getHeight() override\n+    {\n+        int height = ::chainActive.Height();\n+        if (height >= 0) {\n+            return height;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> getBlockHeight(const uint256& hash) override\n+    {\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end() && it->second) {\n+            if (::chainActive.Contains(it->second)) {\n+                return it->second->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    int getBlockDepth(const uint256& hash) override\n+    {\n+        const Optional<int> tip_height = getHeight();\n+        const Optional<int> height = getBlockHeight(hash);\n+        return tip_height && height ? *tip_height - *height + 1 : 0;\n+    }\n+    uint256 getBlockHash(int height) override { return ::chainActive[height]->GetBlockHash(); }\n+    int64_t getBlockTime(int height) override { return ::chainActive[height]->GetBlockTime(); }\n+    int64_t getBlockMedianTimePast(int height) override { return ::chainActive[height]->GetMedianTimePast(); }\n+    bool haveBlockOnDisk(int height) override\n+    {\n+        CBlockIndex* block = ::chainActive[height];\n+        return block && (block->nStatus & BLOCK_HAVE_DATA) && block->nTx > 0;\n+    }\n+    Optional<int> findFirstBlockWithTime(int64_t time) override\n+    {\n+        CBlockIndex* block = ::chainActive.FindEarliestAtLeast(time);\n+        if (block) {\n+            return block->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFirstBlockWithTimeAndHeight(int64_t time, int height) override\n+    {\n+        for (CBlockIndex* block = ::chainActive[height]; block; block = ::chainActive.Next(block)) {\n+            if (block->GetBlockTime() >= time) {\n+                return block->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findPruned(int start_height, Optional<int> stop_height) override\n+    {\n+        if (::fPruneMode) {\n+            CBlockIndex* block = stop_height ? ::chainActive[*stop_height] : ::chainActive.Tip();\n+            while (block && block->nHeight >= start_height) {\n+                if (!(block->nStatus & BLOCK_HAVE_DATA)) {\n+                    return block->nHeight;\n+                }\n+                block = block->pprev;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFork(const uint256& hash, Optional<int>* height) override\n+    {\n+        const CBlockIndex *block{nullptr}, *fork{nullptr};\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end()) {\n+            block = it->second;\n+            fork = ::chainActive.FindFork(block);\n+        }\n+        if (height) {\n+            if (block) {\n+                *height = block->nHeight;\n+            } else {\n+                height->reset();\n+            }\n+        }\n+        if (fork) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool isPotentialTip(const uint256& hash) override\n+    {\n+        if (::chainActive.Tip()->GetBlockHash() == hash) return true;\n+        auto it = ::mapBlockIndex.find(hash);\n+        return it != ::mapBlockIndex.end() && it->second->GetAncestor(::chainActive.Height()) == ::chainActive.Tip();\n+    }\n+    CBlockLocator getLocator() override { return ::chainActive.GetLocator(); }\n+    Optional<int> findLocatorFork(const CBlockLocator& locator) override\n+    {\n+        if (CBlockIndex* fork = FindForkInGlobalIndex(::chainActive, locator)) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool checkFinalTx(const CTransaction& tx) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return CheckFinalTx(tx);\n+    }\n+    bool acceptToMemoryPool(CTransactionRef tx, CValidationState& state) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return AcceptToMemoryPool(::mempool, state, tx, nullptr /* missing inputs */, nullptr /* txn replaced */,\n+            false /* bypass limits */, ::maxTxFee /* absurd fee */);\n+    }\n+};\n+\n+class LockingStateImpl : public LockImpl, public UniqueLock<CCriticalSection>\n+{\n+    using UniqueLock::UniqueLock;\n+};\n+\n+class HandlerImpl : public Handler\n+{\n+public:\n+    HandlerImpl(Chain::Notifications& notifications) : m_forwarder(notifications) {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219691763",
      "id" : 219691763,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTY5MTc2Mw==",
      "original_commit_id" : "e44e639558b1084f14a97847592616c3df9fff38",
      "original_position" : 168,
      "path" : "src/interfaces/chain.cpp",
      "position" : null,
      "pull_request_review_id" : 157932369,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219691763",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219691774"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219691774"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-22 22:50:20 cpplint(pr=10973): src/interfaces/chain.cpp:182:  Single-parameter constructors should be marked explicit.\r\n```",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-09-23T08:24:00Z",
      "diff_hunk" : "@@ -0,0 +1,453 @@\n+#include <interfaces/chain.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <interfaces/handler.h>\n+#include <interfaces/wallet.h>\n+#include <net.h>\n+#include <policy/fees.h>\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <protocol.h>\n+#include <rpc/mining.h>\n+#include <rpc/protocol.h>\n+#include <rpc/server.h>\n+#include <sync.h>\n+#include <threadsafety.h>\n+#include <timedata.h>\n+#include <txmempool.h>\n+#include <ui_interface.h>\n+#include <uint256.h>\n+#include <univalue.h>\n+#include <util.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <tuple>\n+#include <unordered_map>\n+#include <utility>\n+\n+class CReserveScript;\n+\n+namespace interfaces {\n+namespace {\n+\n+//! Extension of std::reference_wrapper with operator< for use as map key.\n+template <typename T>\n+class Ref : public std::reference_wrapper<T>\n+{\n+public:\n+    using std::reference_wrapper<T>::reference_wrapper;\n+    bool operator<(const Ref<T>& other) const { return this->get() < other.get(); }\n+};\n+\n+class LockImpl : public Chain::Lock\n+{\n+    Optional<int> getHeight() override\n+    {\n+        int height = ::chainActive.Height();\n+        if (height >= 0) {\n+            return height;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> getBlockHeight(const uint256& hash) override\n+    {\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end() && it->second) {\n+            if (::chainActive.Contains(it->second)) {\n+                return it->second->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    int getBlockDepth(const uint256& hash) override\n+    {\n+        const Optional<int> tip_height = getHeight();\n+        const Optional<int> height = getBlockHeight(hash);\n+        return tip_height && height ? *tip_height - *height + 1 : 0;\n+    }\n+    uint256 getBlockHash(int height) override { return ::chainActive[height]->GetBlockHash(); }\n+    int64_t getBlockTime(int height) override { return ::chainActive[height]->GetBlockTime(); }\n+    int64_t getBlockMedianTimePast(int height) override { return ::chainActive[height]->GetMedianTimePast(); }\n+    bool haveBlockOnDisk(int height) override\n+    {\n+        CBlockIndex* block = ::chainActive[height];\n+        return block && (block->nStatus & BLOCK_HAVE_DATA) && block->nTx > 0;\n+    }\n+    Optional<int> findFirstBlockWithTime(int64_t time) override\n+    {\n+        CBlockIndex* block = ::chainActive.FindEarliestAtLeast(time);\n+        if (block) {\n+            return block->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFirstBlockWithTimeAndHeight(int64_t time, int height) override\n+    {\n+        for (CBlockIndex* block = ::chainActive[height]; block; block = ::chainActive.Next(block)) {\n+            if (block->GetBlockTime() >= time) {\n+                return block->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findPruned(int start_height, Optional<int> stop_height) override\n+    {\n+        if (::fPruneMode) {\n+            CBlockIndex* block = stop_height ? ::chainActive[*stop_height] : ::chainActive.Tip();\n+            while (block && block->nHeight >= start_height) {\n+                if (!(block->nStatus & BLOCK_HAVE_DATA)) {\n+                    return block->nHeight;\n+                }\n+                block = block->pprev;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFork(const uint256& hash, Optional<int>* height) override\n+    {\n+        const CBlockIndex *block{nullptr}, *fork{nullptr};\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end()) {\n+            block = it->second;\n+            fork = ::chainActive.FindFork(block);\n+        }\n+        if (height) {\n+            if (block) {\n+                *height = block->nHeight;\n+            } else {\n+                height->reset();\n+            }\n+        }\n+        if (fork) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool isPotentialTip(const uint256& hash) override\n+    {\n+        if (::chainActive.Tip()->GetBlockHash() == hash) return true;\n+        auto it = ::mapBlockIndex.find(hash);\n+        return it != ::mapBlockIndex.end() && it->second->GetAncestor(::chainActive.Height()) == ::chainActive.Tip();\n+    }\n+    CBlockLocator getLocator() override { return ::chainActive.GetLocator(); }\n+    Optional<int> findLocatorFork(const CBlockLocator& locator) override\n+    {\n+        if (CBlockIndex* fork = FindForkInGlobalIndex(::chainActive, locator)) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool checkFinalTx(const CTransaction& tx) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return CheckFinalTx(tx);\n+    }\n+    bool acceptToMemoryPool(CTransactionRef tx, CValidationState& state) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return AcceptToMemoryPool(::mempool, state, tx, nullptr /* missing inputs */, nullptr /* txn replaced */,\n+            false /* bypass limits */, ::maxTxFee /* absurd fee */);\n+    }\n+};\n+\n+class LockingStateImpl : public LockImpl, public UniqueLock<CCriticalSection>\n+{\n+    using UniqueLock::UniqueLock;\n+};\n+\n+class HandlerImpl : public Handler\n+{\n+public:\n+    HandlerImpl(Chain::Notifications& notifications) : m_forwarder(notifications) {}\n+    ~HandlerImpl() override\n+    {\n+        // It is important to disconnect here in the HandlerImpl destructor,\n+        // instead of in the HandleImpl::Forwarder destructor, because\n+        // UnregisterAllValidationInterfaces() internally accesses Forwarder\n+        // virtual methods which are no longer available after Forwarder object\n+        // has begun to be being destroyed.\n+        m_forwarder.disconnect();\n+    }\n+    void disconnect() override { m_forwarder.disconnect(); }\n+\n+    struct Forwarder : CValidationInterface\n+    {\n+        Forwarder(Chain::Notifications& notifications) : m_notifications(&notifications)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219691774",
      "id" : 219691774,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTY5MTc3NA==",
      "original_commit_id" : "e44e639558b1084f14a97847592616c3df9fff38",
      "original_position" : 182,
      "path" : "src/interfaces/chain.cpp",
      "position" : null,
      "pull_request_review_id" : 157932380,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219691774",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219691784"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219691784"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-22 22:50:20 cpplint(pr=10973): src/interfaces/chain.cpp:362:  Single-parameter constructors should be marked explicit.\r\n```",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-09-23T08:24:17Z",
      "diff_hunk" : "@@ -0,0 +1,453 @@\n+#include <interfaces/chain.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <interfaces/handler.h>\n+#include <interfaces/wallet.h>\n+#include <net.h>\n+#include <policy/fees.h>\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <protocol.h>\n+#include <rpc/mining.h>\n+#include <rpc/protocol.h>\n+#include <rpc/server.h>\n+#include <sync.h>\n+#include <threadsafety.h>\n+#include <timedata.h>\n+#include <txmempool.h>\n+#include <ui_interface.h>\n+#include <uint256.h>\n+#include <univalue.h>\n+#include <util.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <tuple>\n+#include <unordered_map>\n+#include <utility>\n+\n+class CReserveScript;\n+\n+namespace interfaces {\n+namespace {\n+\n+//! Extension of std::reference_wrapper with operator< for use as map key.\n+template <typename T>\n+class Ref : public std::reference_wrapper<T>\n+{\n+public:\n+    using std::reference_wrapper<T>::reference_wrapper;\n+    bool operator<(const Ref<T>& other) const { return this->get() < other.get(); }\n+};\n+\n+class LockImpl : public Chain::Lock\n+{\n+    Optional<int> getHeight() override\n+    {\n+        int height = ::chainActive.Height();\n+        if (height >= 0) {\n+            return height;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> getBlockHeight(const uint256& hash) override\n+    {\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end() && it->second) {\n+            if (::chainActive.Contains(it->second)) {\n+                return it->second->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    int getBlockDepth(const uint256& hash) override\n+    {\n+        const Optional<int> tip_height = getHeight();\n+        const Optional<int> height = getBlockHeight(hash);\n+        return tip_height && height ? *tip_height - *height + 1 : 0;\n+    }\n+    uint256 getBlockHash(int height) override { return ::chainActive[height]->GetBlockHash(); }\n+    int64_t getBlockTime(int height) override { return ::chainActive[height]->GetBlockTime(); }\n+    int64_t getBlockMedianTimePast(int height) override { return ::chainActive[height]->GetMedianTimePast(); }\n+    bool haveBlockOnDisk(int height) override\n+    {\n+        CBlockIndex* block = ::chainActive[height];\n+        return block && (block->nStatus & BLOCK_HAVE_DATA) && block->nTx > 0;\n+    }\n+    Optional<int> findFirstBlockWithTime(int64_t time) override\n+    {\n+        CBlockIndex* block = ::chainActive.FindEarliestAtLeast(time);\n+        if (block) {\n+            return block->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFirstBlockWithTimeAndHeight(int64_t time, int height) override\n+    {\n+        for (CBlockIndex* block = ::chainActive[height]; block; block = ::chainActive.Next(block)) {\n+            if (block->GetBlockTime() >= time) {\n+                return block->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findPruned(int start_height, Optional<int> stop_height) override\n+    {\n+        if (::fPruneMode) {\n+            CBlockIndex* block = stop_height ? ::chainActive[*stop_height] : ::chainActive.Tip();\n+            while (block && block->nHeight >= start_height) {\n+                if (!(block->nStatus & BLOCK_HAVE_DATA)) {\n+                    return block->nHeight;\n+                }\n+                block = block->pprev;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFork(const uint256& hash, Optional<int>* height) override\n+    {\n+        const CBlockIndex *block{nullptr}, *fork{nullptr};\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end()) {\n+            block = it->second;\n+            fork = ::chainActive.FindFork(block);\n+        }\n+        if (height) {\n+            if (block) {\n+                *height = block->nHeight;\n+            } else {\n+                height->reset();\n+            }\n+        }\n+        if (fork) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool isPotentialTip(const uint256& hash) override\n+    {\n+        if (::chainActive.Tip()->GetBlockHash() == hash) return true;\n+        auto it = ::mapBlockIndex.find(hash);\n+        return it != ::mapBlockIndex.end() && it->second->GetAncestor(::chainActive.Height()) == ::chainActive.Tip();\n+    }\n+    CBlockLocator getLocator() override { return ::chainActive.GetLocator(); }\n+    Optional<int> findLocatorFork(const CBlockLocator& locator) override\n+    {\n+        if (CBlockIndex* fork = FindForkInGlobalIndex(::chainActive, locator)) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool checkFinalTx(const CTransaction& tx) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return CheckFinalTx(tx);\n+    }\n+    bool acceptToMemoryPool(CTransactionRef tx, CValidationState& state) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return AcceptToMemoryPool(::mempool, state, tx, nullptr /* missing inputs */, nullptr /* txn replaced */,\n+            false /* bypass limits */, ::maxTxFee /* absurd fee */);\n+    }\n+};\n+\n+class LockingStateImpl : public LockImpl, public UniqueLock<CCriticalSection>\n+{\n+    using UniqueLock::UniqueLock;\n+};\n+\n+class HandlerImpl : public Handler\n+{\n+public:\n+    HandlerImpl(Chain::Notifications& notifications) : m_forwarder(notifications) {}\n+    ~HandlerImpl() override\n+    {\n+        // It is important to disconnect here in the HandlerImpl destructor,\n+        // instead of in the HandleImpl::Forwarder destructor, because\n+        // UnregisterAllValidationInterfaces() internally accesses Forwarder\n+        // virtual methods which are no longer available after Forwarder object\n+        // has begun to be being destroyed.\n+        m_forwarder.disconnect();\n+    }\n+    void disconnect() override { m_forwarder.disconnect(); }\n+\n+    struct Forwarder : CValidationInterface\n+    {\n+        Forwarder(Chain::Notifications& notifications) : m_notifications(&notifications)\n+        {\n+            RegisterValidationInterface(this);\n+        }\n+        void disconnect()\n+        {\n+            if (m_notifications) {\n+                m_notifications = nullptr;\n+                UnregisterValidationInterface(this);\n+            }\n+        }\n+        void TransactionAddedToMempool(const CTransactionRef& tx) override\n+        {\n+            m_notifications->TransactionAddedToMempool(tx);\n+        }\n+        void TransactionRemovedFromMempool(const CTransactionRef& tx) override\n+        {\n+            m_notifications->TransactionRemovedFromMempool(tx);\n+        }\n+        void BlockConnected(const std::shared_ptr<const CBlock>& block,\n+            const CBlockIndex* index,\n+            const std::vector<CTransactionRef>& tx_conflicted) override\n+        {\n+            m_notifications->BlockConnected(*block, index->GetBlockHash(), tx_conflicted);\n+        }\n+        void BlockDisconnected(const std::shared_ptr<const CBlock>& block) override\n+        {\n+            m_notifications->BlockDisconnected(*block);\n+        }\n+        void ChainStateFlushed(const CBlockLocator& locator) override { m_notifications->ChainStateFlushed(locator); }\n+        void ResendWalletTransactions(int64_t best_block_time, CConnman* connman) override\n+        {\n+            m_notifications->ResendWalletTransactions(best_block_time);\n+        }\n+\n+        Chain::Notifications* m_notifications;\n+    };\n+\n+    Forwarder m_forwarder;\n+};\n+\n+class ChainImpl : public Chain\n+{\n+public:\n+    std::unique_ptr<Chain::Lock> lock(bool try_lock) override\n+    {\n+        auto result = MakeUnique<LockingStateImpl>(::cs_main, \"cs_main\", __FILE__, __LINE__, try_lock);\n+        if (try_lock && result && !*result) return {};\n+        // std::move necessary on some compilers due to conversion from\n+        // LockingStateImpl to Lock pointer\n+        return std::move(result);\n+    }\n+    std::unique_ptr<Chain::Lock> assumeLocked() override { return MakeUnique<LockImpl>(); }\n+    bool findBlock(const uint256& hash, CBlock* block, int64_t* time, int64_t* time_max) override\n+    {\n+        CBlockIndex* index;\n+        {\n+            LOCK(cs_main);\n+            auto it = ::mapBlockIndex.find(hash);\n+            if (it == ::mapBlockIndex.end()) {\n+                return false;\n+            }\n+            index = it->second;\n+            if (time) {\n+                *time = index->GetBlockTime();\n+            }\n+            if (time_max) {\n+                *time_max = index->GetBlockTimeMax();\n+            }\n+        }\n+        if (block && !ReadBlockFromDisk(*block, index, Params().GetConsensus())) {\n+            block->SetNull();\n+        }\n+        return true;\n+    }\n+    std::vector<Coin> findCoins(const std::vector<COutPoint>& outputs) override\n+    {\n+        std::vector<Coin> coins;\n+        LOCK2(cs_main, ::mempool.cs);\n+        assert(pcoinsTip);\n+        CCoinsViewCache& chain_view = *::pcoinsTip;\n+        CCoinsViewMemPool mempool_view(&chain_view, ::mempool);\n+        for (const auto& output : outputs) {\n+            Coin coin;\n+            mempool_view.GetCoin(output, coin);\n+            coins.emplace_back(std::move(coin));\n+        }\n+        return coins;\n+    }\n+    double guessVerificationProgress(const uint256& block_hash) override\n+    {\n+        LOCK(cs_main);\n+        auto it = ::mapBlockIndex.find(block_hash);\n+        return GuessVerificationProgress(Params().TxData(), it != ::mapBlockIndex.end() ? it->second : nullptr);\n+    }\n+    int64_t getVirtualTransactionSize(const CTransaction& tx) override { return GetVirtualTransactionSize(tx); }\n+    RBFTransactionState isRBFOptIn(const CTransaction& tx) override\n+    {\n+        LOCK(::mempool.cs);\n+        return IsRBFOptIn(tx, ::mempool);\n+    }\n+    bool hasDescendantsInMempool(const uint256& txid) override\n+    {\n+        LOCK(::mempool.cs);\n+        auto it_mp = ::mempool.mapTx.find(txid);\n+        return it_mp != ::mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1;\n+    }\n+    bool relayTransaction(const uint256& txid) override\n+    {\n+        if (g_connman) {\n+            CInv inv(MSG_TX, txid);\n+            g_connman->ForEachNode([&inv](CNode* node) { node->PushInventory(inv); });\n+            return true;\n+        }\n+        return false;\n+    }\n+    void getTransactionAncestry(const uint256& txid, size_t& ancestors, size_t& descendants) override\n+    {\n+        ::mempool.GetTransactionAncestry(txid, ancestors, descendants);\n+    }\n+    bool checkChainLimits(CTransactionRef tx) override\n+    {\n+        LockPoints lp;\n+        CTxMemPoolEntry entry(tx, 0, 0, 0, false, 0, lp);\n+        CTxMemPool::setEntries setAncestors;\n+        size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n+        size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT) * 1000;\n+        size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n+        size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT) * 1000;\n+        std::string errString;\n+        LOCK(::mempool.cs);\n+        if (!::mempool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize,\n+                nLimitDescendants, nLimitDescendantSize, errString)) {\n+            return false;\n+        }\n+        return true;\n+    }\n+    CFeeRate estimateSmartFee(int num_blocks, bool conservative, FeeCalculation* calc) override\n+    {\n+        return ::feeEstimator.estimateSmartFee(num_blocks, calc, conservative);\n+    }\n+    int estimateMaxBlocks() override { return ::feeEstimator.HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE); }\n+    CFeeRate poolMinFee() override\n+    {\n+        return ::mempool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    }\n+    bool getPruneMode() override { return ::fPruneMode; }\n+    bool p2pEnabled() override { return g_connman != nullptr; }\n+    bool isInitialBlockDownload() override { return IsInitialBlockDownload(); }\n+    int64_t getAdjustedTime() override { return GetAdjustedTime(); }\n+    void initMessage(const std::string& message) override { ::uiInterface.InitMessage(message); }\n+    void initWarning(const std::string& message) override { InitWarning(message); }\n+    void initError(const std::string& message) override { InitError(message); }\n+    void loadWallet(std::unique_ptr<Wallet> wallet) override { ::uiInterface.LoadWallet(wallet); }\n+    UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbase_script,\n+        int num_blocks,\n+        uint64_t max_tries,\n+        bool keep_script) override\n+    {\n+        return ::generateBlocks(coinbase_script, num_blocks, max_tries, keep_script);\n+    }\n+    unsigned int parseConfirmTarget(const UniValue& value) override { return ParseConfirmTarget(value); }\n+    std::unique_ptr<Handler> handleNotifications(Notifications& notifications) override\n+    {\n+        return MakeUnique<HandlerImpl>(notifications);\n+    }\n+    void waitForNotifications() override { SyncWithValidationInterfaceQueue(); }\n+    std::unique_ptr<Handler> handleRpc(const CRPCCommand& command) override;\n+\n+    //! Map of RPC method name to forwarder. If multiple clients provide\n+    //! implementations of the same RPC method, the RPC forwarder can dispatch\n+    //! between them.\n+    class RpcForwarder;\n+    std::map<Ref<const std::string>, RpcForwarder> m_rpc_forwarders;\n+};\n+\n+//! Forwarder for one RPC method.\n+class ChainImpl::RpcForwarder\n+{\n+public:\n+    RpcForwarder(const CRPCCommand& command) : m_command(command)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219691784",
      "id" : 219691784,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTY5MTc4NA==",
      "original_commit_id" : "e44e639558b1084f14a97847592616c3df9fff38",
      "original_position" : 362,
      "path" : "src/interfaces/chain.cpp",
      "position" : null,
      "pull_request_review_id" : 157932388,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219691784",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219691793"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219691793"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-22 22:50:20 cpplint(pr=10973): src/interfaces/chain.h:0:  No copyright message found.\r\n```",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-09-23T08:24:35Z",
      "diff_hunk" : "@@ -0,0 +1,265 @@\n+#ifndef BITCOIN_INTERFACES_CHAIN_H",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219691793",
      "id" : 219691793,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTY5MTc5Mw==",
      "original_commit_id" : "e44e639558b1084f14a97847592616c3df9fff38",
      "original_position" : 1,
      "path" : "src/interfaces/chain.h",
      "position" : 5,
      "pull_request_review_id" : 157932396,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219691793",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219691803"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219691803"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-22 22:50:20 cpplint(pr=10973): src/threadsafety.h:62:  Single-parameter constructors should be marked explicit.  [runtime/explicit] [5]\r\n```",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-09-23T08:24:56Z",
      "diff_hunk" : "@@ -54,4 +54,15 @@\n #define ASSERT_EXCLUSIVE_LOCK(...)\n #endif // __GNUC__\n \n+// Utility class to indicate mutex is locked for thread analysis when it can't\n+// be determined otherwise.\n+struct SCOPED_LOCKABLE LockAnnotation\n+{\n+    template <typename Mutex>\n+    LockAnnotation(Mutex& mutex) EXCLUSIVE_LOCK_FUNCTION(mutex)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219691803",
      "id" : 219691803,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTY5MTgwMw==",
      "original_commit_id" : "e44e639558b1084f14a97847592616c3df9fff38",
      "original_position" : 9,
      "path" : "src/threadsafety.h",
      "position" : null,
      "pull_request_review_id" : 157932405,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219691803",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219704316"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219704316"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "@practicalswift You know, the signal/noise ratio of these comments would be higher if you omitted the timestamp (which isn't interesting), the PR number and the file path (which are redundant, because that's where the comment is attached). Currently in the web UI, you always have to scroll each comment horizontally to see what it's actually about.\r\n\r\nstatus quo:\r\n<img width=\"676\" alt=\"bildschirmfoto 2018-09-23 um 18 40 53\" src=\"https://user-images.githubusercontent.com/425166/45930419-5f36e980-bf60-11e8-866f-102591e58d38.png\">\r\n\r\nproposed:\r\n<img width=\"664\" alt=\"bildschirmfoto 2018-09-23 um 18 41 21\" src=\"https://user-images.githubusercontent.com/425166/45930424-6958e800-bf60-11e8-841b-1e553ca9d7b6.png\">\r\n\r\n",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-09-23T16:42:36Z",
      "diff_hunk" : "@@ -0,0 +1,453 @@\n+#include <interfaces/chain.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <interfaces/handler.h>\n+#include <interfaces/wallet.h>\n+#include <net.h>\n+#include <policy/fees.h>\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <protocol.h>\n+#include <rpc/mining.h>\n+#include <rpc/protocol.h>\n+#include <rpc/server.h>\n+#include <sync.h>\n+#include <threadsafety.h>\n+#include <timedata.h>\n+#include <txmempool.h>\n+#include <ui_interface.h>\n+#include <uint256.h>\n+#include <univalue.h>\n+#include <util.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <tuple>\n+#include <unordered_map>\n+#include <utility>\n+\n+class CReserveScript;\n+\n+namespace interfaces {\n+namespace {\n+\n+//! Extension of std::reference_wrapper with operator< for use as map key.\n+template <typename T>\n+class Ref : public std::reference_wrapper<T>\n+{\n+public:\n+    using std::reference_wrapper<T>::reference_wrapper;\n+    bool operator<(const Ref<T>& other) const { return this->get() < other.get(); }\n+};\n+\n+class LockImpl : public Chain::Lock\n+{\n+    Optional<int> getHeight() override\n+    {\n+        int height = ::chainActive.Height();\n+        if (height >= 0) {\n+            return height;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> getBlockHeight(const uint256& hash) override\n+    {\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end() && it->second) {\n+            if (::chainActive.Contains(it->second)) {\n+                return it->second->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    int getBlockDepth(const uint256& hash) override\n+    {\n+        const Optional<int> tip_height = getHeight();\n+        const Optional<int> height = getBlockHeight(hash);\n+        return tip_height && height ? *tip_height - *height + 1 : 0;\n+    }\n+    uint256 getBlockHash(int height) override { return ::chainActive[height]->GetBlockHash(); }\n+    int64_t getBlockTime(int height) override { return ::chainActive[height]->GetBlockTime(); }\n+    int64_t getBlockMedianTimePast(int height) override { return ::chainActive[height]->GetMedianTimePast(); }\n+    bool haveBlockOnDisk(int height) override\n+    {\n+        CBlockIndex* block = ::chainActive[height];\n+        return block && (block->nStatus & BLOCK_HAVE_DATA) && block->nTx > 0;\n+    }\n+    Optional<int> findFirstBlockWithTime(int64_t time) override\n+    {\n+        CBlockIndex* block = ::chainActive.FindEarliestAtLeast(time);\n+        if (block) {\n+            return block->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFirstBlockWithTimeAndHeight(int64_t time, int height) override\n+    {\n+        for (CBlockIndex* block = ::chainActive[height]; block; block = ::chainActive.Next(block)) {\n+            if (block->GetBlockTime() >= time) {\n+                return block->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findPruned(int start_height, Optional<int> stop_height) override\n+    {\n+        if (::fPruneMode) {\n+            CBlockIndex* block = stop_height ? ::chainActive[*stop_height] : ::chainActive.Tip();\n+            while (block && block->nHeight >= start_height) {\n+                if (!(block->nStatus & BLOCK_HAVE_DATA)) {\n+                    return block->nHeight;\n+                }\n+                block = block->pprev;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFork(const uint256& hash, Optional<int>* height) override\n+    {\n+        const CBlockIndex *block{nullptr}, *fork{nullptr};\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end()) {\n+            block = it->second;\n+            fork = ::chainActive.FindFork(block);\n+        }\n+        if (height) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219704316",
      "id" : 219704316,
      "in_reply_to_id" : 219412247,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTcwNDMxNg==",
      "original_commit_id" : "e44e639558b1084f14a97847592616c3df9fff38",
      "original_position" : 121,
      "path" : "src/interfaces/chain.cpp",
      "position" : null,
      "pull_request_review_id" : 157944675,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219704316",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/425166?v=4",
         "events_url" : "https://api.github.com/users/flack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/flack/followers",
         "following_url" : "https://api.github.com/users/flack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/flack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/flack",
         "id" : 425166,
         "login" : "flack",
         "node_id" : "MDQ6VXNlcjQyNTE2Ng==",
         "organizations_url" : "https://api.github.com/users/flack/orgs",
         "received_events_url" : "https://api.github.com/users/flack/received_events",
         "repos_url" : "https://api.github.com/users/flack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/flack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/flack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/flack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219705466"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219705466"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@flack Good point! I'll implement that!",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-09-23T17:22:36Z",
      "diff_hunk" : "@@ -0,0 +1,453 @@\n+#include <interfaces/chain.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <interfaces/handler.h>\n+#include <interfaces/wallet.h>\n+#include <net.h>\n+#include <policy/fees.h>\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <protocol.h>\n+#include <rpc/mining.h>\n+#include <rpc/protocol.h>\n+#include <rpc/server.h>\n+#include <sync.h>\n+#include <threadsafety.h>\n+#include <timedata.h>\n+#include <txmempool.h>\n+#include <ui_interface.h>\n+#include <uint256.h>\n+#include <univalue.h>\n+#include <util.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <tuple>\n+#include <unordered_map>\n+#include <utility>\n+\n+class CReserveScript;\n+\n+namespace interfaces {\n+namespace {\n+\n+//! Extension of std::reference_wrapper with operator< for use as map key.\n+template <typename T>\n+class Ref : public std::reference_wrapper<T>\n+{\n+public:\n+    using std::reference_wrapper<T>::reference_wrapper;\n+    bool operator<(const Ref<T>& other) const { return this->get() < other.get(); }\n+};\n+\n+class LockImpl : public Chain::Lock\n+{\n+    Optional<int> getHeight() override\n+    {\n+        int height = ::chainActive.Height();\n+        if (height >= 0) {\n+            return height;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> getBlockHeight(const uint256& hash) override\n+    {\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end() && it->second) {\n+            if (::chainActive.Contains(it->second)) {\n+                return it->second->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    int getBlockDepth(const uint256& hash) override\n+    {\n+        const Optional<int> tip_height = getHeight();\n+        const Optional<int> height = getBlockHeight(hash);\n+        return tip_height && height ? *tip_height - *height + 1 : 0;\n+    }\n+    uint256 getBlockHash(int height) override { return ::chainActive[height]->GetBlockHash(); }\n+    int64_t getBlockTime(int height) override { return ::chainActive[height]->GetBlockTime(); }\n+    int64_t getBlockMedianTimePast(int height) override { return ::chainActive[height]->GetMedianTimePast(); }\n+    bool haveBlockOnDisk(int height) override\n+    {\n+        CBlockIndex* block = ::chainActive[height];\n+        return block && (block->nStatus & BLOCK_HAVE_DATA) && block->nTx > 0;\n+    }\n+    Optional<int> findFirstBlockWithTime(int64_t time) override\n+    {\n+        CBlockIndex* block = ::chainActive.FindEarliestAtLeast(time);\n+        if (block) {\n+            return block->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFirstBlockWithTimeAndHeight(int64_t time, int height) override\n+    {\n+        for (CBlockIndex* block = ::chainActive[height]; block; block = ::chainActive.Next(block)) {\n+            if (block->GetBlockTime() >= time) {\n+                return block->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findPruned(int start_height, Optional<int> stop_height) override\n+    {\n+        if (::fPruneMode) {\n+            CBlockIndex* block = stop_height ? ::chainActive[*stop_height] : ::chainActive.Tip();\n+            while (block && block->nHeight >= start_height) {\n+                if (!(block->nStatus & BLOCK_HAVE_DATA)) {\n+                    return block->nHeight;\n+                }\n+                block = block->pprev;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFork(const uint256& hash, Optional<int>* height) override\n+    {\n+        const CBlockIndex *block{nullptr}, *fork{nullptr};\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end()) {\n+            block = it->second;\n+            fork = ::chainActive.FindFork(block);\n+        }\n+        if (height) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r219705466",
      "id" : 219705466,
      "in_reply_to_id" : 219412247,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTcwNTQ2Ng==",
      "original_commit_id" : "e44e639558b1084f14a97847592616c3df9fff38",
      "original_position" : 121,
      "path" : "src/interfaces/chain.cpp",
      "position" : null,
      "pull_request_review_id" : 157945797,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219705466",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Should this be closed now that https://github.com/bitcoin/bitcoin/pull/14437 has been opened?",
      "created_at" : "2018-10-10T07:29:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-428467415",
      "id" : 428467415,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10973",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyODQ2NzQxNQ==",
      "updated_at" : "2018-10-10T07:30:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/428467415",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> Should this be closed now that #14437 has been opened?\r\n\r\nI updated the PR description above to make it obvious that review comments be added in #14437. I'd still like to keep updating this PR though. I think for example being able to see the complete [`Chain`](https://github.com/ryanofsky/bitcoin/blob/pr/wipc-sep/src/interfaces/chain.h) interface added here is useful for understanding the direction #14437 is starting to go in.",
      "created_at" : "2018-10-10T07:45:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-428471793",
      "id" : 428471793,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10973",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyODQ3MTc5Mw==",
      "updated_at" : "2018-10-10T07:45:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/428471793",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r224318014"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224318014"
         }
      },
      "author_association" : "MEMBER",
      "body" : "An implicit conversion from `unsigned int` to `int` takes place here. Return an unsigned integer instead?",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-10-11T05:24:57Z",
      "diff_hunk" : "@@ -0,0 +1,454 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <interfaces/chain.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <interfaces/handler.h>\n+#include <interfaces/wallet.h>\n+#include <net.h>\n+#include <policy/fees.h>\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <protocol.h>\n+#include <rpc/mining.h>\n+#include <rpc/protocol.h>\n+#include <rpc/server.h>\n+#include <sync.h>\n+#include <threadsafety.h>\n+#include <timedata.h>\n+#include <txmempool.h>\n+#include <ui_interface.h>\n+#include <uint256.h>\n+#include <univalue.h>\n+#include <util.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <tuple>\n+#include <unordered_map>\n+#include <utility>\n+\n+class CReserveScript;\n+\n+namespace interfaces {\n+namespace {\n+\n+//! Extension of std::reference_wrapper with operator< for use as map key.\n+template <typename T>\n+class Ref : public std::reference_wrapper<T>\n+{\n+public:\n+    using std::reference_wrapper<T>::reference_wrapper;\n+    bool operator<(const Ref<T>& other) const { return this->get() < other.get(); }\n+};\n+\n+class LockImpl : public Chain::Lock\n+{\n+    Optional<int> getHeight() override\n+    {\n+        int height = ::chainActive.Height();\n+        if (height >= 0) {\n+            return height;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> getBlockHeight(const uint256& hash) override\n+    {\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end() && it->second) {\n+            if (::chainActive.Contains(it->second)) {\n+                return it->second->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    int getBlockDepth(const uint256& hash) override\n+    {\n+        const Optional<int> tip_height = getHeight();\n+        const Optional<int> height = getBlockHeight(hash);\n+        return tip_height && height ? *tip_height - *height + 1 : 0;\n+    }\n+    uint256 getBlockHash(int height) override { return ::chainActive[height]->GetBlockHash(); }\n+    int64_t getBlockTime(int height) override { return ::chainActive[height]->GetBlockTime(); }\n+    int64_t getBlockMedianTimePast(int height) override { return ::chainActive[height]->GetMedianTimePast(); }\n+    bool haveBlockOnDisk(int height) override\n+    {\n+        CBlockIndex* block = ::chainActive[height];\n+        return block && ((block->nStatus & BLOCK_HAVE_DATA) != 0) && block->nTx > 0;\n+    }\n+    Optional<int> findFirstBlockWithTime(int64_t time) override\n+    {\n+        CBlockIndex* block = ::chainActive.FindEarliestAtLeast(time);\n+        if (block) {\n+            return block->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFirstBlockWithTimeAndHeight(int64_t time, int height) override\n+    {\n+        for (CBlockIndex* block = ::chainActive[height]; block; block = ::chainActive.Next(block)) {\n+            if (block->GetBlockTime() >= time) {\n+                return block->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findPruned(int start_height, Optional<int> stop_height) override\n+    {\n+        if (::fPruneMode) {\n+            CBlockIndex* block = stop_height ? ::chainActive[*stop_height] : ::chainActive.Tip();\n+            while (block && block->nHeight >= start_height) {\n+                if ((block->nStatus & BLOCK_HAVE_DATA) == 0) {\n+                    return block->nHeight;\n+                }\n+                block = block->pprev;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFork(const uint256& hash, Optional<int>* height) override\n+    {\n+        const CBlockIndex *block{nullptr}, *fork{nullptr};\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end()) {\n+            block = it->second;\n+            fork = ::chainActive.FindFork(block);\n+        }\n+        if (height != nullptr) {\n+            if (block) {\n+                *height = block->nHeight;\n+            } else {\n+                height->reset();\n+            }\n+        }\n+        if (fork) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool isPotentialTip(const uint256& hash) override\n+    {\n+        if (::chainActive.Tip()->GetBlockHash() == hash) return true;\n+        auto it = ::mapBlockIndex.find(hash);\n+        return it != ::mapBlockIndex.end() && it->second->GetAncestor(::chainActive.Height()) == ::chainActive.Tip();\n+    }\n+    CBlockLocator getLocator() override { return ::chainActive.GetLocator(); }\n+    Optional<int> findLocatorFork(const CBlockLocator& locator) override\n+    {\n+        if (CBlockIndex* fork = FindForkInGlobalIndex(::chainActive, locator)) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool checkFinalTx(const CTransaction& tx) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return CheckFinalTx(tx);\n+    }\n+    bool acceptToMemoryPool(CTransactionRef tx, CValidationState& state) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return AcceptToMemoryPool(::mempool, state, tx, nullptr /* missing inputs */, nullptr /* txn replaced */,\n+            false /* bypass limits */, ::maxTxFee /* absurd fee */);\n+    }\n+};\n+\n+class LockingStateImpl : public LockImpl, public UniqueLock<CCriticalSection>\n+{\n+    using UniqueLock::UniqueLock;\n+};\n+\n+class HandlerImpl : public Handler\n+{\n+public:\n+    explicit HandlerImpl(Chain::Notifications& notifications) : m_forwarder(notifications) {}\n+    ~HandlerImpl() override\n+    {\n+        // It is important to disconnect here in the HandlerImpl destructor,\n+        // instead of in the HandleImpl::Forwarder destructor, because\n+        // UnregisterAllValidationInterfaces() internally accesses Forwarder\n+        // virtual methods which are no longer available after Forwarder object\n+        // has begun to be being destroyed.\n+        m_forwarder.disconnect();\n+    }\n+    void disconnect() override { m_forwarder.disconnect(); }\n+\n+    struct Forwarder : CValidationInterface\n+    {\n+        explicit Forwarder(Chain::Notifications& notifications) : m_notifications(&notifications)\n+        {\n+            RegisterValidationInterface(this);\n+        }\n+        void disconnect()\n+        {\n+            if (m_notifications) {\n+                m_notifications = nullptr;\n+                UnregisterValidationInterface(this);\n+            }\n+        }\n+        void TransactionAddedToMempool(const CTransactionRef& tx) override\n+        {\n+            m_notifications->TransactionAddedToMempool(tx);\n+        }\n+        void TransactionRemovedFromMempool(const CTransactionRef& tx) override\n+        {\n+            m_notifications->TransactionRemovedFromMempool(tx);\n+        }\n+        void BlockConnected(const std::shared_ptr<const CBlock>& block,\n+            const CBlockIndex* index,\n+            const std::vector<CTransactionRef>& tx_conflicted) override\n+        {\n+            m_notifications->BlockConnected(*block, index->GetBlockHash(), tx_conflicted);\n+        }\n+        void BlockDisconnected(const std::shared_ptr<const CBlock>& block) override\n+        {\n+            m_notifications->BlockDisconnected(*block);\n+        }\n+        void ChainStateFlushed(const CBlockLocator& locator) override { m_notifications->ChainStateFlushed(locator); }\n+        void ResendWalletTransactions(int64_t best_block_time, CConnman*) override\n+        {\n+            m_notifications->ResendWalletTransactions(best_block_time);\n+        }\n+\n+        Chain::Notifications* m_notifications;\n+    };\n+\n+    Forwarder m_forwarder;\n+};\n+\n+class ChainImpl : public Chain\n+{\n+public:\n+    std::unique_ptr<Chain::Lock> lock(bool try_lock) override\n+    {\n+        auto result = MakeUnique<LockingStateImpl>(::cs_main, \"cs_main\", __FILE__, __LINE__, try_lock);\n+        if (try_lock && result && !*result) return {};\n+        // std::move necessary on some compilers due to conversion from\n+        // LockingStateImpl to Lock pointer\n+        return std::move(result);\n+    }\n+    std::unique_ptr<Chain::Lock> assumeLocked() override { return MakeUnique<LockImpl>(); }\n+    bool findBlock(const uint256& hash, CBlock* block, int64_t* time, int64_t* time_max) override\n+    {\n+        CBlockIndex* index;\n+        {\n+            LOCK(cs_main);\n+            auto it = ::mapBlockIndex.find(hash);\n+            if (it == ::mapBlockIndex.end()) {\n+                return false;\n+            }\n+            index = it->second;\n+            if (time) {\n+                *time = index->GetBlockTime();\n+            }\n+            if (time_max) {\n+                *time_max = index->GetBlockTimeMax();\n+            }\n+        }\n+        if (block && !ReadBlockFromDisk(*block, index, Params().GetConsensus())) {\n+            block->SetNull();\n+        }\n+        return true;\n+    }\n+    std::vector<Coin> findCoins(const std::vector<COutPoint>& outputs) override\n+    {\n+        std::vector<Coin> coins;\n+        LOCK2(cs_main, ::mempool.cs);\n+        assert(pcoinsTip);\n+        CCoinsViewCache& chain_view = *::pcoinsTip;\n+        CCoinsViewMemPool mempool_view(&chain_view, ::mempool);\n+        for (const auto& output : outputs) {\n+            Coin coin;\n+            mempool_view.GetCoin(output, coin);\n+            coins.emplace_back(std::move(coin));\n+        }\n+        return coins;\n+    }\n+    double guessVerificationProgress(const uint256& block_hash) override\n+    {\n+        LOCK(cs_main);\n+        auto it = ::mapBlockIndex.find(block_hash);\n+        return GuessVerificationProgress(Params().TxData(), it != ::mapBlockIndex.end() ? it->second : nullptr);\n+    }\n+    int64_t getVirtualTransactionSize(const CTransaction& tx) override { return GetVirtualTransactionSize(tx); }\n+    RBFTransactionState isRBFOptIn(const CTransaction& tx) override\n+    {\n+        LOCK(::mempool.cs);\n+        return IsRBFOptIn(tx, ::mempool);\n+    }\n+    bool hasDescendantsInMempool(const uint256& txid) override\n+    {\n+        LOCK(::mempool.cs);\n+        auto it_mp = ::mempool.mapTx.find(txid);\n+        return it_mp != ::mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1;\n+    }\n+    bool relayTransaction(const uint256& txid) override\n+    {\n+        if (g_connman) {\n+            CInv inv(MSG_TX, txid);\n+            g_connman->ForEachNode([&inv](CNode* node) { node->PushInventory(inv); });\n+            return true;\n+        }\n+        return false;\n+    }\n+    void getTransactionAncestry(const uint256& txid, size_t& ancestors, size_t& descendants) override\n+    {\n+        ::mempool.GetTransactionAncestry(txid, ancestors, descendants);\n+    }\n+    bool checkChainLimits(CTransactionRef tx) override\n+    {\n+        LockPoints lp;\n+        CTxMemPoolEntry entry(tx, 0, 0, 0, false, 0, lp);\n+        CTxMemPool::setEntries setAncestors;\n+        size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n+        size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT) * 1000;\n+        size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n+        size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT) * 1000;\n+        std::string errString;\n+        LOCK(::mempool.cs);\n+        return ::mempool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize,\n+            nLimitDescendants, nLimitDescendantSize, errString);\n+    }\n+    CFeeRate estimateSmartFee(int num_blocks, bool conservative, FeeCalculation* calc) override\n+    {\n+        return ::feeEstimator.estimateSmartFee(num_blocks, calc, conservative);\n+    }\n+    int estimateMaxBlocks() override { return ::feeEstimator.HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE); }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r224318014",
      "id" : 224318014,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNDMxODAxNA==",
      "original_commit_id" : "45b23efaada081a7be9e255df59670f4704c45d1",
      "original_position" : 324,
      "path" : "src/interfaces/chain.cpp",
      "position" : null,
      "pull_request_review_id" : 163653229,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224318014",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r224318332"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224318332"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: Remove `;` :-)",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-10-11T05:27:31Z",
      "diff_hunk" : "@@ -0,0 +1,454 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <interfaces/chain.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <interfaces/handler.h>\n+#include <interfaces/wallet.h>\n+#include <net.h>\n+#include <policy/fees.h>\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <protocol.h>\n+#include <rpc/mining.h>\n+#include <rpc/protocol.h>\n+#include <rpc/server.h>\n+#include <sync.h>\n+#include <threadsafety.h>\n+#include <timedata.h>\n+#include <txmempool.h>\n+#include <ui_interface.h>\n+#include <uint256.h>\n+#include <univalue.h>\n+#include <util.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <tuple>\n+#include <unordered_map>\n+#include <utility>\n+\n+class CReserveScript;\n+\n+namespace interfaces {\n+namespace {\n+\n+//! Extension of std::reference_wrapper with operator< for use as map key.\n+template <typename T>\n+class Ref : public std::reference_wrapper<T>\n+{\n+public:\n+    using std::reference_wrapper<T>::reference_wrapper;\n+    bool operator<(const Ref<T>& other) const { return this->get() < other.get(); }\n+};\n+\n+class LockImpl : public Chain::Lock\n+{\n+    Optional<int> getHeight() override\n+    {\n+        int height = ::chainActive.Height();\n+        if (height >= 0) {\n+            return height;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> getBlockHeight(const uint256& hash) override\n+    {\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end() && it->second) {\n+            if (::chainActive.Contains(it->second)) {\n+                return it->second->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    int getBlockDepth(const uint256& hash) override\n+    {\n+        const Optional<int> tip_height = getHeight();\n+        const Optional<int> height = getBlockHeight(hash);\n+        return tip_height && height ? *tip_height - *height + 1 : 0;\n+    }\n+    uint256 getBlockHash(int height) override { return ::chainActive[height]->GetBlockHash(); }\n+    int64_t getBlockTime(int height) override { return ::chainActive[height]->GetBlockTime(); }\n+    int64_t getBlockMedianTimePast(int height) override { return ::chainActive[height]->GetMedianTimePast(); }\n+    bool haveBlockOnDisk(int height) override\n+    {\n+        CBlockIndex* block = ::chainActive[height];\n+        return block && ((block->nStatus & BLOCK_HAVE_DATA) != 0) && block->nTx > 0;\n+    }\n+    Optional<int> findFirstBlockWithTime(int64_t time) override\n+    {\n+        CBlockIndex* block = ::chainActive.FindEarliestAtLeast(time);\n+        if (block) {\n+            return block->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFirstBlockWithTimeAndHeight(int64_t time, int height) override\n+    {\n+        for (CBlockIndex* block = ::chainActive[height]; block; block = ::chainActive.Next(block)) {\n+            if (block->GetBlockTime() >= time) {\n+                return block->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findPruned(int start_height, Optional<int> stop_height) override\n+    {\n+        if (::fPruneMode) {\n+            CBlockIndex* block = stop_height ? ::chainActive[*stop_height] : ::chainActive.Tip();\n+            while (block && block->nHeight >= start_height) {\n+                if ((block->nStatus & BLOCK_HAVE_DATA) == 0) {\n+                    return block->nHeight;\n+                }\n+                block = block->pprev;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFork(const uint256& hash, Optional<int>* height) override\n+    {\n+        const CBlockIndex *block{nullptr}, *fork{nullptr};\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end()) {\n+            block = it->second;\n+            fork = ::chainActive.FindFork(block);\n+        }\n+        if (height != nullptr) {\n+            if (block) {\n+                *height = block->nHeight;\n+            } else {\n+                height->reset();\n+            }\n+        }\n+        if (fork) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool isPotentialTip(const uint256& hash) override\n+    {\n+        if (::chainActive.Tip()->GetBlockHash() == hash) return true;\n+        auto it = ::mapBlockIndex.find(hash);\n+        return it != ::mapBlockIndex.end() && it->second->GetAncestor(::chainActive.Height()) == ::chainActive.Tip();\n+    }\n+    CBlockLocator getLocator() override { return ::chainActive.GetLocator(); }\n+    Optional<int> findLocatorFork(const CBlockLocator& locator) override\n+    {\n+        if (CBlockIndex* fork = FindForkInGlobalIndex(::chainActive, locator)) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool checkFinalTx(const CTransaction& tx) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return CheckFinalTx(tx);\n+    }\n+    bool acceptToMemoryPool(CTransactionRef tx, CValidationState& state) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return AcceptToMemoryPool(::mempool, state, tx, nullptr /* missing inputs */, nullptr /* txn replaced */,\n+            false /* bypass limits */, ::maxTxFee /* absurd fee */);\n+    }\n+};\n+\n+class LockingStateImpl : public LockImpl, public UniqueLock<CCriticalSection>\n+{\n+    using UniqueLock::UniqueLock;\n+};\n+\n+class HandlerImpl : public Handler\n+{\n+public:\n+    explicit HandlerImpl(Chain::Notifications& notifications) : m_forwarder(notifications) {}\n+    ~HandlerImpl() override\n+    {\n+        // It is important to disconnect here in the HandlerImpl destructor,\n+        // instead of in the HandleImpl::Forwarder destructor, because\n+        // UnregisterAllValidationInterfaces() internally accesses Forwarder\n+        // virtual methods which are no longer available after Forwarder object\n+        // has begun to be being destroyed.\n+        m_forwarder.disconnect();\n+    }\n+    void disconnect() override { m_forwarder.disconnect(); }\n+\n+    struct Forwarder : CValidationInterface\n+    {\n+        explicit Forwarder(Chain::Notifications& notifications) : m_notifications(&notifications)\n+        {\n+            RegisterValidationInterface(this);\n+        }\n+        void disconnect()\n+        {\n+            if (m_notifications) {\n+                m_notifications = nullptr;\n+                UnregisterValidationInterface(this);\n+            }\n+        }\n+        void TransactionAddedToMempool(const CTransactionRef& tx) override\n+        {\n+            m_notifications->TransactionAddedToMempool(tx);\n+        }\n+        void TransactionRemovedFromMempool(const CTransactionRef& tx) override\n+        {\n+            m_notifications->TransactionRemovedFromMempool(tx);\n+        }\n+        void BlockConnected(const std::shared_ptr<const CBlock>& block,\n+            const CBlockIndex* index,\n+            const std::vector<CTransactionRef>& tx_conflicted) override\n+        {\n+            m_notifications->BlockConnected(*block, index->GetBlockHash(), tx_conflicted);\n+        }\n+        void BlockDisconnected(const std::shared_ptr<const CBlock>& block) override\n+        {\n+            m_notifications->BlockDisconnected(*block);\n+        }\n+        void ChainStateFlushed(const CBlockLocator& locator) override { m_notifications->ChainStateFlushed(locator); }\n+        void ResendWalletTransactions(int64_t best_block_time, CConnman*) override\n+        {\n+            m_notifications->ResendWalletTransactions(best_block_time);\n+        }\n+\n+        Chain::Notifications* m_notifications;\n+    };\n+\n+    Forwarder m_forwarder;\n+};\n+\n+class ChainImpl : public Chain\n+{\n+public:\n+    std::unique_ptr<Chain::Lock> lock(bool try_lock) override\n+    {\n+        auto result = MakeUnique<LockingStateImpl>(::cs_main, \"cs_main\", __FILE__, __LINE__, try_lock);\n+        if (try_lock && result && !*result) return {};\n+        // std::move necessary on some compilers due to conversion from\n+        // LockingStateImpl to Lock pointer\n+        return std::move(result);\n+    }\n+    std::unique_ptr<Chain::Lock> assumeLocked() override { return MakeUnique<LockImpl>(); }\n+    bool findBlock(const uint256& hash, CBlock* block, int64_t* time, int64_t* time_max) override\n+    {\n+        CBlockIndex* index;\n+        {\n+            LOCK(cs_main);\n+            auto it = ::mapBlockIndex.find(hash);\n+            if (it == ::mapBlockIndex.end()) {\n+                return false;\n+            }\n+            index = it->second;\n+            if (time) {\n+                *time = index->GetBlockTime();\n+            }\n+            if (time_max) {\n+                *time_max = index->GetBlockTimeMax();\n+            }\n+        }\n+        if (block && !ReadBlockFromDisk(*block, index, Params().GetConsensus())) {\n+            block->SetNull();\n+        }\n+        return true;\n+    }\n+    std::vector<Coin> findCoins(const std::vector<COutPoint>& outputs) override\n+    {\n+        std::vector<Coin> coins;\n+        LOCK2(cs_main, ::mempool.cs);\n+        assert(pcoinsTip);\n+        CCoinsViewCache& chain_view = *::pcoinsTip;\n+        CCoinsViewMemPool mempool_view(&chain_view, ::mempool);\n+        for (const auto& output : outputs) {\n+            Coin coin;\n+            mempool_view.GetCoin(output, coin);\n+            coins.emplace_back(std::move(coin));\n+        }\n+        return coins;\n+    }\n+    double guessVerificationProgress(const uint256& block_hash) override\n+    {\n+        LOCK(cs_main);\n+        auto it = ::mapBlockIndex.find(block_hash);\n+        return GuessVerificationProgress(Params().TxData(), it != ::mapBlockIndex.end() ? it->second : nullptr);\n+    }\n+    int64_t getVirtualTransactionSize(const CTransaction& tx) override { return GetVirtualTransactionSize(tx); }\n+    RBFTransactionState isRBFOptIn(const CTransaction& tx) override\n+    {\n+        LOCK(::mempool.cs);\n+        return IsRBFOptIn(tx, ::mempool);\n+    }\n+    bool hasDescendantsInMempool(const uint256& txid) override\n+    {\n+        LOCK(::mempool.cs);\n+        auto it_mp = ::mempool.mapTx.find(txid);\n+        return it_mp != ::mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1;\n+    }\n+    bool relayTransaction(const uint256& txid) override\n+    {\n+        if (g_connman) {\n+            CInv inv(MSG_TX, txid);\n+            g_connman->ForEachNode([&inv](CNode* node) { node->PushInventory(inv); });\n+            return true;\n+        }\n+        return false;\n+    }\n+    void getTransactionAncestry(const uint256& txid, size_t& ancestors, size_t& descendants) override\n+    {\n+        ::mempool.GetTransactionAncestry(txid, ancestors, descendants);\n+    }\n+    bool checkChainLimits(CTransactionRef tx) override\n+    {\n+        LockPoints lp;\n+        CTxMemPoolEntry entry(tx, 0, 0, 0, false, 0, lp);\n+        CTxMemPool::setEntries setAncestors;\n+        size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n+        size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT) * 1000;\n+        size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n+        size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT) * 1000;\n+        std::string errString;\n+        LOCK(::mempool.cs);\n+        return ::mempool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize,\n+            nLimitDescendants, nLimitDescendantSize, errString);\n+    }\n+    CFeeRate estimateSmartFee(int num_blocks, bool conservative, FeeCalculation* calc) override\n+    {\n+        return ::feeEstimator.estimateSmartFee(num_blocks, calc, conservative);\n+    }\n+    int estimateMaxBlocks() override { return ::feeEstimator.HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE); }\n+    CFeeRate poolMinFee() override\n+    {\n+        return ::mempool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    }\n+    bool getPruneMode() override { return ::fPruneMode; }\n+    bool p2pEnabled() override { return g_connman != nullptr; }\n+    bool isInitialBlockDownload() override { return IsInitialBlockDownload(); }\n+    int64_t getAdjustedTime() override { return GetAdjustedTime(); }\n+    void initMessage(const std::string& message) override { ::uiInterface.InitMessage(message); }\n+    void initWarning(const std::string& message) override { InitWarning(message); }\n+    void initError(const std::string& message) override { InitError(message); }\n+    void loadWallet(std::unique_ptr<Wallet> wallet) override { ::uiInterface.LoadWallet(wallet); }\n+    UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbase_script,\n+        int num_blocks,\n+        uint64_t max_tries,\n+        bool keep_script) override\n+    {\n+        return ::generateBlocks(coinbase_script, num_blocks, max_tries, keep_script);\n+    }\n+    unsigned int parseConfirmTarget(const UniValue& value) override { return ParseConfirmTarget(value); }\n+    std::unique_ptr<Handler> handleNotifications(Notifications& notifications) override\n+    {\n+        return MakeUnique<HandlerImpl>(notifications);\n+    }\n+    void waitForNotifications() override { SyncWithValidationInterfaceQueue(); }\n+    std::unique_ptr<Handler> handleRpc(const CRPCCommand& command) override;\n+\n+    //! Map of RPC method name to forwarder. If multiple clients provide\n+    //! implementations of the same RPC method, the RPC forwarder can dispatch\n+    //! between them.\n+    class RpcForwarder;\n+    std::map<Ref<const std::string>, RpcForwarder> m_rpc_forwarders;\n+};\n+\n+//! Forwarder for one RPC method.\n+class ChainImpl::RpcForwarder\n+{\n+public:\n+    explicit RpcForwarder(const CRPCCommand& command) : m_command(command)\n+    {\n+        m_command.actor = [this](const JSONRPCRequest& request) { return forwardRequest(request); };\n+    }\n+\n+    bool registerForwarder() { return ::tableRPC.appendCommand(m_command.name, &m_command); }\n+\n+    void addCommand(const CRPCCommand& command) { m_commands.emplace_back(&command); }\n+\n+    void removeCommand(const CRPCCommand& command)\n+    {\n+        m_commands.erase(std::remove(m_commands.begin(), m_commands.end(), &command), m_commands.end());\n+    }\n+\n+    UniValue forwardRequest(const JSONRPCRequest& request) const\n+    {\n+        // Simple forwarding of RPC requests. This just sends the request to the\n+        // first client that registered a handler for the RPC method. If the\n+        // handler throws a wallet not found exception, this will retry\n+        // forwarding to the next handler (if any).\n+        //\n+        // This forwarding mechanism could be made more efficient (peeking\n+        // inside the RPC request for wallet name and sending it directly to the\n+        // right handler), but right now all wallets are in-process so there is\n+        // only ever a single handler, and in the future it isn't clear if we\n+        // will want we want to keep forwarding RPCs at all (clients could just\n+        // listen for their own RPCs).\n+        for (auto it = m_commands.begin(); it != m_commands.end();) {\n+            const CRPCCommand& command = **it++;\n+            try {\n+                return command.actor(request);\n+            } catch (const UniValue& e) {\n+                if (it != m_commands.end()) {\n+                    const UniValue& code = e[\"code\"];\n+                    if (code.isNum() && code.get_int() == RPC_WALLET_NOT_FOUND) {\n+                        continue;\n+                    }\n+                }\n+                throw;\n+            }\n+        }\n+\n+        // This will only be reached if m_commands is empty. (Because the RPC\n+        // server provides an appendCommand, but no removeCommand method, it\n+        // will keep sending requests here even if there are no clients left to\n+        // forward to.)\n+        throw JSONRPCError(RPC_METHOD_NOT_FOUND, \"Method not found\");\n+    };",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r224318332",
      "id" : 224318332,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNDMxODMzMg==",
      "original_commit_id" : "45b23efaada081a7be9e255df59670f4704c45d1",
      "original_position" : 410,
      "path" : "src/interfaces/chain.cpp",
      "position" : null,
      "pull_request_review_id" : 163653596,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224318332",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r224318496"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224318496"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be marked `override`?",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-10-11T05:28:52Z",
      "diff_hunk" : "@@ -754,22 +757,44 @@ static UniValue combinerawtransaction(const JSONRPCRequest& request)\n     return EncodeHexTx(mergedTx);\n }\n \n-UniValue SignTransaction(CMutableTransaction& mtx, const UniValue& prevTxsUnival, CBasicKeyStore *keystore, bool is_temp_keystore, const UniValue& hashType)\n+// Wrapper to help add a single coin to CCoinsViewCache.\n+class CoinFill : private CCoinsView\n+{\n+public:\n+    CoinFill(CCoinsViewCache& cache, const COutPoint &output, Coin&& coin, CCoinsView &backend) : m_cache(cache), m_output(output), m_coin(std::move(coin)), m_backend(backend) {\n+        m_cache.SetBackend(*this);\n+        m_cache.AccessCoin(output);\n+    }\n+    ~CoinFill() {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r224318496",
      "id" : 224318496,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNDMxODQ5Ng==",
      "original_commit_id" : "45b23efaada081a7be9e255df59670f4704c45d1",
      "original_position" : 30,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 163653786,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224318496",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@practicalswift - see note in PR description:\r\n\r\n> This PR is based on #14437, so review comments for initial commits should be posted there.\r\n\r\nI recommend you don't spend time reviewing this until #14437 is merged.",
      "created_at" : "2018-10-11T05:42:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-428827811",
      "id" : 428827811,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10973",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyODgyNzgxMQ==",
      "updated_at" : "2018-10-11T05:42:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/428827811",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@jnewbery Oh, thanks!",
      "created_at" : "2018-10-11T07:22:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#issuecomment-428848760",
      "id" : 428848760,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10973",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyODg0ODc2MA==",
      "updated_at" : "2018-10-11T07:22:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/428848760",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r225142332"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225142332"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Make this and the conversions on the lines below explicit?",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-10-15T12:16:14Z",
      "diff_hunk" : "@@ -0,0 +1,454 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <interfaces/chain.h>\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <interfaces/handler.h>\n+#include <interfaces/wallet.h>\n+#include <net.h>\n+#include <policy/fees.h>\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <protocol.h>\n+#include <rpc/mining.h>\n+#include <rpc/protocol.h>\n+#include <rpc/server.h>\n+#include <sync.h>\n+#include <threadsafety.h>\n+#include <timedata.h>\n+#include <txmempool.h>\n+#include <ui_interface.h>\n+#include <uint256.h>\n+#include <univalue.h>\n+#include <util.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <tuple>\n+#include <unordered_map>\n+#include <utility>\n+\n+class CReserveScript;\n+\n+namespace interfaces {\n+namespace {\n+\n+//! Extension of std::reference_wrapper with operator< for use as map key.\n+template <typename T>\n+class Ref : public std::reference_wrapper<T>\n+{\n+public:\n+    using std::reference_wrapper<T>::reference_wrapper;\n+    bool operator<(const Ref<T>& other) const { return this->get() < other.get(); }\n+};\n+\n+class LockImpl : public Chain::Lock\n+{\n+    Optional<int> getHeight() override\n+    {\n+        int height = ::chainActive.Height();\n+        if (height >= 0) {\n+            return height;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> getBlockHeight(const uint256& hash) override\n+    {\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end() && it->second) {\n+            if (::chainActive.Contains(it->second)) {\n+                return it->second->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    int getBlockDepth(const uint256& hash) override\n+    {\n+        const Optional<int> tip_height = getHeight();\n+        const Optional<int> height = getBlockHeight(hash);\n+        return tip_height && height ? *tip_height - *height + 1 : 0;\n+    }\n+    uint256 getBlockHash(int height) override { return ::chainActive[height]->GetBlockHash(); }\n+    int64_t getBlockTime(int height) override { return ::chainActive[height]->GetBlockTime(); }\n+    int64_t getBlockMedianTimePast(int height) override { return ::chainActive[height]->GetMedianTimePast(); }\n+    bool haveBlockOnDisk(int height) override\n+    {\n+        CBlockIndex* block = ::chainActive[height];\n+        return block && ((block->nStatus & BLOCK_HAVE_DATA) != 0) && block->nTx > 0;\n+    }\n+    Optional<int> findFirstBlockWithTime(int64_t time) override\n+    {\n+        CBlockIndex* block = ::chainActive.FindEarliestAtLeast(time);\n+        if (block) {\n+            return block->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFirstBlockWithTimeAndHeight(int64_t time, int height) override\n+    {\n+        for (CBlockIndex* block = ::chainActive[height]; block; block = ::chainActive.Next(block)) {\n+            if (block->GetBlockTime() >= time) {\n+                return block->nHeight;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findPruned(int start_height, Optional<int> stop_height) override\n+    {\n+        if (::fPruneMode) {\n+            CBlockIndex* block = stop_height ? ::chainActive[*stop_height] : ::chainActive.Tip();\n+            while (block && block->nHeight >= start_height) {\n+                if ((block->nStatus & BLOCK_HAVE_DATA) == 0) {\n+                    return block->nHeight;\n+                }\n+                block = block->pprev;\n+            }\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> findFork(const uint256& hash, Optional<int>* height) override\n+    {\n+        const CBlockIndex *block{nullptr}, *fork{nullptr};\n+        auto it = ::mapBlockIndex.find(hash);\n+        if (it != ::mapBlockIndex.end()) {\n+            block = it->second;\n+            fork = ::chainActive.FindFork(block);\n+        }\n+        if (height != nullptr) {\n+            if (block) {\n+                *height = block->nHeight;\n+            } else {\n+                height->reset();\n+            }\n+        }\n+        if (fork) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool isPotentialTip(const uint256& hash) override\n+    {\n+        if (::chainActive.Tip()->GetBlockHash() == hash) return true;\n+        auto it = ::mapBlockIndex.find(hash);\n+        return it != ::mapBlockIndex.end() && it->second->GetAncestor(::chainActive.Height()) == ::chainActive.Tip();\n+    }\n+    CBlockLocator getLocator() override { return ::chainActive.GetLocator(); }\n+    Optional<int> findLocatorFork(const CBlockLocator& locator) override\n+    {\n+        if (CBlockIndex* fork = FindForkInGlobalIndex(::chainActive, locator)) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool checkFinalTx(const CTransaction& tx) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return CheckFinalTx(tx);\n+    }\n+    bool acceptToMemoryPool(CTransactionRef tx, CValidationState& state) override\n+    {\n+        LockAnnotation lock(::cs_main);\n+        return AcceptToMemoryPool(::mempool, state, tx, nullptr /* missing inputs */, nullptr /* txn replaced */,\n+            false /* bypass limits */, ::maxTxFee /* absurd fee */);\n+    }\n+};\n+\n+class LockingStateImpl : public LockImpl, public UniqueLock<CCriticalSection>\n+{\n+    using UniqueLock::UniqueLock;\n+};\n+\n+class HandlerImpl : public Handler\n+{\n+public:\n+    explicit HandlerImpl(Chain::Notifications& notifications) : m_forwarder(notifications) {}\n+    ~HandlerImpl() override\n+    {\n+        // It is important to disconnect here in the HandlerImpl destructor,\n+        // instead of in the HandleImpl::Forwarder destructor, because\n+        // UnregisterAllValidationInterfaces() internally accesses Forwarder\n+        // virtual methods which are no longer available after Forwarder object\n+        // has begun to be being destroyed.\n+        m_forwarder.disconnect();\n+    }\n+    void disconnect() override { m_forwarder.disconnect(); }\n+\n+    struct Forwarder : CValidationInterface\n+    {\n+        explicit Forwarder(Chain::Notifications& notifications) : m_notifications(&notifications)\n+        {\n+            RegisterValidationInterface(this);\n+        }\n+        void disconnect()\n+        {\n+            if (m_notifications) {\n+                m_notifications = nullptr;\n+                UnregisterValidationInterface(this);\n+            }\n+        }\n+        void TransactionAddedToMempool(const CTransactionRef& tx) override\n+        {\n+            m_notifications->TransactionAddedToMempool(tx);\n+        }\n+        void TransactionRemovedFromMempool(const CTransactionRef& tx) override\n+        {\n+            m_notifications->TransactionRemovedFromMempool(tx);\n+        }\n+        void BlockConnected(const std::shared_ptr<const CBlock>& block,\n+            const CBlockIndex* index,\n+            const std::vector<CTransactionRef>& tx_conflicted) override\n+        {\n+            m_notifications->BlockConnected(*block, index->GetBlockHash(), tx_conflicted);\n+        }\n+        void BlockDisconnected(const std::shared_ptr<const CBlock>& block) override\n+        {\n+            m_notifications->BlockDisconnected(*block);\n+        }\n+        void ChainStateFlushed(const CBlockLocator& locator) override { m_notifications->ChainStateFlushed(locator); }\n+        void ResendWalletTransactions(int64_t best_block_time, CConnman*) override\n+        {\n+            m_notifications->ResendWalletTransactions(best_block_time);\n+        }\n+\n+        Chain::Notifications* m_notifications;\n+    };\n+\n+    Forwarder m_forwarder;\n+};\n+\n+class ChainImpl : public Chain\n+{\n+public:\n+    std::unique_ptr<Chain::Lock> lock(bool try_lock) override\n+    {\n+        auto result = MakeUnique<LockingStateImpl>(::cs_main, \"cs_main\", __FILE__, __LINE__, try_lock);\n+        if (try_lock && result && !*result) return {};\n+        // std::move necessary on some compilers due to conversion from\n+        // LockingStateImpl to Lock pointer\n+        return std::move(result);\n+    }\n+    std::unique_ptr<Chain::Lock> assumeLocked() override { return MakeUnique<LockImpl>(); }\n+    bool findBlock(const uint256& hash, CBlock* block, int64_t* time, int64_t* time_max) override\n+    {\n+        CBlockIndex* index;\n+        {\n+            LOCK(cs_main);\n+            auto it = ::mapBlockIndex.find(hash);\n+            if (it == ::mapBlockIndex.end()) {\n+                return false;\n+            }\n+            index = it->second;\n+            if (time) {\n+                *time = index->GetBlockTime();\n+            }\n+            if (time_max) {\n+                *time_max = index->GetBlockTimeMax();\n+            }\n+        }\n+        if (block && !ReadBlockFromDisk(*block, index, Params().GetConsensus())) {\n+            block->SetNull();\n+        }\n+        return true;\n+    }\n+    std::vector<Coin> findCoins(const std::vector<COutPoint>& outputs) override\n+    {\n+        std::vector<Coin> coins;\n+        LOCK2(cs_main, ::mempool.cs);\n+        assert(pcoinsTip);\n+        CCoinsViewCache& chain_view = *::pcoinsTip;\n+        CCoinsViewMemPool mempool_view(&chain_view, ::mempool);\n+        for (const auto& output : outputs) {\n+            Coin coin;\n+            mempool_view.GetCoin(output, coin);\n+            coins.emplace_back(std::move(coin));\n+        }\n+        return coins;\n+    }\n+    double guessVerificationProgress(const uint256& block_hash) override\n+    {\n+        LOCK(cs_main);\n+        auto it = ::mapBlockIndex.find(block_hash);\n+        return GuessVerificationProgress(Params().TxData(), it != ::mapBlockIndex.end() ? it->second : nullptr);\n+    }\n+    int64_t getVirtualTransactionSize(const CTransaction& tx) override { return GetVirtualTransactionSize(tx); }\n+    RBFTransactionState isRBFOptIn(const CTransaction& tx) override\n+    {\n+        LOCK(::mempool.cs);\n+        return IsRBFOptIn(tx, ::mempool);\n+    }\n+    bool hasDescendantsInMempool(const uint256& txid) override\n+    {\n+        LOCK(::mempool.cs);\n+        auto it_mp = ::mempool.mapTx.find(txid);\n+        return it_mp != ::mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1;\n+    }\n+    bool relayTransaction(const uint256& txid) override\n+    {\n+        if (g_connman) {\n+            CInv inv(MSG_TX, txid);\n+            g_connman->ForEachNode([&inv](CNode* node) { node->PushInventory(inv); });\n+            return true;\n+        }\n+        return false;\n+    }\n+    void getTransactionAncestry(const uint256& txid, size_t& ancestors, size_t& descendants) override\n+    {\n+        ::mempool.GetTransactionAncestry(txid, ancestors, descendants);\n+    }\n+    bool checkChainLimits(CTransactionRef tx) override\n+    {\n+        LockPoints lp;\n+        CTxMemPoolEntry entry(tx, 0, 0, 0, false, 0, lp);\n+        CTxMemPool::setEntries setAncestors;\n+        size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r225142332",
      "id" : 225142332,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTE0MjMzMg==",
      "original_commit_id" : "45b23efaada081a7be9e255df59670f4704c45d1",
      "original_position" : 311,
      "path" : "src/interfaces/chain.cpp",
      "position" : null,
      "pull_request_review_id" : 164676052,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225142332",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r225142764"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225142764"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Implicit sign conversion here: see comment on `estimateMaxBlocks` above.",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-10-15T12:17:43Z",
      "diff_hunk" : "@@ -90,10 +89,10 @@ CFeeRate GetMinimumFeeRate(const CWallet& wallet, const CCoinControl& coin_contr\n     return feerate_needed;\n }\n \n-CFeeRate GetDiscardRate(const CWallet& wallet, const CBlockPolicyEstimator& estimator)\n+CFeeRate GetDiscardRate(const CWallet& wallet)\n {\n-    unsigned int highest_target = estimator.HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE);\n-    CFeeRate discard_rate = estimator.estimateSmartFee(highest_target, nullptr /* FeeCalculation */, false /* conservative */);\n+    unsigned int highest_target = wallet.chain().estimateMaxBlocks();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r225142764",
      "id" : 225142764,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTE0Mjc2NA==",
      "original_commit_id" : "45b23efaada081a7be9e255df59670f4704c45d1",
      "original_position" : 56,
      "path" : "src/wallet/fees.cpp",
      "position" : 56,
      "pull_request_review_id" : 164676589,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225142764",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r226438193"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/226438193"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/10973#discussion_r185934311\r\n\r\n> Seems like these instances of straight pass-through to some underlying function may be good cases for templated argument forwarding.\r\n\r\nI think fully specifying the interface in `chain.h` is nicer than having to look in different files to see names and types of the arguments. Writing the arguments explicitly also means internal functions can potentially change while the external interface remains stable. And C++ doesn't really support [virtual template functions](https://stackoverflow.com/questions/2354210/can-a-c-class-member-function-template-be-virtual]), so you'd have to rig something up with varargs and [`std::any`](https://en.cppreference.com/w/cpp/utility/any) to forward arguments without listing names or types. Also, many chain functions here are not just passing their arguments verbatim, so this forwarding couldn't be used in many cases.",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-10-18T19:36:06Z",
      "diff_hunk" : "@@ -296,6 +299,13 @@ class ChainImpl : public Chain\n     void initMessage(const std::string& message) override { ::uiInterface.InitMessage(message); }\n     void initWarning(const std::string& message) override { InitWarning(message); }\n     void initError(const std::string& message) override { InitError(message); }\n+    UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbase_script,\n+        int num_blocks,\n+        uint64_t max_tries,\n+        bool keep_script) override\n+    {\n+        return ::generateBlocks(coinbase_script, num_blocks, max_tries, keep_script);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r226438193",
      "id" : 226438193,
      "in_reply_to_id" : 185934311,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNjQzODE5Mw==",
      "original_commit_id" : "604c567e3c39099d2dd62ead72804d6a584cf34a",
      "original_position" : 26,
      "path" : "src/interfaces/chain.cpp",
      "position" : 341,
      "pull_request_review_id" : 166261224,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:04:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/226438193",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r229078622"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229078622"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/10973#discussion_r189395768\r\n\r\n> This feels like a weird method to put in the chain interface\r\n\r\nAgree, removed this method.",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-10-29T20:05:49Z",
      "diff_hunk" : "@@ -182,6 +182,9 @@ class Chain\n         uint64_t max_tries,\n         bool keep_script) = 0;\n \n+    //! Parse confirm target.\n+    virtual unsigned int parseConfirmTarget(const UniValue& value) = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r229078622",
      "id" : 229078622,
      "in_reply_to_id" : 189395768,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTA3ODYyMg==",
      "original_commit_id" : "a71c5b8e73d991f28945280c8812fa0c2898a710",
      "original_position" : 5,
      "path" : "src/interfaces/chain.h",
      "position" : null,
      "pull_request_review_id" : 166261224,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:04:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/229078622",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r230112626"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230112626"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/10973#discussion_r213473620\r\n\r\n> Probably out-of-scope nit: I wish the uint32_t max was instead a named constant\r\n\r\nAdded LOCKTIME_MAX constant here and in #14636.",
      "commit_id" : "1461fcacbc441f1abb782406bd6dcd48edf36aa6",
      "created_at" : "2018-11-01T16:47:16Z",
      "diff_hunk" : "@@ -2726,7 +2741,8 @@ bool CWallet::CreateTransaction(interfaces::Chain::Lock& locked_chain, const std\n     // enough, that fee sniping isn't a problem yet, but by implementing a fix\n     // now we ensure code won't be written that makes assumptions about\n     // nLockTime that preclude a fix later.\n-    txNew.nLockTime = chainActive.Height();\n+    const Optional<int> tip_height = locked_chain.getHeight();\n+    txNew.nLockTime = tip_height ? *tip_height : std::numeric_limits<uint32_t>::max();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10973#discussion_r230112626",
      "id" : 230112626,
      "in_reply_to_id" : 213473620,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDExMjYyNg==",
      "original_commit_id" : "2aa964dc531464c47c7236ec7b288e3b9c403a1e",
      "original_position" : 292,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 166261224,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10973",
      "updated_at" : "2018-11-01T21:27:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230112626",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   }
]
