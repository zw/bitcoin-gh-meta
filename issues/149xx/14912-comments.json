[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2018-12-10T14:59:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#issuecomment-445845036",
      "id" : 445845036,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14912",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0NTg0NTAzNg==",
      "updated_at" : "2018-12-10T14:59:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/445845036",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "> close HWI repo somewhere and launch bitcoind -signer=../HWI/hwi.py\r\n\r\nNit: you meant \"clone\", right?\r\n",
      "created_at" : "2018-12-10T16:33:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#issuecomment-445880496",
      "id" : 445880496,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14912",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0NTg4MDQ5Ng==",
      "updated_at" : "2018-12-10T16:33:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/445880496",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/1835345?v=4",
         "events_url" : "https://api.github.com/users/tsusanka/events{/privacy}",
         "followers_url" : "https://api.github.com/users/tsusanka/followers",
         "following_url" : "https://api.github.com/users/tsusanka/following{/other_user}",
         "gists_url" : "https://api.github.com/users/tsusanka/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/tsusanka",
         "id" : 1835345,
         "login" : "tsusanka",
         "node_id" : "MDQ6VXNlcjE4MzUzNDU=",
         "organizations_url" : "https://api.github.com/users/tsusanka/orgs",
         "received_events_url" : "https://api.github.com/users/tsusanka/received_events",
         "repos_url" : "https://api.github.com/users/tsusanka/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/tsusanka/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/tsusanka/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/tsusanka"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Now that #14491 has been rebased, the `hww` branch I'm building off should also soon be rebased. At that point I can rebase and make Travis happy. In addition, I'll be able to leverage #14646 to clean up my descriptor related code (I'm currently using string concatenation to build descriptors). I have a few other spring cleaning items on my todo list too.\r\n\r\nSee also the [wallet meeting notes](http://www.erisian.com.au/bitcoin-core-dev/log-2018-12-14.html#l-473).",
      "created_at" : "2018-12-15T11:22:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#issuecomment-447561259",
      "id" : 447561259,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14912",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0NzU2MTI1OQ==",
      "updated_at" : "2018-12-15T11:22:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/447561259",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#15911](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/15911.html) (Use wallet RBF default for walletcreatefundedpsbt by Sjors)\n* [#15741](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/15741.html) (Batch write imported stuff in importmulti by achow101)\n* [#15529](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/15529.html) (Add Qt programs to msvc build by sipsorcery)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2018-12-17T20:12:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#issuecomment-447982606",
      "id" : 447982606,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14912",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0Nzk4MjYwNg==",
      "updated_at" : "2019-05-13T19:28:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/447982606",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242604518"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242604518"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The documentation format is incorrect here :-)",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2018-12-18T16:19:33Z",
      "diff_hunk" : "@@ -24,6 +25,17 @@ void RegisterWalletRPCCommands(CRPCTable &t);\n  */\n std::shared_ptr<CWallet> GetWalletForJSONRPCRequest(const JSONRPCRequest& request);\n \n+/**\n+ * Figures out what external signer to use for a JSONRPCRequest.\n+ *\n+ * @param[in] request JSONRPCRequest that wishes to access a signer\n+ * @param[pos] which argument contains the signer fingerprint. Optional, returns the first signer otherwise\n+ * @param[pwallet] the wallet",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242604518",
      "id" : 242604518,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYwNDUxOA==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 17,
      "path" : "src/wallet/rpcwallet.h",
      "position" : null,
      "pull_request_review_id" : 186155471,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242604518",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242605089"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242605089"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`ExternalSigner signer` shadows `UniValue signer` :-)",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2018-12-18T16:20:53Z",
      "diff_hunk" : "@@ -0,0 +1,45 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <wallet/externalsigner.h>\n+#include <util/system.h>\n+\n+ExternalSigner::ExternalSigner(const std::string& command, const std::string& fingerprint, bool mainnet): m_command(command), m_fingerprint(fingerprint), m_mainnet(mainnet) {}\n+\n+UniValue ExternalSigner::Enumerate(const std::string& command, std::vector<ExternalSigner>& signers, bool mainnet)\n+{\n+    // Call <command> enumerate\n+    const UniValue result = runCommandParseJSON(command + \" enumerate\");\n+    if (!result.isArray())\n+        throw ExternalSignerException(strprintf(\"'%s' received invalid response, expected array of signers\", command));\n+    for (UniValue signer : result.getValues()) {\n+        const UniValue& fingerprint = find_value(signer, \"fingerprint\");\n+        if (result.isNull())\n+            throw ExternalSignerException(strprintf(\"'%s' received invalid response, missing signer fingerprint\", command));\n+        std::string fingerprintStr = fingerprint.get_str();\n+        // Skip duplicate signer\n+        bool duplicate = false;\n+        for (ExternalSigner signer : signers) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242605089",
      "id" : 242605089,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYwNTA4OQ==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 23,
      "path" : "src/wallet/externalsigner.cpp",
      "position" : 28,
      "pull_request_review_id" : 186156153,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242605089",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242605811"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242605811"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The type of `i` should match the type of `range_start` to avoid implicit precision losing conversion?",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2018-12-18T16:22:38Z",
      "diff_hunk" : "@@ -836,246 +837,419 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n-\n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+struct ImportData\n {\n-    try {\n-        // First ensure scriptPubKey has either a script or JSON with \"address\" string\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n-        }\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n-\n-        // Generate the script and destination for the scriptPubKey provided\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //!< Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //!< Provided witnessScript; will be moved to `import_scripts` if relevant.\n \n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n-        }\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::map<CKeyID, bool> used_keys; //!< Import these private keys if available (the value indicates whether if the key is required for solvability)\n+    std::map<CKeyID, KeyOriginInfo> key_origins;\n+};\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided scriptPubKey, determining which keys and which redeem scripts from the ImportData struct are needed to spend it, and mark them as used.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& import_data, const ScriptContext script_ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        import_data.used_keys.emplace(pubkey.GetID(), false);\n+        return \"\";\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.used_keys[id] = true;\n+        return \"\";\n+    }\n+    case TX_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::P2SH) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside another P2SH\");\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside a P2WSH\");\n+        assert(script_ctx == ScriptContext::TOP);\n+        CScriptID id = CScriptID(uint160(solverdata[0]));\n+        auto subscript = std::move(import_data.redeemscript);\n+        if (!subscript) return \"missing redeemscript\";\n+        if (CScriptID(*subscript) != id) return \"redeemScript does not match the scriptPubKey\";\n+        import_data.import_scripts.emplace(*subscript);\n+        return RecurseImportData(*subscript, import_data, ScriptContext::P2SH);\n+    }\n+    case TX_MULTISIG: {\n+        for (size_t i = 1; i + 1< solverdata.size(); ++i) {\n+            CPubKey pubkey(solverdata[i].begin(), solverdata[i].end());\n+            import_data.used_keys.emplace(pubkey.GetID(), false);\n         }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        return \"\";\n+    }\n+    case TX_WITNESS_V0_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WSH inside another P2WSH\");\n+        uint256 fullid(solverdata[0]);\n+        CScriptID id;\n+        CRIPEMD160().Write(fullid.begin(), fullid.size()).Finalize(id.begin());\n+        auto subscript = std::move(import_data.witnessscript);\n+        if (!subscript) return \"missing witnessscript\";\n+        if (CScriptID(*subscript) != id) return \"witnessScript does not match the scriptPubKey or redeemScript\";\n+        if (script_ctx == ScriptContext::TOP) {\n+            import_data.import_scripts.emplace(script); // Special rule for IsMine: native P2WSH requires the TOP script imported (see script/ismine.cpp)\n         }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n+        import_data.import_scripts.emplace(*subscript);\n+        return RecurseImportData(*subscript, import_data, ScriptContext::WITNESS_V0);\n+    }\n+    case TX_WITNESS_V0_KEYHASH: {\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WPKH inside P2WSH\");\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.used_keys[id] = true;\n+        if (script_ctx == ScriptContext::TOP) {\n+            import_data.import_scripts.emplace(script); // Special rule for IsMine: native P2WPKH requires the TOP script imported (see script/ismine.cpp)\n         }\n+        return \"\";\n+    }\n+    case TX_NULL_DATA:\n+        return \"unspendable script\";\n+    case TX_NONSTANDARD:\n+    case TX_WITNESS_UNKNOWN:\n+    default:\n+        return \"unrecognized script\";\n+    }\n+}\n \n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n-            if (!IsHex(strRedeemScript)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n-            }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n+static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data, std::vector<CKeyID>& ordered_pubkeys)\n+{\n+    UniValue warnings(UniValue::VARR);\n \n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n         }\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n+        }\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n+        }\n+    }\n+    script_pub_keys.emplace(script);\n \n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n-            }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n+    // Parse all arguments\n+    if (strRedeemScript.size()) {\n+        if (!IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n+        }\n+        auto parsed_redeemscript = ParseHex(strRedeemScript);\n+        import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    }\n+    if (witness_script_hex.size()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n+        }\n+        auto parsed_witnessscript = ParseHex(witness_script_hex);\n+        import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+    }\n+    for (size_t i = 0; i < pubKeys.size(); ++i) {\n+        const auto& str = pubKeys[i].get_str();\n+        if (!IsHex(str)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n+        }\n+        auto parsed_pubkey = ParseHex(str);\n+        CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+        if (!pubkey.IsFullyValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n+        }\n+        pubkey_map.emplace(pubkey.GetID(), pubkey);\n+        ordered_pubkeys.push_back(pubkey.GetID());\n+    }\n+    for (size_t i = 0; i < keys.size(); ++i) {\n+        const auto& str = keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n+        if (pubkey_map.count(id)) {\n+            pubkey_map.erase(id);\n+        }\n+        privkey_map.emplace(id, key);\n+    }\n \n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n+    // Verify and process input data\n+    have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();\n+    if (have_solving_data) {\n+        // Match up data in import_data with the scriptPubKey in script.\n+        auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n \n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        // Verify whether the watchonly option corresponds to the availability of private keys.\n+        bool spendable = std::all_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const std::pair<CKeyID, bool>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+        if (!watchOnly && !spendable) {\n+            warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n+        }\n+        if (watchOnly && spendable) {\n+            warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n+        }\n \n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        // Check that all required keys for solvability are provided.\n+        if (error.empty()) {\n+            for (const auto& require_key : import_data.used_keys) {\n+                if (!require_key.second) continue; // Not a required key\n+                if (pubkey_map.count(require_key.first) == 0 && privkey_map.count(require_key.first) == 0) {\n+                    error = \"some required keys are missing\";\n+                }\n             }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n         }\n \n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n-            }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n-            }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n-            }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+        if (!error.empty()) {\n+            warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+            import_data = ImportData();\n+            pubkey_map.clear();\n+            privkey_map.clear();\n+            have_solving_data = false;\n+        } else {\n+            // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+            if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+            if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+            for (auto it = privkey_map.begin(); it != privkey_map.end(); ) {\n+                auto oldit = it++;\n+                if (import_data.used_keys.count(oldit->first) == 0) {\n+                    warnings.push_back(\"Ignoring irrelevant private key.\");\n+                    privkey_map.erase(oldit);\n                 }\n-                pubkey = pubkey_temp;\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n+            for (auto it = pubkey_map.begin(); it != pubkey_map.end(); ) {\n+                auto oldit = it++;\n+                auto key_data_it = import_data.used_keys.find(oldit->first);\n+                if (key_data_it == import_data.used_keys.end() || !key_data_it->second) {\n+                    warnings.push_back(\"Ignoring public key \\\"\" + HexStr(oldit->first) + \"\\\" as it doesn't appear inside P2PKH or P2WPKH.\");\n+                    pubkey_map.erase(oldit);\n                 }\n+            }\n+        }\n+    }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n+    return warnings;\n+}\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n+static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data, std::vector<CKeyID>& ordered_pubkeys)\n+{\n+    UniValue warnings(UniValue::VARR);\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+    const std::string& descriptor = data[\"desc\"].get_str();\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n \n-                pwallet->MarkDirty();\n+    have_solving_data = parsed_desc->IsSolvable();\n+    const bool watch_only = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-            }\n+    int64_t range_start = 0, range_end = 0;\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange()) {\n+        if (!data.exists(\"range\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n         }\n-\n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        const UniValue& range = data[\"range\"];\n+        range_start = range.exists(\"start\") ? range[\"start\"].get_int64() : 0;\n+        if (!range.exists(\"end\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End of range for descriptor must be specified\");\n         }\n+        range_end = range[\"end\"].get_int64();\n+    }\n \n-        pwallet->MarkDirty();\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    // Expand all descriptors to get public keys and scripts.\n+    // TODO: get private keys from descriptors too\n+    for (int i = range_start; i <= range_end; ++i) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242605811",
      "id" : 242605811,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYwNTgxMQ==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 426,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 186157079,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242605811",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242606157"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242606157"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be dropped since unused?",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2018-12-18T16:23:17Z",
      "diff_hunk" : "@@ -836,246 +837,419 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n-\n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+struct ImportData\n {\n-    try {\n-        // First ensure scriptPubKey has either a script or JSON with \"address\" string\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n-        }\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n-\n-        // Generate the script and destination for the scriptPubKey provided\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //!< Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //!< Provided witnessScript; will be moved to `import_scripts` if relevant.\n \n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n-        }\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::map<CKeyID, bool> used_keys; //!< Import these private keys if available (the value indicates whether if the key is required for solvability)\n+    std::map<CKeyID, KeyOriginInfo> key_origins;\n+};\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided scriptPubKey, determining which keys and which redeem scripts from the ImportData struct are needed to spend it, and mark them as used.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& import_data, const ScriptContext script_ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        import_data.used_keys.emplace(pubkey.GetID(), false);\n+        return \"\";\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.used_keys[id] = true;\n+        return \"\";\n+    }\n+    case TX_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::P2SH) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside another P2SH\");\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside a P2WSH\");\n+        assert(script_ctx == ScriptContext::TOP);\n+        CScriptID id = CScriptID(uint160(solverdata[0]));\n+        auto subscript = std::move(import_data.redeemscript);\n+        if (!subscript) return \"missing redeemscript\";\n+        if (CScriptID(*subscript) != id) return \"redeemScript does not match the scriptPubKey\";\n+        import_data.import_scripts.emplace(*subscript);\n+        return RecurseImportData(*subscript, import_data, ScriptContext::P2SH);\n+    }\n+    case TX_MULTISIG: {\n+        for (size_t i = 1; i + 1< solverdata.size(); ++i) {\n+            CPubKey pubkey(solverdata[i].begin(), solverdata[i].end());\n+            import_data.used_keys.emplace(pubkey.GetID(), false);\n         }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        return \"\";\n+    }\n+    case TX_WITNESS_V0_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WSH inside another P2WSH\");\n+        uint256 fullid(solverdata[0]);\n+        CScriptID id;\n+        CRIPEMD160().Write(fullid.begin(), fullid.size()).Finalize(id.begin());\n+        auto subscript = std::move(import_data.witnessscript);\n+        if (!subscript) return \"missing witnessscript\";\n+        if (CScriptID(*subscript) != id) return \"witnessScript does not match the scriptPubKey or redeemScript\";\n+        if (script_ctx == ScriptContext::TOP) {\n+            import_data.import_scripts.emplace(script); // Special rule for IsMine: native P2WSH requires the TOP script imported (see script/ismine.cpp)\n         }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n+        import_data.import_scripts.emplace(*subscript);\n+        return RecurseImportData(*subscript, import_data, ScriptContext::WITNESS_V0);\n+    }\n+    case TX_WITNESS_V0_KEYHASH: {\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WPKH inside P2WSH\");\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.used_keys[id] = true;\n+        if (script_ctx == ScriptContext::TOP) {\n+            import_data.import_scripts.emplace(script); // Special rule for IsMine: native P2WPKH requires the TOP script imported (see script/ismine.cpp)\n         }\n+        return \"\";\n+    }\n+    case TX_NULL_DATA:\n+        return \"unspendable script\";\n+    case TX_NONSTANDARD:\n+    case TX_WITNESS_UNKNOWN:\n+    default:\n+        return \"unrecognized script\";\n+    }\n+}\n \n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n-            if (!IsHex(strRedeemScript)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n-            }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n+static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data, std::vector<CKeyID>& ordered_pubkeys)\n+{\n+    UniValue warnings(UniValue::VARR);\n \n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n         }\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n+        }\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n+        }\n+    }\n+    script_pub_keys.emplace(script);\n \n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n-            }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n+    // Parse all arguments\n+    if (strRedeemScript.size()) {\n+        if (!IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n+        }\n+        auto parsed_redeemscript = ParseHex(strRedeemScript);\n+        import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    }\n+    if (witness_script_hex.size()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n+        }\n+        auto parsed_witnessscript = ParseHex(witness_script_hex);\n+        import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+    }\n+    for (size_t i = 0; i < pubKeys.size(); ++i) {\n+        const auto& str = pubKeys[i].get_str();\n+        if (!IsHex(str)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n+        }\n+        auto parsed_pubkey = ParseHex(str);\n+        CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+        if (!pubkey.IsFullyValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n+        }\n+        pubkey_map.emplace(pubkey.GetID(), pubkey);\n+        ordered_pubkeys.push_back(pubkey.GetID());\n+    }\n+    for (size_t i = 0; i < keys.size(); ++i) {\n+        const auto& str = keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n+        if (pubkey_map.count(id)) {\n+            pubkey_map.erase(id);\n+        }\n+        privkey_map.emplace(id, key);\n+    }\n \n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n+    // Verify and process input data\n+    have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();\n+    if (have_solving_data) {\n+        // Match up data in import_data with the scriptPubKey in script.\n+        auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n \n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        // Verify whether the watchonly option corresponds to the availability of private keys.\n+        bool spendable = std::all_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const std::pair<CKeyID, bool>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+        if (!watchOnly && !spendable) {\n+            warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n+        }\n+        if (watchOnly && spendable) {\n+            warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n+        }\n \n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        // Check that all required keys for solvability are provided.\n+        if (error.empty()) {\n+            for (const auto& require_key : import_data.used_keys) {\n+                if (!require_key.second) continue; // Not a required key\n+                if (pubkey_map.count(require_key.first) == 0 && privkey_map.count(require_key.first) == 0) {\n+                    error = \"some required keys are missing\";\n+                }\n             }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n         }\n \n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n-            }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n-            }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n-            }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+        if (!error.empty()) {\n+            warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+            import_data = ImportData();\n+            pubkey_map.clear();\n+            privkey_map.clear();\n+            have_solving_data = false;\n+        } else {\n+            // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+            if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+            if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+            for (auto it = privkey_map.begin(); it != privkey_map.end(); ) {\n+                auto oldit = it++;\n+                if (import_data.used_keys.count(oldit->first) == 0) {\n+                    warnings.push_back(\"Ignoring irrelevant private key.\");\n+                    privkey_map.erase(oldit);\n                 }\n-                pubkey = pubkey_temp;\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n+            for (auto it = pubkey_map.begin(); it != pubkey_map.end(); ) {\n+                auto oldit = it++;\n+                auto key_data_it = import_data.used_keys.find(oldit->first);\n+                if (key_data_it == import_data.used_keys.end() || !key_data_it->second) {\n+                    warnings.push_back(\"Ignoring public key \\\"\" + HexStr(oldit->first) + \"\\\" as it doesn't appear inside P2PKH or P2WPKH.\");\n+                    pubkey_map.erase(oldit);\n                 }\n+            }\n+        }\n+    }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n+    return warnings;\n+}\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n+static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data, std::vector<CKeyID>& ordered_pubkeys)\n+{\n+    UniValue warnings(UniValue::VARR);\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+    const std::string& descriptor = data[\"desc\"].get_str();\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n \n-                pwallet->MarkDirty();\n+    have_solving_data = parsed_desc->IsSolvable();\n+    const bool watch_only = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-            }\n+    int64_t range_start = 0, range_end = 0;\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange()) {\n+        if (!data.exists(\"range\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n         }\n-\n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        const UniValue& range = data[\"range\"];\n+        range_start = range.exists(\"start\") ? range[\"start\"].get_int64() : 0;\n+        if (!range.exists(\"end\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End of range for descriptor must be specified\");\n         }\n+        range_end = range[\"end\"].get_int64();\n+    }\n \n-        pwallet->MarkDirty();\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    // Expand all descriptors to get public keys and scripts.\n+    // TODO: get private keys from descriptors too\n+    for (int i = range_start; i <= range_end; ++i) {\n+        FlatSigningProvider out_keys;\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        std::copy(scripts_temp.begin(), scripts_temp.end(), std::inserter(script_pub_keys, script_pub_keys.end()));\n+        for (const auto& key_pair : out_keys.pubkeys) {\n+            ordered_pubkeys.push_back(key_pair.first);\n+        }\n \n-        if (!pwallet->AddWatchOnly(scriptpubkey_script, timestamp)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        for (auto const& x : out_keys.scripts) {\n+            import_data.import_scripts.emplace(x.second);\n         }\n \n-        if (!watchOnly && !pwallet->HaveCScript(CScriptID(scriptpubkey_script)) && !pwallet->AddCScript(scriptpubkey_script)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding scriptPubKey script to wallet\");\n+        std::copy(out_keys.pubkeys.begin(), out_keys.pubkeys.end(), std::inserter(pubkey_map, pubkey_map.end()));\n+        std::copy(out_keys.origins.begin(), out_keys.origins.end(), std::inserter(import_data.key_origins, import_data.key_origins.end()));\n+    }\n+\n+    for (size_t i = 0; i < priv_keys.size(); ++i) {\n+        const auto& str = priv_keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n         }\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n \n-        // if not internal add to address book or update label\n-        if (!internal) {\n-            assert(IsValidDestination(scriptpubkey_dest));\n-            pwallet->SetAddressBook(scriptpubkey_dest, label, \"receive\");\n+        // Check if this private key corresponds to a public key from the descriptor\n+        if (!pubkey_map.count(id)) {\n+            warnings.push_back(\"Ignoring irrelevant private key.\");\n+        } else {\n+            privkey_map.emplace(id, key);\n         }\n+    }\n \n-        // Import private keys.\n-        for (size_t i = 0; i < keys.size(); i++) {\n-            const std::string& strPrivkey = keys[i].get_str();\n+    // Check if all the public keys have corresponding private keys in the import for spendability.\n+    // This does not take into account threshold multisigs which could be spendable without all keys\n+    bool spendable = std::all_of(pubkey_map.begin(), pubkey_map.end(), [&](const std::pair<CKeyID, CPubKey>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+    if (!watch_only && !spendable) {\n+        warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n+    }\n+    if (watch_only && spendable) {\n+        warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n+    }\n \n-            // Checks.\n-            CKey key = DecodeSecret(strPrivkey);\n+    return warnings;\n+}\n \n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-            }\n+static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    try {\n+        bool watch_only = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242606157",
      "id" : 242606157,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYwNjE1Nw==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 492,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 186157488,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242606157",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242606739"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242606739"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Make signedness changing implicit conversion explicit? Also, remove redundant initialization to zero on the line above? Merge the two lines.",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2018-12-18T16:24:28Z",
      "diff_hunk" : "@@ -1263,3 +1444,145 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n \n     return response;\n }\n+\n+UniValue signerfetchkeys(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() > 1) {\n+        throw std::runtime_error(\n+            \"signerfetchkeys ( fingerprint )\\n\"\n+            \"Obtains keys from external signer and imports them into the wallet.\\n\"\n+            \"Call enumeratesigners before using this.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"fingerprint\\\"   (string, optional) Master key fingerprint of signer\\n\"\n+            \"\\nResult (same as for importmulti):\\n\"\n+            \"[{ \\\"success\\\": true }\"\n+        );\n+    }\n+\n+    ExternalSigner *signer = GetSignerForJSONRPCRequest(request, 0, pwallet);\n+\n+    UniValue descriptors = UniValue(UniValue::VARR);\n+    std::string desc_prefix = \"\";\n+    std::string desc_suffix = \"\";\n+    std::string purpose = \"\";\n+    switch(pwallet->m_default_address_type) {\n+        case OutputType::LEGACY: {\n+            desc_prefix = \"pkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"44h\";\n+            break;\n+        }\n+        case OutputType::P2SH_SEGWIT: {\n+            desc_prefix = \"sh(wpkh(\";\n+            desc_suffix = \"))\";\n+            purpose = \"49h\";\n+            break;\n+        }\n+        case OutputType::BECH32: {\n+            desc_prefix = \"wpkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"84h\";\n+            break;\n+        }\n+        case OutputType::CHANGE_AUTO: {\n+            assert(false);\n+        }\n+    }\n+\n+    const std::string receive_desc = desc_prefix + signer->m_fingerprint + \"/\" + purpose + \"/\" + (signer->m_mainnet ? \"0h\" : \"1h\") + \"/0h/0/*\" + desc_suffix;\n+    UniValue receive_descriptors = signer->getKeys(receive_desc);\n+    if (!receive_descriptors.isArray()) JSONRPCError(RPC_WALLET_ERROR, \"Expected an array of receive descriptors\");\n+    for (const UniValue& descriptor : receive_descriptors.getValues()) {\n+        descriptors.push_back(descriptor);\n+    }\n+\n+\n+    switch(pwallet->m_default_change_type) {\n+        case OutputType::LEGACY: {\n+            desc_prefix = \"pkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"44h\";\n+            break;\n+        }\n+        case OutputType::P2SH_SEGWIT: {\n+            desc_prefix = \"sh(wpkh(\";\n+            desc_suffix = \"))\";\n+            purpose = \"49h\";\n+            break;\n+        }\n+        case OutputType::BECH32: {\n+            desc_prefix = \"wpkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"84h\";\n+            break;\n+        }\n+        case OutputType::CHANGE_AUTO: {\n+            // Use same values as for receive descriptor\n+            break;\n+        }\n+    }\n+\n+    const std::string change_desc = desc_prefix + signer->m_fingerprint + \"/\" + purpose + \"/\" + (signer->m_mainnet ? \"0h\" : \"1h\") + \"/0h/1/*\" + desc_suffix;\n+    UniValue change_descriptors = signer->getKeys(change_desc);\n+    if (!change_descriptors.isArray()) JSONRPCError(RPC_WALLET_ERROR, \"Expected an array of change descriptors\");\n+    for (const UniValue& descriptor : change_descriptors.getValues()) {\n+        descriptors.push_back(descriptor);\n+    }\n+\n+    if (receive_descriptors.size() != change_descriptors.size()) JSONRPCError(RPC_WALLET_ERROR, \"Expected same number of receive and change descriptors\");\n+\n+    // Use importmulti to process the descriptors:\n+    UniValue importdata(UniValue::VARR);\n+\n+    uint64_t keypool_target_size = 0;\n+    keypool_target_size = gArgs.GetArg(\"-keypool\", DEFAULT_KEYPOOL_SIZE);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242606739",
      "id" : 242606739,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYwNjczOQ==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 770,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 186158164,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242606739",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242608963"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242608963"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Initialize to zero?",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2018-12-18T16:29:39Z",
      "diff_hunk" : "@@ -1198,6 +1200,24 @@ void runCommand(const std::string& strCommand)\n         LogPrintf(\"runCommand error: system(%s) returned %d\\n\", strCommand, nErr);\n }\n \n+UniValue runCommandParseJSON(const std::string& strCommand)\n+{\n+    if (strCommand.empty()) return UniValue::VNULL;\n+\n+    std::array<char, 128> buffer;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242608963",
      "id" : 242608963,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYwODk2Mw==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 20,
      "path" : "src/util/system.cpp",
      "position" : null,
      "pull_request_review_id" : 186161053,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242608963",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242609613"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242609613"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be \"fingerprint\" :-)",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2018-12-18T16:31:09Z",
      "diff_hunk" : "@@ -3988,6 +4010,37 @@ UniValue walletprocesspsbt(const JSONRPCRequest& request)\n     bool bip32derivs = request.params[3].isNull() ? false : request.params[3].get_bool();\n     bool complete = FillPSBT(pwallet, psbtx, nHashType, sign, bip32derivs);\n \n+    // Process again with external signer if needed\n+    if (!complete && sign && !wallet->m_external_signers.empty()) {\n+        ExternalSigner *signer = GetSignerForJSONRPCRequest(request, 4, pwallet);\n+        if (signer && !bip32derivs) JSONRPCError(RPC_WALLET_ERROR, \"Using signer requires bip32derivs argument to be true\");\n+\n+        // Check if signer fingerpint matches any input master key fingerprint",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242609613",
      "id" : 242609613,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYwOTYxMw==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 112,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 186161866,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242609613",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242612528"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242612528"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I haven't reviewed this use of `popen()` closer, but please note the recommendations/risks with regards to `popen()` used described in the CERT secure coding guidelines (more specifically rule ENV33-C).",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2018-12-18T16:38:09Z",
      "diff_hunk" : "@@ -1198,6 +1200,24 @@ void runCommand(const std::string& strCommand)\n         LogPrintf(\"runCommand error: system(%s) returned %d\\n\", strCommand, nErr);\n }\n \n+UniValue runCommandParseJSON(const std::string& strCommand)\n+{\n+    if (strCommand.empty()) return UniValue::VNULL;\n+\n+    std::array<char, 128> buffer;\n+    std::string result;\n+    std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(strCommand.c_str(), \"r\"), pclose);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242612528",
      "id" : 242612528,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYxMjUyOA==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 22,
      "path" : "src/util/system.cpp",
      "position" : null,
      "pull_request_review_id" : 186165666,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242612528",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242612922"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242612922"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`keypath` should be const reference?",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2018-12-18T16:38:57Z",
      "diff_hunk" : "@@ -587,6 +587,21 @@ bool ParseHDKeypath(const std::string& keypath_str, std::vector<uint32_t>& keypa\n     return true;\n }\n \n+std::string FormatKeyPath(const std::vector<uint32_t>& path)\n+{\n+    std::string ret;\n+    for (auto i : path) {\n+        ret += strprintf(\"/%i\", (i << 1) >> 1);\n+        if (i >> 31) ret += '\\'';\n+    }\n+    return ret;\n+}\n+\n+std::string WriteHdKeypath(const std::vector<uint32_t> keypath)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242612922",
      "id" : 242612922,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYxMjkyMg==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 14,
      "path" : "src/util/strencodings.cpp",
      "position" : null,
      "pull_request_review_id" : 186166112,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242612922",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242614487"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242614487"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: Could use `command.empty()`? :-)",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2018-12-18T16:42:48Z",
      "diff_hunk" : "@@ -4113,6 +4166,111 @@ UniValue walletcreatefundedpsbt(const JSONRPCRequest& request)\n     return result;\n }\n \n+static UniValue enumeratesigners(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() != 0) {\n+        throw std::runtime_error(\n+            \"enumeratesigners\\n\"\n+            \"Returns a list of external signers from -signer and associates them\\n\"\n+            \"with the wallet until you stop bitcoind.\\n\"\n+            \"{\\n\"\n+            \"  \\\"signers\\\" : [                                (json array of objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"masterkeyfingerprint\\\" : \\\"fingerprint\\\" (string) Master key fingerprint\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+        );\n+    }\n+\n+    const std::string command = gArgs.GetArg(\"-signer\", DEFAULT_EXTERNAL_SIGNER);\n+    if (command == \"\") throw JSONRPCError(RPC_WALLET_ERROR, \"Error: restart bitcoind with -signer=<cmd>\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242614487",
      "id" : 242614487,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYxNDQ4Nw==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 171,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 186168170,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242614487",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242614853"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242614853"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be const reference? :-)",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2018-12-18T16:43:39Z",
      "diff_hunk" : "@@ -0,0 +1,45 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <wallet/externalsigner.h>\n+#include <util/system.h>\n+\n+ExternalSigner::ExternalSigner(const std::string& command, const std::string& fingerprint, bool mainnet): m_command(command), m_fingerprint(fingerprint), m_mainnet(mainnet) {}\n+\n+UniValue ExternalSigner::Enumerate(const std::string& command, std::vector<ExternalSigner>& signers, bool mainnet)\n+{\n+    // Call <command> enumerate\n+    const UniValue result = runCommandParseJSON(command + \" enumerate\");\n+    if (!result.isArray())\n+        throw ExternalSignerException(strprintf(\"'%s' received invalid response, expected array of signers\", command));\n+    for (UniValue signer : result.getValues()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242614853",
      "id" : 242614853,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYxNDg1Mw==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 16,
      "path" : "src/wallet/externalsigner.cpp",
      "position" : 21,
      "pull_request_review_id" : 186168654,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242614853",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242614951"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242614951"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be const reference? :-)",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2018-12-18T16:43:54Z",
      "diff_hunk" : "@@ -0,0 +1,45 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <wallet/externalsigner.h>\n+#include <util/system.h>\n+\n+ExternalSigner::ExternalSigner(const std::string& command, const std::string& fingerprint, bool mainnet): m_command(command), m_fingerprint(fingerprint), m_mainnet(mainnet) {}\n+\n+UniValue ExternalSigner::Enumerate(const std::string& command, std::vector<ExternalSigner>& signers, bool mainnet)\n+{\n+    // Call <command> enumerate\n+    const UniValue result = runCommandParseJSON(command + \" enumerate\");\n+    if (!result.isArray())\n+        throw ExternalSignerException(strprintf(\"'%s' received invalid response, expected array of signers\", command));\n+    for (UniValue signer : result.getValues()) {\n+        const UniValue& fingerprint = find_value(signer, \"fingerprint\");\n+        if (result.isNull())\n+            throw ExternalSignerException(strprintf(\"'%s' received invalid response, missing signer fingerprint\", command));\n+        std::string fingerprintStr = fingerprint.get_str();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242614951",
      "id" : 242614951,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYxNDk1MQ==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 20,
      "path" : "src/wallet/externalsigner.cpp",
      "position" : 25,
      "pull_request_review_id" : 186168772,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242614951",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242615222"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242615222"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Use string equality operator instead of `compare` :-)",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2018-12-18T16:44:29Z",
      "diff_hunk" : "@@ -0,0 +1,45 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <wallet/externalsigner.h>\n+#include <util/system.h>\n+\n+ExternalSigner::ExternalSigner(const std::string& command, const std::string& fingerprint, bool mainnet): m_command(command), m_fingerprint(fingerprint), m_mainnet(mainnet) {}\n+\n+UniValue ExternalSigner::Enumerate(const std::string& command, std::vector<ExternalSigner>& signers, bool mainnet)\n+{\n+    // Call <command> enumerate\n+    const UniValue result = runCommandParseJSON(command + \" enumerate\");\n+    if (!result.isArray())\n+        throw ExternalSignerException(strprintf(\"'%s' received invalid response, expected array of signers\", command));\n+    for (UniValue signer : result.getValues()) {\n+        const UniValue& fingerprint = find_value(signer, \"fingerprint\");\n+        if (result.isNull())\n+            throw ExternalSignerException(strprintf(\"'%s' received invalid response, missing signer fingerprint\", command));\n+        std::string fingerprintStr = fingerprint.get_str();\n+        // Skip duplicate signer\n+        bool duplicate = false;\n+        for (ExternalSigner signer : signers) {\n+            if (signer.m_fingerprint.compare(fingerprintStr) == 0) duplicate = true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242615222",
      "id" : 242615222,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYxNTIyMg==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 24,
      "path" : "src/wallet/externalsigner.cpp",
      "position" : 29,
      "pull_request_review_id" : 186169074,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242615222",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242616373"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242616373"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`signer` can be `nullptr` here if the check on L4016 is correct?",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2018-12-18T16:47:04Z",
      "diff_hunk" : "@@ -3988,6 +4010,37 @@ UniValue walletprocesspsbt(const JSONRPCRequest& request)\n     bool bip32derivs = request.params[3].isNull() ? false : request.params[3].get_bool();\n     bool complete = FillPSBT(pwallet, psbtx, nHashType, sign, bip32derivs);\n \n+    // Process again with external signer if needed\n+    if (!complete && sign && !wallet->m_external_signers.empty()) {\n+        ExternalSigner *signer = GetSignerForJSONRPCRequest(request, 4, pwallet);\n+        if (signer && !bip32derivs) JSONRPCError(RPC_WALLET_ERROR, \"Using signer requires bip32derivs argument to be true\");\n+\n+        // Check if signer fingerpint matches any input master key fingerprint\n+        bool match = false;\n+        for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {\n+            const PSBTInput& input = psbtx.inputs[i];\n+            for (auto entry : input.hd_keypaths) {\n+                if (signer->m_fingerprint == strprintf(\"%08x\", ReadBE32(entry.second.fingerprint))) match = true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242616373",
      "id" : 242616373,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYxNjM3Mw==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 117,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 186170522,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242616373",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242616597"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242616597"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Same here: `signer` can be `nullptr` here if the check on L4016 is correct?",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2018-12-18T16:47:38Z",
      "diff_hunk" : "@@ -3988,6 +4010,37 @@ UniValue walletprocesspsbt(const JSONRPCRequest& request)\n     bool bip32derivs = request.params[3].isNull() ? false : request.params[3].get_bool();\n     bool complete = FillPSBT(pwallet, psbtx, nHashType, sign, bip32derivs);\n \n+    // Process again with external signer if needed\n+    if (!complete && sign && !wallet->m_external_signers.empty()) {\n+        ExternalSigner *signer = GetSignerForJSONRPCRequest(request, 4, pwallet);\n+        if (signer && !bip32derivs) JSONRPCError(RPC_WALLET_ERROR, \"Using signer requires bip32derivs argument to be true\");\n+\n+        // Check if signer fingerpint matches any input master key fingerprint\n+        bool match = false;\n+        for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {\n+            const PSBTInput& input = psbtx.inputs[i];\n+            for (auto entry : input.hd_keypaths) {\n+                if (signer->m_fingerprint == strprintf(\"%08x\", ReadBE32(entry.second.fingerprint))) match = true;\n+            }\n+        }\n+\n+        if (!match) JSONRPCError(RPC_WALLET_ERROR, \"Signer fingerprint does not match any of the inputs\");\n+\n+        // Call signer, get result\n+        const UniValue signer_result = signer->signTransaction(request.params[0].get_str());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242616597",
      "id" : 242616597,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYxNjU5Nw==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 124,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 186170810,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242616597",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242617121"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242617121"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`keypath` should be const reference?",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2018-12-18T16:48:58Z",
      "diff_hunk" : "@@ -204,6 +204,10 @@ bool ConvertBits(const O& outfn, I it, I end) {\n /** Parse an HD keypaths like \"m/7/0'/2000\". */\n NODISCARD bool ParseHDKeypath(const std::string& keypath_str, std::vector<uint32_t>& keypath);\n \n+/** Write HD keypaths as strings */\n+std::string WriteHdKeypath(const std::vector<uint32_t> keypath);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242617121",
      "id" : 242617121,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYxNzEyMQ==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 5,
      "path" : "src/util/strencodings.h",
      "position" : null,
      "pull_request_review_id" : 186171510,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242617121",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242617685"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242617685"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: Could use `std::copy` instead?",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2018-12-18T16:50:23Z",
      "diff_hunk" : "@@ -1263,3 +1444,145 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n \n     return response;\n }\n+\n+UniValue signerfetchkeys(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() > 1) {\n+        throw std::runtime_error(\n+            \"signerfetchkeys ( fingerprint )\\n\"\n+            \"Obtains keys from external signer and imports them into the wallet.\\n\"\n+            \"Call enumeratesigners before using this.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"fingerprint\\\"   (string, optional) Master key fingerprint of signer\\n\"\n+            \"\\nResult (same as for importmulti):\\n\"\n+            \"[{ \\\"success\\\": true }\"\n+        );\n+    }\n+\n+    ExternalSigner *signer = GetSignerForJSONRPCRequest(request, 0, pwallet);\n+\n+    UniValue descriptors = UniValue(UniValue::VARR);\n+    std::string desc_prefix = \"\";\n+    std::string desc_suffix = \"\";\n+    std::string purpose = \"\";\n+    switch(pwallet->m_default_address_type) {\n+        case OutputType::LEGACY: {\n+            desc_prefix = \"pkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"44h\";\n+            break;\n+        }\n+        case OutputType::P2SH_SEGWIT: {\n+            desc_prefix = \"sh(wpkh(\";\n+            desc_suffix = \"))\";\n+            purpose = \"49h\";\n+            break;\n+        }\n+        case OutputType::BECH32: {\n+            desc_prefix = \"wpkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"84h\";\n+            break;\n+        }\n+        case OutputType::CHANGE_AUTO: {\n+            assert(false);\n+        }\n+    }\n+\n+    const std::string receive_desc = desc_prefix + signer->m_fingerprint + \"/\" + purpose + \"/\" + (signer->m_mainnet ? \"0h\" : \"1h\") + \"/0h/0/*\" + desc_suffix;\n+    UniValue receive_descriptors = signer->getKeys(receive_desc);\n+    if (!receive_descriptors.isArray()) JSONRPCError(RPC_WALLET_ERROR, \"Expected an array of receive descriptors\");\n+    for (const UniValue& descriptor : receive_descriptors.getValues()) {\n+        descriptors.push_back(descriptor);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242617685",
      "id" : 242617685,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYxNzY4NQ==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 728,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 186172231,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242617685",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242617864"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242617864"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Same here: Could you `std::copy`?",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2018-12-18T16:50:51Z",
      "diff_hunk" : "@@ -1263,3 +1444,145 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n \n     return response;\n }\n+\n+UniValue signerfetchkeys(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() > 1) {\n+        throw std::runtime_error(\n+            \"signerfetchkeys ( fingerprint )\\n\"\n+            \"Obtains keys from external signer and imports them into the wallet.\\n\"\n+            \"Call enumeratesigners before using this.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"fingerprint\\\"   (string, optional) Master key fingerprint of signer\\n\"\n+            \"\\nResult (same as for importmulti):\\n\"\n+            \"[{ \\\"success\\\": true }\"\n+        );\n+    }\n+\n+    ExternalSigner *signer = GetSignerForJSONRPCRequest(request, 0, pwallet);\n+\n+    UniValue descriptors = UniValue(UniValue::VARR);\n+    std::string desc_prefix = \"\";\n+    std::string desc_suffix = \"\";\n+    std::string purpose = \"\";\n+    switch(pwallet->m_default_address_type) {\n+        case OutputType::LEGACY: {\n+            desc_prefix = \"pkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"44h\";\n+            break;\n+        }\n+        case OutputType::P2SH_SEGWIT: {\n+            desc_prefix = \"sh(wpkh(\";\n+            desc_suffix = \"))\";\n+            purpose = \"49h\";\n+            break;\n+        }\n+        case OutputType::BECH32: {\n+            desc_prefix = \"wpkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"84h\";\n+            break;\n+        }\n+        case OutputType::CHANGE_AUTO: {\n+            assert(false);\n+        }\n+    }\n+\n+    const std::string receive_desc = desc_prefix + signer->m_fingerprint + \"/\" + purpose + \"/\" + (signer->m_mainnet ? \"0h\" : \"1h\") + \"/0h/0/*\" + desc_suffix;\n+    UniValue receive_descriptors = signer->getKeys(receive_desc);\n+    if (!receive_descriptors.isArray()) JSONRPCError(RPC_WALLET_ERROR, \"Expected an array of receive descriptors\");\n+    for (const UniValue& descriptor : receive_descriptors.getValues()) {\n+        descriptors.push_back(descriptor);\n+    }\n+\n+\n+    switch(pwallet->m_default_change_type) {\n+        case OutputType::LEGACY: {\n+            desc_prefix = \"pkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"44h\";\n+            break;\n+        }\n+        case OutputType::P2SH_SEGWIT: {\n+            desc_prefix = \"sh(wpkh(\";\n+            desc_suffix = \"))\";\n+            purpose = \"49h\";\n+            break;\n+        }\n+        case OutputType::BECH32: {\n+            desc_prefix = \"wpkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"84h\";\n+            break;\n+        }\n+        case OutputType::CHANGE_AUTO: {\n+            // Use same values as for receive descriptor\n+            break;\n+        }\n+    }\n+\n+    const std::string change_desc = desc_prefix + signer->m_fingerprint + \"/\" + purpose + \"/\" + (signer->m_mainnet ? \"0h\" : \"1h\") + \"/0h/1/*\" + desc_suffix;\n+    UniValue change_descriptors = signer->getKeys(change_desc);\n+    if (!change_descriptors.isArray()) JSONRPCError(RPC_WALLET_ERROR, \"Expected an array of change descriptors\");\n+    for (const UniValue& descriptor : change_descriptors.getValues()) {\n+        descriptors.push_back(descriptor);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242617864",
      "id" : 242617864,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYxNzg2NA==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 761,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 186172442,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242617864",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242618665"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242618665"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Missing space before `(`. Consider running new code through `clang-format` :-)",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2018-12-18T16:52:53Z",
      "diff_hunk" : "@@ -1263,3 +1444,145 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n \n     return response;\n }\n+\n+UniValue signerfetchkeys(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() > 1) {\n+        throw std::runtime_error(\n+            \"signerfetchkeys ( fingerprint )\\n\"\n+            \"Obtains keys from external signer and imports them into the wallet.\\n\"\n+            \"Call enumeratesigners before using this.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"fingerprint\\\"   (string, optional) Master key fingerprint of signer\\n\"\n+            \"\\nResult (same as for importmulti):\\n\"\n+            \"[{ \\\"success\\\": true }\"\n+        );\n+    }\n+\n+    ExternalSigner *signer = GetSignerForJSONRPCRequest(request, 0, pwallet);\n+\n+    UniValue descriptors = UniValue(UniValue::VARR);\n+    std::string desc_prefix = \"\";\n+    std::string desc_suffix = \"\";\n+    std::string purpose = \"\";\n+    switch(pwallet->m_default_address_type) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242618665",
      "id" : 242618665,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYxODY2NQ==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 700,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 186173510,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242618665",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242618820"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242618820"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Same here: Missing whitespace before `(`.",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2018-12-18T16:53:15Z",
      "diff_hunk" : "@@ -1263,3 +1444,145 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n \n     return response;\n }\n+\n+UniValue signerfetchkeys(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() > 1) {\n+        throw std::runtime_error(\n+            \"signerfetchkeys ( fingerprint )\\n\"\n+            \"Obtains keys from external signer and imports them into the wallet.\\n\"\n+            \"Call enumeratesigners before using this.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"fingerprint\\\"   (string, optional) Master key fingerprint of signer\\n\"\n+            \"\\nResult (same as for importmulti):\\n\"\n+            \"[{ \\\"success\\\": true }\"\n+        );\n+    }\n+\n+    ExternalSigner *signer = GetSignerForJSONRPCRequest(request, 0, pwallet);\n+\n+    UniValue descriptors = UniValue(UniValue::VARR);\n+    std::string desc_prefix = \"\";\n+    std::string desc_suffix = \"\";\n+    std::string purpose = \"\";\n+    switch(pwallet->m_default_address_type) {\n+        case OutputType::LEGACY: {\n+            desc_prefix = \"pkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"44h\";\n+            break;\n+        }\n+        case OutputType::P2SH_SEGWIT: {\n+            desc_prefix = \"sh(wpkh(\";\n+            desc_suffix = \"))\";\n+            purpose = \"49h\";\n+            break;\n+        }\n+        case OutputType::BECH32: {\n+            desc_prefix = \"wpkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"84h\";\n+            break;\n+        }\n+        case OutputType::CHANGE_AUTO: {\n+            assert(false);\n+        }\n+    }\n+\n+    const std::string receive_desc = desc_prefix + signer->m_fingerprint + \"/\" + purpose + \"/\" + (signer->m_mainnet ? \"0h\" : \"1h\") + \"/0h/0/*\" + desc_suffix;\n+    UniValue receive_descriptors = signer->getKeys(receive_desc);\n+    if (!receive_descriptors.isArray()) JSONRPCError(RPC_WALLET_ERROR, \"Expected an array of receive descriptors\");\n+    for (const UniValue& descriptor : receive_descriptors.getValues()) {\n+        descriptors.push_back(descriptor);\n+    }\n+\n+\n+    switch(pwallet->m_default_change_type) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242618820",
      "id" : 242618820,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYxODgyMA==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 732,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 186173710,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242618820",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242619074"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242619074"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Remove space before `;` :-)",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2018-12-18T16:53:47Z",
      "diff_hunk" : "@@ -3988,6 +4010,37 @@ UniValue walletprocesspsbt(const JSONRPCRequest& request)\n     bool bip32derivs = request.params[3].isNull() ? false : request.params[3].get_bool();\n     bool complete = FillPSBT(pwallet, psbtx, nHashType, sign, bip32derivs);\n \n+    // Process again with external signer if needed\n+    if (!complete && sign && !wallet->m_external_signers.empty()) {\n+        ExternalSigner *signer = GetSignerForJSONRPCRequest(request, 4, pwallet);\n+        if (signer && !bip32derivs) JSONRPCError(RPC_WALLET_ERROR, \"Using signer requires bip32derivs argument to be true\");\n+\n+        // Check if signer fingerpint matches any input master key fingerprint\n+        bool match = false;\n+        for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {\n+            const PSBTInput& input = psbtx.inputs[i];\n+            for (auto entry : input.hd_keypaths) {\n+                if (signer->m_fingerprint == strprintf(\"%08x\", ReadBE32(entry.second.fingerprint))) match = true;\n+            }\n+        }\n+\n+        if (!match) JSONRPCError(RPC_WALLET_ERROR, \"Signer fingerprint does not match any of the inputs\");\n+\n+        // Call signer, get result\n+        const UniValue signer_result = signer->signTransaction(request.params[0].get_str());\n+        if (!find_value(signer_result, \"psbt\").isStr()) JSONRPCError(RPC_WALLET_ERROR, \"Unexpected result from signer\");\n+\n+        // Process result from signer:\n+        std::string signer_psbt_error;\n+        PartiallySignedTransaction signer_psbtx ;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242619074",
      "id" : 242619074,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYxOTA3NA==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 129,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 186174018,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242619074",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242619836"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242619836"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Indentation is not a multiple of four :-)",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2018-12-18T16:55:41Z",
      "diff_hunk" : "@@ -119,9 +126,13 @@ def get_multisig(self):\n                         CScript([OP_HASH160, witness_script, OP_EQUAL]).hex(),  # p2sh-p2wsh\n                         script_to_p2sh_p2wsh(script_code))  # p2sh-p2wsh addr\n \n-    def test_importmulti(self, req, success, error_code=None, error_message=None):\n+    def test_importmulti(self, req, success, error_code=None, error_message=None, warnings=[]):\n         \"\"\"Run importmulti and assert success\"\"\"\n         result = self.nodes[1].importmulti([req])\n+        observed_warnings = []\n+        if 'warnings' in result[0]:\n+           observed_warnings = result[0]['warnings']",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242619836",
      "id" : 242619836,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYxOTgzNg==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 24,
      "path" : "test/functional/wallet_importmulti.py",
      "position" : null,
      "pull_request_review_id" : 186174993,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242619836",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242620899"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242620899"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be \"derivation\" :-)",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2018-12-18T16:57:56Z",
      "diff_hunk" : "@@ -1263,3 +1444,145 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n \n     return response;\n }\n+\n+UniValue signerfetchkeys(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() > 1) {\n+        throw std::runtime_error(\n+            \"signerfetchkeys ( fingerprint )\\n\"\n+            \"Obtains keys from external signer and imports them into the wallet.\\n\"\n+            \"Call enumeratesigners before using this.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"fingerprint\\\"   (string, optional) Master key fingerprint of signer\\n\"\n+            \"\\nResult (same as for importmulti):\\n\"\n+            \"[{ \\\"success\\\": true }\"\n+        );\n+    }\n+\n+    ExternalSigner *signer = GetSignerForJSONRPCRequest(request, 0, pwallet);\n+\n+    UniValue descriptors = UniValue(UniValue::VARR);\n+    std::string desc_prefix = \"\";\n+    std::string desc_suffix = \"\";\n+    std::string purpose = \"\";\n+    switch(pwallet->m_default_address_type) {\n+        case OutputType::LEGACY: {\n+            desc_prefix = \"pkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"44h\";\n+            break;\n+        }\n+        case OutputType::P2SH_SEGWIT: {\n+            desc_prefix = \"sh(wpkh(\";\n+            desc_suffix = \"))\";\n+            purpose = \"49h\";\n+            break;\n+        }\n+        case OutputType::BECH32: {\n+            desc_prefix = \"wpkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"84h\";\n+            break;\n+        }\n+        case OutputType::CHANGE_AUTO: {\n+            assert(false);\n+        }\n+    }\n+\n+    const std::string receive_desc = desc_prefix + signer->m_fingerprint + \"/\" + purpose + \"/\" + (signer->m_mainnet ? \"0h\" : \"1h\") + \"/0h/0/*\" + desc_suffix;\n+    UniValue receive_descriptors = signer->getKeys(receive_desc);\n+    if (!receive_descriptors.isArray()) JSONRPCError(RPC_WALLET_ERROR, \"Expected an array of receive descriptors\");\n+    for (const UniValue& descriptor : receive_descriptors.getValues()) {\n+        descriptors.push_back(descriptor);\n+    }\n+\n+\n+    switch(pwallet->m_default_change_type) {\n+        case OutputType::LEGACY: {\n+            desc_prefix = \"pkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"44h\";\n+            break;\n+        }\n+        case OutputType::P2SH_SEGWIT: {\n+            desc_prefix = \"sh(wpkh(\";\n+            desc_suffix = \"))\";\n+            purpose = \"49h\";\n+            break;\n+        }\n+        case OutputType::BECH32: {\n+            desc_prefix = \"wpkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"84h\";\n+            break;\n+        }\n+        case OutputType::CHANGE_AUTO: {\n+            // Use same values as for receive descriptor\n+            break;\n+        }\n+    }\n+\n+    const std::string change_desc = desc_prefix + signer->m_fingerprint + \"/\" + purpose + \"/\" + (signer->m_mainnet ? \"0h\" : \"1h\") + \"/0h/1/*\" + desc_suffix;\n+    UniValue change_descriptors = signer->getKeys(change_desc);\n+    if (!change_descriptors.isArray()) JSONRPCError(RPC_WALLET_ERROR, \"Expected an array of change descriptors\");\n+    for (const UniValue& descriptor : change_descriptors.getValues()) {\n+        descriptors.push_back(descriptor);\n+    }\n+\n+    if (receive_descriptors.size() != change_descriptors.size()) JSONRPCError(RPC_WALLET_ERROR, \"Expected same number of receive and change descriptors\");\n+\n+    // Use importmulti to process the descriptors:\n+    UniValue importdata(UniValue::VARR);\n+\n+    uint64_t keypool_target_size = 0;\n+    keypool_target_size = gArgs.GetArg(\"-keypool\", DEFAULT_KEYPOOL_SIZE);\n+\n+    if (keypool_target_size == 0) JSONRPCError(RPC_WALLET_ERROR, \"-keypool must be > 0\");\n+\n+    for (unsigned int i = 0; i < descriptors.size(); ++i) {\n+        const UniValue& descriptor = descriptors.getValues()[i];\n+        // TODO: sanity check the descriptors:\n+        // * check if they're valid descriptors\n+        // * check that it's the fingerprint we asked for\n+        // * check it's the deriviation path we asked for",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242620899",
      "id" : 242620899,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYyMDg5OQ==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 779,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 186176286,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242620899",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242621312"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242621312"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Unused?",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2018-12-18T16:58:46Z",
      "diff_hunk" : "@@ -4113,6 +4166,111 @@ UniValue walletcreatefundedpsbt(const JSONRPCRequest& request)\n     return result;\n }\n \n+static UniValue enumeratesigners(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() != 0) {\n+        throw std::runtime_error(\n+            \"enumeratesigners\\n\"\n+            \"Returns a list of external signers from -signer and associates them\\n\"\n+            \"with the wallet until you stop bitcoind.\\n\"\n+            \"{\\n\"\n+            \"  \\\"signers\\\" : [                                (json array of objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"masterkeyfingerprint\\\" : \\\"fingerprint\\\" (string) Master key fingerprint\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+        );\n+    }\n+\n+    const std::string command = gArgs.GetArg(\"-signer\", DEFAULT_EXTERNAL_SIGNER);\n+    if (command == \"\") throw JSONRPCError(RPC_WALLET_ERROR, \"Error: restart bitcoind with -signer=<cmd>\");\n+    std::string chain = gArgs.GetChainName();\n+    const bool mainnet = chain == CBaseChainParams::MAIN;\n+    UniValue signers;\n+    try {\n+        signers = ExternalSigner::Enumerate(command, pwallet->m_external_signers, mainnet);\n+    } catch (const ExternalSignerException& e) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, e.what());\n+    }\n+    UniValue result(UniValue::VOBJ);\n+    result.pushKV(\"signers\", signers);\n+    return result;\n+}\n+\n+static UniValue signerdisplayaddress(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.empty() || request.params.size() > 1) {\n+        throw std::runtime_error(\n+            \"signerdisplayaddress\\n\"\n+            \"Display address on an external signer for verification.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"address\\\"       (string, required) The bitcoin address to display.\\n\"\n+            \"2. \\\"fingerprint\\\"   (string, optional) Master key fingerprint of signer\\n\"\n+        );\n+    }\n+\n+    ExternalSigner *signer = GetSignerForJSONRPCRequest(request, 1, pwallet);\n+\n+    LOCK(pwallet->cs_wallet);\n+\n+    UniValue ret(UniValue::VOBJ);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242621312",
      "id" : 242621312,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYyMTMxMg==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 208,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 186176818,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242621312",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Great work!\r\nI think the signer API (calling an external script/application) seems fine. We should make sure all calls are non-blocking sync it could be, that the signer application has a GUI and requires user interaction on all non-obvious commands like \"displayaddress\". Also, the device could require initialisation which could be triggered by a first display/sign command.",
      "created_at" : "2018-12-18T19:12:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#issuecomment-448335664",
      "id" : 448335664,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14912",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0ODMzNTY2NA==",
      "updated_at" : "2018-12-18T19:12:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/448335664",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r243240204"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243240204"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Thanks, I'll look into how that's supposed to work...",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2018-12-20T11:32:33Z",
      "diff_hunk" : "@@ -24,6 +25,17 @@ void RegisterWalletRPCCommands(CRPCTable &t);\n  */\n std::shared_ptr<CWallet> GetWalletForJSONRPCRequest(const JSONRPCRequest& request);\n \n+/**\n+ * Figures out what external signer to use for a JSONRPCRequest.\n+ *\n+ * @param[in] request JSONRPCRequest that wishes to access a signer\n+ * @param[pos] which argument contains the signer fingerprint. Optional, returns the first signer otherwise\n+ * @param[pwallet] the wallet",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r243240204",
      "id" : 243240204,
      "in_reply_to_id" : 242604518,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MzI0MDIwNA==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 17,
      "path" : "src/wallet/rpcwallet.h",
      "position" : null,
      "pull_request_review_id" : 186955536,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243240204",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r243240638"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243240638"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The compiler didn't like it when I initialized using `gArgs.GetArg`.",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2018-12-20T11:34:16Z",
      "diff_hunk" : "@@ -1263,3 +1444,145 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n \n     return response;\n }\n+\n+UniValue signerfetchkeys(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() > 1) {\n+        throw std::runtime_error(\n+            \"signerfetchkeys ( fingerprint )\\n\"\n+            \"Obtains keys from external signer and imports them into the wallet.\\n\"\n+            \"Call enumeratesigners before using this.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"fingerprint\\\"   (string, optional) Master key fingerprint of signer\\n\"\n+            \"\\nResult (same as for importmulti):\\n\"\n+            \"[{ \\\"success\\\": true }\"\n+        );\n+    }\n+\n+    ExternalSigner *signer = GetSignerForJSONRPCRequest(request, 0, pwallet);\n+\n+    UniValue descriptors = UniValue(UniValue::VARR);\n+    std::string desc_prefix = \"\";\n+    std::string desc_suffix = \"\";\n+    std::string purpose = \"\";\n+    switch(pwallet->m_default_address_type) {\n+        case OutputType::LEGACY: {\n+            desc_prefix = \"pkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"44h\";\n+            break;\n+        }\n+        case OutputType::P2SH_SEGWIT: {\n+            desc_prefix = \"sh(wpkh(\";\n+            desc_suffix = \"))\";\n+            purpose = \"49h\";\n+            break;\n+        }\n+        case OutputType::BECH32: {\n+            desc_prefix = \"wpkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"84h\";\n+            break;\n+        }\n+        case OutputType::CHANGE_AUTO: {\n+            assert(false);\n+        }\n+    }\n+\n+    const std::string receive_desc = desc_prefix + signer->m_fingerprint + \"/\" + purpose + \"/\" + (signer->m_mainnet ? \"0h\" : \"1h\") + \"/0h/0/*\" + desc_suffix;\n+    UniValue receive_descriptors = signer->getKeys(receive_desc);\n+    if (!receive_descriptors.isArray()) JSONRPCError(RPC_WALLET_ERROR, \"Expected an array of receive descriptors\");\n+    for (const UniValue& descriptor : receive_descriptors.getValues()) {\n+        descriptors.push_back(descriptor);\n+    }\n+\n+\n+    switch(pwallet->m_default_change_type) {\n+        case OutputType::LEGACY: {\n+            desc_prefix = \"pkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"44h\";\n+            break;\n+        }\n+        case OutputType::P2SH_SEGWIT: {\n+            desc_prefix = \"sh(wpkh(\";\n+            desc_suffix = \"))\";\n+            purpose = \"49h\";\n+            break;\n+        }\n+        case OutputType::BECH32: {\n+            desc_prefix = \"wpkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"84h\";\n+            break;\n+        }\n+        case OutputType::CHANGE_AUTO: {\n+            // Use same values as for receive descriptor\n+            break;\n+        }\n+    }\n+\n+    const std::string change_desc = desc_prefix + signer->m_fingerprint + \"/\" + purpose + \"/\" + (signer->m_mainnet ? \"0h\" : \"1h\") + \"/0h/1/*\" + desc_suffix;\n+    UniValue change_descriptors = signer->getKeys(change_desc);\n+    if (!change_descriptors.isArray()) JSONRPCError(RPC_WALLET_ERROR, \"Expected an array of change descriptors\");\n+    for (const UniValue& descriptor : change_descriptors.getValues()) {\n+        descriptors.push_back(descriptor);\n+    }\n+\n+    if (receive_descriptors.size() != change_descriptors.size()) JSONRPCError(RPC_WALLET_ERROR, \"Expected same number of receive and change descriptors\");\n+\n+    // Use importmulti to process the descriptors:\n+    UniValue importdata(UniValue::VARR);\n+\n+    uint64_t keypool_target_size = 0;\n+    keypool_target_size = gArgs.GetArg(\"-keypool\", DEFAULT_KEYPOOL_SIZE);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r243240638",
      "id" : 243240638,
      "in_reply_to_id" : 242606739,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MzI0MDYzOA==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 770,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 186956063,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243240638",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r243241046"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243241046"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This is straight from stack overflow, so certainly needs more review... I'm surprised how complicated it is to just read some JSON from `stdout`.",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2018-12-20T11:35:50Z",
      "diff_hunk" : "@@ -1198,6 +1200,24 @@ void runCommand(const std::string& strCommand)\n         LogPrintf(\"runCommand error: system(%s) returned %d\\n\", strCommand, nErr);\n }\n \n+UniValue runCommandParseJSON(const std::string& strCommand)\n+{\n+    if (strCommand.empty()) return UniValue::VNULL;\n+\n+    std::array<char, 128> buffer;\n+    std::string result;\n+    std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(strCommand.c_str(), \"r\"), pclose);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r243241046",
      "id" : 243241046,
      "in_reply_to_id" : 242612528,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MzI0MTA0Ng==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 22,
      "path" : "src/util/system.cpp",
      "position" : null,
      "pull_request_review_id" : 186956559,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/243241046",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@jonasschnelli I have a idea on how to allow asynchronous interaction. That also makes sense if  you're using an online service with a 48 hour cool down period.\r\n\r\nThe `signtransaction` command (called by `processpsbt` in this PR) could take an optional ephemeral public key argument. The commands then immediately returns with a UUID and a timestamp for when the client should come back. We could then add a `polltransaction` command which takes the UUID and returns the encrypted transaction (or nothing), encrypted using the ephemeral public key. This would involve making the wallet aware of pending transactions, and perhaps an additional RPC call like `walletprocesspendingtransactions`.\r\n\r\nDevice initialization could be a new RPC call, and other calls would just throw an error if not initialized. The `enumeratesigners` call can return more information about the device, such as the initialization status.",
      "created_at" : "2018-12-20T11:44:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#issuecomment-448970210",
      "id" : 448970210,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14912",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0ODk3MDIxMA==",
      "updated_at" : "2018-12-20T11:46:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/448970210",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2018-12-24T12:21:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#issuecomment-449727634",
      "id" : 449727634,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14912",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0OTcyNzYzNA==",
      "updated_at" : "2018-12-24T12:21:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/449727634",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r249118973"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/249118973"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Upstream",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2019-01-18T17:10:24Z",
      "diff_hunk" : "@@ -119,9 +126,13 @@ def get_multisig(self):\n                         CScript([OP_HASH160, witness_script, OP_EQUAL]).hex(),  # p2sh-p2wsh\n                         script_to_p2sh_p2wsh(script_code))  # p2sh-p2wsh addr\n \n-    def test_importmulti(self, req, success, error_code=None, error_message=None):\n+    def test_importmulti(self, req, success, error_code=None, error_message=None, warnings=[]):\n         \"\"\"Run importmulti and assert success\"\"\"\n         result = self.nodes[1].importmulti([req])\n+        observed_warnings = []\n+        if 'warnings' in result[0]:\n+           observed_warnings = result[0]['warnings']",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r249118973",
      "id" : 249118973,
      "in_reply_to_id" : 242619836,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0OTExODk3Mw==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 24,
      "path" : "test/functional/wallet_importmulti.py",
      "position" : null,
      "pull_request_review_id" : 194196156,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/249118973",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r249119860"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/249119860"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Upstream",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2019-01-18T17:13:22Z",
      "diff_hunk" : "@@ -836,246 +837,419 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n-\n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+struct ImportData\n {\n-    try {\n-        // First ensure scriptPubKey has either a script or JSON with \"address\" string\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n-        }\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n-\n-        // Generate the script and destination for the scriptPubKey provided\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //!< Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //!< Provided witnessScript; will be moved to `import_scripts` if relevant.\n \n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n-        }\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::map<CKeyID, bool> used_keys; //!< Import these private keys if available (the value indicates whether if the key is required for solvability)\n+    std::map<CKeyID, KeyOriginInfo> key_origins;\n+};\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided scriptPubKey, determining which keys and which redeem scripts from the ImportData struct are needed to spend it, and mark them as used.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& import_data, const ScriptContext script_ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        import_data.used_keys.emplace(pubkey.GetID(), false);\n+        return \"\";\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.used_keys[id] = true;\n+        return \"\";\n+    }\n+    case TX_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::P2SH) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside another P2SH\");\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside a P2WSH\");\n+        assert(script_ctx == ScriptContext::TOP);\n+        CScriptID id = CScriptID(uint160(solverdata[0]));\n+        auto subscript = std::move(import_data.redeemscript);\n+        if (!subscript) return \"missing redeemscript\";\n+        if (CScriptID(*subscript) != id) return \"redeemScript does not match the scriptPubKey\";\n+        import_data.import_scripts.emplace(*subscript);\n+        return RecurseImportData(*subscript, import_data, ScriptContext::P2SH);\n+    }\n+    case TX_MULTISIG: {\n+        for (size_t i = 1; i + 1< solverdata.size(); ++i) {\n+            CPubKey pubkey(solverdata[i].begin(), solverdata[i].end());\n+            import_data.used_keys.emplace(pubkey.GetID(), false);\n         }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        return \"\";\n+    }\n+    case TX_WITNESS_V0_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WSH inside another P2WSH\");\n+        uint256 fullid(solverdata[0]);\n+        CScriptID id;\n+        CRIPEMD160().Write(fullid.begin(), fullid.size()).Finalize(id.begin());\n+        auto subscript = std::move(import_data.witnessscript);\n+        if (!subscript) return \"missing witnessscript\";\n+        if (CScriptID(*subscript) != id) return \"witnessScript does not match the scriptPubKey or redeemScript\";\n+        if (script_ctx == ScriptContext::TOP) {\n+            import_data.import_scripts.emplace(script); // Special rule for IsMine: native P2WSH requires the TOP script imported (see script/ismine.cpp)\n         }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n+        import_data.import_scripts.emplace(*subscript);\n+        return RecurseImportData(*subscript, import_data, ScriptContext::WITNESS_V0);\n+    }\n+    case TX_WITNESS_V0_KEYHASH: {\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WPKH inside P2WSH\");\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.used_keys[id] = true;\n+        if (script_ctx == ScriptContext::TOP) {\n+            import_data.import_scripts.emplace(script); // Special rule for IsMine: native P2WPKH requires the TOP script imported (see script/ismine.cpp)\n         }\n+        return \"\";\n+    }\n+    case TX_NULL_DATA:\n+        return \"unspendable script\";\n+    case TX_NONSTANDARD:\n+    case TX_WITNESS_UNKNOWN:\n+    default:\n+        return \"unrecognized script\";\n+    }\n+}\n \n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n-            if (!IsHex(strRedeemScript)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n-            }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n+static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data, std::vector<CKeyID>& ordered_pubkeys)\n+{\n+    UniValue warnings(UniValue::VARR);\n \n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n         }\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n+        }\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n+        }\n+    }\n+    script_pub_keys.emplace(script);\n \n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n-            }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n+    // Parse all arguments\n+    if (strRedeemScript.size()) {\n+        if (!IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n+        }\n+        auto parsed_redeemscript = ParseHex(strRedeemScript);\n+        import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    }\n+    if (witness_script_hex.size()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n+        }\n+        auto parsed_witnessscript = ParseHex(witness_script_hex);\n+        import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+    }\n+    for (size_t i = 0; i < pubKeys.size(); ++i) {\n+        const auto& str = pubKeys[i].get_str();\n+        if (!IsHex(str)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n+        }\n+        auto parsed_pubkey = ParseHex(str);\n+        CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+        if (!pubkey.IsFullyValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n+        }\n+        pubkey_map.emplace(pubkey.GetID(), pubkey);\n+        ordered_pubkeys.push_back(pubkey.GetID());\n+    }\n+    for (size_t i = 0; i < keys.size(); ++i) {\n+        const auto& str = keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n+        if (pubkey_map.count(id)) {\n+            pubkey_map.erase(id);\n+        }\n+        privkey_map.emplace(id, key);\n+    }\n \n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n+    // Verify and process input data\n+    have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();\n+    if (have_solving_data) {\n+        // Match up data in import_data with the scriptPubKey in script.\n+        auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n \n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        // Verify whether the watchonly option corresponds to the availability of private keys.\n+        bool spendable = std::all_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const std::pair<CKeyID, bool>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+        if (!watchOnly && !spendable) {\n+            warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n+        }\n+        if (watchOnly && spendable) {\n+            warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n+        }\n \n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        // Check that all required keys for solvability are provided.\n+        if (error.empty()) {\n+            for (const auto& require_key : import_data.used_keys) {\n+                if (!require_key.second) continue; // Not a required key\n+                if (pubkey_map.count(require_key.first) == 0 && privkey_map.count(require_key.first) == 0) {\n+                    error = \"some required keys are missing\";\n+                }\n             }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n         }\n \n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n-            }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n-            }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n-            }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+        if (!error.empty()) {\n+            warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+            import_data = ImportData();\n+            pubkey_map.clear();\n+            privkey_map.clear();\n+            have_solving_data = false;\n+        } else {\n+            // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+            if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+            if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+            for (auto it = privkey_map.begin(); it != privkey_map.end(); ) {\n+                auto oldit = it++;\n+                if (import_data.used_keys.count(oldit->first) == 0) {\n+                    warnings.push_back(\"Ignoring irrelevant private key.\");\n+                    privkey_map.erase(oldit);\n                 }\n-                pubkey = pubkey_temp;\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n+            for (auto it = pubkey_map.begin(); it != pubkey_map.end(); ) {\n+                auto oldit = it++;\n+                auto key_data_it = import_data.used_keys.find(oldit->first);\n+                if (key_data_it == import_data.used_keys.end() || !key_data_it->second) {\n+                    warnings.push_back(\"Ignoring public key \\\"\" + HexStr(oldit->first) + \"\\\" as it doesn't appear inside P2PKH or P2WPKH.\");\n+                    pubkey_map.erase(oldit);\n                 }\n+            }\n+        }\n+    }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n+    return warnings;\n+}\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n+static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data, std::vector<CKeyID>& ordered_pubkeys)\n+{\n+    UniValue warnings(UniValue::VARR);\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+    const std::string& descriptor = data[\"desc\"].get_str();\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n \n-                pwallet->MarkDirty();\n+    have_solving_data = parsed_desc->IsSolvable();\n+    const bool watch_only = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-            }\n+    int64_t range_start = 0, range_end = 0;\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange()) {\n+        if (!data.exists(\"range\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n         }\n-\n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        const UniValue& range = data[\"range\"];\n+        range_start = range.exists(\"start\") ? range[\"start\"].get_int64() : 0;\n+        if (!range.exists(\"end\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End of range for descriptor must be specified\");\n         }\n+        range_end = range[\"end\"].get_int64();\n+    }\n \n-        pwallet->MarkDirty();\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    // Expand all descriptors to get public keys and scripts.\n+    // TODO: get private keys from descriptors too\n+    for (int i = range_start; i <= range_end; ++i) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r249119860",
      "id" : 249119860,
      "in_reply_to_id" : 242605811,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0OTExOTg2MA==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 426,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 194197314,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/249119860",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r249119912"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/249119912"
         }
      },
      "author_association" : "MEMBER",
      "body" : "(fixed upstream)",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2019-01-18T17:13:34Z",
      "diff_hunk" : "@@ -836,246 +837,419 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n-\n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+struct ImportData\n {\n-    try {\n-        // First ensure scriptPubKey has either a script or JSON with \"address\" string\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n-        }\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n-\n-        // Generate the script and destination for the scriptPubKey provided\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //!< Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //!< Provided witnessScript; will be moved to `import_scripts` if relevant.\n \n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n-        }\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::map<CKeyID, bool> used_keys; //!< Import these private keys if available (the value indicates whether if the key is required for solvability)\n+    std::map<CKeyID, KeyOriginInfo> key_origins;\n+};\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided scriptPubKey, determining which keys and which redeem scripts from the ImportData struct are needed to spend it, and mark them as used.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& import_data, const ScriptContext script_ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        import_data.used_keys.emplace(pubkey.GetID(), false);\n+        return \"\";\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.used_keys[id] = true;\n+        return \"\";\n+    }\n+    case TX_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::P2SH) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside another P2SH\");\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside a P2WSH\");\n+        assert(script_ctx == ScriptContext::TOP);\n+        CScriptID id = CScriptID(uint160(solverdata[0]));\n+        auto subscript = std::move(import_data.redeemscript);\n+        if (!subscript) return \"missing redeemscript\";\n+        if (CScriptID(*subscript) != id) return \"redeemScript does not match the scriptPubKey\";\n+        import_data.import_scripts.emplace(*subscript);\n+        return RecurseImportData(*subscript, import_data, ScriptContext::P2SH);\n+    }\n+    case TX_MULTISIG: {\n+        for (size_t i = 1; i + 1< solverdata.size(); ++i) {\n+            CPubKey pubkey(solverdata[i].begin(), solverdata[i].end());\n+            import_data.used_keys.emplace(pubkey.GetID(), false);\n         }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        return \"\";\n+    }\n+    case TX_WITNESS_V0_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WSH inside another P2WSH\");\n+        uint256 fullid(solverdata[0]);\n+        CScriptID id;\n+        CRIPEMD160().Write(fullid.begin(), fullid.size()).Finalize(id.begin());\n+        auto subscript = std::move(import_data.witnessscript);\n+        if (!subscript) return \"missing witnessscript\";\n+        if (CScriptID(*subscript) != id) return \"witnessScript does not match the scriptPubKey or redeemScript\";\n+        if (script_ctx == ScriptContext::TOP) {\n+            import_data.import_scripts.emplace(script); // Special rule for IsMine: native P2WSH requires the TOP script imported (see script/ismine.cpp)\n         }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n+        import_data.import_scripts.emplace(*subscript);\n+        return RecurseImportData(*subscript, import_data, ScriptContext::WITNESS_V0);\n+    }\n+    case TX_WITNESS_V0_KEYHASH: {\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WPKH inside P2WSH\");\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.used_keys[id] = true;\n+        if (script_ctx == ScriptContext::TOP) {\n+            import_data.import_scripts.emplace(script); // Special rule for IsMine: native P2WPKH requires the TOP script imported (see script/ismine.cpp)\n         }\n+        return \"\";\n+    }\n+    case TX_NULL_DATA:\n+        return \"unspendable script\";\n+    case TX_NONSTANDARD:\n+    case TX_WITNESS_UNKNOWN:\n+    default:\n+        return \"unrecognized script\";\n+    }\n+}\n \n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n-            if (!IsHex(strRedeemScript)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n-            }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n+static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data, std::vector<CKeyID>& ordered_pubkeys)\n+{\n+    UniValue warnings(UniValue::VARR);\n \n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n         }\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n+        }\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n+        }\n+    }\n+    script_pub_keys.emplace(script);\n \n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n-            }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n+    // Parse all arguments\n+    if (strRedeemScript.size()) {\n+        if (!IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n+        }\n+        auto parsed_redeemscript = ParseHex(strRedeemScript);\n+        import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    }\n+    if (witness_script_hex.size()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n+        }\n+        auto parsed_witnessscript = ParseHex(witness_script_hex);\n+        import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+    }\n+    for (size_t i = 0; i < pubKeys.size(); ++i) {\n+        const auto& str = pubKeys[i].get_str();\n+        if (!IsHex(str)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n+        }\n+        auto parsed_pubkey = ParseHex(str);\n+        CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+        if (!pubkey.IsFullyValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n+        }\n+        pubkey_map.emplace(pubkey.GetID(), pubkey);\n+        ordered_pubkeys.push_back(pubkey.GetID());\n+    }\n+    for (size_t i = 0; i < keys.size(); ++i) {\n+        const auto& str = keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n+        if (pubkey_map.count(id)) {\n+            pubkey_map.erase(id);\n+        }\n+        privkey_map.emplace(id, key);\n+    }\n \n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n+    // Verify and process input data\n+    have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();\n+    if (have_solving_data) {\n+        // Match up data in import_data with the scriptPubKey in script.\n+        auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n \n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        // Verify whether the watchonly option corresponds to the availability of private keys.\n+        bool spendable = std::all_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const std::pair<CKeyID, bool>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+        if (!watchOnly && !spendable) {\n+            warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n+        }\n+        if (watchOnly && spendable) {\n+            warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n+        }\n \n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        // Check that all required keys for solvability are provided.\n+        if (error.empty()) {\n+            for (const auto& require_key : import_data.used_keys) {\n+                if (!require_key.second) continue; // Not a required key\n+                if (pubkey_map.count(require_key.first) == 0 && privkey_map.count(require_key.first) == 0) {\n+                    error = \"some required keys are missing\";\n+                }\n             }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n         }\n \n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n-            }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n-            }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n-            }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+        if (!error.empty()) {\n+            warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+            import_data = ImportData();\n+            pubkey_map.clear();\n+            privkey_map.clear();\n+            have_solving_data = false;\n+        } else {\n+            // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+            if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+            if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+            for (auto it = privkey_map.begin(); it != privkey_map.end(); ) {\n+                auto oldit = it++;\n+                if (import_data.used_keys.count(oldit->first) == 0) {\n+                    warnings.push_back(\"Ignoring irrelevant private key.\");\n+                    privkey_map.erase(oldit);\n                 }\n-                pubkey = pubkey_temp;\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n+            for (auto it = pubkey_map.begin(); it != pubkey_map.end(); ) {\n+                auto oldit = it++;\n+                auto key_data_it = import_data.used_keys.find(oldit->first);\n+                if (key_data_it == import_data.used_keys.end() || !key_data_it->second) {\n+                    warnings.push_back(\"Ignoring public key \\\"\" + HexStr(oldit->first) + \"\\\" as it doesn't appear inside P2PKH or P2WPKH.\");\n+                    pubkey_map.erase(oldit);\n                 }\n+            }\n+        }\n+    }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n+    return warnings;\n+}\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n+static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data, std::vector<CKeyID>& ordered_pubkeys)\n+{\n+    UniValue warnings(UniValue::VARR);\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+    const std::string& descriptor = data[\"desc\"].get_str();\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n \n-                pwallet->MarkDirty();\n+    have_solving_data = parsed_desc->IsSolvable();\n+    const bool watch_only = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-            }\n+    int64_t range_start = 0, range_end = 0;\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange()) {\n+        if (!data.exists(\"range\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n         }\n-\n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        const UniValue& range = data[\"range\"];\n+        range_start = range.exists(\"start\") ? range[\"start\"].get_int64() : 0;\n+        if (!range.exists(\"end\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End of range for descriptor must be specified\");\n         }\n+        range_end = range[\"end\"].get_int64();\n+    }\n \n-        pwallet->MarkDirty();\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    // Expand all descriptors to get public keys and scripts.\n+    // TODO: get private keys from descriptors too\n+    for (int i = range_start; i <= range_end; ++i) {\n+        FlatSigningProvider out_keys;\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        std::copy(scripts_temp.begin(), scripts_temp.end(), std::inserter(script_pub_keys, script_pub_keys.end()));\n+        for (const auto& key_pair : out_keys.pubkeys) {\n+            ordered_pubkeys.push_back(key_pair.first);\n+        }\n \n-        if (!pwallet->AddWatchOnly(scriptpubkey_script, timestamp)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        for (auto const& x : out_keys.scripts) {\n+            import_data.import_scripts.emplace(x.second);\n         }\n \n-        if (!watchOnly && !pwallet->HaveCScript(CScriptID(scriptpubkey_script)) && !pwallet->AddCScript(scriptpubkey_script)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding scriptPubKey script to wallet\");\n+        std::copy(out_keys.pubkeys.begin(), out_keys.pubkeys.end(), std::inserter(pubkey_map, pubkey_map.end()));\n+        std::copy(out_keys.origins.begin(), out_keys.origins.end(), std::inserter(import_data.key_origins, import_data.key_origins.end()));\n+    }\n+\n+    for (size_t i = 0; i < priv_keys.size(); ++i) {\n+        const auto& str = priv_keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n         }\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n \n-        // if not internal add to address book or update label\n-        if (!internal) {\n-            assert(IsValidDestination(scriptpubkey_dest));\n-            pwallet->SetAddressBook(scriptpubkey_dest, label, \"receive\");\n+        // Check if this private key corresponds to a public key from the descriptor\n+        if (!pubkey_map.count(id)) {\n+            warnings.push_back(\"Ignoring irrelevant private key.\");\n+        } else {\n+            privkey_map.emplace(id, key);\n         }\n+    }\n \n-        // Import private keys.\n-        for (size_t i = 0; i < keys.size(); i++) {\n-            const std::string& strPrivkey = keys[i].get_str();\n+    // Check if all the public keys have corresponding private keys in the import for spendability.\n+    // This does not take into account threshold multisigs which could be spendable without all keys\n+    bool spendable = std::all_of(pubkey_map.begin(), pubkey_map.end(), [&](const std::pair<CKeyID, CPubKey>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+    if (!watch_only && !spendable) {\n+        warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n+    }\n+    if (watch_only && spendable) {\n+        warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n+    }\n \n-            // Checks.\n-            CKey key = DecodeSecret(strPrivkey);\n+    return warnings;\n+}\n \n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-            }\n+static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    try {\n+        bool watch_only = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r249119912",
      "id" : 249119912,
      "in_reply_to_id" : 242606157,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0OTExOTkxMg==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 492,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 194197389,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/249119912",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I added a `signersend` RPC method which Just Works(tm) by combining the functionality of `walletcreatefundedpsbt`, `signerprocesspsbt`, `finalizepsbt` and `sendrawtransaction`. Updated the documentation.\r\n\r\nAddressed some of the nits. Still much to improve in terms of code quality, and I'm waiting on multiple upstream pull requests.\r\n\r\nThe most useful review at this point is to test the workflow. In addition, feedback on `runCommandParseJSON()` is welcome.\r\n\r\nSome things I plan to work on next:\r\n1. Create `wallet/rpcsigner.cpp` and move the various functions there; `wallet/rpcwallet.cpp` and `src/rpc/rpcdump.cpp` are already big enough\r\n2. Clean up the way I made `sendrawtransaction` reusable (I just noticed #14978 already does that)\r\n3. Incorporate #14978 (reusable PSBT code, I might wait for that to be merged)\r\n4. Similar to #14978, find a way to make this code reusable, so I can build GUI support in a followup PR",
      "created_at" : "2019-01-18T17:28:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#issuecomment-455624882",
      "id" : 455624882,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14912",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ1NTYyNDg4Mg==",
      "updated_at" : "2019-01-18T17:42:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/455624882",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased on the latest `hww` branch. Moved a bunch of things to `wallet/rpcsigner.cpp`.\r\n\r\n@ken2812221 any idea how I can make AppVeyor happy? My guess is that it doesn't like `runCommandParseJSON()` in `system.cpp`\r\n\r\n<img width=\"899\" alt=\"schermafbeelding 2019-01-19 om 19 08 39\" src=\"https://user-images.githubusercontent.com/10217/51430571-a5a20980-1c1d-11e9-87b4-f4dab92e4dc3.png\">\r\n",
      "created_at" : "2019-01-19T18:08:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#issuecomment-455802298",
      "id" : 455802298,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14912",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ1NTgwMjI5OA==",
      "updated_at" : "2019-01-19T18:08:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/455802298",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r249290295"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/249290295"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`popen` and `pclose` are unix-like only. You can't use them on Windows. IMO you could use boost process instead.",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2019-01-20T18:30:27Z",
      "diff_hunk" : "@@ -1198,6 +1200,24 @@ void runCommand(const std::string& strCommand)\n         LogPrintf(\"runCommand error: system(%s) returned %d\\n\", strCommand, nErr);\n }\n \n+UniValue runCommandParseJSON(const std::string& strCommand)\n+{\n+    if (strCommand.empty()) return UniValue::VNULL;\n+\n+    std::array<char, 128> buffer;\n+    std::string result;\n+    std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(strCommand.c_str(), \"r\"), pclose);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r249290295",
      "id" : 249290295,
      "in_reply_to_id" : 242612528,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0OTI5MDI5NQ==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 22,
      "path" : "src/util/system.cpp",
      "position" : null,
      "pull_request_review_id" : 194403831,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/249290295",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/11154118?v=4",
         "events_url" : "https://api.github.com/users/ken2812221/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ken2812221/followers",
         "following_url" : "https://api.github.com/users/ken2812221/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ken2812221/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ken2812221",
         "id" : 11154118,
         "login" : "ken2812221",
         "node_id" : "MDQ6VXNlcjExMTU0MTE4",
         "organizations_url" : "https://api.github.com/users/ken2812221/orgs",
         "received_events_url" : "https://api.github.com/users/ken2812221/received_events",
         "repos_url" : "https://api.github.com/users/ken2812221/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ken2812221/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ken2812221/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ken2812221"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r249290368"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/249290368"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think we don't depend on boost process.",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2019-01-20T18:32:30Z",
      "diff_hunk" : "@@ -1198,6 +1200,24 @@ void runCommand(const std::string& strCommand)\n         LogPrintf(\"runCommand error: system(%s) returned %d\\n\", strCommand, nErr);\n }\n \n+UniValue runCommandParseJSON(const std::string& strCommand)\n+{\n+    if (strCommand.empty()) return UniValue::VNULL;\n+\n+    std::array<char, 128> buffer;\n+    std::string result;\n+    std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(strCommand.c_str(), \"r\"), pclose);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r249290368",
      "id" : 249290368,
      "in_reply_to_id" : 242612528,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0OTI5MDM2OA==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 22,
      "path" : "src/util/system.cpp",
      "position" : null,
      "pull_request_review_id" : 194403895,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/249290368",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r249290710"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/249290710"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I know. But this is the simplest way if this is really necessary to call another process. I don't think that any one here know how to use Windows `CreateProcess` API.",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2019-01-20T18:43:02Z",
      "diff_hunk" : "@@ -1198,6 +1200,24 @@ void runCommand(const std::string& strCommand)\n         LogPrintf(\"runCommand error: system(%s) returned %d\\n\", strCommand, nErr);\n }\n \n+UniValue runCommandParseJSON(const std::string& strCommand)\n+{\n+    if (strCommand.empty()) return UniValue::VNULL;\n+\n+    std::array<char, 128> buffer;\n+    std::string result;\n+    std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(strCommand.c_str(), \"r\"), pclose);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r249290710",
      "id" : 249290710,
      "in_reply_to_id" : 242612528,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0OTI5MDcxMA==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 22,
      "path" : "src/util/system.cpp",
      "position" : null,
      "pull_request_review_id" : 194404207,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/249290710",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/11154118?v=4",
         "events_url" : "https://api.github.com/users/ken2812221/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ken2812221/followers",
         "following_url" : "https://api.github.com/users/ken2812221/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ken2812221/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ken2812221",
         "id" : 11154118,
         "login" : "ken2812221",
         "node_id" : "MDQ6VXNlcjExMTU0MTE4",
         "organizations_url" : "https://api.github.com/users/ken2812221/orgs",
         "received_events_url" : "https://api.github.com/users/ken2812221/received_events",
         "repos_url" : "https://api.github.com/users/ken2812221/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ken2812221/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ken2812221/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ken2812221"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r249681804"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/249681804"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`txhex` should be const ref?",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2019-01-22T08:37:10Z",
      "diff_hunk" : "@@ -1005,44 +1005,20 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n         \"Clients should transition to using signrawtransactionwithkey and signrawtransactionwithwallet\");\n }\n \n-static UniValue sendrawtransaction(const JSONRPCRequest& request)\n-{\n-    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw std::runtime_error(\n-            RPCHelpMan{\"sendrawtransaction\",\n-                \"\\nSubmits raw transaction (serialized, hex-encoded) to local node and network.\\n\"\n-                \"\\nAlso see createrawtransaction and signrawtransactionwithkey calls.\\n\",\n-                {\n-                    {\"hexstring\", RPCArg::Type::STR_HEX, /* opt */ false, /* default_val */ \"\", \"The hex string of the raw transaction\"},\n-                    {\"allowhighfees\", RPCArg::Type::BOOL, /* opt */ true, /* default_val */ \"false\", \"Allow high fees\"},\n-                }}\n-                .ToString() +\n-            \"\\nResult:\\n\"\n-            \"\\\"hex\\\"             (string) The transaction hash in hex\\n\"\n-            \"\\nExamples:\\n\"\n-            \"\\nCreate a transaction\\n\"\n-            + HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\" : \\\\\\\"mytxid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"{\\\\\\\"myaddress\\\\\\\":0.01}\\\"\") +\n-            \"Sign the transaction, and get back the hex\\n\"\n-            + HelpExampleCli(\"signrawtransactionwithwallet\", \"\\\"myhex\\\"\") +\n-            \"\\nSend the transaction (signed hex)\\n\"\n-            + HelpExampleCli(\"sendrawtransaction\", \"\\\"signedhex\\\"\") +\n-            \"\\nAs a JSON-RPC call\\n\"\n-            + HelpExampleRpc(\"sendrawtransaction\", \"\\\"signedhex\\\"\")\n-        );\n-\n+std::string sendrawtransaction(std::string txhex, bool allowhighfees) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r249681804",
      "id" : 249681804,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0OTY4MTgwNA==",
      "original_commit_id" : "5297b78e7929d7c74727a1f41a4cf85a180b7b08",
      "original_position" : 29,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 194884550,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/249681804",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r249682373"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/249682373"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`error` shadows function `error` from L62 in `src/util/system.h`.",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2019-01-22T08:39:13Z",
      "diff_hunk" : "@@ -0,0 +1,595 @@\n+// Copyright (c) 2018-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparamsbase.h>\n+#include <core_io.h>\n+#include <key_io.h>\n+#include <rpc/rawtransaction.h>\n+#include <rpc/server.h>\n+#include <rpc/util.h>\n+#include <script/descriptor.h>\n+#include <validation.h>\n+#include <wallet/rpcdump.h>\n+#include <wallet/rpcwallet.h>\n+\n+\n+#include <univalue.h>\n+\n+static UniValue enumeratesigners(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() != 0) {\n+        throw std::runtime_error(\n+            \"enumeratesigners\\n\"\n+            \"Returns a list of external signers from -signer and associates them\\n\"\n+            \"with the wallet until you stop bitcoind.\\n\"\n+            \"{\\n\"\n+            \"  \\\"signers\\\" : [                                (json array of objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"masterkeyfingerprint\\\" : \\\"fingerprint\\\" (string) Master key fingerprint\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+        );\n+    }\n+\n+    const std::string command = gArgs.GetArg(\"-signer\", DEFAULT_EXTERNAL_SIGNER);\n+    if (command == \"\") throw JSONRPCError(RPC_WALLET_ERROR, \"Error: restart bitcoind with -signer=<cmd>\");\n+    std::string chain = gArgs.GetChainName();\n+    const bool mainnet = chain == CBaseChainParams::MAIN;\n+    UniValue signers;\n+    try {\n+        signers = ExternalSigner::Enumerate(command, pwallet->m_external_signers, mainnet);\n+    } catch (const ExternalSignerException& e) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, e.what());\n+    }\n+    UniValue result(UniValue::VOBJ);\n+    result.pushKV(\"signers\", signers);\n+    return result;\n+}\n+\n+ExternalSigner *GetSignerForJSONRPCRequest(const JSONRPCRequest& request, int index, CWallet* pwallet) {\n+    if (pwallet->m_external_signers.empty()) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"First call enumeratesigners\");\n+    }\n+\n+    // If no fingerprint is specified, return the only available signer\n+    if (request.params.size() < size_t(index + 1) || request.params[index].isNull()) {\n+        if (pwallet->m_external_signers.size() > 1) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Multiple signers found, please specify which to use\");\n+        }\n+        return &pwallet->m_external_signers.front();\n+    }\n+\n+    const std::string fingerprint = request.params[index].get_str();\n+    for (ExternalSigner &candidate : pwallet->m_external_signers) {\n+        if (candidate.m_fingerprint == fingerprint) return &candidate;\n+    }\n+    throw JSONRPCError(RPC_WALLET_ERROR, \"Signer fingerprint not found\");\n+}\n+\n+UniValue signerdissociate(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() > 1) {\n+        throw std::runtime_error(\n+            \"signerdissociate ( fingerprint )\\n\"\n+            \"Disossociates external signer from the wallet.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"fingerprint\\\"   (string, optional) Master key fingerprint of signer\\n\"\n+        );\n+    }\n+\n+    ExternalSigner *signer = GetSignerForJSONRPCRequest(request, 0, pwallet);\n+\n+    assert(signer != nullptr);\n+    std::vector<ExternalSigner>::iterator position = std::find(pwallet->m_external_signers.begin(), pwallet->m_external_signers.end(), *signer);\n+    if (position != pwallet->m_external_signers.end()) pwallet->m_external_signers.erase(position);\n+\n+    return NullUniValue;\n+}\n+\n+static UniValue signerdisplayaddress(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.empty() || request.params.size() > 2) {\n+        throw std::runtime_error(\n+            \"signerdisplayaddress\\n\"\n+            \"Display address on an external signer for verification.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"address\\\"       (string, required) The bitcoin address to display.\\n\"\n+            \"2. \\\"fingerprint\\\"   (string, optional) Master key fingerprint of signer\\n\"\n+        );\n+    }\n+\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    ExternalSigner *signer = GetSignerForJSONRPCRequest(request, 1, pwallet);\n+\n+    LOCK(pwallet->cs_wallet);\n+\n+    CTxDestination dest = DecodeDestination(request.params[0].get_str());\n+\n+    // Make sure the destination is valid\n+    if (!IsValidDestination(dest)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+    }\n+\n+    const CKeyMetadata* meta = nullptr;\n+    CKeyID key_id = GetKeyForDestination(*pwallet, dest);\n+    if (!key_id.IsNull()) {\n+        auto it = pwallet->mapKeyMetadata.find(key_id);\n+        if (it != pwallet->mapKeyMetadata.end()) {\n+            meta = &it->second;\n+        }\n+    }\n+    // TODO: use inferred descriptor (preferably with xpub at the account level)\n+    CScript scriptPubKey = GetScriptForDestination(dest);\n+    if (!meta) {\n+        auto it = pwallet->m_script_metadata.find(CScriptID(scriptPubKey));\n+        if (it != pwallet->m_script_metadata.end()) {\n+            meta = &it->second;\n+        }\n+    }\n+    if (!meta || meta->key_origin.IsNull()) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Missing BIP32 derivation data\");\n+    }\n+\n+    std::string path = meta->hdKeypath;\n+    path.erase(0,2); // Unsafe, but to be replaced with inferred descriptor\n+\n+    KeyOriginInfo info;\n+    if (!pwallet->GetKeyOrigin(key_id, info)) {\n+        throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+    }\n+\n+    bool solvable = IsSolvable(*pwallet, scriptPubKey);\n+    if (!solvable) {\n+        throw JSONRPCError(RPC_INTERNAL_ERROR, \"Address is not solvable\");\n+    }\n+\n+    std::string inferredDescriptor = InferDescriptor(scriptPubKey, *pwallet)->ToString();\n+\n+    // TODO: Use the inferred descriptor directly. Unfortunately it's currently\n+    //       not useful (or is it??).\n+\n+    std::string prefix = \"\";\n+    std::string postfix = \"\";\n+\n+    if (inferredDescriptor.find(\"wpkh\") == 0) {\n+        prefix = \"wpkh(\";\n+        postfix = \")\";\n+    } else if (inferredDescriptor.find(\"sh(wpkh\") == 0) {\n+        prefix = \"sh(wpkh(\";\n+        postfix = \"))\";\n+    } else if (inferredDescriptor.find(\"pkh\") == 0) {\n+        prefix = \"pkh(\";\n+        postfix = \")\";\n+    } else {\n+        throw JSONRPCError(RPC_INTERNAL_ERROR, \"Unable to produce descriptor\");\n+    }\n+    std::string descriptor = prefix + strprintf(\"%08x/\", ReadBE32(info.fingerprint)) + WriteHDKeypath(info.path).erase(0,2) + postfix;\n+    signer->displayAddress(descriptor);\n+\n+    return UniValue(UniValue::VNULL);\n+}\n+\n+UniValue signerfetchkeys(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() > 1) {\n+        throw std::runtime_error(\n+            \"signerfetchkeys ( fingerprint )\\n\"\n+            \"Obtains keys from external signer and imports them into the wallet.\\n\"\n+            \"Call enumeratesigners before using this.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"fingerprint\\\"   (string, optional) Master key fingerprint of signer\\n\"\n+            \"\\nResult (same as for importmulti):\\n\"\n+            \"[{ \\\"success\\\": true }\"\n+        );\n+    }\n+\n+    ExternalSigner *signer = GetSignerForJSONRPCRequest(request, 0, pwallet);\n+\n+    UniValue descriptors = UniValue(UniValue::VARR);\n+    std::string desc_prefix = \"\";\n+    std::string desc_suffix = \"\";\n+    std::string purpose = \"\";\n+    switch(pwallet->m_default_address_type) {\n+        case OutputType::LEGACY: {\n+            desc_prefix = \"pkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"44h\";\n+            break;\n+        }\n+        case OutputType::P2SH_SEGWIT: {\n+            desc_prefix = \"sh(wpkh(\";\n+            desc_suffix = \"))\";\n+            purpose = \"49h\";\n+            break;\n+        }\n+        case OutputType::BECH32: {\n+            desc_prefix = \"wpkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"84h\";\n+            break;\n+        }\n+        case OutputType::CHANGE_AUTO: {\n+            assert(false);\n+        }\n+    }\n+\n+    const std::string receive_desc = desc_prefix + signer->m_fingerprint + \"/\" + purpose + \"/\" + (signer->m_mainnet ? \"0h\" : \"1h\") + \"/0h/0/*\" + desc_suffix;\n+    UniValue receive_descriptors = signer->getKeys(receive_desc);\n+    if (!receive_descriptors.isArray()) JSONRPCError(RPC_WALLET_ERROR, \"Expected an array of receive descriptors\");\n+    for (const UniValue& descriptor : receive_descriptors.getValues()) {\n+        descriptors.push_back(descriptor);\n+    }\n+\n+\n+    switch(pwallet->m_default_change_type) {\n+        case OutputType::LEGACY: {\n+            desc_prefix = \"pkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"44h\";\n+            break;\n+        }\n+        case OutputType::P2SH_SEGWIT: {\n+            desc_prefix = \"sh(wpkh(\";\n+            desc_suffix = \"))\";\n+            purpose = \"49h\";\n+            break;\n+        }\n+        case OutputType::BECH32: {\n+            desc_prefix = \"wpkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"84h\";\n+            break;\n+        }\n+        case OutputType::CHANGE_AUTO: {\n+            // Use same values as for receive descriptor\n+            break;\n+        }\n+    }\n+\n+    const std::string change_desc = desc_prefix + signer->m_fingerprint + \"/\" + purpose + \"/\" + (signer->m_mainnet ? \"0h\" : \"1h\") + \"/0h/1/*\" + desc_suffix;\n+    UniValue change_descriptors = signer->getKeys(change_desc);\n+    if (!change_descriptors.isArray()) JSONRPCError(RPC_WALLET_ERROR, \"Expected an array of change descriptors\");\n+    for (const UniValue& descriptor : change_descriptors.getValues()) {\n+        descriptors.push_back(descriptor);\n+    }\n+\n+    if (receive_descriptors.size() != change_descriptors.size()) JSONRPCError(RPC_WALLET_ERROR, \"Expected same number of receive and change descriptors\");\n+\n+    // Use importmulti to process the descriptors:\n+    UniValue importdata(UniValue::VARR);\n+\n+    uint64_t keypool_target_size = 0;\n+    keypool_target_size = gArgs.GetArg(\"-keypool\", DEFAULT_KEYPOOL_SIZE);\n+\n+    if (keypool_target_size == 0) JSONRPCError(RPC_WALLET_ERROR, \"-keypool must be > 0\");\n+\n+    for (unsigned int i = 0; i < descriptors.size(); ++i) {\n+        const UniValue& descriptor = descriptors.getValues()[i];\n+        // TODO: sanity check the descriptors:\n+        // * check if they're valid descriptors\n+        // * check that it's the fingerprint we asked for\n+        // * check it's the deriviation path we asked for\n+        UniValue key_data(UniValue::VOBJ);\n+        key_data.pushKV(\"desc\", descriptor);\n+        if (receive_descriptors.size() == 1) {\n+            // TODO: check that the descriptor is ranged\n+            UniValue range(UniValue::VOBJ);\n+            // TODO: base range start and end on what's currently in the keypool\n+            range.pushKV(\"start\", 0);\n+            range.pushKV(\"end\", keypool_target_size - 1);\n+            key_data.pushKV(\"range\", range);\n+        } else {\n+            // TODO: check that the descriptor is not ranged\n+        }\n+        if (i >= receive_descriptors.size()) {\n+            key_data.pushKV(\"internal\", true);\n+        }\n+        key_data.pushKV(\"keypool\", true);\n+        key_data.pushKV(\"watchonly\", true);\n+        importdata.push_back(key_data);\n+    }\n+\n+    UniValue result(UniValue::VARR);\n+    {\n+        auto locked_chain = pwallet->chain().lock();\n+        int64_t now = chainActive.Tip() ? chainActive.Tip()->GetMedianTimePast() : 0;\n+        LOCK(pwallet->cs_wallet);\n+        EnsureWalletIsUnlocked(pwallet);\n+        for (const UniValue& data : importdata.getValues()) {\n+            // TODO: prevent inserting the same key twice\n+            result.push_back(ProcessImport(pwallet, data, now));\n+        }\n+    }\n+\n+    return result;\n+}\n+\n+bool signer_process_psbt(ExternalSigner *signer, PartiallySignedTransaction &psbtx) {\n+    assert(signer != nullptr);\n+\n+    // Check if signer fingerpint matches any input master key fingerprint\n+    bool match = false;\n+    for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {\n+        const PSBTInput& input = psbtx.inputs[i];\n+        for (auto entry : input.hd_keypaths) {\n+            if (signer->m_fingerprint == strprintf(\"%08x\", ReadBE32(entry.second.fingerprint))) match = true;\n+        }\n+    }\n+\n+    if (!match) JSONRPCError(RPC_WALLET_ERROR, \"Signer fingerprint does not match any of the inputs\");\n+\n+    // Serialize the PSBT\n+    // TODO: ExternalSigner signTransaction should take PartiallySignedTransaction argument and serialize that\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+\n+    const UniValue signer_result = signer->signTransaction(EncodeBase64(ssTx.str()));\n+    if (!find_value(signer_result, \"psbt\").isStr()) JSONRPCError(RPC_WALLET_ERROR, \"Unexpected result from signer\");\n+\n+    // Process result from signer:\n+    std::string signer_psbt_error;\n+    PartiallySignedTransaction signer_psbtx;\n+    if (!DecodePSBT(signer_psbtx, find_value(signer_result, \"psbt\").get_str(), signer_psbt_error)) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", signer_psbt_error));\n+    }\n+\n+    // TODO: deduplicate completeness check from finalizepsbt:\n+    // Finalize input signatures -- in case we have partial signatures that add up to a complete\n+    //   signature, but have not combined them yet (e.g. because the combiner that created this\n+    //   PartiallySignedTransaction did not understand them), this will combine them into a final\n+    //   script.\n+    bool complete = true;\n+    for (unsigned int i = 0; i < signer_psbtx.tx->vin.size(); ++i) {\n+        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, signer_psbtx, i, SIGHASH_ALL); // Or use SIGHASH type in the PSBT??\n+    }\n+\n+    psbtx = signer_psbtx;\n+\n+    return complete;\n+}\n+\n+UniValue signerprocesspsbt(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            RPCHelpMan{\"signerprocesspsbt\",\n+                \"\\nSign PSBT inputs using external signer\\n\"\n+                \"that we can sign for.\" +\n+                    HelpRequiringPassphrase(pwallet) + \"\\n\",\n+                {\n+                    {\"psbt\", RPCArg::Type::STR, /* opt */ false, /* default_val */ \"\", \"The transaction base64 string\"},\n+                    {\"fingerprint\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"\", \"master key fingerprint of signer\"},\n+                }}\n+                .ToString() +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"psbt\\\" : \\\"value\\\",          (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"signerprocesspsbt\", \"\\\"psbt\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VSTR});\n+\n+    // Unserialize the transaction\n+    PartiallySignedTransaction psbtx;\n+    std::string error;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r249682373",
      "id" : 249682373,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0OTY4MjM3Mw==",
      "original_commit_id" : "5297b78e7929d7c74727a1f41a4cf85a180b7b08",
      "original_position" : 416,
      "path" : "src/wallet/rpcsigner.cpp",
      "position" : 402,
      "pull_request_review_id" : 194885215,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/249682373",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r249693754"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/249693754"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`compare` is more efficient than `find` when checking prefixes, right?\r\n\r\nWhat about `StartsWith(inferredDescriptor, \"wpkh\")` instead?\r\n\r\n```\r\nstatic inline bool StartsWith(const std::string& input, const std::string& prefix) {\r\n    return input.size() >= prefix.size() && input.compare(0, prefix.size(), prefix) == 0;\r\n}\r\n```",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2019-01-22T09:13:33Z",
      "diff_hunk" : "@@ -0,0 +1,595 @@\n+// Copyright (c) 2018-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparamsbase.h>\n+#include <core_io.h>\n+#include <key_io.h>\n+#include <rpc/rawtransaction.h>\n+#include <rpc/server.h>\n+#include <rpc/util.h>\n+#include <script/descriptor.h>\n+#include <validation.h>\n+#include <wallet/rpcdump.h>\n+#include <wallet/rpcwallet.h>\n+\n+\n+#include <univalue.h>\n+\n+static UniValue enumeratesigners(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() != 0) {\n+        throw std::runtime_error(\n+            \"enumeratesigners\\n\"\n+            \"Returns a list of external signers from -signer and associates them\\n\"\n+            \"with the wallet until you stop bitcoind.\\n\"\n+            \"{\\n\"\n+            \"  \\\"signers\\\" : [                                (json array of objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"masterkeyfingerprint\\\" : \\\"fingerprint\\\" (string) Master key fingerprint\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+        );\n+    }\n+\n+    const std::string command = gArgs.GetArg(\"-signer\", DEFAULT_EXTERNAL_SIGNER);\n+    if (command == \"\") throw JSONRPCError(RPC_WALLET_ERROR, \"Error: restart bitcoind with -signer=<cmd>\");\n+    std::string chain = gArgs.GetChainName();\n+    const bool mainnet = chain == CBaseChainParams::MAIN;\n+    UniValue signers;\n+    try {\n+        signers = ExternalSigner::Enumerate(command, pwallet->m_external_signers, mainnet);\n+    } catch (const ExternalSignerException& e) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, e.what());\n+    }\n+    UniValue result(UniValue::VOBJ);\n+    result.pushKV(\"signers\", signers);\n+    return result;\n+}\n+\n+ExternalSigner *GetSignerForJSONRPCRequest(const JSONRPCRequest& request, int index, CWallet* pwallet) {\n+    if (pwallet->m_external_signers.empty()) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"First call enumeratesigners\");\n+    }\n+\n+    // If no fingerprint is specified, return the only available signer\n+    if (request.params.size() < size_t(index + 1) || request.params[index].isNull()) {\n+        if (pwallet->m_external_signers.size() > 1) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Multiple signers found, please specify which to use\");\n+        }\n+        return &pwallet->m_external_signers.front();\n+    }\n+\n+    const std::string fingerprint = request.params[index].get_str();\n+    for (ExternalSigner &candidate : pwallet->m_external_signers) {\n+        if (candidate.m_fingerprint == fingerprint) return &candidate;\n+    }\n+    throw JSONRPCError(RPC_WALLET_ERROR, \"Signer fingerprint not found\");\n+}\n+\n+UniValue signerdissociate(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() > 1) {\n+        throw std::runtime_error(\n+            \"signerdissociate ( fingerprint )\\n\"\n+            \"Disossociates external signer from the wallet.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"fingerprint\\\"   (string, optional) Master key fingerprint of signer\\n\"\n+        );\n+    }\n+\n+    ExternalSigner *signer = GetSignerForJSONRPCRequest(request, 0, pwallet);\n+\n+    assert(signer != nullptr);\n+    std::vector<ExternalSigner>::iterator position = std::find(pwallet->m_external_signers.begin(), pwallet->m_external_signers.end(), *signer);\n+    if (position != pwallet->m_external_signers.end()) pwallet->m_external_signers.erase(position);\n+\n+    return NullUniValue;\n+}\n+\n+static UniValue signerdisplayaddress(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.empty() || request.params.size() > 2) {\n+        throw std::runtime_error(\n+            \"signerdisplayaddress\\n\"\n+            \"Display address on an external signer for verification.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"address\\\"       (string, required) The bitcoin address to display.\\n\"\n+            \"2. \\\"fingerprint\\\"   (string, optional) Master key fingerprint of signer\\n\"\n+        );\n+    }\n+\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    ExternalSigner *signer = GetSignerForJSONRPCRequest(request, 1, pwallet);\n+\n+    LOCK(pwallet->cs_wallet);\n+\n+    CTxDestination dest = DecodeDestination(request.params[0].get_str());\n+\n+    // Make sure the destination is valid\n+    if (!IsValidDestination(dest)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+    }\n+\n+    const CKeyMetadata* meta = nullptr;\n+    CKeyID key_id = GetKeyForDestination(*pwallet, dest);\n+    if (!key_id.IsNull()) {\n+        auto it = pwallet->mapKeyMetadata.find(key_id);\n+        if (it != pwallet->mapKeyMetadata.end()) {\n+            meta = &it->second;\n+        }\n+    }\n+    // TODO: use inferred descriptor (preferably with xpub at the account level)\n+    CScript scriptPubKey = GetScriptForDestination(dest);\n+    if (!meta) {\n+        auto it = pwallet->m_script_metadata.find(CScriptID(scriptPubKey));\n+        if (it != pwallet->m_script_metadata.end()) {\n+            meta = &it->second;\n+        }\n+    }\n+    if (!meta || meta->key_origin.IsNull()) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Missing BIP32 derivation data\");\n+    }\n+\n+    std::string path = meta->hdKeypath;\n+    path.erase(0,2); // Unsafe, but to be replaced with inferred descriptor\n+\n+    KeyOriginInfo info;\n+    if (!pwallet->GetKeyOrigin(key_id, info)) {\n+        throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+    }\n+\n+    bool solvable = IsSolvable(*pwallet, scriptPubKey);\n+    if (!solvable) {\n+        throw JSONRPCError(RPC_INTERNAL_ERROR, \"Address is not solvable\");\n+    }\n+\n+    std::string inferredDescriptor = InferDescriptor(scriptPubKey, *pwallet)->ToString();\n+\n+    // TODO: Use the inferred descriptor directly. Unfortunately it's currently\n+    //       not useful (or is it??).\n+\n+    std::string prefix = \"\";\n+    std::string postfix = \"\";\n+\n+    if (inferredDescriptor.find(\"wpkh\") == 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r249693754",
      "id" : 249693754,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0OTY5Mzc1NA==",
      "original_commit_id" : "5297b78e7929d7c74727a1f41a4cf85a180b7b08",
      "original_position" : 177,
      "path" : "src/wallet/rpcsigner.cpp",
      "position" : null,
      "pull_request_review_id" : 194898800,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/249693754",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r249876959"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/249876959"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I plan to ditch this part of the code, so no need to improve it :-)",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2019-01-22T17:11:15Z",
      "diff_hunk" : "@@ -0,0 +1,595 @@\n+// Copyright (c) 2018-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparamsbase.h>\n+#include <core_io.h>\n+#include <key_io.h>\n+#include <rpc/rawtransaction.h>\n+#include <rpc/server.h>\n+#include <rpc/util.h>\n+#include <script/descriptor.h>\n+#include <validation.h>\n+#include <wallet/rpcdump.h>\n+#include <wallet/rpcwallet.h>\n+\n+\n+#include <univalue.h>\n+\n+static UniValue enumeratesigners(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() != 0) {\n+        throw std::runtime_error(\n+            \"enumeratesigners\\n\"\n+            \"Returns a list of external signers from -signer and associates them\\n\"\n+            \"with the wallet until you stop bitcoind.\\n\"\n+            \"{\\n\"\n+            \"  \\\"signers\\\" : [                                (json array of objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"masterkeyfingerprint\\\" : \\\"fingerprint\\\" (string) Master key fingerprint\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+        );\n+    }\n+\n+    const std::string command = gArgs.GetArg(\"-signer\", DEFAULT_EXTERNAL_SIGNER);\n+    if (command == \"\") throw JSONRPCError(RPC_WALLET_ERROR, \"Error: restart bitcoind with -signer=<cmd>\");\n+    std::string chain = gArgs.GetChainName();\n+    const bool mainnet = chain == CBaseChainParams::MAIN;\n+    UniValue signers;\n+    try {\n+        signers = ExternalSigner::Enumerate(command, pwallet->m_external_signers, mainnet);\n+    } catch (const ExternalSignerException& e) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, e.what());\n+    }\n+    UniValue result(UniValue::VOBJ);\n+    result.pushKV(\"signers\", signers);\n+    return result;\n+}\n+\n+ExternalSigner *GetSignerForJSONRPCRequest(const JSONRPCRequest& request, int index, CWallet* pwallet) {\n+    if (pwallet->m_external_signers.empty()) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"First call enumeratesigners\");\n+    }\n+\n+    // If no fingerprint is specified, return the only available signer\n+    if (request.params.size() < size_t(index + 1) || request.params[index].isNull()) {\n+        if (pwallet->m_external_signers.size() > 1) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Multiple signers found, please specify which to use\");\n+        }\n+        return &pwallet->m_external_signers.front();\n+    }\n+\n+    const std::string fingerprint = request.params[index].get_str();\n+    for (ExternalSigner &candidate : pwallet->m_external_signers) {\n+        if (candidate.m_fingerprint == fingerprint) return &candidate;\n+    }\n+    throw JSONRPCError(RPC_WALLET_ERROR, \"Signer fingerprint not found\");\n+}\n+\n+UniValue signerdissociate(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() > 1) {\n+        throw std::runtime_error(\n+            \"signerdissociate ( fingerprint )\\n\"\n+            \"Disossociates external signer from the wallet.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"fingerprint\\\"   (string, optional) Master key fingerprint of signer\\n\"\n+        );\n+    }\n+\n+    ExternalSigner *signer = GetSignerForJSONRPCRequest(request, 0, pwallet);\n+\n+    assert(signer != nullptr);\n+    std::vector<ExternalSigner>::iterator position = std::find(pwallet->m_external_signers.begin(), pwallet->m_external_signers.end(), *signer);\n+    if (position != pwallet->m_external_signers.end()) pwallet->m_external_signers.erase(position);\n+\n+    return NullUniValue;\n+}\n+\n+static UniValue signerdisplayaddress(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.empty() || request.params.size() > 2) {\n+        throw std::runtime_error(\n+            \"signerdisplayaddress\\n\"\n+            \"Display address on an external signer for verification.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"address\\\"       (string, required) The bitcoin address to display.\\n\"\n+            \"2. \\\"fingerprint\\\"   (string, optional) Master key fingerprint of signer\\n\"\n+        );\n+    }\n+\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    ExternalSigner *signer = GetSignerForJSONRPCRequest(request, 1, pwallet);\n+\n+    LOCK(pwallet->cs_wallet);\n+\n+    CTxDestination dest = DecodeDestination(request.params[0].get_str());\n+\n+    // Make sure the destination is valid\n+    if (!IsValidDestination(dest)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n+    }\n+\n+    const CKeyMetadata* meta = nullptr;\n+    CKeyID key_id = GetKeyForDestination(*pwallet, dest);\n+    if (!key_id.IsNull()) {\n+        auto it = pwallet->mapKeyMetadata.find(key_id);\n+        if (it != pwallet->mapKeyMetadata.end()) {\n+            meta = &it->second;\n+        }\n+    }\n+    // TODO: use inferred descriptor (preferably with xpub at the account level)\n+    CScript scriptPubKey = GetScriptForDestination(dest);\n+    if (!meta) {\n+        auto it = pwallet->m_script_metadata.find(CScriptID(scriptPubKey));\n+        if (it != pwallet->m_script_metadata.end()) {\n+            meta = &it->second;\n+        }\n+    }\n+    if (!meta || meta->key_origin.IsNull()) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Missing BIP32 derivation data\");\n+    }\n+\n+    std::string path = meta->hdKeypath;\n+    path.erase(0,2); // Unsafe, but to be replaced with inferred descriptor\n+\n+    KeyOriginInfo info;\n+    if (!pwallet->GetKeyOrigin(key_id, info)) {\n+        throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal keypath is broken\");\n+    }\n+\n+    bool solvable = IsSolvable(*pwallet, scriptPubKey);\n+    if (!solvable) {\n+        throw JSONRPCError(RPC_INTERNAL_ERROR, \"Address is not solvable\");\n+    }\n+\n+    std::string inferredDescriptor = InferDescriptor(scriptPubKey, *pwallet)->ToString();\n+\n+    // TODO: Use the inferred descriptor directly. Unfortunately it's currently\n+    //       not useful (or is it??).\n+\n+    std::string prefix = \"\";\n+    std::string postfix = \"\";\n+\n+    if (inferredDescriptor.find(\"wpkh\") == 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r249876959",
      "id" : 249876959,
      "in_reply_to_id" : 249693754,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0OTg3Njk1OQ==",
      "original_commit_id" : "5297b78e7929d7c74727a1f41a4cf85a180b7b08",
      "original_position" : 177,
      "path" : "src/wallet/rpcsigner.cpp",
      "position" : null,
      "pull_request_review_id" : 195127569,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/249876959",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r249910603"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/249910603"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "It would be reasonable to call `_popen` function here on windows or `#define popen _popen`: https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/system-wsystem.\r\n\r\nYou do need to be very careful about special characters passed in the command string, but it should be ok if you stick to hex/base64.",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2019-01-22T18:42:16Z",
      "diff_hunk" : "@@ -1198,6 +1200,24 @@ void runCommand(const std::string& strCommand)\n         LogPrintf(\"runCommand error: system(%s) returned %d\\n\", strCommand, nErr);\n }\n \n+UniValue runCommandParseJSON(const std::string& strCommand)\n+{\n+    if (strCommand.empty()) return UniValue::VNULL;\n+\n+    std::array<char, 128> buffer;\n+    std::string result;\n+    std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(strCommand.c_str(), \"r\"), pclose);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r249910603",
      "id" : 249910603,
      "in_reply_to_id" : 242612528,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0OTkxMDYwMw==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 22,
      "path" : "src/util/system.cpp",
      "position" : null,
      "pull_request_review_id" : 195168960,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/249910603",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r249924733"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/249924733"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`_popen` would only work in console program. See https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/popen-wpopen. So it doesn't work in Qt.",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2019-01-22T19:20:35Z",
      "diff_hunk" : "@@ -1198,6 +1200,24 @@ void runCommand(const std::string& strCommand)\n         LogPrintf(\"runCommand error: system(%s) returned %d\\n\", strCommand, nErr);\n }\n \n+UniValue runCommandParseJSON(const std::string& strCommand)\n+{\n+    if (strCommand.empty()) return UniValue::VNULL;\n+\n+    std::array<char, 128> buffer;\n+    std::string result;\n+    std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(strCommand.c_str(), \"r\"), pclose);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r249924733",
      "id" : 249924733,
      "in_reply_to_id" : 242612528,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0OTkyNDczMw==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 22,
      "path" : "src/util/system.cpp",
      "position" : null,
      "pull_request_review_id" : 195186455,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/249924733",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/11154118?v=4",
         "events_url" : "https://api.github.com/users/ken2812221/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ken2812221/followers",
         "following_url" : "https://api.github.com/users/ken2812221/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ken2812221/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ken2812221",
         "id" : 11154118,
         "login" : "ken2812221",
         "node_id" : "MDQ6VXNlcjExMTU0MTE4",
         "organizations_url" : "https://api.github.com/users/ken2812221/orgs",
         "received_events_url" : "https://api.github.com/users/ken2812221/received_events",
         "repos_url" : "https://api.github.com/users/ken2812221/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ken2812221/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ken2812221/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ken2812221"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "* updated to incorporate the latest changes in https://github.com/achow101/HWI/pull/73 and \r\nhttps://github.com/achow101/bitcoin/tree/hww\r\n* added (BIP32) `account` argument to `signerfetchkeys` (will add custom descriptor arguments later)\r\n* using `RPCHelpMan` (surviving the Travis linter again)\r\n* using inferred descriptor for `signerdisplayaddress`\r\n* included commits from #14978 to clean up PSBT & sendrawtransaction stuff (and fix Travis)\r\n* added the most important remaining todo's to the PR description",
      "created_at" : "2019-01-24T11:16:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#issuecomment-457161230",
      "id" : 457161230,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14912",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ1NzE2MTIzMA==",
      "updated_at" : "2019-01-24T14:11:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/457161230",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I changed `signerfetchkeys` to use `getxpub` instead of `getkeys`. You can now use the `master` branch of HWI, except for [displayaddress](https://github.com/bitcoin-core/HWI/pull/117).\r\n\r\nI'll deal with the rebase once a bit more upstream stuff is merged.",
      "created_at" : "2019-02-02T13:20:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#issuecomment-459964623",
      "id" : 459964623,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14912",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ1OTk2NDYyMw==",
      "updated_at" : "2019-02-02T13:20:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/459964623",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r253279565"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/253279565"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The result is \"null\", not \"\". This causes the crash.",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2019-02-02T21:50:26Z",
      "diff_hunk" : "@@ -0,0 +1,594 @@\n+// Copyright (c) 2018-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparamsbase.h>\n+#include <core_io.h>\n+#include <key_io.h>\n+#include <psbt.h>\n+#include <rpc/rawtransaction.h>\n+#include <rpc/server.h>\n+#include <rpc/util.h>\n+#include <script/descriptor.h>\n+#include <validation.h>\n+#include <wallet/psbtwallet.h>\n+#include <wallet/rpcdump.h>\n+#include <wallet/rpcwallet.h>\n+\n+\n+#include <univalue.h>\n+\n+UniValue getsigners(CWallet *pwallet) {\n+    const std::string command = gArgs.GetArg(\"-signer\", DEFAULT_EXTERNAL_SIGNER);\n+    if (command == \"\") throw JSONRPCError(RPC_WALLET_ERROR, \"Error: restart bitcoind with -signer=<cmd>\");\n+    std::string chain = gArgs.GetChainName();\n+    const bool mainnet = chain == CBaseChainParams::MAIN;\n+    UniValue signers;\n+    try {\n+        return ExternalSigner::Enumerate(command, pwallet->m_external_signers, mainnet);\n+    } catch (const ExternalSignerException& e) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, e.what());\n+    }\n+}\n+\n+static UniValue enumeratesigners(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() != 0) {\n+        throw std::runtime_error(\n+            RPCHelpMan{\"enumeratesigners\\n\",\n+                \"Returns a list of external signers from -signer and associates them\\n\"\n+                \"with the wallet until you stop bitcoind.\\n\",\n+                {},\n+                RPCResult{\n+                    \"{\\n\"\n+                    \"  \\\"signers\\\" : [                              (json array of objects)\\n\"\n+                    \"    {\\n\"\n+                    \"      \\\"masterkeyfingerprint\\\" : \\\"fingerprint\\\" (string) Master key fingerprint\\n\"\n+                    \"    }\\n\"\n+                    \"    ,...\\n\"\n+                    \"  ]\\n\"\n+                    \"}\\n\"\n+                },\n+                RPCExamples{\"\"}\n+            }.ToString()\n+        );\n+    }\n+\n+    UniValue signers = getsigners(pwallet);\n+    UniValue result(UniValue::VOBJ);\n+    result.pushKV(\"signers\", signers);\n+    return result;\n+}\n+\n+ExternalSigner *GetSignerForJSONRPCRequest(const JSONRPCRequest& request, int index, CWallet* pwallet) {\n+    if (pwallet->m_external_signers.empty()) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"First call enumeratesigners\");\n+    }\n+\n+    // If no fingerprint is specified, return the only available signer\n+    if (request.params.size() < size_t(index + 1) || request.params[index].isNull()) {\n+        if (pwallet->m_external_signers.size() > 1) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Multiple signers found, please specify which to use\");\n+        }\n+        return &pwallet->m_external_signers.front();\n+    }\n+\n+    const std::string fingerprint = request.params[index].get_str();\n+    for (ExternalSigner &candidate : pwallet->m_external_signers) {\n+        if (candidate.m_fingerprint == fingerprint) return &candidate;\n+    }\n+    throw JSONRPCError(RPC_WALLET_ERROR, \"Signer fingerprint not found\");\n+}\n+\n+UniValue signerdissociate(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() > 1) {\n+        throw std::runtime_error(\n+            RPCHelpMan{\"signerdissociate\",\n+                \"Disossociates external signer from the wallet.\\n\",\n+                {\n+                    {\"fingerprint\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"\", \"Master key fingerprint of signer\"},\n+                },\n+                RPCResult{\"\"},",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r253279565",
      "id" : 253279565,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MzI3OTU2NQ==",
      "original_commit_id" : "6323969eef86dfa1c35359f1ff67aec6318f46f4",
      "original_position" : 106,
      "path" : "src/wallet/rpcsigner.cpp",
      "position" : null,
      "pull_request_review_id" : 199363825,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/253279565",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r253279783"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/253279783"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed!",
      "commit_id" : "c80b40c5fcd681f1f6a7f05f1baeefc333118512",
      "created_at" : "2019-02-02T22:00:12Z",
      "diff_hunk" : "@@ -0,0 +1,594 @@\n+// Copyright (c) 2018-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparamsbase.h>\n+#include <core_io.h>\n+#include <key_io.h>\n+#include <psbt.h>\n+#include <rpc/rawtransaction.h>\n+#include <rpc/server.h>\n+#include <rpc/util.h>\n+#include <script/descriptor.h>\n+#include <validation.h>\n+#include <wallet/psbtwallet.h>\n+#include <wallet/rpcdump.h>\n+#include <wallet/rpcwallet.h>\n+\n+\n+#include <univalue.h>\n+\n+UniValue getsigners(CWallet *pwallet) {\n+    const std::string command = gArgs.GetArg(\"-signer\", DEFAULT_EXTERNAL_SIGNER);\n+    if (command == \"\") throw JSONRPCError(RPC_WALLET_ERROR, \"Error: restart bitcoind with -signer=<cmd>\");\n+    std::string chain = gArgs.GetChainName();\n+    const bool mainnet = chain == CBaseChainParams::MAIN;\n+    UniValue signers;\n+    try {\n+        return ExternalSigner::Enumerate(command, pwallet->m_external_signers, mainnet);\n+    } catch (const ExternalSignerException& e) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, e.what());\n+    }\n+}\n+\n+static UniValue enumeratesigners(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() != 0) {\n+        throw std::runtime_error(\n+            RPCHelpMan{\"enumeratesigners\\n\",\n+                \"Returns a list of external signers from -signer and associates them\\n\"\n+                \"with the wallet until you stop bitcoind.\\n\",\n+                {},\n+                RPCResult{\n+                    \"{\\n\"\n+                    \"  \\\"signers\\\" : [                              (json array of objects)\\n\"\n+                    \"    {\\n\"\n+                    \"      \\\"masterkeyfingerprint\\\" : \\\"fingerprint\\\" (string) Master key fingerprint\\n\"\n+                    \"    }\\n\"\n+                    \"    ,...\\n\"\n+                    \"  ]\\n\"\n+                    \"}\\n\"\n+                },\n+                RPCExamples{\"\"}\n+            }.ToString()\n+        );\n+    }\n+\n+    UniValue signers = getsigners(pwallet);\n+    UniValue result(UniValue::VOBJ);\n+    result.pushKV(\"signers\", signers);\n+    return result;\n+}\n+\n+ExternalSigner *GetSignerForJSONRPCRequest(const JSONRPCRequest& request, int index, CWallet* pwallet) {\n+    if (pwallet->m_external_signers.empty()) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"First call enumeratesigners\");\n+    }\n+\n+    // If no fingerprint is specified, return the only available signer\n+    if (request.params.size() < size_t(index + 1) || request.params[index].isNull()) {\n+        if (pwallet->m_external_signers.size() > 1) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Multiple signers found, please specify which to use\");\n+        }\n+        return &pwallet->m_external_signers.front();\n+    }\n+\n+    const std::string fingerprint = request.params[index].get_str();\n+    for (ExternalSigner &candidate : pwallet->m_external_signers) {\n+        if (candidate.m_fingerprint == fingerprint) return &candidate;\n+    }\n+    throw JSONRPCError(RPC_WALLET_ERROR, \"Signer fingerprint not found\");\n+}\n+\n+UniValue signerdissociate(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() > 1) {\n+        throw std::runtime_error(\n+            RPCHelpMan{\"signerdissociate\",\n+                \"Disossociates external signer from the wallet.\\n\",\n+                {\n+                    {\"fingerprint\", RPCArg::Type::STR, /* opt */ true, /* default_val */ \"\", \"Master key fingerprint of signer\"},\n+                },\n+                RPCResult{\"\"},",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r253279783",
      "id" : 253279783,
      "in_reply_to_id" : 253279565,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MzI3OTc4Mw==",
      "original_commit_id" : "6323969eef86dfa1c35359f1ff67aec6318f46f4",
      "original_position" : 106,
      "path" : "src/wallet/rpcsigner.cpp",
      "position" : null,
      "pull_request_review_id" : 199364098,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2019-05-12T14:26:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/253279783",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Conceptually, I think we should initially create the option to allow a wallet to contain a main descriptor (main xpub). The scripts may be derived in-mem only during wallet load. If a form of \"getnewaddress\" (receive address) (child-pub-key-derviation) is supported, the wallet may want to remain the used child key indexes for the metadata storage rather than the pubkeyhash.",
      "created_at" : "2019-02-14T02:17:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#issuecomment-463458567",
      "id" : 463458567,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14912",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ2MzQ1ODU2Nw==",
      "updated_at" : "2019-02-14T02:17:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/463458567",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Time for a big rebase  ",
      "created_at" : "2019-02-14T23:56:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#issuecomment-463851398",
      "id" : 463851398,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14912",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ2Mzg1MTM5OA==",
      "updated_at" : "2019-02-14T23:56:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/463851398",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Giant rebase done! I created separate pull request for a number of commits in order to keep discussion a bit focussed here. Please check the list at the bottom of the PR description before commenting.\r\n\r\nThere's still two significant todo's (plus cleanup) before this is really read for review, but more high level feedback is always welcome:\r\n\r\n1. A way to construct descriptors from code, to get rid of the string concatenation mess in `signerfetchkeys` (separate PR)\r\n2. Have the device sign one or more messages using the keys after importing with `signerfetchkeys`",
      "created_at" : "2019-02-15T12:12:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#issuecomment-464026454",
      "id" : 464026454,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14912",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ2NDAyNjQ1NA==",
      "updated_at" : "2019-02-15T12:12:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/464026454",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased! I changed `signerfetchkeys` to call `hwi.py getdescriptors` (https://github.com/bitcoin-core/HWI/pull/137).",
      "created_at" : "2019-03-08T14:30:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#issuecomment-470947271",
      "id" : 470947271,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14912",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ3MDk0NzI3MQ==",
      "updated_at" : "2019-03-08T14:30:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/470947271",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2019-03-21T08:26:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#issuecomment-475144939",
      "id" : 475144939,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14912",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ3NTE0NDkzOQ==",
      "updated_at" : "2019-03-21T08:26:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/475144939",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2019-04-26T12:18:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#issuecomment-487036726",
      "id" : 487036726,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14912",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ4NzAzNjcyNg==",
      "updated_at" : "2019-04-26T12:18:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/487036726",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "#15713 adds a `broadcastTransaction()` chain interface method which is required here, so would remove one of the commits from this PR.",
      "created_at" : "2019-04-29T23:03:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#issuecomment-487773426",
      "id" : 487773426,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14912",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ4Nzc3MzQyNg==",
      "updated_at" : "2019-04-29T23:03:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/487773426",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I don't understand why users would apparently need to use new RPCs to achieve the same things they can already do?",
      "created_at" : "2019-05-01T06:10:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#issuecomment-488217804",
      "id" : 488217804,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14912",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ4ODIxNzgwNA==",
      "updated_at" : "2019-05-01T06:10:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/488217804",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@luke-jr that's true for `enumerate` which does exactly the same as `hwi.py enumerate`. But fetching keys, sending transactions and (as a followup) doing RBF is very tedious without these RPC methods. The same goes for generating a new receive address in the wallet and displaying it on the device.\r\n\r\nThe longer term goal is to get this functionality in the GUI, so I also see the RPC as a foundation for that (combined with making RPC code more reusable in general). It's also much easier to write RPC tests than GUI tests.",
      "created_at" : "2019-05-03T12:15:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#issuecomment-489075526",
      "id" : 489075526,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14912",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ4OTA3NTUyNg==",
      "updated_at" : "2019-05-03T12:23:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/489075526",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   }
]
