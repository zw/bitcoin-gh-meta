[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2018-12-10T14:59:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#issuecomment-445845036",
      "id" : 445845036,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14912",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0NTg0NTAzNg==",
      "updated_at" : "2018-12-10T14:59:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/445845036",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "> close HWI repo somewhere and launch bitcoind -signer=../HWI/hwi.py\r\n\r\nNit: you meant \"clone\", right?\r\n",
      "created_at" : "2018-12-10T16:33:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#issuecomment-445880496",
      "id" : 445880496,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14912",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0NTg4MDQ5Ng==",
      "updated_at" : "2018-12-10T16:33:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/445880496",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/1835345?v=4",
         "events_url" : "https://api.github.com/users/tsusanka/events{/privacy}",
         "followers_url" : "https://api.github.com/users/tsusanka/followers",
         "following_url" : "https://api.github.com/users/tsusanka/following{/other_user}",
         "gists_url" : "https://api.github.com/users/tsusanka/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/tsusanka",
         "id" : 1835345,
         "login" : "tsusanka",
         "node_id" : "MDQ6VXNlcjE4MzUzNDU=",
         "organizations_url" : "https://api.github.com/users/tsusanka/orgs",
         "received_events_url" : "https://api.github.com/users/tsusanka/received_events",
         "repos_url" : "https://api.github.com/users/tsusanka/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/tsusanka/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/tsusanka/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/tsusanka"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Now that #14491 has been rebased, the `hww` branch I'm building off should also soon be rebased. At that point I can rebase and make Travis happy. In addition, I'll be able to leverage #14646 to clean up my descriptor related code (I'm currently using string concatenation to build descriptors). I have a few other spring cleaning items on my todo list too.\r\n\r\nSee also the [wallet meeting notes](http://www.erisian.com.au/bitcoin-core-dev/log-2018-12-14.html#l-473).",
      "created_at" : "2018-12-15T11:22:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#issuecomment-447561259",
      "id" : 447561259,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14912",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0NzU2MTI1OQ==",
      "updated_at" : "2018-12-15T11:22:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/447561259",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#14987](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14987.html) ([rcp] RPCHelpMan: Require documentation of return value at compile time by MarcoFalke)\n* [#14952](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14952.html) ([do not merge] [tests] tidy up wallet_importmulti.py by jnewbery)\n* [#14918](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14918.html) (RPCHelpMan: Check default values are given at compile-time by MarcoFalke)\n* [#14565](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14565.html) (Overhaul importmulti logic by sipa)\n* [#14533](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14533.html) (wallet: ensure wallet files are not reused across chains by mrwhythat)\n* [#14491](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14491.html) (Allow descriptor imports with importmulti by MeshCollider)\n* [#14459](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14459.html) (More RPC help description fixes by ch4ot1c)\n* [#14075](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14075.html) (Import watch only pubkeys to the keypool if private keys are disabled by achow101)\n* [#14021](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14021.html) (Import key origin data through descriptors in importmulti by achow101)\n* [#13756](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/13756.html) (wallet: \"avoid_reuse\" wallet flag for improved privacy by kallewoof)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2018-12-17T20:12:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#issuecomment-447982606",
      "id" : 447982606,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14912",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0Nzk4MjYwNg==",
      "updated_at" : "2018-12-18T06:41:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/447982606",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242604518"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242604518"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The documentation format is incorrect here :-)",
      "commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "created_at" : "2018-12-18T16:19:33Z",
      "diff_hunk" : "@@ -24,6 +25,17 @@ void RegisterWalletRPCCommands(CRPCTable &t);\n  */\n std::shared_ptr<CWallet> GetWalletForJSONRPCRequest(const JSONRPCRequest& request);\n \n+/**\n+ * Figures out what external signer to use for a JSONRPCRequest.\n+ *\n+ * @param[in] request JSONRPCRequest that wishes to access a signer\n+ * @param[pos] which argument contains the signer fingerprint. Optional, returns the first signer otherwise\n+ * @param[pwallet] the wallet",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242604518",
      "id" : 242604518,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYwNDUxOA==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 17,
      "path" : "src/wallet/rpcwallet.h",
      "position" : 17,
      "pull_request_review_id" : 186155471,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2018-12-18T16:20:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242604518",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242605089"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242605089"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`ExternalSigner signer` shadows `UniValue signer` :-)",
      "commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "created_at" : "2018-12-18T16:20:53Z",
      "diff_hunk" : "@@ -0,0 +1,45 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <wallet/externalsigner.h>\n+#include <util/system.h>\n+\n+ExternalSigner::ExternalSigner(const std::string& command, const std::string& fingerprint, bool mainnet): m_command(command), m_fingerprint(fingerprint), m_mainnet(mainnet) {}\n+\n+UniValue ExternalSigner::Enumerate(const std::string& command, std::vector<ExternalSigner>& signers, bool mainnet)\n+{\n+    // Call <command> enumerate\n+    const UniValue result = runCommandParseJSON(command + \" enumerate\");\n+    if (!result.isArray())\n+        throw ExternalSignerException(strprintf(\"'%s' received invalid response, expected array of signers\", command));\n+    for (UniValue signer : result.getValues()) {\n+        const UniValue& fingerprint = find_value(signer, \"fingerprint\");\n+        if (result.isNull())\n+            throw ExternalSignerException(strprintf(\"'%s' received invalid response, missing signer fingerprint\", command));\n+        std::string fingerprintStr = fingerprint.get_str();\n+        // Skip duplicate signer\n+        bool duplicate = false;\n+        for (ExternalSigner signer : signers) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242605089",
      "id" : 242605089,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYwNTA4OQ==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 23,
      "path" : "src/wallet/externalsigner.cpp",
      "position" : 23,
      "pull_request_review_id" : 186156153,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2018-12-18T16:20:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242605089",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242605811"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242605811"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The type of `i` should match the type of `range_start` to avoid implicit precision losing conversion?",
      "commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "created_at" : "2018-12-18T16:22:38Z",
      "diff_hunk" : "@@ -836,246 +837,419 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n-\n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+struct ImportData\n {\n-    try {\n-        // First ensure scriptPubKey has either a script or JSON with \"address\" string\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n-        }\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n-\n-        // Generate the script and destination for the scriptPubKey provided\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //!< Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //!< Provided witnessScript; will be moved to `import_scripts` if relevant.\n \n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n-        }\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::map<CKeyID, bool> used_keys; //!< Import these private keys if available (the value indicates whether if the key is required for solvability)\n+    std::map<CKeyID, KeyOriginInfo> key_origins;\n+};\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided scriptPubKey, determining which keys and which redeem scripts from the ImportData struct are needed to spend it, and mark them as used.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& import_data, const ScriptContext script_ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        import_data.used_keys.emplace(pubkey.GetID(), false);\n+        return \"\";\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.used_keys[id] = true;\n+        return \"\";\n+    }\n+    case TX_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::P2SH) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside another P2SH\");\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside a P2WSH\");\n+        assert(script_ctx == ScriptContext::TOP);\n+        CScriptID id = CScriptID(uint160(solverdata[0]));\n+        auto subscript = std::move(import_data.redeemscript);\n+        if (!subscript) return \"missing redeemscript\";\n+        if (CScriptID(*subscript) != id) return \"redeemScript does not match the scriptPubKey\";\n+        import_data.import_scripts.emplace(*subscript);\n+        return RecurseImportData(*subscript, import_data, ScriptContext::P2SH);\n+    }\n+    case TX_MULTISIG: {\n+        for (size_t i = 1; i + 1< solverdata.size(); ++i) {\n+            CPubKey pubkey(solverdata[i].begin(), solverdata[i].end());\n+            import_data.used_keys.emplace(pubkey.GetID(), false);\n         }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        return \"\";\n+    }\n+    case TX_WITNESS_V0_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WSH inside another P2WSH\");\n+        uint256 fullid(solverdata[0]);\n+        CScriptID id;\n+        CRIPEMD160().Write(fullid.begin(), fullid.size()).Finalize(id.begin());\n+        auto subscript = std::move(import_data.witnessscript);\n+        if (!subscript) return \"missing witnessscript\";\n+        if (CScriptID(*subscript) != id) return \"witnessScript does not match the scriptPubKey or redeemScript\";\n+        if (script_ctx == ScriptContext::TOP) {\n+            import_data.import_scripts.emplace(script); // Special rule for IsMine: native P2WSH requires the TOP script imported (see script/ismine.cpp)\n         }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n+        import_data.import_scripts.emplace(*subscript);\n+        return RecurseImportData(*subscript, import_data, ScriptContext::WITNESS_V0);\n+    }\n+    case TX_WITNESS_V0_KEYHASH: {\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WPKH inside P2WSH\");\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.used_keys[id] = true;\n+        if (script_ctx == ScriptContext::TOP) {\n+            import_data.import_scripts.emplace(script); // Special rule for IsMine: native P2WPKH requires the TOP script imported (see script/ismine.cpp)\n         }\n+        return \"\";\n+    }\n+    case TX_NULL_DATA:\n+        return \"unspendable script\";\n+    case TX_NONSTANDARD:\n+    case TX_WITNESS_UNKNOWN:\n+    default:\n+        return \"unrecognized script\";\n+    }\n+}\n \n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n-            if (!IsHex(strRedeemScript)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n-            }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n+static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data, std::vector<CKeyID>& ordered_pubkeys)\n+{\n+    UniValue warnings(UniValue::VARR);\n \n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n         }\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n+        }\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n+        }\n+    }\n+    script_pub_keys.emplace(script);\n \n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n-            }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n+    // Parse all arguments\n+    if (strRedeemScript.size()) {\n+        if (!IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n+        }\n+        auto parsed_redeemscript = ParseHex(strRedeemScript);\n+        import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    }\n+    if (witness_script_hex.size()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n+        }\n+        auto parsed_witnessscript = ParseHex(witness_script_hex);\n+        import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+    }\n+    for (size_t i = 0; i < pubKeys.size(); ++i) {\n+        const auto& str = pubKeys[i].get_str();\n+        if (!IsHex(str)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n+        }\n+        auto parsed_pubkey = ParseHex(str);\n+        CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+        if (!pubkey.IsFullyValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n+        }\n+        pubkey_map.emplace(pubkey.GetID(), pubkey);\n+        ordered_pubkeys.push_back(pubkey.GetID());\n+    }\n+    for (size_t i = 0; i < keys.size(); ++i) {\n+        const auto& str = keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n+        if (pubkey_map.count(id)) {\n+            pubkey_map.erase(id);\n+        }\n+        privkey_map.emplace(id, key);\n+    }\n \n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n+    // Verify and process input data\n+    have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();\n+    if (have_solving_data) {\n+        // Match up data in import_data with the scriptPubKey in script.\n+        auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n \n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        // Verify whether the watchonly option corresponds to the availability of private keys.\n+        bool spendable = std::all_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const std::pair<CKeyID, bool>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+        if (!watchOnly && !spendable) {\n+            warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n+        }\n+        if (watchOnly && spendable) {\n+            warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n+        }\n \n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        // Check that all required keys for solvability are provided.\n+        if (error.empty()) {\n+            for (const auto& require_key : import_data.used_keys) {\n+                if (!require_key.second) continue; // Not a required key\n+                if (pubkey_map.count(require_key.first) == 0 && privkey_map.count(require_key.first) == 0) {\n+                    error = \"some required keys are missing\";\n+                }\n             }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n         }\n \n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n-            }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n-            }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n-            }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+        if (!error.empty()) {\n+            warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+            import_data = ImportData();\n+            pubkey_map.clear();\n+            privkey_map.clear();\n+            have_solving_data = false;\n+        } else {\n+            // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+            if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+            if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+            for (auto it = privkey_map.begin(); it != privkey_map.end(); ) {\n+                auto oldit = it++;\n+                if (import_data.used_keys.count(oldit->first) == 0) {\n+                    warnings.push_back(\"Ignoring irrelevant private key.\");\n+                    privkey_map.erase(oldit);\n                 }\n-                pubkey = pubkey_temp;\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n+            for (auto it = pubkey_map.begin(); it != pubkey_map.end(); ) {\n+                auto oldit = it++;\n+                auto key_data_it = import_data.used_keys.find(oldit->first);\n+                if (key_data_it == import_data.used_keys.end() || !key_data_it->second) {\n+                    warnings.push_back(\"Ignoring public key \\\"\" + HexStr(oldit->first) + \"\\\" as it doesn't appear inside P2PKH or P2WPKH.\");\n+                    pubkey_map.erase(oldit);\n                 }\n+            }\n+        }\n+    }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n+    return warnings;\n+}\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n+static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data, std::vector<CKeyID>& ordered_pubkeys)\n+{\n+    UniValue warnings(UniValue::VARR);\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+    const std::string& descriptor = data[\"desc\"].get_str();\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n \n-                pwallet->MarkDirty();\n+    have_solving_data = parsed_desc->IsSolvable();\n+    const bool watch_only = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-            }\n+    int64_t range_start = 0, range_end = 0;\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange()) {\n+        if (!data.exists(\"range\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n         }\n-\n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        const UniValue& range = data[\"range\"];\n+        range_start = range.exists(\"start\") ? range[\"start\"].get_int64() : 0;\n+        if (!range.exists(\"end\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End of range for descriptor must be specified\");\n         }\n+        range_end = range[\"end\"].get_int64();\n+    }\n \n-        pwallet->MarkDirty();\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    // Expand all descriptors to get public keys and scripts.\n+    // TODO: get private keys from descriptors too\n+    for (int i = range_start; i <= range_end; ++i) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242605811",
      "id" : 242605811,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYwNTgxMQ==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 426,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 426,
      "pull_request_review_id" : 186157079,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2018-12-18T16:22:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242605811",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242606157"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242606157"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be dropped since unused?",
      "commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "created_at" : "2018-12-18T16:23:17Z",
      "diff_hunk" : "@@ -836,246 +837,419 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n-\n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+struct ImportData\n {\n-    try {\n-        // First ensure scriptPubKey has either a script or JSON with \"address\" string\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n-        }\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n-\n-        // Generate the script and destination for the scriptPubKey provided\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //!< Provided redeemScript; will be moved to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //!< Provided witnessScript; will be moved to `import_scripts` if relevant.\n \n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n-        }\n+    // Output data\n+    std::set<CScript> import_scripts;\n+    std::map<CKeyID, bool> used_keys; //!< Import these private keys if available (the value indicates whether if the key is required for solvability)\n+    std::map<CKeyID, KeyOriginInfo> key_origins;\n+};\n \n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided scriptPubKey, determining which keys and which redeem scripts from the ImportData struct are needed to spend it, and mark them as used.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& import_data, const ScriptContext script_ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        import_data.used_keys.emplace(pubkey.GetID(), false);\n+        return \"\";\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.used_keys[id] = true;\n+        return \"\";\n+    }\n+    case TX_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::P2SH) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside another P2SH\");\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside a P2WSH\");\n+        assert(script_ctx == ScriptContext::TOP);\n+        CScriptID id = CScriptID(uint160(solverdata[0]));\n+        auto subscript = std::move(import_data.redeemscript);\n+        if (!subscript) return \"missing redeemscript\";\n+        if (CScriptID(*subscript) != id) return \"redeemScript does not match the scriptPubKey\";\n+        import_data.import_scripts.emplace(*subscript);\n+        return RecurseImportData(*subscript, import_data, ScriptContext::P2SH);\n+    }\n+    case TX_MULTISIG: {\n+        for (size_t i = 1; i + 1< solverdata.size(); ++i) {\n+            CPubKey pubkey(solverdata[i].begin(), solverdata[i].end());\n+            import_data.used_keys.emplace(pubkey.GetID(), false);\n         }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        return \"\";\n+    }\n+    case TX_WITNESS_V0_SCRIPTHASH: {\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WSH inside another P2WSH\");\n+        uint256 fullid(solverdata[0]);\n+        CScriptID id;\n+        CRIPEMD160().Write(fullid.begin(), fullid.size()).Finalize(id.begin());\n+        auto subscript = std::move(import_data.witnessscript);\n+        if (!subscript) return \"missing witnessscript\";\n+        if (CScriptID(*subscript) != id) return \"witnessScript does not match the scriptPubKey or redeemScript\";\n+        if (script_ctx == ScriptContext::TOP) {\n+            import_data.import_scripts.emplace(script); // Special rule for IsMine: native P2WSH requires the TOP script imported (see script/ismine.cpp)\n         }\n-\n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n+        import_data.import_scripts.emplace(*subscript);\n+        return RecurseImportData(*subscript, import_data, ScriptContext::WITNESS_V0);\n+    }\n+    case TX_WITNESS_V0_KEYHASH: {\n+        if (script_ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WPKH inside P2WSH\");\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        import_data.used_keys[id] = true;\n+        if (script_ctx == ScriptContext::TOP) {\n+            import_data.import_scripts.emplace(script); // Special rule for IsMine: native P2WPKH requires the TOP script imported (see script/ismine.cpp)\n         }\n+        return \"\";\n+    }\n+    case TX_NULL_DATA:\n+        return \"unspendable script\";\n+    case TX_NONSTANDARD:\n+    case TX_WITNESS_UNKNOWN:\n+    default:\n+        return \"unrecognized script\";\n+    }\n+}\n \n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n-            if (!IsHex(strRedeemScript)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n-            }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n+static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data, std::vector<CKeyID>& ordered_pubkeys)\n+{\n+    UniValue warnings(UniValue::VARR);\n \n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n         }\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n+        }\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n+        }\n+    }\n+    script_pub_keys.emplace(script);\n \n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n-            }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n+    // Parse all arguments\n+    if (strRedeemScript.size()) {\n+        if (!IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n+        }\n+        auto parsed_redeemscript = ParseHex(strRedeemScript);\n+        import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    }\n+    if (witness_script_hex.size()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n+        }\n+        auto parsed_witnessscript = ParseHex(witness_script_hex);\n+        import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+    }\n+    for (size_t i = 0; i < pubKeys.size(); ++i) {\n+        const auto& str = pubKeys[i].get_str();\n+        if (!IsHex(str)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n+        }\n+        auto parsed_pubkey = ParseHex(str);\n+        CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+        if (!pubkey.IsFullyValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n+        }\n+        pubkey_map.emplace(pubkey.GetID(), pubkey);\n+        ordered_pubkeys.push_back(pubkey.GetID());\n+    }\n+    for (size_t i = 0; i < keys.size(); ++i) {\n+        const auto& str = keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n+        if (pubkey_map.count(id)) {\n+            pubkey_map.erase(id);\n+        }\n+        privkey_map.emplace(id, key);\n+    }\n \n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n+    // Verify and process input data\n+    have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();\n+    if (have_solving_data) {\n+        // Match up data in import_data with the scriptPubKey in script.\n+        auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n \n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        // Verify whether the watchonly option corresponds to the availability of private keys.\n+        bool spendable = std::all_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const std::pair<CKeyID, bool>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+        if (!watchOnly && !spendable) {\n+            warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n+        }\n+        if (watchOnly && spendable) {\n+            warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n+        }\n \n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        // Check that all required keys for solvability are provided.\n+        if (error.empty()) {\n+            for (const auto& require_key : import_data.used_keys) {\n+                if (!require_key.second) continue; // Not a required key\n+                if (pubkey_map.count(require_key.first) == 0 && privkey_map.count(require_key.first) == 0) {\n+                    error = \"some required keys are missing\";\n+                }\n             }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n         }\n \n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n-            }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n-            }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n-            }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+        if (!error.empty()) {\n+            warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+            import_data = ImportData();\n+            pubkey_map.clear();\n+            privkey_map.clear();\n+            have_solving_data = false;\n+        } else {\n+            // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+            if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+            if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+            for (auto it = privkey_map.begin(); it != privkey_map.end(); ) {\n+                auto oldit = it++;\n+                if (import_data.used_keys.count(oldit->first) == 0) {\n+                    warnings.push_back(\"Ignoring irrelevant private key.\");\n+                    privkey_map.erase(oldit);\n                 }\n-                pubkey = pubkey_temp;\n             }\n-            if (pubkey.size() > 0) {\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n+            for (auto it = pubkey_map.begin(); it != pubkey_map.end(); ) {\n+                auto oldit = it++;\n+                auto key_data_it = import_data.used_keys.find(oldit->first);\n+                if (key_data_it == import_data.used_keys.end() || !key_data_it->second) {\n+                    warnings.push_back(\"Ignoring public key \\\"\" + HexStr(oldit->first) + \"\\\" as it doesn't appear inside P2PKH or P2WPKH.\");\n+                    pubkey_map.erase(oldit);\n                 }\n+            }\n+        }\n+    }\n \n-                // Check the key corresponds to the destination given\n-                std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n-                if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n-                }\n+    return warnings;\n+}\n \n-                // This is necessary to force the wallet to import the pubKey\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n+static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data, std::vector<CKeyID>& ordered_pubkeys)\n+{\n+    UniValue warnings(UniValue::VARR);\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+    const std::string& descriptor = data[\"desc\"].get_str();\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n \n-                pwallet->MarkDirty();\n+    have_solving_data = parsed_desc->IsSolvable();\n+    const bool watch_only = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-            }\n+    int64_t range_start = 0, range_end = 0;\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange()) {\n+        if (!data.exists(\"range\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n         }\n-\n-        // Import the address\n-        if (::IsMine(*pwallet, scriptpubkey_script) == ISMINE_SPENDABLE) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        const UniValue& range = data[\"range\"];\n+        range_start = range.exists(\"start\") ? range[\"start\"].get_int64() : 0;\n+        if (!range.exists(\"end\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End of range for descriptor must be specified\");\n         }\n+        range_end = range[\"end\"].get_int64();\n+    }\n \n-        pwallet->MarkDirty();\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    // Expand all descriptors to get public keys and scripts.\n+    // TODO: get private keys from descriptors too\n+    for (int i = range_start; i <= range_end; ++i) {\n+        FlatSigningProvider out_keys;\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        std::copy(scripts_temp.begin(), scripts_temp.end(), std::inserter(script_pub_keys, script_pub_keys.end()));\n+        for (const auto& key_pair : out_keys.pubkeys) {\n+            ordered_pubkeys.push_back(key_pair.first);\n+        }\n \n-        if (!pwallet->AddWatchOnly(scriptpubkey_script, timestamp)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        for (auto const& x : out_keys.scripts) {\n+            import_data.import_scripts.emplace(x.second);\n         }\n \n-        if (!watchOnly && !pwallet->HaveCScript(CScriptID(scriptpubkey_script)) && !pwallet->AddCScript(scriptpubkey_script)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding scriptPubKey script to wallet\");\n+        std::copy(out_keys.pubkeys.begin(), out_keys.pubkeys.end(), std::inserter(pubkey_map, pubkey_map.end()));\n+        std::copy(out_keys.origins.begin(), out_keys.origins.end(), std::inserter(import_data.key_origins, import_data.key_origins.end()));\n+    }\n+\n+    for (size_t i = 0; i < priv_keys.size(); ++i) {\n+        const auto& str = priv_keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n         }\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n \n-        // if not internal add to address book or update label\n-        if (!internal) {\n-            assert(IsValidDestination(scriptpubkey_dest));\n-            pwallet->SetAddressBook(scriptpubkey_dest, label, \"receive\");\n+        // Check if this private key corresponds to a public key from the descriptor\n+        if (!pubkey_map.count(id)) {\n+            warnings.push_back(\"Ignoring irrelevant private key.\");\n+        } else {\n+            privkey_map.emplace(id, key);\n         }\n+    }\n \n-        // Import private keys.\n-        for (size_t i = 0; i < keys.size(); i++) {\n-            const std::string& strPrivkey = keys[i].get_str();\n+    // Check if all the public keys have corresponding private keys in the import for spendability.\n+    // This does not take into account threshold multisigs which could be spendable without all keys\n+    bool spendable = std::all_of(pubkey_map.begin(), pubkey_map.end(), [&](const std::pair<CKeyID, CPubKey>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+    if (!watch_only && !spendable) {\n+        warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n+    }\n+    if (watch_only && spendable) {\n+        warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n+    }\n \n-            // Checks.\n-            CKey key = DecodeSecret(strPrivkey);\n+    return warnings;\n+}\n \n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-            }\n+static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    try {\n+        bool watch_only = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242606157",
      "id" : 242606157,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYwNjE1Nw==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 492,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 492,
      "pull_request_review_id" : 186157488,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2018-12-18T16:23:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242606157",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242606739"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242606739"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Make signedness changing implicit conversion explicit? Also, remove redundant initialization to zero on the line above? Merge the two lines.",
      "commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "created_at" : "2018-12-18T16:24:28Z",
      "diff_hunk" : "@@ -1263,3 +1444,145 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n \n     return response;\n }\n+\n+UniValue signerfetchkeys(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() > 1) {\n+        throw std::runtime_error(\n+            \"signerfetchkeys ( fingerprint )\\n\"\n+            \"Obtains keys from external signer and imports them into the wallet.\\n\"\n+            \"Call enumeratesigners before using this.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"fingerprint\\\"   (string, optional) Master key fingerprint of signer\\n\"\n+            \"\\nResult (same as for importmulti):\\n\"\n+            \"[{ \\\"success\\\": true }\"\n+        );\n+    }\n+\n+    ExternalSigner *signer = GetSignerForJSONRPCRequest(request, 0, pwallet);\n+\n+    UniValue descriptors = UniValue(UniValue::VARR);\n+    std::string desc_prefix = \"\";\n+    std::string desc_suffix = \"\";\n+    std::string purpose = \"\";\n+    switch(pwallet->m_default_address_type) {\n+        case OutputType::LEGACY: {\n+            desc_prefix = \"pkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"44h\";\n+            break;\n+        }\n+        case OutputType::P2SH_SEGWIT: {\n+            desc_prefix = \"sh(wpkh(\";\n+            desc_suffix = \"))\";\n+            purpose = \"49h\";\n+            break;\n+        }\n+        case OutputType::BECH32: {\n+            desc_prefix = \"wpkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"84h\";\n+            break;\n+        }\n+        case OutputType::CHANGE_AUTO: {\n+            assert(false);\n+        }\n+    }\n+\n+    const std::string receive_desc = desc_prefix + signer->m_fingerprint + \"/\" + purpose + \"/\" + (signer->m_mainnet ? \"0h\" : \"1h\") + \"/0h/0/*\" + desc_suffix;\n+    UniValue receive_descriptors = signer->getKeys(receive_desc);\n+    if (!receive_descriptors.isArray()) JSONRPCError(RPC_WALLET_ERROR, \"Expected an array of receive descriptors\");\n+    for (const UniValue& descriptor : receive_descriptors.getValues()) {\n+        descriptors.push_back(descriptor);\n+    }\n+\n+\n+    switch(pwallet->m_default_change_type) {\n+        case OutputType::LEGACY: {\n+            desc_prefix = \"pkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"44h\";\n+            break;\n+        }\n+        case OutputType::P2SH_SEGWIT: {\n+            desc_prefix = \"sh(wpkh(\";\n+            desc_suffix = \"))\";\n+            purpose = \"49h\";\n+            break;\n+        }\n+        case OutputType::BECH32: {\n+            desc_prefix = \"wpkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"84h\";\n+            break;\n+        }\n+        case OutputType::CHANGE_AUTO: {\n+            // Use same values as for receive descriptor\n+            break;\n+        }\n+    }\n+\n+    const std::string change_desc = desc_prefix + signer->m_fingerprint + \"/\" + purpose + \"/\" + (signer->m_mainnet ? \"0h\" : \"1h\") + \"/0h/1/*\" + desc_suffix;\n+    UniValue change_descriptors = signer->getKeys(change_desc);\n+    if (!change_descriptors.isArray()) JSONRPCError(RPC_WALLET_ERROR, \"Expected an array of change descriptors\");\n+    for (const UniValue& descriptor : change_descriptors.getValues()) {\n+        descriptors.push_back(descriptor);\n+    }\n+\n+    if (receive_descriptors.size() != change_descriptors.size()) JSONRPCError(RPC_WALLET_ERROR, \"Expected same number of receive and change descriptors\");\n+\n+    // Use importmulti to process the descriptors:\n+    UniValue importdata(UniValue::VARR);\n+\n+    uint64_t keypool_target_size = 0;\n+    keypool_target_size = gArgs.GetArg(\"-keypool\", DEFAULT_KEYPOOL_SIZE);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242606739",
      "id" : 242606739,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYwNjczOQ==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 770,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 770,
      "pull_request_review_id" : 186158164,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2018-12-18T16:24:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242606739",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242608963"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242608963"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Initialize to zero?",
      "commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "created_at" : "2018-12-18T16:29:39Z",
      "diff_hunk" : "@@ -1198,6 +1200,24 @@ void runCommand(const std::string& strCommand)\n         LogPrintf(\"runCommand error: system(%s) returned %d\\n\", strCommand, nErr);\n }\n \n+UniValue runCommandParseJSON(const std::string& strCommand)\n+{\n+    if (strCommand.empty()) return UniValue::VNULL;\n+\n+    std::array<char, 128> buffer;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242608963",
      "id" : 242608963,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYwODk2Mw==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 20,
      "path" : "src/util/system.cpp",
      "position" : 20,
      "pull_request_review_id" : 186161053,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2018-12-18T16:29:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242608963",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242609613"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242609613"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be \"fingerprint\" :-)",
      "commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "created_at" : "2018-12-18T16:31:09Z",
      "diff_hunk" : "@@ -3988,6 +4010,37 @@ UniValue walletprocesspsbt(const JSONRPCRequest& request)\n     bool bip32derivs = request.params[3].isNull() ? false : request.params[3].get_bool();\n     bool complete = FillPSBT(pwallet, psbtx, nHashType, sign, bip32derivs);\n \n+    // Process again with external signer if needed\n+    if (!complete && sign && !wallet->m_external_signers.empty()) {\n+        ExternalSigner *signer = GetSignerForJSONRPCRequest(request, 4, pwallet);\n+        if (signer && !bip32derivs) JSONRPCError(RPC_WALLET_ERROR, \"Using signer requires bip32derivs argument to be true\");\n+\n+        // Check if signer fingerpint matches any input master key fingerprint",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242609613",
      "id" : 242609613,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYwOTYxMw==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 112,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 112,
      "pull_request_review_id" : 186161866,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2018-12-18T16:31:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242609613",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242612528"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242612528"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I haven't reviewed this use of `popen()` closer, but please note the recommendations/risks with regards to `popen()` used described in the CERT secure coding guidelines (more specifically rule ENV33-C).",
      "commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "created_at" : "2018-12-18T16:38:09Z",
      "diff_hunk" : "@@ -1198,6 +1200,24 @@ void runCommand(const std::string& strCommand)\n         LogPrintf(\"runCommand error: system(%s) returned %d\\n\", strCommand, nErr);\n }\n \n+UniValue runCommandParseJSON(const std::string& strCommand)\n+{\n+    if (strCommand.empty()) return UniValue::VNULL;\n+\n+    std::array<char, 128> buffer;\n+    std::string result;\n+    std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(strCommand.c_str(), \"r\"), pclose);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242612528",
      "id" : 242612528,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYxMjUyOA==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 22,
      "path" : "src/util/system.cpp",
      "position" : 22,
      "pull_request_review_id" : 186165666,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2018-12-18T16:38:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242612528",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242612922"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242612922"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`keypath` should be const reference?",
      "commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "created_at" : "2018-12-18T16:38:57Z",
      "diff_hunk" : "@@ -587,6 +587,21 @@ bool ParseHDKeypath(const std::string& keypath_str, std::vector<uint32_t>& keypa\n     return true;\n }\n \n+std::string FormatKeyPath(const std::vector<uint32_t>& path)\n+{\n+    std::string ret;\n+    for (auto i : path) {\n+        ret += strprintf(\"/%i\", (i << 1) >> 1);\n+        if (i >> 31) ret += '\\'';\n+    }\n+    return ret;\n+}\n+\n+std::string WriteHdKeypath(const std::vector<uint32_t> keypath)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242612922",
      "id" : 242612922,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYxMjkyMg==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 14,
      "path" : "src/util/strencodings.cpp",
      "position" : 14,
      "pull_request_review_id" : 186166112,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2018-12-18T16:38:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242612922",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242614487"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242614487"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: Could use `command.empty()`? :-)",
      "commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "created_at" : "2018-12-18T16:42:48Z",
      "diff_hunk" : "@@ -4113,6 +4166,111 @@ UniValue walletcreatefundedpsbt(const JSONRPCRequest& request)\n     return result;\n }\n \n+static UniValue enumeratesigners(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() != 0) {\n+        throw std::runtime_error(\n+            \"enumeratesigners\\n\"\n+            \"Returns a list of external signers from -signer and associates them\\n\"\n+            \"with the wallet until you stop bitcoind.\\n\"\n+            \"{\\n\"\n+            \"  \\\"signers\\\" : [                                (json array of objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"masterkeyfingerprint\\\" : \\\"fingerprint\\\" (string) Master key fingerprint\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+        );\n+    }\n+\n+    const std::string command = gArgs.GetArg(\"-signer\", DEFAULT_EXTERNAL_SIGNER);\n+    if (command == \"\") throw JSONRPCError(RPC_WALLET_ERROR, \"Error: restart bitcoind with -signer=<cmd>\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242614487",
      "id" : 242614487,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYxNDQ4Nw==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 171,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 171,
      "pull_request_review_id" : 186168170,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2018-12-18T16:42:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242614487",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242614853"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242614853"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be const reference? :-)",
      "commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "created_at" : "2018-12-18T16:43:39Z",
      "diff_hunk" : "@@ -0,0 +1,45 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <wallet/externalsigner.h>\n+#include <util/system.h>\n+\n+ExternalSigner::ExternalSigner(const std::string& command, const std::string& fingerprint, bool mainnet): m_command(command), m_fingerprint(fingerprint), m_mainnet(mainnet) {}\n+\n+UniValue ExternalSigner::Enumerate(const std::string& command, std::vector<ExternalSigner>& signers, bool mainnet)\n+{\n+    // Call <command> enumerate\n+    const UniValue result = runCommandParseJSON(command + \" enumerate\");\n+    if (!result.isArray())\n+        throw ExternalSignerException(strprintf(\"'%s' received invalid response, expected array of signers\", command));\n+    for (UniValue signer : result.getValues()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242614853",
      "id" : 242614853,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYxNDg1Mw==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 16,
      "path" : "src/wallet/externalsigner.cpp",
      "position" : 16,
      "pull_request_review_id" : 186168654,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2018-12-18T16:43:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242614853",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242614951"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242614951"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be const reference? :-)",
      "commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "created_at" : "2018-12-18T16:43:54Z",
      "diff_hunk" : "@@ -0,0 +1,45 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <wallet/externalsigner.h>\n+#include <util/system.h>\n+\n+ExternalSigner::ExternalSigner(const std::string& command, const std::string& fingerprint, bool mainnet): m_command(command), m_fingerprint(fingerprint), m_mainnet(mainnet) {}\n+\n+UniValue ExternalSigner::Enumerate(const std::string& command, std::vector<ExternalSigner>& signers, bool mainnet)\n+{\n+    // Call <command> enumerate\n+    const UniValue result = runCommandParseJSON(command + \" enumerate\");\n+    if (!result.isArray())\n+        throw ExternalSignerException(strprintf(\"'%s' received invalid response, expected array of signers\", command));\n+    for (UniValue signer : result.getValues()) {\n+        const UniValue& fingerprint = find_value(signer, \"fingerprint\");\n+        if (result.isNull())\n+            throw ExternalSignerException(strprintf(\"'%s' received invalid response, missing signer fingerprint\", command));\n+        std::string fingerprintStr = fingerprint.get_str();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242614951",
      "id" : 242614951,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYxNDk1MQ==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 20,
      "path" : "src/wallet/externalsigner.cpp",
      "position" : 20,
      "pull_request_review_id" : 186168772,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2018-12-18T16:43:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242614951",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242615222"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242615222"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Use string equality operator instead of `compare` :-)",
      "commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "created_at" : "2018-12-18T16:44:29Z",
      "diff_hunk" : "@@ -0,0 +1,45 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <wallet/externalsigner.h>\n+#include <util/system.h>\n+\n+ExternalSigner::ExternalSigner(const std::string& command, const std::string& fingerprint, bool mainnet): m_command(command), m_fingerprint(fingerprint), m_mainnet(mainnet) {}\n+\n+UniValue ExternalSigner::Enumerate(const std::string& command, std::vector<ExternalSigner>& signers, bool mainnet)\n+{\n+    // Call <command> enumerate\n+    const UniValue result = runCommandParseJSON(command + \" enumerate\");\n+    if (!result.isArray())\n+        throw ExternalSignerException(strprintf(\"'%s' received invalid response, expected array of signers\", command));\n+    for (UniValue signer : result.getValues()) {\n+        const UniValue& fingerprint = find_value(signer, \"fingerprint\");\n+        if (result.isNull())\n+            throw ExternalSignerException(strprintf(\"'%s' received invalid response, missing signer fingerprint\", command));\n+        std::string fingerprintStr = fingerprint.get_str();\n+        // Skip duplicate signer\n+        bool duplicate = false;\n+        for (ExternalSigner signer : signers) {\n+            if (signer.m_fingerprint.compare(fingerprintStr) == 0) duplicate = true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242615222",
      "id" : 242615222,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYxNTIyMg==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 24,
      "path" : "src/wallet/externalsigner.cpp",
      "position" : 24,
      "pull_request_review_id" : 186169074,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2018-12-18T16:44:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242615222",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242616373"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242616373"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`signer` can be `nullptr` here if the check on L4016 is correct?",
      "commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "created_at" : "2018-12-18T16:47:04Z",
      "diff_hunk" : "@@ -3988,6 +4010,37 @@ UniValue walletprocesspsbt(const JSONRPCRequest& request)\n     bool bip32derivs = request.params[3].isNull() ? false : request.params[3].get_bool();\n     bool complete = FillPSBT(pwallet, psbtx, nHashType, sign, bip32derivs);\n \n+    // Process again with external signer if needed\n+    if (!complete && sign && !wallet->m_external_signers.empty()) {\n+        ExternalSigner *signer = GetSignerForJSONRPCRequest(request, 4, pwallet);\n+        if (signer && !bip32derivs) JSONRPCError(RPC_WALLET_ERROR, \"Using signer requires bip32derivs argument to be true\");\n+\n+        // Check if signer fingerpint matches any input master key fingerprint\n+        bool match = false;\n+        for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {\n+            const PSBTInput& input = psbtx.inputs[i];\n+            for (auto entry : input.hd_keypaths) {\n+                if (signer->m_fingerprint == strprintf(\"%08x\", ReadBE32(entry.second.fingerprint))) match = true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242616373",
      "id" : 242616373,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYxNjM3Mw==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 117,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 117,
      "pull_request_review_id" : 186170522,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2018-12-18T16:47:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242616373",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242616597"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242616597"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Same here: `signer` can be `nullptr` here if the check on L4016 is correct?",
      "commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "created_at" : "2018-12-18T16:47:38Z",
      "diff_hunk" : "@@ -3988,6 +4010,37 @@ UniValue walletprocesspsbt(const JSONRPCRequest& request)\n     bool bip32derivs = request.params[3].isNull() ? false : request.params[3].get_bool();\n     bool complete = FillPSBT(pwallet, psbtx, nHashType, sign, bip32derivs);\n \n+    // Process again with external signer if needed\n+    if (!complete && sign && !wallet->m_external_signers.empty()) {\n+        ExternalSigner *signer = GetSignerForJSONRPCRequest(request, 4, pwallet);\n+        if (signer && !bip32derivs) JSONRPCError(RPC_WALLET_ERROR, \"Using signer requires bip32derivs argument to be true\");\n+\n+        // Check if signer fingerpint matches any input master key fingerprint\n+        bool match = false;\n+        for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {\n+            const PSBTInput& input = psbtx.inputs[i];\n+            for (auto entry : input.hd_keypaths) {\n+                if (signer->m_fingerprint == strprintf(\"%08x\", ReadBE32(entry.second.fingerprint))) match = true;\n+            }\n+        }\n+\n+        if (!match) JSONRPCError(RPC_WALLET_ERROR, \"Signer fingerprint does not match any of the inputs\");\n+\n+        // Call signer, get result\n+        const UniValue signer_result = signer->signTransaction(request.params[0].get_str());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242616597",
      "id" : 242616597,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYxNjU5Nw==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 124,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 124,
      "pull_request_review_id" : 186170810,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2018-12-18T16:47:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242616597",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242617121"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242617121"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`keypath` should be const reference?",
      "commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "created_at" : "2018-12-18T16:48:58Z",
      "diff_hunk" : "@@ -204,6 +204,10 @@ bool ConvertBits(const O& outfn, I it, I end) {\n /** Parse an HD keypaths like \"m/7/0'/2000\". */\n NODISCARD bool ParseHDKeypath(const std::string& keypath_str, std::vector<uint32_t>& keypath);\n \n+/** Write HD keypaths as strings */\n+std::string WriteHdKeypath(const std::vector<uint32_t> keypath);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242617121",
      "id" : 242617121,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYxNzEyMQ==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 5,
      "path" : "src/util/strencodings.h",
      "position" : 5,
      "pull_request_review_id" : 186171510,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2018-12-18T16:48:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242617121",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242617685"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242617685"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: Could use `std::copy` instead?",
      "commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "created_at" : "2018-12-18T16:50:23Z",
      "diff_hunk" : "@@ -1263,3 +1444,145 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n \n     return response;\n }\n+\n+UniValue signerfetchkeys(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() > 1) {\n+        throw std::runtime_error(\n+            \"signerfetchkeys ( fingerprint )\\n\"\n+            \"Obtains keys from external signer and imports them into the wallet.\\n\"\n+            \"Call enumeratesigners before using this.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"fingerprint\\\"   (string, optional) Master key fingerprint of signer\\n\"\n+            \"\\nResult (same as for importmulti):\\n\"\n+            \"[{ \\\"success\\\": true }\"\n+        );\n+    }\n+\n+    ExternalSigner *signer = GetSignerForJSONRPCRequest(request, 0, pwallet);\n+\n+    UniValue descriptors = UniValue(UniValue::VARR);\n+    std::string desc_prefix = \"\";\n+    std::string desc_suffix = \"\";\n+    std::string purpose = \"\";\n+    switch(pwallet->m_default_address_type) {\n+        case OutputType::LEGACY: {\n+            desc_prefix = \"pkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"44h\";\n+            break;\n+        }\n+        case OutputType::P2SH_SEGWIT: {\n+            desc_prefix = \"sh(wpkh(\";\n+            desc_suffix = \"))\";\n+            purpose = \"49h\";\n+            break;\n+        }\n+        case OutputType::BECH32: {\n+            desc_prefix = \"wpkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"84h\";\n+            break;\n+        }\n+        case OutputType::CHANGE_AUTO: {\n+            assert(false);\n+        }\n+    }\n+\n+    const std::string receive_desc = desc_prefix + signer->m_fingerprint + \"/\" + purpose + \"/\" + (signer->m_mainnet ? \"0h\" : \"1h\") + \"/0h/0/*\" + desc_suffix;\n+    UniValue receive_descriptors = signer->getKeys(receive_desc);\n+    if (!receive_descriptors.isArray()) JSONRPCError(RPC_WALLET_ERROR, \"Expected an array of receive descriptors\");\n+    for (const UniValue& descriptor : receive_descriptors.getValues()) {\n+        descriptors.push_back(descriptor);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242617685",
      "id" : 242617685,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYxNzY4NQ==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 728,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 728,
      "pull_request_review_id" : 186172231,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2018-12-18T16:50:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242617685",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242617864"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242617864"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Same here: Could you `std::copy`?",
      "commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "created_at" : "2018-12-18T16:50:51Z",
      "diff_hunk" : "@@ -1263,3 +1444,145 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n \n     return response;\n }\n+\n+UniValue signerfetchkeys(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() > 1) {\n+        throw std::runtime_error(\n+            \"signerfetchkeys ( fingerprint )\\n\"\n+            \"Obtains keys from external signer and imports them into the wallet.\\n\"\n+            \"Call enumeratesigners before using this.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"fingerprint\\\"   (string, optional) Master key fingerprint of signer\\n\"\n+            \"\\nResult (same as for importmulti):\\n\"\n+            \"[{ \\\"success\\\": true }\"\n+        );\n+    }\n+\n+    ExternalSigner *signer = GetSignerForJSONRPCRequest(request, 0, pwallet);\n+\n+    UniValue descriptors = UniValue(UniValue::VARR);\n+    std::string desc_prefix = \"\";\n+    std::string desc_suffix = \"\";\n+    std::string purpose = \"\";\n+    switch(pwallet->m_default_address_type) {\n+        case OutputType::LEGACY: {\n+            desc_prefix = \"pkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"44h\";\n+            break;\n+        }\n+        case OutputType::P2SH_SEGWIT: {\n+            desc_prefix = \"sh(wpkh(\";\n+            desc_suffix = \"))\";\n+            purpose = \"49h\";\n+            break;\n+        }\n+        case OutputType::BECH32: {\n+            desc_prefix = \"wpkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"84h\";\n+            break;\n+        }\n+        case OutputType::CHANGE_AUTO: {\n+            assert(false);\n+        }\n+    }\n+\n+    const std::string receive_desc = desc_prefix + signer->m_fingerprint + \"/\" + purpose + \"/\" + (signer->m_mainnet ? \"0h\" : \"1h\") + \"/0h/0/*\" + desc_suffix;\n+    UniValue receive_descriptors = signer->getKeys(receive_desc);\n+    if (!receive_descriptors.isArray()) JSONRPCError(RPC_WALLET_ERROR, \"Expected an array of receive descriptors\");\n+    for (const UniValue& descriptor : receive_descriptors.getValues()) {\n+        descriptors.push_back(descriptor);\n+    }\n+\n+\n+    switch(pwallet->m_default_change_type) {\n+        case OutputType::LEGACY: {\n+            desc_prefix = \"pkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"44h\";\n+            break;\n+        }\n+        case OutputType::P2SH_SEGWIT: {\n+            desc_prefix = \"sh(wpkh(\";\n+            desc_suffix = \"))\";\n+            purpose = \"49h\";\n+            break;\n+        }\n+        case OutputType::BECH32: {\n+            desc_prefix = \"wpkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"84h\";\n+            break;\n+        }\n+        case OutputType::CHANGE_AUTO: {\n+            // Use same values as for receive descriptor\n+            break;\n+        }\n+    }\n+\n+    const std::string change_desc = desc_prefix + signer->m_fingerprint + \"/\" + purpose + \"/\" + (signer->m_mainnet ? \"0h\" : \"1h\") + \"/0h/1/*\" + desc_suffix;\n+    UniValue change_descriptors = signer->getKeys(change_desc);\n+    if (!change_descriptors.isArray()) JSONRPCError(RPC_WALLET_ERROR, \"Expected an array of change descriptors\");\n+    for (const UniValue& descriptor : change_descriptors.getValues()) {\n+        descriptors.push_back(descriptor);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242617864",
      "id" : 242617864,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYxNzg2NA==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 761,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 761,
      "pull_request_review_id" : 186172442,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2018-12-18T16:50:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242617864",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242618665"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242618665"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Missing space before `(`. Consider running new code through `clang-format` :-)",
      "commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "created_at" : "2018-12-18T16:52:53Z",
      "diff_hunk" : "@@ -1263,3 +1444,145 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n \n     return response;\n }\n+\n+UniValue signerfetchkeys(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() > 1) {\n+        throw std::runtime_error(\n+            \"signerfetchkeys ( fingerprint )\\n\"\n+            \"Obtains keys from external signer and imports them into the wallet.\\n\"\n+            \"Call enumeratesigners before using this.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"fingerprint\\\"   (string, optional) Master key fingerprint of signer\\n\"\n+            \"\\nResult (same as for importmulti):\\n\"\n+            \"[{ \\\"success\\\": true }\"\n+        );\n+    }\n+\n+    ExternalSigner *signer = GetSignerForJSONRPCRequest(request, 0, pwallet);\n+\n+    UniValue descriptors = UniValue(UniValue::VARR);\n+    std::string desc_prefix = \"\";\n+    std::string desc_suffix = \"\";\n+    std::string purpose = \"\";\n+    switch(pwallet->m_default_address_type) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242618665",
      "id" : 242618665,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYxODY2NQ==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 700,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 700,
      "pull_request_review_id" : 186173510,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2018-12-18T16:52:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242618665",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242618820"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242618820"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Same here: Missing whitespace before `(`.",
      "commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "created_at" : "2018-12-18T16:53:15Z",
      "diff_hunk" : "@@ -1263,3 +1444,145 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n \n     return response;\n }\n+\n+UniValue signerfetchkeys(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() > 1) {\n+        throw std::runtime_error(\n+            \"signerfetchkeys ( fingerprint )\\n\"\n+            \"Obtains keys from external signer and imports them into the wallet.\\n\"\n+            \"Call enumeratesigners before using this.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"fingerprint\\\"   (string, optional) Master key fingerprint of signer\\n\"\n+            \"\\nResult (same as for importmulti):\\n\"\n+            \"[{ \\\"success\\\": true }\"\n+        );\n+    }\n+\n+    ExternalSigner *signer = GetSignerForJSONRPCRequest(request, 0, pwallet);\n+\n+    UniValue descriptors = UniValue(UniValue::VARR);\n+    std::string desc_prefix = \"\";\n+    std::string desc_suffix = \"\";\n+    std::string purpose = \"\";\n+    switch(pwallet->m_default_address_type) {\n+        case OutputType::LEGACY: {\n+            desc_prefix = \"pkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"44h\";\n+            break;\n+        }\n+        case OutputType::P2SH_SEGWIT: {\n+            desc_prefix = \"sh(wpkh(\";\n+            desc_suffix = \"))\";\n+            purpose = \"49h\";\n+            break;\n+        }\n+        case OutputType::BECH32: {\n+            desc_prefix = \"wpkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"84h\";\n+            break;\n+        }\n+        case OutputType::CHANGE_AUTO: {\n+            assert(false);\n+        }\n+    }\n+\n+    const std::string receive_desc = desc_prefix + signer->m_fingerprint + \"/\" + purpose + \"/\" + (signer->m_mainnet ? \"0h\" : \"1h\") + \"/0h/0/*\" + desc_suffix;\n+    UniValue receive_descriptors = signer->getKeys(receive_desc);\n+    if (!receive_descriptors.isArray()) JSONRPCError(RPC_WALLET_ERROR, \"Expected an array of receive descriptors\");\n+    for (const UniValue& descriptor : receive_descriptors.getValues()) {\n+        descriptors.push_back(descriptor);\n+    }\n+\n+\n+    switch(pwallet->m_default_change_type) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242618820",
      "id" : 242618820,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYxODgyMA==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 732,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 732,
      "pull_request_review_id" : 186173710,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2018-12-18T16:53:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242618820",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242619074"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242619074"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Remove space before `;` :-)",
      "commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "created_at" : "2018-12-18T16:53:47Z",
      "diff_hunk" : "@@ -3988,6 +4010,37 @@ UniValue walletprocesspsbt(const JSONRPCRequest& request)\n     bool bip32derivs = request.params[3].isNull() ? false : request.params[3].get_bool();\n     bool complete = FillPSBT(pwallet, psbtx, nHashType, sign, bip32derivs);\n \n+    // Process again with external signer if needed\n+    if (!complete && sign && !wallet->m_external_signers.empty()) {\n+        ExternalSigner *signer = GetSignerForJSONRPCRequest(request, 4, pwallet);\n+        if (signer && !bip32derivs) JSONRPCError(RPC_WALLET_ERROR, \"Using signer requires bip32derivs argument to be true\");\n+\n+        // Check if signer fingerpint matches any input master key fingerprint\n+        bool match = false;\n+        for (unsigned int i = 0; i < psbtx.inputs.size(); ++i) {\n+            const PSBTInput& input = psbtx.inputs[i];\n+            for (auto entry : input.hd_keypaths) {\n+                if (signer->m_fingerprint == strprintf(\"%08x\", ReadBE32(entry.second.fingerprint))) match = true;\n+            }\n+        }\n+\n+        if (!match) JSONRPCError(RPC_WALLET_ERROR, \"Signer fingerprint does not match any of the inputs\");\n+\n+        // Call signer, get result\n+        const UniValue signer_result = signer->signTransaction(request.params[0].get_str());\n+        if (!find_value(signer_result, \"psbt\").isStr()) JSONRPCError(RPC_WALLET_ERROR, \"Unexpected result from signer\");\n+\n+        // Process result from signer:\n+        std::string signer_psbt_error;\n+        PartiallySignedTransaction signer_psbtx ;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242619074",
      "id" : 242619074,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYxOTA3NA==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 129,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 129,
      "pull_request_review_id" : 186174018,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2018-12-18T16:53:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242619074",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242619836"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242619836"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Indentation is not a multiple of four :-)",
      "commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "created_at" : "2018-12-18T16:55:41Z",
      "diff_hunk" : "@@ -119,9 +126,13 @@ def get_multisig(self):\n                         CScript([OP_HASH160, witness_script, OP_EQUAL]).hex(),  # p2sh-p2wsh\n                         script_to_p2sh_p2wsh(script_code))  # p2sh-p2wsh addr\n \n-    def test_importmulti(self, req, success, error_code=None, error_message=None):\n+    def test_importmulti(self, req, success, error_code=None, error_message=None, warnings=[]):\n         \"\"\"Run importmulti and assert success\"\"\"\n         result = self.nodes[1].importmulti([req])\n+        observed_warnings = []\n+        if 'warnings' in result[0]:\n+           observed_warnings = result[0]['warnings']",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242619836",
      "id" : 242619836,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYxOTgzNg==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 24,
      "path" : "test/functional/wallet_importmulti.py",
      "position" : 24,
      "pull_request_review_id" : 186174993,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2018-12-18T16:55:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242619836",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242620899"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242620899"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be \"derivation\" :-)",
      "commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "created_at" : "2018-12-18T16:57:56Z",
      "diff_hunk" : "@@ -1263,3 +1444,145 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n \n     return response;\n }\n+\n+UniValue signerfetchkeys(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() > 1) {\n+        throw std::runtime_error(\n+            \"signerfetchkeys ( fingerprint )\\n\"\n+            \"Obtains keys from external signer and imports them into the wallet.\\n\"\n+            \"Call enumeratesigners before using this.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"fingerprint\\\"   (string, optional) Master key fingerprint of signer\\n\"\n+            \"\\nResult (same as for importmulti):\\n\"\n+            \"[{ \\\"success\\\": true }\"\n+        );\n+    }\n+\n+    ExternalSigner *signer = GetSignerForJSONRPCRequest(request, 0, pwallet);\n+\n+    UniValue descriptors = UniValue(UniValue::VARR);\n+    std::string desc_prefix = \"\";\n+    std::string desc_suffix = \"\";\n+    std::string purpose = \"\";\n+    switch(pwallet->m_default_address_type) {\n+        case OutputType::LEGACY: {\n+            desc_prefix = \"pkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"44h\";\n+            break;\n+        }\n+        case OutputType::P2SH_SEGWIT: {\n+            desc_prefix = \"sh(wpkh(\";\n+            desc_suffix = \"))\";\n+            purpose = \"49h\";\n+            break;\n+        }\n+        case OutputType::BECH32: {\n+            desc_prefix = \"wpkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"84h\";\n+            break;\n+        }\n+        case OutputType::CHANGE_AUTO: {\n+            assert(false);\n+        }\n+    }\n+\n+    const std::string receive_desc = desc_prefix + signer->m_fingerprint + \"/\" + purpose + \"/\" + (signer->m_mainnet ? \"0h\" : \"1h\") + \"/0h/0/*\" + desc_suffix;\n+    UniValue receive_descriptors = signer->getKeys(receive_desc);\n+    if (!receive_descriptors.isArray()) JSONRPCError(RPC_WALLET_ERROR, \"Expected an array of receive descriptors\");\n+    for (const UniValue& descriptor : receive_descriptors.getValues()) {\n+        descriptors.push_back(descriptor);\n+    }\n+\n+\n+    switch(pwallet->m_default_change_type) {\n+        case OutputType::LEGACY: {\n+            desc_prefix = \"pkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"44h\";\n+            break;\n+        }\n+        case OutputType::P2SH_SEGWIT: {\n+            desc_prefix = \"sh(wpkh(\";\n+            desc_suffix = \"))\";\n+            purpose = \"49h\";\n+            break;\n+        }\n+        case OutputType::BECH32: {\n+            desc_prefix = \"wpkh(\";\n+            desc_suffix = \")\";\n+            purpose = \"84h\";\n+            break;\n+        }\n+        case OutputType::CHANGE_AUTO: {\n+            // Use same values as for receive descriptor\n+            break;\n+        }\n+    }\n+\n+    const std::string change_desc = desc_prefix + signer->m_fingerprint + \"/\" + purpose + \"/\" + (signer->m_mainnet ? \"0h\" : \"1h\") + \"/0h/1/*\" + desc_suffix;\n+    UniValue change_descriptors = signer->getKeys(change_desc);\n+    if (!change_descriptors.isArray()) JSONRPCError(RPC_WALLET_ERROR, \"Expected an array of change descriptors\");\n+    for (const UniValue& descriptor : change_descriptors.getValues()) {\n+        descriptors.push_back(descriptor);\n+    }\n+\n+    if (receive_descriptors.size() != change_descriptors.size()) JSONRPCError(RPC_WALLET_ERROR, \"Expected same number of receive and change descriptors\");\n+\n+    // Use importmulti to process the descriptors:\n+    UniValue importdata(UniValue::VARR);\n+\n+    uint64_t keypool_target_size = 0;\n+    keypool_target_size = gArgs.GetArg(\"-keypool\", DEFAULT_KEYPOOL_SIZE);\n+\n+    if (keypool_target_size == 0) JSONRPCError(RPC_WALLET_ERROR, \"-keypool must be > 0\");\n+\n+    for (unsigned int i = 0; i < descriptors.size(); ++i) {\n+        const UniValue& descriptor = descriptors.getValues()[i];\n+        // TODO: sanity check the descriptors:\n+        // * check if they're valid descriptors\n+        // * check that it's the fingerprint we asked for\n+        // * check it's the deriviation path we asked for",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242620899",
      "id" : 242620899,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYyMDg5OQ==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 779,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 779,
      "pull_request_review_id" : 186176286,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2018-12-18T16:57:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242620899",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242621312"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242621312"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Unused?",
      "commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "created_at" : "2018-12-18T16:58:46Z",
      "diff_hunk" : "@@ -4113,6 +4166,111 @@ UniValue walletcreatefundedpsbt(const JSONRPCRequest& request)\n     return result;\n }\n \n+static UniValue enumeratesigners(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() != 0) {\n+        throw std::runtime_error(\n+            \"enumeratesigners\\n\"\n+            \"Returns a list of external signers from -signer and associates them\\n\"\n+            \"with the wallet until you stop bitcoind.\\n\"\n+            \"{\\n\"\n+            \"  \\\"signers\\\" : [                                (json array of objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"masterkeyfingerprint\\\" : \\\"fingerprint\\\" (string) Master key fingerprint\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+        );\n+    }\n+\n+    const std::string command = gArgs.GetArg(\"-signer\", DEFAULT_EXTERNAL_SIGNER);\n+    if (command == \"\") throw JSONRPCError(RPC_WALLET_ERROR, \"Error: restart bitcoind with -signer=<cmd>\");\n+    std::string chain = gArgs.GetChainName();\n+    const bool mainnet = chain == CBaseChainParams::MAIN;\n+    UniValue signers;\n+    try {\n+        signers = ExternalSigner::Enumerate(command, pwallet->m_external_signers, mainnet);\n+    } catch (const ExternalSignerException& e) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, e.what());\n+    }\n+    UniValue result(UniValue::VOBJ);\n+    result.pushKV(\"signers\", signers);\n+    return result;\n+}\n+\n+static UniValue signerdisplayaddress(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.empty() || request.params.size() > 1) {\n+        throw std::runtime_error(\n+            \"signerdisplayaddress\\n\"\n+            \"Display address on an external signer for verification.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"address\\\"       (string, required) The bitcoin address to display.\\n\"\n+            \"2. \\\"fingerprint\\\"   (string, optional) Master key fingerprint of signer\\n\"\n+        );\n+    }\n+\n+    ExternalSigner *signer = GetSignerForJSONRPCRequest(request, 1, pwallet);\n+\n+    LOCK(pwallet->cs_wallet);\n+\n+    UniValue ret(UniValue::VOBJ);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14912#discussion_r242621312",
      "id" : 242621312,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MjYyMTMxMg==",
      "original_commit_id" : "9ec4aaca284673e1c92a02fdc4dea9a1a3e6038c",
      "original_position" : 208,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 208,
      "pull_request_review_id" : 186176818,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14912",
      "updated_at" : "2018-12-18T16:58:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/242621312",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   }
]
